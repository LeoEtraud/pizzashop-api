import {createRequire} from "node:module";
import { Elysia } from 'elysia';
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/memoirist/dist/cjs/index.js
var require_cjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true }), function(e2, t2) {
    for (var r2 in t2)
      Object.defineProperty(e2, r2, { enumerable: true, get: t2[r2] });
  }(exports, { Memoirist: function() {
    return a;
  }, default: function() {
    return n;
  } });
  var e = (e2, t2) => ({ part: e2, store: null, inert: t2 !== undefined ? new Map(t2.map((e3) => [e3.part.charCodeAt(0), e3])) : null, params: null, wildcardStore: null });
  var t = (e2, t2) => ({ ...e2, part: t2 });
  var r = (e2) => ({ paramName: e2, store: null, inert: null });

  class a {
    root = {};
    history = [];
    static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
    add(l2, n2, i) {
      let s;
      if (typeof n2 != "string")
        throw TypeError("Route path must be a string");
      n2 === "" ? n2 = "/" : n2[0] !== "/" && (n2 = `/${n2}`), this.history.push([l2, n2, i]);
      let o = n2[n2.length - 1] === "*";
      o && (n2 = n2.slice(0, -1));
      let u = n2.split(a.regex.static), p = n2.match(a.regex.params) || [];
      u[u.length - 1] === "" && u.pop(), s = this.root[l2] ? this.root[l2] : this.root[l2] = e("/");
      let c = 0;
      for (let a2 = 0;a2 < u.length; ++a2) {
        let l3 = u[a2];
        if (a2 > 0) {
          let t2 = p[c++].slice(1);
          if (s.params === null)
            s.params = r(t2);
          else if (s.params.paramName !== t2)
            throw Error(`Cannot create route "${n2}" with parameter "${t2}" because a route already exists with a different parameter name ("${s.params.paramName}") in the same location`);
          let a3 = s.params;
          if (a3.inert === null) {
            s = a3.inert = e(l3);
            continue;
          }
          s = a3.inert;
        }
        for (let r2 = 0;; ) {
          if (r2 === l3.length) {
            if (r2 < s.part.length) {
              let a3 = t(s, s.part.slice(r2));
              Object.assign(s, e(l3, [a3]));
            }
            break;
          }
          if (r2 === s.part.length) {
            if (s.inert === null)
              s.inert = new Map;
            else if (s.inert.has(l3.charCodeAt(r2))) {
              s = s.inert.get(l3.charCodeAt(r2)), l3 = l3.slice(r2), r2 = 0;
              continue;
            }
            let t2 = e(l3.slice(r2));
            s.inert.set(l3.charCodeAt(r2), t2), s = t2;
            break;
          }
          if (l3[r2] !== s.part[r2]) {
            let a3 = t(s, s.part.slice(r2)), n3 = e(l3.slice(r2));
            Object.assign(s, e(s.part.slice(0, r2), [a3, n3])), s = n3;
            break;
          }
          ++r2;
        }
      }
      if (c < p.length) {
        let e2 = p[c], t2 = e2.slice(1);
        if (s.params === null)
          s.params = r(t2);
        else if (s.params.paramName !== t2)
          throw Error(`Cannot create route "${n2}" with parameter "${t2}" because a route already exists with a different parameter name ("${s.params.paramName}") in the same location`);
        return s.params.store === null && (s.params.store = i), s.params.store;
      }
      return o ? (s.wildcardStore === null && (s.wildcardStore = i), s.wildcardStore) : (s.store === null && (s.store = i), s.store);
    }
    find(e2, t2) {
      let r2 = this.root[e2];
      return r2 ? l(t2, t2.length, r2, 0) : null;
    }
  }
  var l = (e2, t2, r2, a2) => {
    let n2 = r2?.part, i = a2 + n2.length;
    if (n2.length > 1) {
      if (i > t2)
        return null;
      if (n2.length < 15) {
        for (let t3 = 1, r3 = a2 + 1;t3 < n2.length; ++t3, ++r3)
          if (n2.charCodeAt(t3) !== e2.charCodeAt(r3))
            return null;
      } else if (e2.substring(a2, i) !== n2)
        return null;
    }
    if (i === t2)
      return r2.store !== null ? { store: r2.store, params: {} } : r2.wildcardStore !== null ? { store: r2.wildcardStore, params: { "*": "" } } : null;
    if (r2.inert !== null) {
      let a3 = r2.inert.get(e2.charCodeAt(i));
      if (a3 !== undefined) {
        let r3 = l(e2, t2, a3, i);
        if (r3 !== null)
          return r3;
      }
    }
    if (r2.params !== null) {
      let a3 = r2.params, n3 = e2.indexOf("/", i);
      if (n3 !== i) {
        if (n3 === -1 || n3 >= t2) {
          if (a3.store !== null) {
            let r3 = {};
            return r3[a3.paramName] = e2.substring(i, t2), { store: a3.store, params: r3 };
          }
        } else if (a3.inert !== null) {
          let r3 = l(e2, t2, a3.inert, n3);
          if (r3 !== null)
            return r3.params[a3.paramName] = e2.substring(i, n3), r3;
        }
      }
    }
    return r2.wildcardStore !== null ? { store: r2.wildcardStore, params: { "*": e2.substring(i, t2) } } : null;
  };
  var n = a;
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS((exports, module) => {
  function Events() {
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events;
    else
      delete emitter._events[evt];
  }
  function EventEmitter() {
    this._events = new Events;
    this._eventsCount = 0;
  }
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l);i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1);i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0;i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1);j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length;i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter;
  }
});

// node_modules/elysia/dist/cjs/trace.js
var require_trace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTraceListener = undefined;
  var resolver = () => {
    let resolve;
    const promise = new Promise((r) => {
      resolve = r;
    });
    return [promise, resolve];
  };
  var createSignal = () => {
    const [start, resolveStart] = resolver();
    const [end, resolveEnd] = resolver();
    const children = [];
    const resolvers = [];
    return {
      signal: start,
      consume: (trace) => {
        switch (trace.type) {
          case "begin":
            if (trace.unit && children.length === 0)
              for (let i = 0;i < trace.unit; i++) {
                const [start2, resolveStart2] = resolver();
                const [end2, resolveEnd2] = resolver();
                children.push(start2);
                resolvers.push([
                  (trace2) => {
                    resolveStart2({
                      children: [],
                      end: end2,
                      name: trace2.name ?? "",
                      skip: false,
                      time: trace2.time
                    });
                  },
                  (time) => {
                    resolveEnd2(time);
                  }
                ]);
              }
            resolveStart({
              children,
              end,
              name: trace.name ?? "",
              skip: false,
              time: trace.time
            });
            break;
          case "end":
            resolveEnd(trace.time);
            break;
        }
      },
      consumeChild(trace) {
        switch (trace.type) {
          case "begin":
            if (!resolvers[0])
              return;
            const [resolveStart2] = resolvers[0];
            resolveStart2({
              children: [],
              end,
              name: trace.name ?? "",
              skip: false,
              time: trace.time
            });
            break;
          case "end":
            const child = resolvers.shift();
            if (!child)
              return;
            child[1](trace.time);
        }
      },
      resolve() {
        resolveStart({
          children: [],
          end: new Promise((resolve) => resolve(0)),
          name: "",
          skip: true,
          time: 0
        });
        for (const [resolveStart2, resolveEnd2] of resolvers) {
          resolveStart2({
            children: [],
            end: new Promise((resolve) => resolve(0)),
            name: "",
            skip: true,
            time: 0
          });
          resolveEnd2(0);
        }
        resolveEnd(0);
      }
    };
  };
  var createTraceListener = (getReporter, totalListener, handler) => {
    return async function trace(trace) {
      if (trace.event !== "request" || trace.type !== "begin")
        return;
      const id = trace.id;
      const reporter = getReporter();
      const request = createSignal();
      const parse = createSignal();
      const transform = createSignal();
      const beforeHandle = createSignal();
      const handle = createSignal();
      const afterHandle = createSignal();
      const error = createSignal();
      const response = createSignal();
      request.consume(trace);
      const reducer = (event) => {
        if (event.id === id)
          switch (event.event) {
            case "request":
              request.consume(event);
              break;
            case "request.unit":
              request.consumeChild(event);
              break;
            case "parse":
              parse.consume(event);
              break;
            case "parse.unit":
              parse.consumeChild(event);
              break;
            case "transform":
              transform.consume(event);
              break;
            case "transform.unit":
              transform.consumeChild(event);
              break;
            case "beforeHandle":
              beforeHandle.consume(event);
              break;
            case "beforeHandle.unit":
              beforeHandle.consumeChild(event);
              break;
            case "handle":
              handle.consume(event);
              break;
            case "afterHandle":
              afterHandle.consume(event);
              break;
            case "afterHandle.unit":
              afterHandle.consumeChild(event);
              break;
            case "error":
              error.consume(event);
              break;
            case "error.unit":
              error.consumeChild(event);
              break;
            case "response":
              if (event.type === "begin") {
                request.resolve();
                parse.resolve();
                transform.resolve();
                beforeHandle.resolve();
                handle.resolve();
                afterHandle.resolve();
                error.resolve();
              } else
                reporter.off("event", reducer);
              response.consume(event);
              break;
            case "response.unit":
              response.consumeChild(event);
              break;
            case "exit":
              request.resolve();
              parse.resolve();
              transform.resolve();
              beforeHandle.resolve();
              handle.resolve();
              afterHandle.resolve();
              error.resolve();
              break;
          }
      };
      reporter.on("event", reducer);
      await handler({
        id,
        context: trace.ctx,
        set: trace.ctx?.set,
        store: trace.ctx?.store,
        time: trace.time,
        request: request.signal,
        parse: parse.signal,
        transform: transform.signal,
        beforeHandle: beforeHandle.signal,
        handle: handle.signal,
        afterHandle: afterHandle.signal,
        error: error.signal,
        response: response.signal
      });
      reporter.emit(`res${id}.${totalListener}`, undefined);
    };
  };
  exports.createTraceListener = createTraceListener;
});

// node_modules/@sinclair/typebox/value/guard.js
var require_guard = __commonJS((exports) => {
  function IsAsyncIterator(value) {
    return IsObject(value) && Symbol.asyncIterator in value;
  }
  function IsIterator(value) {
    return IsObject(value) && Symbol.iterator in value;
  }
  function IsTypedArray(value) {
    return ArrayBuffer.isView(value);
  }
  function IsPromise(value) {
    return value instanceof Promise;
  }
  function IsUint8Array(value) {
    return value instanceof Uint8Array;
  }
  function IsDate(value) {
    return value instanceof Date && Number.isFinite(value.getTime());
  }
  function HasPropertyKey(value, key) {
    return key in value;
  }
  function IsPlainObject(value) {
    return IsObject(value) && IsFunction(value.constructor) && value.constructor.name === "Object";
  }
  function IsObject(value) {
    return value !== null && typeof value === "object";
  }
  function IsArray(value) {
    return Array.isArray(value) && !ArrayBuffer.isView(value);
  }
  function IsUndefined(value) {
    return value === undefined;
  }
  function IsNull(value) {
    return value === null;
  }
  function IsBoolean(value) {
    return typeof value === "boolean";
  }
  function IsNumber(value) {
    return typeof value === "number";
  }
  function IsInteger(value) {
    return IsNumber(value) && Number.isInteger(value);
  }
  function IsBigInt(value) {
    return typeof value === "bigint";
  }
  function IsString(value) {
    return typeof value === "string";
  }
  function IsFunction(value) {
    return typeof value === "function";
  }
  function IsSymbol(value) {
    return typeof value === "symbol";
  }
  function IsValueType(value) {
    return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsValueType = exports.IsSymbol = exports.IsFunction = exports.IsString = exports.IsBigInt = exports.IsInteger = exports.IsNumber = exports.IsBoolean = exports.IsNull = exports.IsUndefined = exports.IsArray = exports.IsObject = exports.IsPlainObject = exports.HasPropertyKey = exports.IsDate = exports.IsUint8Array = exports.IsPromise = exports.IsTypedArray = exports.IsIterator = exports.IsAsyncIterator = undefined;
  exports.IsAsyncIterator = IsAsyncIterator;
  exports.IsIterator = IsIterator;
  exports.IsTypedArray = IsTypedArray;
  exports.IsPromise = IsPromise;
  exports.IsUint8Array = IsUint8Array;
  exports.IsDate = IsDate;
  exports.HasPropertyKey = HasPropertyKey;
  exports.IsPlainObject = IsPlainObject;
  exports.IsObject = IsObject;
  exports.IsArray = IsArray;
  exports.IsUndefined = IsUndefined;
  exports.IsNull = IsNull;
  exports.IsBoolean = IsBoolean;
  exports.IsNumber = IsNumber;
  exports.IsInteger = IsInteger;
  exports.IsBigInt = IsBigInt;
  exports.IsString = IsString;
  exports.IsFunction = IsFunction;
  exports.IsSymbol = IsSymbol;
  exports.IsValueType = IsValueType;
});

// node_modules/@sinclair/typebox/typebox.js
var require_typebox = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Type = exports.JsonType = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = exports.TypeBuilder = exports.TypeBuilderError = exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralGeneratorError = exports.TemplateLiteralFinite = exports.TemplateLiteralFiniteError = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.TemplateLiteralPatternError = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyArrayResolverError = exports.KeyResolver = exports.ObjectMap = exports.Intrinsic = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.TypeExtendsError = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.ValueGuard = exports.FormatRegistry = exports.TypeBoxError = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Optional = exports.Readonly = exports.Transform = undefined;
  exports.Transform = Symbol.for("TypeBox.Transform");
  exports.Readonly = Symbol.for("TypeBox.Readonly");
  exports.Optional = Symbol.for("TypeBox.Optional");
  exports.Hint = Symbol.for("TypeBox.Hint");
  exports.Kind = Symbol.for("TypeBox.Kind");
  exports.PatternBoolean = "(true|false)";
  exports.PatternNumber = "(0|[1-9][0-9]*)";
  exports.PatternString = "(.*)";
  exports.PatternBooleanExact = `^${exports.PatternBoolean}\$`;
  exports.PatternNumberExact = `^${exports.PatternNumber}\$`;
  exports.PatternStringExact = `^${exports.PatternString}\$`;
  var TypeRegistry;
  (function(TypeRegistry2) {
    const map = new Map;
    function Entries() {
      return new Map(map);
    }
    TypeRegistry2.Entries = Entries;
    function Clear() {
      return map.clear();
    }
    TypeRegistry2.Clear = Clear;
    function Delete(kind) {
      return map.delete(kind);
    }
    TypeRegistry2.Delete = Delete;
    function Has(kind) {
      return map.has(kind);
    }
    TypeRegistry2.Has = Has;
    function Set2(kind, func) {
      map.set(kind, func);
    }
    TypeRegistry2.Set = Set2;
    function Get(kind) {
      return map.get(kind);
    }
    TypeRegistry2.Get = Get;
  })(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));

  class TypeBoxError extends Error {
    constructor(message) {
      super(message);
    }
  }
  exports.TypeBoxError = TypeBoxError;
  var FormatRegistry;
  (function(FormatRegistry2) {
    const map = new Map;
    function Entries() {
      return new Map(map);
    }
    FormatRegistry2.Entries = Entries;
    function Clear() {
      return map.clear();
    }
    FormatRegistry2.Clear = Clear;
    function Delete(format) {
      return map.delete(format);
    }
    FormatRegistry2.Delete = Delete;
    function Has(format) {
      return map.has(format);
    }
    FormatRegistry2.Has = Has;
    function Set2(format, func) {
      map.set(format, func);
    }
    FormatRegistry2.Set = Set2;
    function Get(format) {
      return map.get(format);
    }
    FormatRegistry2.Get = Get;
  })(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));
  var ValueGuard;
  (function(ValueGuard2) {
    function IsArray(value) {
      return Array.isArray(value);
    }
    ValueGuard2.IsArray = IsArray;
    function IsBigInt(value) {
      return typeof value === "bigint";
    }
    ValueGuard2.IsBigInt = IsBigInt;
    function IsBoolean(value) {
      return typeof value === "boolean";
    }
    ValueGuard2.IsBoolean = IsBoolean;
    function IsDate(value) {
      return value instanceof globalThis.Date;
    }
    ValueGuard2.IsDate = IsDate;
    function IsNull(value) {
      return value === null;
    }
    ValueGuard2.IsNull = IsNull;
    function IsNumber(value) {
      return typeof value === "number";
    }
    ValueGuard2.IsNumber = IsNumber;
    function IsObject(value) {
      return typeof value === "object" && value !== null;
    }
    ValueGuard2.IsObject = IsObject;
    function IsString(value) {
      return typeof value === "string";
    }
    ValueGuard2.IsString = IsString;
    function IsUint8Array(value) {
      return value instanceof globalThis.Uint8Array;
    }
    ValueGuard2.IsUint8Array = IsUint8Array;
    function IsUndefined(value) {
      return value === undefined;
    }
    ValueGuard2.IsUndefined = IsUndefined;
  })(ValueGuard || (exports.ValueGuard = ValueGuard = {}));

  class TypeGuardUnknownTypeError extends TypeBoxError {
  }
  exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
  var TypeGuard;
  (function(TypeGuard2) {
    function IsPattern(value) {
      try {
        new RegExp(value);
        return true;
      } catch {
        return false;
      }
    }
    function IsControlCharacterFree(value) {
      if (!ValueGuard.IsString(value))
        return false;
      for (let i = 0;i < value.length; i++) {
        const code = value.charCodeAt(i);
        if (code >= 7 && code <= 13 || code === 27 || code === 127) {
          return false;
        }
      }
      return true;
    }
    function IsAdditionalProperties(value) {
      return IsOptionalBoolean(value) || TSchema(value);
    }
    function IsOptionalBigInt(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
    }
    function IsOptionalNumber(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
    }
    function IsOptionalBoolean(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
    }
    function IsOptionalString(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
    }
    function IsOptionalPattern(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
    }
    function IsOptionalFormat(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value);
    }
    function IsOptionalSchema(value) {
      return ValueGuard.IsUndefined(value) || TSchema(value);
    }
    function TAny(schema) {
      return TKindOf(schema, "Any") && IsOptionalString(schema.$id);
    }
    TypeGuard2.TAny = TAny;
    function TArray(schema) {
      return TKindOf(schema, "Array") && schema.type === "array" && IsOptionalString(schema.$id) && TSchema(schema.items) && IsOptionalNumber(schema.minItems) && IsOptionalNumber(schema.maxItems) && IsOptionalBoolean(schema.uniqueItems) && IsOptionalSchema(schema.contains) && IsOptionalNumber(schema.minContains) && IsOptionalNumber(schema.maxContains);
    }
    TypeGuard2.TArray = TArray;
    function TAsyncIterator(schema) {
      return TKindOf(schema, "AsyncIterator") && schema.type === "AsyncIterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
    }
    TypeGuard2.TAsyncIterator = TAsyncIterator;
    function TBigInt(schema) {
      return TKindOf(schema, "BigInt") && schema.type === "bigint" && IsOptionalString(schema.$id) && IsOptionalBigInt(schema.exclusiveMaximum) && IsOptionalBigInt(schema.exclusiveMinimum) && IsOptionalBigInt(schema.maximum) && IsOptionalBigInt(schema.minimum) && IsOptionalBigInt(schema.multipleOf);
    }
    TypeGuard2.TBigInt = TBigInt;
    function TBoolean(schema) {
      return TKindOf(schema, "Boolean") && schema.type === "boolean" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TBoolean = TBoolean;
    function TConstructor(schema) {
      return TKindOf(schema, "Constructor") && schema.type === "Constructor" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
    }
    TypeGuard2.TConstructor = TConstructor;
    function TDate(schema) {
      return TKindOf(schema, "Date") && schema.type === "Date" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximumTimestamp) && IsOptionalNumber(schema.exclusiveMinimumTimestamp) && IsOptionalNumber(schema.maximumTimestamp) && IsOptionalNumber(schema.minimumTimestamp) && IsOptionalNumber(schema.multipleOfTimestamp);
    }
    TypeGuard2.TDate = TDate;
    function TFunction(schema) {
      return TKindOf(schema, "Function") && schema.type === "Function" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
    }
    TypeGuard2.TFunction = TFunction;
    function TInteger(schema) {
      return TKindOf(schema, "Integer") && schema.type === "integer" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
    }
    TypeGuard2.TInteger = TInteger;
    function TIntersect(schema) {
      return TKindOf(schema, "Intersect") && (ValueGuard.IsString(schema.type) && schema.type !== "object" ? false : true) && ValueGuard.IsArray(schema.allOf) && schema.allOf.every((schema2) => TSchema(schema2) && !TTransform(schema2)) && IsOptionalString(schema.type) && (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) && IsOptionalString(schema.$id);
    }
    TypeGuard2.TIntersect = TIntersect;
    function TIterator(schema) {
      return TKindOf(schema, "Iterator") && schema.type === "Iterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
    }
    TypeGuard2.TIterator = TIterator;
    function TKindOf(schema, kind) {
      return TKind(schema) && schema[exports.Kind] === kind;
    }
    TypeGuard2.TKindOf = TKindOf;
    function TKind(schema) {
      return ValueGuard.IsObject(schema) && exports.Kind in schema && ValueGuard.IsString(schema[exports.Kind]);
    }
    TypeGuard2.TKind = TKind;
    function TLiteralString(schema) {
      return TLiteral(schema) && ValueGuard.IsString(schema.const);
    }
    TypeGuard2.TLiteralString = TLiteralString;
    function TLiteralNumber(schema) {
      return TLiteral(schema) && ValueGuard.IsNumber(schema.const);
    }
    TypeGuard2.TLiteralNumber = TLiteralNumber;
    function TLiteralBoolean(schema) {
      return TLiteral(schema) && ValueGuard.IsBoolean(schema.const);
    }
    TypeGuard2.TLiteralBoolean = TLiteralBoolean;
    function TLiteral(schema) {
      return TKindOf(schema, "Literal") && IsOptionalString(schema.$id) && (ValueGuard.IsBoolean(schema.const) || ValueGuard.IsNumber(schema.const) || ValueGuard.IsString(schema.const));
    }
    TypeGuard2.TLiteral = TLiteral;
    function TNever(schema) {
      return TKindOf(schema, "Never") && ValueGuard.IsObject(schema.not) && Object.getOwnPropertyNames(schema.not).length === 0;
    }
    TypeGuard2.TNever = TNever;
    function TNot(schema) {
      return TKindOf(schema, "Not") && TSchema(schema.not);
    }
    TypeGuard2.TNot = TNot;
    function TNull(schema) {
      return TKindOf(schema, "Null") && schema.type === "null" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TNull = TNull;
    function TNumber(schema) {
      return TKindOf(schema, "Number") && schema.type === "number" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
    }
    TypeGuard2.TNumber = TNumber;
    function TObject(schema) {
      return TKindOf(schema, "Object") && schema.type === "object" && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema.properties) && IsAdditionalProperties(schema.additionalProperties) && IsOptionalNumber(schema.minProperties) && IsOptionalNumber(schema.maxProperties) && Object.entries(schema.properties).every(([key, schema2]) => IsControlCharacterFree(key) && TSchema(schema2));
    }
    TypeGuard2.TObject = TObject;
    function TPromise(schema) {
      return TKindOf(schema, "Promise") && schema.type === "Promise" && IsOptionalString(schema.$id) && TSchema(schema.item);
    }
    TypeGuard2.TPromise = TPromise;
    function TRecord(schema) {
      return TKindOf(schema, "Record") && schema.type === "object" && IsOptionalString(schema.$id) && IsAdditionalProperties(schema.additionalProperties) && ValueGuard.IsObject(schema.patternProperties) && ((schema2) => {
        const keys = Object.getOwnPropertyNames(schema2.patternProperties);
        return keys.length === 1 && IsPattern(keys[0]) && ValueGuard.IsObject(schema2.patternProperties) && TSchema(schema2.patternProperties[keys[0]]);
      })(schema);
    }
    TypeGuard2.TRecord = TRecord;
    function TRecursive(schema) {
      return ValueGuard.IsObject(schema) && exports.Hint in schema && schema[exports.Hint] === "Recursive";
    }
    TypeGuard2.TRecursive = TRecursive;
    function TRef(schema) {
      return TKindOf(schema, "Ref") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
    }
    TypeGuard2.TRef = TRef;
    function TString(schema) {
      return TKindOf(schema, "String") && schema.type === "string" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minLength) && IsOptionalNumber(schema.maxLength) && IsOptionalPattern(schema.pattern) && IsOptionalFormat(schema.format);
    }
    TypeGuard2.TString = TString;
    function TSymbol(schema) {
      return TKindOf(schema, "Symbol") && schema.type === "symbol" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TSymbol = TSymbol;
    function TTemplateLiteral(schema) {
      return TKindOf(schema, "TemplateLiteral") && schema.type === "string" && ValueGuard.IsString(schema.pattern) && schema.pattern[0] === "^" && schema.pattern[schema.pattern.length - 1] === "$";
    }
    TypeGuard2.TTemplateLiteral = TTemplateLiteral;
    function TThis(schema) {
      return TKindOf(schema, "This") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
    }
    TypeGuard2.TThis = TThis;
    function TTransform(schema) {
      return ValueGuard.IsObject(schema) && exports.Transform in schema;
    }
    TypeGuard2.TTransform = TTransform;
    function TTuple(schema) {
      return TKindOf(schema, "Tuple") && schema.type === "array" && IsOptionalString(schema.$id) && ValueGuard.IsNumber(schema.minItems) && ValueGuard.IsNumber(schema.maxItems) && schema.minItems === schema.maxItems && (ValueGuard.IsUndefined(schema.items) && ValueGuard.IsUndefined(schema.additionalItems) && schema.minItems === 0 || ValueGuard.IsArray(schema.items) && schema.items.every((schema2) => TSchema(schema2)));
    }
    TypeGuard2.TTuple = TTuple;
    function TUndefined(schema) {
      return TKindOf(schema, "Undefined") && schema.type === "undefined" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TUndefined = TUndefined;
    function TUnionLiteral(schema) {
      return TUnion(schema) && schema.anyOf.every((schema2) => TLiteralString(schema2) || TLiteralNumber(schema2));
    }
    TypeGuard2.TUnionLiteral = TUnionLiteral;
    function TUnion(schema) {
      return TKindOf(schema, "Union") && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema) && ValueGuard.IsArray(schema.anyOf) && schema.anyOf.every((schema2) => TSchema(schema2));
    }
    TypeGuard2.TUnion = TUnion;
    function TUint8Array(schema) {
      return TKindOf(schema, "Uint8Array") && schema.type === "Uint8Array" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);
    }
    TypeGuard2.TUint8Array = TUint8Array;
    function TUnknown(schema) {
      return TKindOf(schema, "Unknown") && IsOptionalString(schema.$id);
    }
    TypeGuard2.TUnknown = TUnknown;
    function TUnsafe(schema) {
      return TKindOf(schema, "Unsafe");
    }
    TypeGuard2.TUnsafe = TUnsafe;
    function TVoid(schema) {
      return TKindOf(schema, "Void") && schema.type === "void" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TVoid = TVoid;
    function TReadonly(schema) {
      return ValueGuard.IsObject(schema) && schema[exports.Readonly] === "Readonly";
    }
    TypeGuard2.TReadonly = TReadonly;
    function TOptional(schema) {
      return ValueGuard.IsObject(schema) && schema[exports.Optional] === "Optional";
    }
    TypeGuard2.TOptional = TOptional;
    function TSchema(schema) {
      return ValueGuard.IsObject(schema) && (TAny(schema) || TArray(schema) || TBoolean(schema) || TBigInt(schema) || TAsyncIterator(schema) || TConstructor(schema) || TDate(schema) || TFunction(schema) || TInteger(schema) || TIntersect(schema) || TIterator(schema) || TLiteral(schema) || TNever(schema) || TNot(schema) || TNull(schema) || TNumber(schema) || TObject(schema) || TPromise(schema) || TRecord(schema) || TRef(schema) || TString(schema) || TSymbol(schema) || TTemplateLiteral(schema) || TThis(schema) || TTuple(schema) || TUndefined(schema) || TUnion(schema) || TUint8Array(schema) || TUnknown(schema) || TUnsafe(schema) || TVoid(schema) || TKind(schema) && TypeRegistry.Has(schema[exports.Kind]));
    }
    TypeGuard2.TSchema = TSchema;
  })(TypeGuard || (exports.TypeGuard = TypeGuard = {}));
  var ExtendsUndefined;
  (function(ExtendsUndefined2) {
    function Check(schema) {
      return schema[exports.Kind] === "Intersect" ? schema.allOf.every((schema2) => Check(schema2)) : schema[exports.Kind] === "Union" ? schema.anyOf.some((schema2) => Check(schema2)) : schema[exports.Kind] === "Undefined" ? true : schema[exports.Kind] === "Not" ? !Check(schema.not) : false;
    }
    ExtendsUndefined2.Check = Check;
  })(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));

  class TypeExtendsError extends TypeBoxError {
  }
  exports.TypeExtendsError = TypeExtendsError;
  var TypeExtendsResult;
  (function(TypeExtendsResult2) {
    TypeExtendsResult2[TypeExtendsResult2["Union"] = 0] = "Union";
    TypeExtendsResult2[TypeExtendsResult2["True"] = 1] = "True";
    TypeExtendsResult2[TypeExtendsResult2["False"] = 2] = "False";
  })(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));
  var TypeExtends;
  (function(TypeExtends2) {
    function IntoBooleanResult(result) {
      return result === TypeExtendsResult.False ? result : TypeExtendsResult.True;
    }
    function Throw(message) {
      throw new TypeExtendsError(message);
    }
    function IsStructuralRight(right) {
      return TypeGuard.TNever(right) || TypeGuard.TIntersect(right) || TypeGuard.TUnion(right) || TypeGuard.TUnknown(right) || TypeGuard.TAny(right);
    }
    function StructuralRight(left, right) {
      return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : Throw("StructuralRight");
    }
    function TAnyRight(left, right) {
      return TypeExtendsResult.True;
    }
    function TAny(left, right) {
      return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)) ? TypeExtendsResult.True : TypeGuard.TUnion(right) ? TypeExtendsResult.Union : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeGuard.TAny(right) ? TypeExtendsResult.True : TypeExtendsResult.Union;
    }
    function TArrayRight(left, right) {
      return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TArray(left, right) {
      return TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TArray(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
    }
    function TAsyncIterator(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TAsyncIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
    }
    function TBigInt(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TBooleanRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const) ? TypeExtendsResult.True : TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TBoolean(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TConstructor(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TConstructor(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
    }
    function TDate(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TFunction(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TFunction(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
    }
    function TIntegerRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TInteger(left, right) {
      return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeExtendsResult.False;
    }
    function TIntersectRight(left, right) {
      return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TIntersect(left, right) {
      return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TIterator(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
    }
    function TLiteral(left, right) {
      return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeExtendsResult.False;
    }
    function TNeverRight(left, right) {
      return TypeExtendsResult.False;
    }
    function TNever(left, right) {
      return TypeExtendsResult.True;
    }
    function UnwrapTNot(schema) {
      let [current, depth] = [schema, 0];
      while (true) {
        if (!TypeGuard.TNot(current))
          break;
        current = current.not;
        depth += 1;
      }
      return depth % 2 === 0 ? current : exports.Type.Unknown();
    }
    function TNot(left, right) {
      return TypeGuard.TNot(left) ? Visit(UnwrapTNot(left), right) : TypeGuard.TNot(right) ? Visit(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
    }
    function TNull(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TNumberRight(left, right) {
      return TypeGuard.TLiteralNumber(left) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TNumber(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function IsObjectPropertyCount(schema, count) {
      return Object.getOwnPropertyNames(schema.properties).length === count;
    }
    function IsObjectStringLike(schema) {
      return IsObjectArrayLike(schema);
    }
    function IsObjectSymbolLike(schema) {
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema.properties.description.anyOf[1]) || TypeGuard.TString(schema.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema.properties.description.anyOf[0]));
    }
    function IsObjectNumberLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectBooleanLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectBigIntLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectDateLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectUint8ArrayLike(schema) {
      return IsObjectArrayLike(schema);
    }
    function IsObjectFunctionLike(schema) {
      const length = exports.Type.Number();
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
    }
    function IsObjectConstructorLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectArrayLike(schema) {
      const length = exports.Type.Number();
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
    }
    function IsObjectPromiseLike(schema) {
      const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit(schema.properties["then"], then)) === TypeExtendsResult.True;
    }
    function Property(left, right) {
      return Visit(left, right) === TypeExtendsResult.False ? TypeExtendsResult.False : TypeGuard.TOptional(left) && !TypeGuard.TOptional(right) ? TypeExtendsResult.False : TypeExtendsResult.True;
    }
    function TObjectRight(left, right) {
      return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) || TypeGuard.TLiteralString(left) && IsObjectStringLike(right) || TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right) || TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TBigInt(left) && IsObjectBigIntLike(right) || TypeGuard.TString(left) && IsObjectStringLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TNumber(left) && IsObjectNumberLike(right) || TypeGuard.TInteger(left) && IsObjectNumberLike(right) || TypeGuard.TBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right) || TypeGuard.TDate(left) && IsObjectDateLike(right) || TypeGuard.TConstructor(left) && IsObjectConstructorLike(right) || TypeGuard.TFunction(left) && IsObjectFunctionLike(right) ? TypeExtendsResult.True : TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left)) ? (() => {
        return right[exports.Hint] === "Record" ? TypeExtendsResult.True : TypeExtendsResult.False;
      })() : TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left)) ? (() => {
        return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;
      })() : TypeExtendsResult.False;
    }
    function TObject(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : !TypeGuard.TObject(right) ? TypeExtendsResult.False : (() => {
        for (const key of Object.getOwnPropertyNames(right.properties)) {
          if (!(key in left.properties) && !TypeGuard.TOptional(right.properties[key])) {
            return TypeExtendsResult.False;
          }
          if (TypeGuard.TOptional(right.properties[key])) {
            return TypeExtendsResult.True;
          }
          if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {
            return TypeExtendsResult.False;
          }
        }
        return TypeExtendsResult.True;
      })();
    }
    function TPromise(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectPromiseLike(right) ? TypeExtendsResult.True : !TypeGuard.TPromise(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.item, right.item));
    }
    function RecordKey(schema) {
      return exports.PatternNumberExact in schema.patternProperties ? exports.Type.Number() : (exports.PatternStringExact in schema.patternProperties) ? exports.Type.String() : Throw("Unknown record key pattern");
    }
    function RecordValue(schema) {
      return exports.PatternNumberExact in schema.patternProperties ? schema.patternProperties[exports.PatternNumberExact] : (exports.PatternStringExact in schema.patternProperties) ? schema.patternProperties[exports.PatternStringExact] : Throw("Unable to get record value schema");
    }
    function TRecordRight(left, right) {
      const [Key, Value] = [RecordKey(right), RecordValue(right)];
      return TypeGuard.TLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True ? TypeExtendsResult.True : TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TString(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TArray(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TObject(left) ? (() => {
        for (const key of Object.getOwnPropertyNames(left.properties)) {
          if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {
            return TypeExtendsResult.False;
          }
        }
        return TypeExtendsResult.True;
      })() : TypeExtendsResult.False;
    }
    function TRecord(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TRecord(right) ? TypeExtendsResult.False : Visit(RecordValue(left), RecordValue(right));
    }
    function TStringRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const) ? TypeExtendsResult.True : TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TString(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TSymbol(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TTemplateLiteral(left, right) {
      return TypeGuard.TTemplateLiteral(left) ? Visit(TemplateLiteralResolver.Resolve(left), right) : TypeGuard.TTemplateLiteral(right) ? Visit(left, TemplateLiteralResolver.Resolve(right)) : Throw("Invalid fallthrough for TemplateLiteral");
    }
    function IsArrayOfTuple(left, right) {
      return TypeGuard.TArray(right) && left.items !== undefined && left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True);
    }
    function TTupleRight(left, right) {
      return TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeExtendsResult.False;
    }
    function TTuple(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : TypeGuard.TArray(right) && IsArrayOfTuple(left, right) ? TypeExtendsResult.True : !TypeGuard.TTuple(right) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) || !ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.True : left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUint8Array(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUndefined(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TVoid(right) ? VoidRight(left, right) : TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUnionRight(left, right) {
      return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUnion(left, right) {
      return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUnknownRight(left, right) {
      return TypeExtendsResult.True;
    }
    function TUnknown(left, right) {
      return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeGuard.TArray(right) ? TArrayRight(left, right) : TypeGuard.TTuple(right) ? TTupleRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function VoidRight(left, right) {
      return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TVoid(left, right) {
      return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function Visit(left, right) {
      return TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right) ? TTemplateLiteral(left, right) : TypeGuard.TNot(left) || TypeGuard.TNot(right) ? TNot(left, right) : TypeGuard.TAny(left) ? TAny(left, right) : TypeGuard.TArray(left) ? TArray(left, right) : TypeGuard.TBigInt(left) ? TBigInt(left, right) : TypeGuard.TBoolean(left) ? TBoolean(left, right) : TypeGuard.TAsyncIterator(left) ? TAsyncIterator(left, right) : TypeGuard.TConstructor(left) ? TConstructor(left, right) : TypeGuard.TDate(left) ? TDate(left, right) : TypeGuard.TFunction(left) ? TFunction(left, right) : TypeGuard.TInteger(left) ? TInteger(left, right) : TypeGuard.TIntersect(left) ? TIntersect(left, right) : TypeGuard.TIterator(left) ? TIterator(left, right) : TypeGuard.TLiteral(left) ? TLiteral(left, right) : TypeGuard.TNever(left) ? TNever(left, right) : TypeGuard.TNull(left) ? TNull(left, right) : TypeGuard.TNumber(left) ? TNumber(left, right) : TypeGuard.TObject(left) ? TObject(left, right) : TypeGuard.TRecord(left) ? TRecord(left, right) : TypeGuard.TString(left) ? TString(left, right) : TypeGuard.TSymbol(left) ? TSymbol(left, right) : TypeGuard.TTuple(left) ? TTuple(left, right) : TypeGuard.TPromise(left) ? TPromise(left, right) : TypeGuard.TUint8Array(left) ? TUint8Array(left, right) : TypeGuard.TUndefined(left) ? TUndefined(left, right) : TypeGuard.TUnion(left) ? TUnion(left, right) : TypeGuard.TUnknown(left) ? TUnknown(left, right) : TypeGuard.TVoid(left) ? TVoid(left, right) : Throw(`Unknown left type operand '${left[exports.Kind]}'`);
    }
    function Extends(left, right) {
      return Visit(left, right);
    }
    TypeExtends2.Extends = Extends;
  })(TypeExtends || (exports.TypeExtends = TypeExtends = {}));
  var TypeClone;
  (function(TypeClone2) {
    function ArrayType(value) {
      return value.map((value2) => Visit(value2));
    }
    function DateType(value) {
      return new Date(value.getTime());
    }
    function Uint8ArrayType(value) {
      return new Uint8Array(value);
    }
    function ObjectType(value) {
      const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
      const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
      return { ...clonedProperties, ...clonedSymbols };
    }
    function Visit(value) {
      return ValueGuard.IsArray(value) ? ArrayType(value) : ValueGuard.IsDate(value) ? DateType(value) : ValueGuard.IsUint8Array(value) ? Uint8ArrayType(value) : ValueGuard.IsObject(value) ? ObjectType(value) : value;
    }
    function Rest(schemas) {
      return schemas.map((schema) => Type(schema));
    }
    TypeClone2.Rest = Rest;
    function Type(schema, options = {}) {
      return { ...Visit(schema), ...options };
    }
    TypeClone2.Type = Type;
  })(TypeClone || (exports.TypeClone = TypeClone = {}));
  var IndexedAccessor;
  (function(IndexedAccessor2) {
    function OptionalUnwrap(schema) {
      return schema.map((schema2) => {
        const { [exports.Optional]: _, ...clone } = TypeClone.Type(schema2);
        return clone;
      });
    }
    function IsIntersectOptional(schema) {
      return schema.every((schema2) => TypeGuard.TOptional(schema2));
    }
    function IsUnionOptional(schema) {
      return schema.some((schema2) => TypeGuard.TOptional(schema2));
    }
    function ResolveIntersect(schema) {
      return IsIntersectOptional(schema.allOf) ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;
    }
    function ResolveUnion(schema) {
      return IsUnionOptional(schema.anyOf) ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;
    }
    function ResolveOptional(schema) {
      return schema[exports.Kind] === "Intersect" ? ResolveIntersect(schema) : schema[exports.Kind] === "Union" ? ResolveUnion(schema) : schema;
    }
    function TIntersect(schema, key) {
      const resolved = schema.allOf.reduce((acc, schema2) => {
        const indexed = Visit(schema2, key);
        return indexed[exports.Kind] === "Never" ? acc : [...acc, indexed];
      }, []);
      return ResolveOptional(exports.Type.Intersect(resolved));
    }
    function TUnion(schema, key) {
      const resolved = schema.anyOf.map((schema2) => Visit(schema2, key));
      return ResolveOptional(exports.Type.Union(resolved));
    }
    function TObject(schema, key) {
      const property = schema.properties[key];
      return ValueGuard.IsUndefined(property) ? exports.Type.Never() : exports.Type.Union([property]);
    }
    function TTuple(schema, key) {
      const items = schema.items;
      if (ValueGuard.IsUndefined(items))
        return exports.Type.Never();
      const element = items[key];
      if (ValueGuard.IsUndefined(element))
        return exports.Type.Never();
      return element;
    }
    function Visit(schema, key) {
      return schema[exports.Kind] === "Intersect" ? TIntersect(schema, key) : schema[exports.Kind] === "Union" ? TUnion(schema, key) : schema[exports.Kind] === "Object" ? TObject(schema, key) : schema[exports.Kind] === "Tuple" ? TTuple(schema, key) : exports.Type.Never();
    }
    function Resolve(schema, keys, options = {}) {
      const resolved = keys.map((key) => Visit(schema, key.toString()));
      return ResolveOptional(exports.Type.Union(resolved, options));
    }
    IndexedAccessor2.Resolve = Resolve;
  })(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));
  var Intrinsic;
  (function(Intrinsic2) {
    function Uncapitalize(value) {
      const [first, rest] = [value.slice(0, 1), value.slice(1)];
      return `${first.toLowerCase()}${rest}`;
    }
    function Capitalize(value) {
      const [first, rest] = [value.slice(0, 1), value.slice(1)];
      return `${first.toUpperCase()}${rest}`;
    }
    function Uppercase(value) {
      return value.toUpperCase();
    }
    function Lowercase(value) {
      return value.toLowerCase();
    }
    function IntrinsicTemplateLiteral(schema, mode) {
      const expression = TemplateLiteralParser.ParseExact(schema.pattern);
      const finite = TemplateLiteralFinite.Check(expression);
      if (!finite)
        return { ...schema, pattern: IntrinsicLiteral(schema.pattern, mode) };
      const strings = [...TemplateLiteralGenerator.Generate(expression)];
      const literals = strings.map((value) => exports.Type.Literal(value));
      const mapped = IntrinsicRest(literals, mode);
      const union = exports.Type.Union(mapped);
      return exports.Type.TemplateLiteral([union]);
    }
    function IntrinsicLiteral(value, mode) {
      return typeof value === "string" ? mode === "Uncapitalize" ? Uncapitalize(value) : mode === "Capitalize" ? Capitalize(value) : mode === "Uppercase" ? Uppercase(value) : mode === "Lowercase" ? Lowercase(value) : value : value.toString();
    }
    function IntrinsicRest(schema, mode) {
      if (schema.length === 0)
        return [];
      const [L, ...R] = schema;
      return [Map2(L, mode), ...IntrinsicRest(R, mode)];
    }
    function Visit(schema, mode) {
      return TypeGuard.TTemplateLiteral(schema) ? IntrinsicTemplateLiteral(schema, mode) : TypeGuard.TUnion(schema) ? exports.Type.Union(IntrinsicRest(schema.anyOf, mode)) : TypeGuard.TLiteral(schema) ? exports.Type.Literal(IntrinsicLiteral(schema.const, mode)) : schema;
    }
    function Map2(schema, mode) {
      return Visit(schema, mode);
    }
    Intrinsic2.Map = Map2;
  })(Intrinsic || (exports.Intrinsic = Intrinsic = {}));
  var ObjectMap;
  (function(ObjectMap2) {
    function TIntersect(schema, callback) {
      return exports.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });
    }
    function TUnion(schema, callback) {
      return exports.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });
    }
    function TObject(schema, callback) {
      return callback(schema);
    }
    function Visit(schema, callback) {
      return schema[exports.Kind] === "Intersect" ? TIntersect(schema, callback) : schema[exports.Kind] === "Union" ? TUnion(schema, callback) : schema[exports.Kind] === "Object" ? TObject(schema, callback) : schema;
    }
    function Map2(schema, callback, options) {
      return { ...Visit(TypeClone.Type(schema), callback), ...options };
    }
    ObjectMap2.Map = Map2;
  })(ObjectMap || (exports.ObjectMap = ObjectMap = {}));
  var KeyResolver;
  (function(KeyResolver2) {
    function UnwrapPattern(key) {
      return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
    }
    function TIntersect(schema, options) {
      return schema.allOf.reduce((acc, schema2) => [...acc, ...Visit(schema2, options)], []);
    }
    function TUnion(schema, options) {
      const sets = schema.anyOf.map((inner) => Visit(inner, options));
      return [...sets.reduce((set, outer) => outer.map((key) => sets.every((inner) => inner.includes(key)) ? set.add(key) : set)[0], new Set)];
    }
    function TObject(schema, options) {
      return Object.getOwnPropertyNames(schema.properties);
    }
    function TRecord(schema, options) {
      return options.includePatterns ? Object.getOwnPropertyNames(schema.patternProperties) : [];
    }
    function Visit(schema, options) {
      return TypeGuard.TIntersect(schema) ? TIntersect(schema, options) : TypeGuard.TUnion(schema) ? TUnion(schema, options) : TypeGuard.TObject(schema) ? TObject(schema, options) : TypeGuard.TRecord(schema) ? TRecord(schema, options) : [];
    }
    function ResolveKeys(schema, options) {
      return [...new Set(Visit(schema, options))];
    }
    KeyResolver2.ResolveKeys = ResolveKeys;
    function ResolvePattern(schema) {
      const keys = ResolveKeys(schema, { includePatterns: true });
      const pattern = keys.map((key) => `(${UnwrapPattern(key)})`);
      return `^(${pattern.join("|")})\$`;
    }
    KeyResolver2.ResolvePattern = ResolvePattern;
  })(KeyResolver || (exports.KeyResolver = KeyResolver = {}));

  class KeyArrayResolverError extends TypeBoxError {
  }
  exports.KeyArrayResolverError = KeyArrayResolverError;
  var KeyArrayResolver;
  (function(KeyArrayResolver2) {
    function Resolve(schema) {
      return Array.isArray(schema) ? schema : TypeGuard.TUnionLiteral(schema) ? schema.anyOf.map((schema2) => schema2.const.toString()) : TypeGuard.TLiteral(schema) ? [schema.const] : TypeGuard.TTemplateLiteral(schema) ? (() => {
        const expression = TemplateLiteralParser.ParseExact(schema.pattern);
        if (!TemplateLiteralFinite.Check(expression))
          throw new KeyArrayResolverError("Cannot resolve keys from infinite template expression");
        return [...TemplateLiteralGenerator.Generate(expression)];
      })() : [];
    }
    KeyArrayResolver2.Resolve = Resolve;
  })(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));
  var UnionResolver;
  (function(UnionResolver2) {
    function* TUnion(union) {
      for (const schema of union.anyOf) {
        if (schema[exports.Kind] === "Union") {
          yield* TUnion(schema);
        } else {
          yield schema;
        }
      }
    }
    function Resolve(union) {
      return exports.Type.Union([...TUnion(union)], { ...union });
    }
    UnionResolver2.Resolve = Resolve;
  })(UnionResolver || (exports.UnionResolver = UnionResolver = {}));

  class TemplateLiteralPatternError extends TypeBoxError {
  }
  exports.TemplateLiteralPatternError = TemplateLiteralPatternError;
  var TemplateLiteralPattern;
  (function(TemplateLiteralPattern2) {
    function Throw(message) {
      throw new TemplateLiteralPatternError(message);
    }
    function Escape(value) {
      return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function Visit(schema, acc) {
      return TypeGuard.TTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : TypeGuard.TUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit(schema2, acc)).join("|")})` : TypeGuard.TNumber(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TInteger(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TBigInt(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TString(schema) ? `${acc}${exports.PatternString}` : TypeGuard.TLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : TypeGuard.TBoolean(schema) ? `${acc}${exports.PatternBoolean}` : Throw(`Unexpected Kind '${schema[exports.Kind]}'`);
    }
    function Create(kinds) {
      return `^${kinds.map((schema) => Visit(schema, "")).join("")}$`;
    }
    TemplateLiteralPattern2.Create = Create;
  })(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));
  var TemplateLiteralResolver;
  (function(TemplateLiteralResolver2) {
    function Resolve(template) {
      const expression = TemplateLiteralParser.ParseExact(template.pattern);
      if (!TemplateLiteralFinite.Check(expression))
        return exports.Type.String();
      const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));
      return exports.Type.Union(literals);
    }
    TemplateLiteralResolver2.Resolve = Resolve;
  })(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));

  class TemplateLiteralParserError extends TypeBoxError {
  }
  exports.TemplateLiteralParserError = TemplateLiteralParserError;
  var TemplateLiteralParser;
  (function(TemplateLiteralParser2) {
    function IsNonEscaped(pattern, index, char) {
      return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
    }
    function IsOpenParen(pattern, index) {
      return IsNonEscaped(pattern, index, "(");
    }
    function IsCloseParen(pattern, index) {
      return IsNonEscaped(pattern, index, ")");
    }
    function IsSeparator(pattern, index) {
      return IsNonEscaped(pattern, index, "|");
    }
    function IsGroup(pattern) {
      if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
        return false;
      let count = 0;
      for (let index = 0;index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
          count += 1;
        if (IsCloseParen(pattern, index))
          count -= 1;
        if (count === 0 && index !== pattern.length - 1)
          return false;
      }
      return true;
    }
    function InGroup(pattern) {
      return pattern.slice(1, pattern.length - 1);
    }
    function IsPrecedenceOr(pattern) {
      let count = 0;
      for (let index = 0;index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
          count += 1;
        if (IsCloseParen(pattern, index))
          count -= 1;
        if (IsSeparator(pattern, index) && count === 0)
          return true;
      }
      return false;
    }
    function IsPrecedenceAnd(pattern) {
      for (let index = 0;index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
          return true;
      }
      return false;
    }
    function Or(pattern) {
      let [count, start] = [0, 0];
      const expressions = [];
      for (let index = 0;index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
          count += 1;
        if (IsCloseParen(pattern, index))
          count -= 1;
        if (IsSeparator(pattern, index) && count === 0) {
          const range2 = pattern.slice(start, index);
          if (range2.length > 0)
            expressions.push(Parse(range2));
          start = index + 1;
        }
      }
      const range = pattern.slice(start);
      if (range.length > 0)
        expressions.push(Parse(range));
      if (expressions.length === 0)
        return { type: "const", const: "" };
      if (expressions.length === 1)
        return expressions[0];
      return { type: "or", expr: expressions };
    }
    function And(pattern) {
      function Group(value, index) {
        if (!IsOpenParen(value, index))
          throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
        let count = 0;
        for (let scan = index;scan < value.length; scan++) {
          if (IsOpenParen(value, scan))
            count += 1;
          if (IsCloseParen(value, scan))
            count -= 1;
          if (count === 0)
            return [index, scan];
        }
        throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
      }
      function Range(pattern2, index) {
        for (let scan = index;scan < pattern2.length; scan++) {
          if (IsOpenParen(pattern2, scan))
            return [index, scan];
        }
        return [index, pattern2.length];
      }
      const expressions = [];
      for (let index = 0;index < pattern.length; index++) {
        if (IsOpenParen(pattern, index)) {
          const [start, end] = Group(pattern, index);
          const range = pattern.slice(start, end + 1);
          expressions.push(Parse(range));
          index = end;
        } else {
          const [start, end] = Range(pattern, index);
          const range = pattern.slice(start, end);
          if (range.length > 0)
            expressions.push(Parse(range));
          index = end - 1;
        }
      }
      return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
    }
    function Parse(pattern) {
      return IsGroup(pattern) ? Parse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: pattern };
    }
    TemplateLiteralParser2.Parse = Parse;
    function ParseExact(pattern) {
      return Parse(pattern.slice(1, pattern.length - 1));
    }
    TemplateLiteralParser2.ParseExact = ParseExact;
  })(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));

  class TemplateLiteralFiniteError extends TypeBoxError {
  }
  exports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
  var TemplateLiteralFinite;
  (function(TemplateLiteralFinite2) {
    function Throw(message) {
      throw new TemplateLiteralFiniteError(message);
    }
    function IsNumber(expression) {
      return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
    }
    function IsBoolean(expression) {
      return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
    }
    function IsString(expression) {
      return expression.type === "const" && expression.const === ".*";
    }
    function Check(expression) {
      return IsBoolean(expression) ? true : IsNumber(expression) || IsString(expression) ? false : expression.type === "and" ? expression.expr.every((expr) => Check(expr)) : expression.type === "or" ? expression.expr.every((expr) => Check(expr)) : expression.type === "const" ? true : Throw(`Unknown expression type`);
    }
    TemplateLiteralFinite2.Check = Check;
  })(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));

  class TemplateLiteralGeneratorError extends TypeBoxError {
  }
  exports.TemplateLiteralGeneratorError = TemplateLiteralGeneratorError;
  var TemplateLiteralGenerator;
  (function(TemplateLiteralGenerator2) {
    function* Reduce(buffer) {
      if (buffer.length === 1)
        return yield* buffer[0];
      for (const left of buffer[0]) {
        for (const right of Reduce(buffer.slice(1))) {
          yield `${left}${right}`;
        }
      }
    }
    function* And(expression) {
      return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));
    }
    function* Or(expression) {
      for (const expr of expression.expr)
        yield* Generate(expr);
    }
    function* Const(expression) {
      return yield expression.const;
    }
    function* Generate(expression) {
      return expression.type === "and" ? yield* And(expression) : expression.type === "or" ? yield* Or(expression) : expression.type === "const" ? yield* Const(expression) : (() => {
        throw new TemplateLiteralGeneratorError("Unknown expression");
      })();
    }
    TemplateLiteralGenerator2.Generate = Generate;
  })(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));
  var TemplateLiteralDslParser;
  (function(TemplateLiteralDslParser2) {
    function* ParseUnion(template) {
      const trim = template.trim().replace(/"|'/g, "");
      return trim === "boolean" ? yield exports.Type.Boolean() : trim === "number" ? yield exports.Type.Number() : trim === "bigint" ? yield exports.Type.BigInt() : trim === "string" ? yield exports.Type.String() : yield (() => {
        const literals = trim.split("|").map((literal) => exports.Type.Literal(literal.trim()));
        return literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);
      })();
    }
    function* ParseTerminal(template) {
      if (template[1] !== "{") {
        const L = exports.Type.Literal("$");
        const R = ParseLiteral(template.slice(1));
        return yield* [L, ...R];
      }
      for (let i = 2;i < template.length; i++) {
        if (template[i] === "}") {
          const L = ParseUnion(template.slice(2, i));
          const R = ParseLiteral(template.slice(i + 1));
          return yield* [...L, ...R];
        }
      }
      yield exports.Type.Literal(template);
    }
    function* ParseLiteral(template) {
      for (let i = 0;i < template.length; i++) {
        if (template[i] === "$") {
          const L = exports.Type.Literal(template.slice(0, i));
          const R = ParseTerminal(template.slice(i));
          return yield* [L, ...R];
        }
      }
      yield exports.Type.Literal(template);
    }
    function Parse(template_dsl) {
      return [...ParseLiteral(template_dsl)];
    }
    TemplateLiteralDslParser2.Parse = Parse;
  })(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));

  class TransformDecodeBuilder {
    constructor(schema) {
      this.schema = schema;
    }
    Decode(decode) {
      return new TransformEncodeBuilder(this.schema, decode);
    }
  }
  exports.TransformDecodeBuilder = TransformDecodeBuilder;

  class TransformEncodeBuilder {
    constructor(schema, decode) {
      this.schema = schema;
      this.decode = decode;
    }
    Encode(encode) {
      const schema = TypeClone.Type(this.schema);
      return TypeGuard.TTransform(schema) ? (() => {
        const Encode = (value) => schema[exports.Transform].Encode(encode(value));
        const Decode = (value) => this.decode(schema[exports.Transform].Decode(value));
        const Codec = { Encode, Decode };
        return { ...schema, [exports.Transform]: Codec };
      })() : (() => {
        const Codec = { Decode: this.decode, Encode: encode };
        return { ...schema, [exports.Transform]: Codec };
      })();
    }
  }
  exports.TransformEncodeBuilder = TransformEncodeBuilder;
  var TypeOrdinal = 0;

  class TypeBuilderError extends TypeBoxError {
  }
  exports.TypeBuilderError = TypeBuilderError;

  class TypeBuilder {
    Create(schema) {
      return schema;
    }
    Throw(message) {
      throw new TypeBuilderError(message);
    }
    Discard(record, keys) {
      return keys.reduce((acc, key) => {
        const { [key]: _, ...rest } = acc;
        return rest;
      }, record);
    }
    Strict(schema) {
      return JSON.parse(JSON.stringify(schema));
    }
  }
  exports.TypeBuilder = TypeBuilder;

  class JsonTypeBuilder extends TypeBuilder {
    ReadonlyOptional(schema) {
      return this.Readonly(this.Optional(schema));
    }
    Readonly(schema) {
      return { ...TypeClone.Type(schema), [exports.Readonly]: "Readonly" };
    }
    Optional(schema) {
      return { ...TypeClone.Type(schema), [exports.Optional]: "Optional" };
    }
    Any(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Any" });
    }
    Array(schema, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Array", type: "array", items: TypeClone.Type(schema) });
    }
    Boolean(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Boolean", type: "boolean" });
    }
    Capitalize(schema, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema), "Capitalize"), ...options };
    }
    Composite(objects, options) {
      const intersect = exports.Type.Intersect(objects, {});
      const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });
      const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect, [key]) }), {});
      return exports.Type.Object(properties, options);
    }
    Enum(item, options = {}) {
      if (ValueGuard.IsUndefined(item))
        return this.Throw("Enum undefined or empty");
      const values1 = Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
      const values2 = [...new Set(values1)];
      const anyOf = values2.map((value) => exports.Type.Literal(value));
      return this.Union(anyOf, { ...options, [exports.Hint]: "Enum" });
    }
    Extends(left, right, trueType, falseType, options = {}) {
      switch (TypeExtends.Extends(left, right)) {
        case TypeExtendsResult.Union:
          return this.Union([TypeClone.Type(trueType, options), TypeClone.Type(falseType, options)]);
        case TypeExtendsResult.True:
          return TypeClone.Type(trueType, options);
        case TypeExtendsResult.False:
          return TypeClone.Type(falseType, options);
      }
    }
    Exclude(unionType, excludedMembers, options = {}) {
      return TypeGuard.TTemplateLiteral(unionType) ? this.Exclude(TemplateLiteralResolver.Resolve(unionType), excludedMembers, options) : TypeGuard.TTemplateLiteral(excludedMembers) ? this.Exclude(unionType, TemplateLiteralResolver.Resolve(excludedMembers), options) : TypeGuard.TUnion(unionType) ? (() => {
        const narrowed = unionType.anyOf.filter((inner) => TypeExtends.Extends(inner, excludedMembers) === TypeExtendsResult.False);
        return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
      })() : TypeExtends.Extends(unionType, excludedMembers) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Type(unionType, options);
    }
    Extract(type, union, options = {}) {
      return TypeGuard.TTemplateLiteral(type) ? this.Extract(TemplateLiteralResolver.Resolve(type), union, options) : TypeGuard.TTemplateLiteral(union) ? this.Extract(type, TemplateLiteralResolver.Resolve(union), options) : TypeGuard.TUnion(type) ? (() => {
        const narrowed = type.anyOf.filter((inner) => TypeExtends.Extends(inner, union) !== TypeExtendsResult.False);
        return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
      })() : TypeExtends.Extends(type, union) !== TypeExtendsResult.False ? TypeClone.Type(type, options) : this.Never(options);
    }
    Index(schema, unresolved, options = {}) {
      return TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved) ? (() => {
        return TypeClone.Type(schema.items, options);
      })() : TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved) ? (() => {
        const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
        const cloned = items.map((schema2) => TypeClone.Type(schema2));
        return this.Union(cloned, options);
      })() : (() => {
        const keys = KeyArrayResolver.Resolve(unresolved);
        const clone = TypeClone.Type(schema);
        return IndexedAccessor.Resolve(clone, keys, options);
      })();
    }
    Integer(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Integer", type: "integer" });
    }
    Intersect(allOf, options = {}) {
      if (allOf.length === 0)
        return exports.Type.Never();
      if (allOf.length === 1)
        return TypeClone.Type(allOf[0], options);
      if (allOf.some((schema) => TypeGuard.TTransform(schema)))
        this.Throw("Cannot intersect transform types");
      const objects = allOf.every((schema) => TypeGuard.TObject(schema));
      const cloned = TypeClone.Rest(allOf);
      const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Type(options.unevaluatedProperties) } : {};
      return options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects ? this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", type: "object", allOf: cloned }) : this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", allOf: cloned });
    }
    KeyOf(schema, options = {}) {
      return TypeGuard.TRecord(schema) ? (() => {
        const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
        return pattern === exports.PatternNumberExact ? this.Number(options) : pattern === exports.PatternStringExact ? this.String(options) : this.Throw("Unable to resolve key type from Record key pattern");
      })() : TypeGuard.TTuple(schema) ? (() => {
        const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
        const literals = items.map((_, index) => exports.Type.Literal(index.toString()));
        return this.Union(literals, options);
      })() : TypeGuard.TArray(schema) ? (() => {
        return this.Number(options);
      })() : (() => {
        const keys = KeyResolver.ResolveKeys(schema, { includePatterns: false });
        if (keys.length === 0)
          return this.Never(options);
        const literals = keys.map((key) => this.Literal(key));
        return this.Union(literals, options);
      })();
    }
    Literal(value, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Literal", const: value, type: typeof value });
    }
    Lowercase(schema, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema), "Lowercase"), ...options };
    }
    Never(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Never", not: {} });
    }
    Not(schema, options) {
      return this.Create({ ...options, [exports.Kind]: "Not", not: TypeClone.Type(schema) });
    }
    Null(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Null", type: "null" });
    }
    Number(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Number", type: "number" });
    }
    Object(properties, options = {}) {
      const propertyKeys = Object.getOwnPropertyNames(properties);
      const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]));
      const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
      const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Type(options.additionalProperties) } : {};
      const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Type(properties[key]) }), {});
      return requiredKeys.length > 0 ? this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys }) : this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties });
    }
    Omit(schema, unresolved, options = {}) {
      const keys = KeyArrayResolver.Resolve(unresolved);
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
        if (ValueGuard.IsArray(object.required)) {
          object.required = object.required.filter((key) => !keys.includes(key));
          if (object.required.length === 0)
            delete object.required;
        }
        for (const key of Object.getOwnPropertyNames(object.properties)) {
          if (keys.includes(key))
            delete object.properties[key];
        }
        return this.Create(object);
      }, options);
    }
    Partial(schema, options = {}) {
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
        const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
          return { ...acc, [key]: this.Optional(object.properties[key]) };
        }, {});
        return this.Object(properties, this.Discard(object, ["required"]));
      }, options);
    }
    Pick(schema, unresolved, options = {}) {
      const keys = KeyArrayResolver.Resolve(unresolved);
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
        if (ValueGuard.IsArray(object.required)) {
          object.required = object.required.filter((key) => keys.includes(key));
          if (object.required.length === 0)
            delete object.required;
        }
        for (const key of Object.getOwnPropertyNames(object.properties)) {
          if (!keys.includes(key))
            delete object.properties[key];
        }
        return this.Create(object);
      }, options);
    }
    Record(key, schema, options = {}) {
      return TypeGuard.TTemplateLiteral(key) ? (() => {
        const expression = TemplateLiteralParser.ParseExact(key.pattern);
        return TemplateLiteralFinite.Check(expression) ? this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key2) => ({ ...acc, [key2]: TypeClone.Type(schema) }), {}), options) : this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [key.pattern]: TypeClone.Type(schema) } });
      })() : TypeGuard.TUnion(key) ? (() => {
        const union = UnionResolver.Resolve(key);
        if (TypeGuard.TUnionLiteral(union)) {
          const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Type(schema) }), {});
          return this.Object(properties, { ...options, [exports.Hint]: "Record" });
        } else
          this.Throw("Record key of type union contains non-literal types");
      })() : TypeGuard.TLiteral(key) ? (() => {
        return ValueGuard.IsString(key.const) || ValueGuard.IsNumber(key.const) ? this.Object({ [key.const]: TypeClone.Type(schema) }, options) : this.Throw("Record key of type literal is not of type string or number");
      })() : TypeGuard.TInteger(key) || TypeGuard.TNumber(key) ? (() => {
        return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [exports.PatternNumberExact]: TypeClone.Type(schema) } });
      })() : TypeGuard.TString(key) ? (() => {
        const pattern = ValueGuard.IsUndefined(key.pattern) ? exports.PatternStringExact : key.pattern;
        return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [pattern]: TypeClone.Type(schema) } });
      })() : this.Never();
    }
    Recursive(callback, options = {}) {
      if (ValueGuard.IsUndefined(options.$id))
        options.$id = `T${TypeOrdinal++}`;
      const thisType = callback({ [exports.Kind]: "This", $ref: `${options.$id}` });
      thisType.$id = options.$id;
      return this.Create({ ...options, [exports.Hint]: "Recursive", ...thisType });
    }
    Ref(unresolved, options = {}) {
      if (ValueGuard.IsString(unresolved))
        return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved });
      if (ValueGuard.IsUndefined(unresolved.$id))
        this.Throw("Reference target type must specify an $id");
      return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved.$id });
    }
    Required(schema, options = {}) {
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
        const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
          return { ...acc, [key]: this.Discard(object.properties[key], [exports.Optional]) };
        }, {});
        return this.Object(properties, object);
      }, options);
    }
    Rest(schema) {
      return TypeGuard.TTuple(schema) && !ValueGuard.IsUndefined(schema.items) ? TypeClone.Rest(schema.items) : TypeGuard.TIntersect(schema) ? TypeClone.Rest(schema.allOf) : TypeGuard.TUnion(schema) ? TypeClone.Rest(schema.anyOf) : [];
    }
    String(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "String", type: "string" });
    }
    TemplateLiteral(unresolved, options = {}) {
      const pattern = ValueGuard.IsString(unresolved) ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);
      return this.Create({ ...options, [exports.Kind]: "TemplateLiteral", type: "string", pattern });
    }
    Transform(schema) {
      return new TransformDecodeBuilder(schema);
    }
    Tuple(items, options = {}) {
      const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
      const clonedItems = TypeClone.Rest(items);
      const schema = items.length > 0 ? { ...options, [exports.Kind]: "Tuple", type: "array", items: clonedItems, additionalItems, minItems, maxItems } : { ...options, [exports.Kind]: "Tuple", type: "array", minItems, maxItems };
      return this.Create(schema);
    }
    Uncapitalize(schema, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema), "Uncapitalize"), ...options };
    }
    Union(union, options = {}) {
      return TypeGuard.TTemplateLiteral(union) ? TemplateLiteralResolver.Resolve(union) : (() => {
        const anyOf = union;
        if (anyOf.length === 0)
          return this.Never(options);
        if (anyOf.length === 1)
          return this.Create(TypeClone.Type(anyOf[0], options));
        const clonedAnyOf = TypeClone.Rest(anyOf);
        return this.Create({ ...options, [exports.Kind]: "Union", anyOf: clonedAnyOf });
      })();
    }
    Unknown(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Unknown" });
    }
    Unsafe(options = {}) {
      return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || "Unsafe" });
    }
    Uppercase(schema, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema), "Uppercase"), ...options };
    }
  }
  exports.JsonTypeBuilder = JsonTypeBuilder;

  class JavaScriptTypeBuilder extends JsonTypeBuilder {
    AsyncIterator(items, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "AsyncIterator", type: "AsyncIterator", items: TypeClone.Type(items) });
    }
    Awaited(schema, options = {}) {
      const Unwrap = (rest) => rest.length > 0 ? (() => {
        const [L, ...R] = rest;
        return [this.Awaited(L), ...Unwrap(R)];
      })() : rest;
      return TypeGuard.TIntersect(schema) ? exports.Type.Intersect(Unwrap(schema.allOf)) : TypeGuard.TUnion(schema) ? exports.Type.Union(Unwrap(schema.anyOf)) : TypeGuard.TPromise(schema) ? this.Awaited(schema.item) : TypeClone.Type(schema, options);
    }
    BigInt(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "BigInt", type: "bigint" });
    }
    ConstructorParameters(schema, options = {}) {
      return this.Tuple([...schema.parameters], { ...options });
    }
    Constructor(parameters, returns, options) {
      const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
      return this.Create({ ...options, [exports.Kind]: "Constructor", type: "Constructor", parameters: clonedParameters, returns: clonedReturns });
    }
    Date(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Date", type: "Date" });
    }
    Function(parameters, returns, options) {
      const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
      return this.Create({ ...options, [exports.Kind]: "Function", type: "Function", parameters: clonedParameters, returns: clonedReturns });
    }
    InstanceType(schema, options = {}) {
      return TypeClone.Type(schema.returns, options);
    }
    Iterator(items, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Iterator", type: "Iterator", items: TypeClone.Type(items) });
    }
    Parameters(schema, options = {}) {
      return this.Tuple(schema.parameters, { ...options });
    }
    Promise(item, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Promise", type: "Promise", item: TypeClone.Type(item) });
    }
    RegExp(unresolved, options = {}) {
      const pattern = ValueGuard.IsString(unresolved) ? unresolved : unresolved.source;
      return this.Create({ ...options, [exports.Kind]: "String", type: "string", pattern });
    }
    RegEx(regex, options = {}) {
      return this.RegExp(regex, options);
    }
    ReturnType(schema, options = {}) {
      return TypeClone.Type(schema.returns, options);
    }
    Symbol(options) {
      return this.Create({ ...options, [exports.Kind]: "Symbol", type: "symbol" });
    }
    Undefined(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Undefined", type: "undefined" });
    }
    Uint8Array(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Uint8Array", type: "Uint8Array" });
    }
    Void(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Void", type: "void" });
    }
  }
  exports.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
  exports.JsonType = new JsonTypeBuilder;
  exports.Type = new JavaScriptTypeBuilder;
});

// node_modules/@sinclair/typebox/system/system.js
var require_system = __commonJS((exports) => {
  function DefaultErrorFunction(schema, errorType) {
    switch (errorType) {
      case errors_1.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case errors_1.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${schema.maxContains} matching values`;
      case errors_1.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${schema.minContains} matching values`;
      case errors_1.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${schema.maxItems}`;
      case errors_1.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${schema.minItems}`;
      case errors_1.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case errors_1.ValueErrorType.Array:
        return "Expected array";
      case errors_1.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case errors_1.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${schema.maximum}`;
      case errors_1.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${schema.minimum}`;
      case errors_1.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${schema.multipleOf}`;
      case errors_1.ValueErrorType.BigInt:
        return "Expected bigint";
      case errors_1.ValueErrorType.Boolean:
        return "Expected boolean";
      case errors_1.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${schema.exclusiveMinimumTimestamp}`;
      case errors_1.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${schema.exclusiveMaximumTimestamp}`;
      case errors_1.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${schema.minimumTimestamp}`;
      case errors_1.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${schema.maximumTimestamp}`;
      case errors_1.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${schema.multipleOfTimestamp}`;
      case errors_1.ValueErrorType.Date:
        return "Expected Date";
      case errors_1.ValueErrorType.Function:
        return "Expected function";
      case errors_1.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${schema.maximum}`;
      case errors_1.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${schema.minimum}`;
      case errors_1.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${schema.multipleOf}`;
      case errors_1.ValueErrorType.Integer:
        return "Expected integer";
      case errors_1.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case errors_1.ValueErrorType.Intersect:
        return "Expected all values to match";
      case errors_1.ValueErrorType.Iterator:
        return "Expected Iterator";
      case errors_1.ValueErrorType.Literal:
        return `Expected ${typeof schema.const === "string" ? `'${schema.const}'` : schema.const}`;
      case errors_1.ValueErrorType.Never:
        return "Never";
      case errors_1.ValueErrorType.Not:
        return "Value should not match";
      case errors_1.ValueErrorType.Null:
        return "Expected null";
      case errors_1.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${schema.maximum}`;
      case errors_1.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${schema.minimum}`;
      case errors_1.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${schema.multipleOf}`;
      case errors_1.ValueErrorType.Number:
        return "Expected number";
      case errors_1.ValueErrorType.Object:
        return "Expected object";
      case errors_1.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case errors_1.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${schema.maxProperties} properties`;
      case errors_1.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${schema.minProperties} properties`;
      case errors_1.ValueErrorType.ObjectRequiredProperty:
        return "Required property";
      case errors_1.ValueErrorType.Promise:
        return "Expected Promise";
      case errors_1.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${schema.format}'`;
      case errors_1.ValueErrorType.StringFormat:
        return `Expected string to match '${schema.format}' format`;
      case errors_1.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${schema.maxLength}`;
      case errors_1.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${schema.minLength}`;
      case errors_1.ValueErrorType.StringPattern:
        return `Expected string to match '${schema.pattern}'`;
      case errors_1.ValueErrorType.String:
        return "Expected string";
      case errors_1.ValueErrorType.Symbol:
        return "Expected symbol";
      case errors_1.ValueErrorType.TupleLength:
        return `Expected tuple to have ${schema.maxItems || 0} elements`;
      case errors_1.ValueErrorType.Tuple:
        return "Expected tuple";
      case errors_1.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${schema.maxByteLength}`;
      case errors_1.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${schema.minByteLength}`;
      case errors_1.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case errors_1.ValueErrorType.Undefined:
        return "Expected undefined";
      case errors_1.ValueErrorType.Union:
        return "Expected union value";
      case errors_1.ValueErrorType.Void:
        return "Expected void";
      case errors_1.ValueErrorType.Kind:
        return `Expected kind '${schema[Types.Kind]}'`;
      default:
        return "Unknown error type";
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DefaultErrorFunction = exports.TypeSystemPolicy = exports.TypeSystemErrorFunction = exports.TypeSystem = exports.TypeSystemDuplicateFormat = exports.TypeSystemDuplicateTypeKind = undefined;
  var guard_1 = require_guard();
  var errors_1 = require_errors();
  var Types = require_typebox();

  class TypeSystemDuplicateTypeKind extends Types.TypeBoxError {
    constructor(kind) {
      super(`Duplicate type kind '${kind}' detected`);
    }
  }
  exports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;

  class TypeSystemDuplicateFormat extends Types.TypeBoxError {
    constructor(kind) {
      super(`Duplicate string format '${kind}' detected`);
    }
  }
  exports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;
  var TypeSystem;
  (function(TypeSystem2) {
    function Type(kind, check) {
      if (Types.TypeRegistry.Has(kind))
        throw new TypeSystemDuplicateTypeKind(kind);
      Types.TypeRegistry.Set(kind, check);
      return (options = {}) => Types.Type.Unsafe({ ...options, [Types.Kind]: kind });
    }
    TypeSystem2.Type = Type;
    function Format(format, check) {
      if (Types.FormatRegistry.Has(format))
        throw new TypeSystemDuplicateFormat(format);
      Types.FormatRegistry.Set(format, check);
      return format;
    }
    TypeSystem2.Format = Format;
  })(TypeSystem || (exports.TypeSystem = TypeSystem = {}));
  var TypeSystemErrorFunction;
  (function(TypeSystemErrorFunction2) {
    let errorMessageFunction = DefaultErrorFunction;
    function Reset() {
      errorMessageFunction = DefaultErrorFunction;
    }
    TypeSystemErrorFunction2.Reset = Reset;
    function Set2(callback) {
      errorMessageFunction = callback;
    }
    TypeSystemErrorFunction2.Set = Set2;
    function Get() {
      return errorMessageFunction;
    }
    TypeSystemErrorFunction2.Get = Get;
  })(TypeSystemErrorFunction || (exports.TypeSystemErrorFunction = TypeSystemErrorFunction = {}));
  var TypeSystemPolicy;
  (function(TypeSystemPolicy2) {
    TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
    TypeSystemPolicy2.AllowArrayObject = false;
    TypeSystemPolicy2.AllowNaN = false;
    TypeSystemPolicy2.AllowNullVoid = false;
    function IsExactOptionalProperty(value, key) {
      return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
    }
    TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
    function IsObjectLike(value) {
      const isObject = (0, guard_1.IsObject)(value);
      return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !(0, guard_1.IsArray)(value);
    }
    TypeSystemPolicy2.IsObjectLike = IsObjectLike;
    function IsRecordLike(value) {
      return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
    }
    TypeSystemPolicy2.IsRecordLike = IsRecordLike;
    function IsNumberLike(value) {
      const isNumber = (0, guard_1.IsNumber)(value);
      return TypeSystemPolicy2.AllowNaN ? isNumber : isNumber && Number.isFinite(value);
    }
    TypeSystemPolicy2.IsNumberLike = IsNumberLike;
    function IsVoidLike(value) {
      const isUndefined = (0, guard_1.IsUndefined)(value);
      return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
    }
    TypeSystemPolicy2.IsVoidLike = IsVoidLike;
  })(TypeSystemPolicy || (exports.TypeSystemPolicy = TypeSystemPolicy = {}));
  exports.DefaultErrorFunction = DefaultErrorFunction;
});

// node_modules/@sinclair/typebox/value/deref.js
var require_deref = __commonJS((exports) => {
  function Deref(schema, references) {
    const index = references.findIndex((target) => target.$id === schema.$ref);
    if (index === -1)
      throw new TypeDereferenceError(schema);
    return references[index];
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Deref = exports.TypeDereferenceError = undefined;
  var typebox_1 = require_typebox();

  class TypeDereferenceError extends typebox_1.TypeBoxError {
    constructor(schema) {
      super(`Unable to dereference schema with \$id '${schema.$id}'`);
      this.schema = schema;
    }
  }
  exports.TypeDereferenceError = TypeDereferenceError;
  exports.Deref = Deref;
});

// node_modules/@sinclair/typebox/value/hash.js
var require_hash = __commonJS((exports) => {
  function* NumberToBytes(value) {
    const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
    for (let i = 0;i < byteCount; i++) {
      yield value >> 8 * (byteCount - 1 - i) & 255;
    }
  }
  function ArrayType(value) {
    FNV1A64(ByteMarker.Array);
    for (const item of value) {
      Visit(item);
    }
  }
  function BooleanType(value) {
    FNV1A64(ByteMarker.Boolean);
    FNV1A64(value ? 1 : 0);
  }
  function BigIntType(value) {
    FNV1A64(ByteMarker.BigInt);
    F64In.setBigInt64(0, value);
    for (const byte of F64Out) {
      FNV1A64(byte);
    }
  }
  function DateType(value) {
    FNV1A64(ByteMarker.Date);
    Visit(value.getTime());
  }
  function NullType(value) {
    FNV1A64(ByteMarker.Null);
  }
  function NumberType(value) {
    FNV1A64(ByteMarker.Number);
    F64In.setFloat64(0, value);
    for (const byte of F64Out) {
      FNV1A64(byte);
    }
  }
  function ObjectType(value) {
    FNV1A64(ByteMarker.Object);
    for (const key of globalThis.Object.keys(value).sort()) {
      Visit(key);
      Visit(value[key]);
    }
  }
  function StringType(value) {
    FNV1A64(ByteMarker.String);
    for (let i = 0;i < value.length; i++) {
      for (const byte of NumberToBytes(value.charCodeAt(i))) {
        FNV1A64(byte);
      }
    }
  }
  function SymbolType(value) {
    FNV1A64(ByteMarker.Symbol);
    Visit(value.description);
  }
  function Uint8ArrayType(value) {
    FNV1A64(ByteMarker.Uint8Array);
    for (let i = 0;i < value.length; i++) {
      FNV1A64(value[i]);
    }
  }
  function UndefinedType(value) {
    return FNV1A64(ByteMarker.Undefined);
  }
  function Visit(value) {
    if ((0, guard_1.IsArray)(value))
      return ArrayType(value);
    if ((0, guard_1.IsBoolean)(value))
      return BooleanType(value);
    if ((0, guard_1.IsBigInt)(value))
      return BigIntType(value);
    if ((0, guard_1.IsDate)(value))
      return DateType(value);
    if ((0, guard_1.IsNull)(value))
      return NullType(value);
    if ((0, guard_1.IsNumber)(value))
      return NumberType(value);
    if ((0, guard_1.IsPlainObject)(value))
      return ObjectType(value);
    if ((0, guard_1.IsString)(value))
      return StringType(value);
    if ((0, guard_1.IsSymbol)(value))
      return SymbolType(value);
    if ((0, guard_1.IsUint8Array)(value))
      return Uint8ArrayType(value);
    if ((0, guard_1.IsUndefined)(value))
      return UndefinedType(value);
    throw new ValueHashError(value);
  }
  function FNV1A64(byte) {
    Accumulator = Accumulator ^ Bytes[byte];
    Accumulator = Accumulator * Prime % Size;
  }
  function Hash(value) {
    Accumulator = BigInt("14695981039346656037");
    Visit(value);
    return Accumulator;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Hash = exports.ByteMarker = exports.ValueHashError = undefined;
  var guard_1 = require_guard();

  class ValueHashError extends Error {
    constructor(value) {
      super(`Unable to hash value`);
      this.value = value;
    }
  }
  exports.ValueHashError = ValueHashError;
  var ByteMarker;
  (function(ByteMarker2) {
    ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
    ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
    ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
    ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
    ByteMarker2[ByteMarker2["String"] = 4] = "String";
    ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
    ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
    ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
    ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
    ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
    ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
  })(ByteMarker || (exports.ByteMarker = ByteMarker = {}));
  var Accumulator = BigInt("14695981039346656037");
  var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
  var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
  var F64 = new Float64Array(1);
  var F64In = new DataView(F64.buffer);
  var F64Out = new Uint8Array(F64.buffer);
  exports.Hash = Hash;
});

// node_modules/@sinclair/typebox/errors/errors.js
var require_errors = __commonJS((exports) => {
  function EscapeKey(key) {
    return key.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function IsDefined(value) {
    return value !== undefined;
  }
  function Create(type, schema, path, value) {
    return { type, schema, path, value, message: system_1.TypeSystemErrorFunction.Get()(schema, type) };
  }
  function* TAny(schema, references, path, value) {
  }
  function* TArray(schema, references, path, value) {
    if (!(0, guard_1.IsArray)(value)) {
      return yield Create(ValueErrorType.Array, schema, path, value);
    }
    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
      yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
    }
    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
      yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
    }
    for (let i = 0;i < value.length; i++) {
      yield* Visit(schema.items, references, `${path}/${i}`, value[i]);
    }
    if (schema.uniqueItems === true && !function() {
      const set = new Set;
      for (const element of value) {
        const hashed = (0, hash_1.Hash)(element);
        if (set.has(hashed)) {
          return false;
        } else {
          set.add(hashed);
        }
      }
      return true;
    }()) {
      yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
    }
    if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
      return;
    }
    const containsSchema = IsDefined(schema.contains) ? schema.contains : Types.Type.Never();
    const containsCount = value.reduce((acc, value2, index) => Visit(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      yield Create(ValueErrorType.ArrayContains, schema, path, value);
    }
    if ((0, guard_1.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
      yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
    }
    if ((0, guard_1.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
      yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
    }
  }
  function* TAsyncIterator(schema, references, path, value) {
    if (!(0, guard_1.IsAsyncIterator)(value))
      yield Create(ValueErrorType.AsyncIterator, schema, path, value);
  }
  function* TBigInt(schema, references, path, value) {
    if (!(0, guard_1.IsBigInt)(value))
      return yield Create(ValueErrorType.BigInt, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
      yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
    }
  }
  function* TBoolean(schema, references, path, value) {
    if (!(0, guard_1.IsBoolean)(value))
      yield Create(ValueErrorType.Boolean, schema, path, value);
  }
  function* TConstructor(schema, references, path, value) {
    yield* Visit(schema.returns, references, path, value.prototype);
  }
  function* TDate(schema, references, path, value) {
    if (!(0, guard_1.IsDate)(value))
      return yield Create(ValueErrorType.Date, schema, path, value);
    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
      yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
      yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
      yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
      yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
      yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
    }
  }
  function* TFunction(schema, references, path, value) {
    if (!(0, guard_1.IsFunction)(value))
      yield Create(ValueErrorType.Function, schema, path, value);
  }
  function* TInteger(schema, references, path, value) {
    if (!(0, guard_1.IsInteger)(value))
      return yield Create(ValueErrorType.Integer, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
    }
  }
  function* TIntersect(schema, references, path, value) {
    for (const inner of schema.allOf) {
      const next = Visit(inner, references, path, value).next();
      if (!next.done) {
        yield Create(ValueErrorType.Intersect, schema, path, value);
        yield next.value;
      }
    }
    if (schema.unevaluatedProperties === false) {
      const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));
      for (const valueKey of Object.getOwnPropertyNames(value)) {
        if (!keyCheck.test(valueKey)) {
          yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
        }
      }
    }
    if (typeof schema.unevaluatedProperties === "object") {
      const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));
      for (const valueKey of Object.getOwnPropertyNames(value)) {
        if (!keyCheck.test(valueKey)) {
          const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
          if (!next.done)
            yield next.value;
        }
      }
    }
  }
  function* TIterator(schema, references, path, value) {
    if (!(0, guard_1.IsIterator)(value))
      yield Create(ValueErrorType.Iterator, schema, path, value);
  }
  function* TLiteral(schema, references, path, value) {
    if (!(value === schema.const))
      yield Create(ValueErrorType.Literal, schema, path, value);
  }
  function* TNever(schema, references, path, value) {
    yield Create(ValueErrorType.Never, schema, path, value);
  }
  function* TNot(schema, references, path, value) {
    if (Visit(schema.not, references, path, value).next().done === true)
      yield Create(ValueErrorType.Not, schema, path, value);
  }
  function* TNull(schema, references, path, value) {
    if (!(0, guard_1.IsNull)(value))
      yield Create(ValueErrorType.Null, schema, path, value);
  }
  function* TNumber(schema, references, path, value) {
    if (!system_1.TypeSystemPolicy.IsNumberLike(value))
      return yield Create(ValueErrorType.Number, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.NumberMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.NumberMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
    }
  }
  function* TObject(schema, references, path, value) {
    if (!system_1.TypeSystemPolicy.IsObjectLike(value))
      return yield Create(ValueErrorType.Object, schema, path, value);
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
    }
    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    const unknownKeys = Object.getOwnPropertyNames(value);
    for (const requiredKey of requiredKeys) {
      if (unknownKeys.includes(requiredKey))
        continue;
      yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
    }
    if (schema.additionalProperties === false) {
      for (const valueKey of unknownKeys) {
        if (!knownKeys.includes(valueKey)) {
          yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
        }
      }
    }
    if (typeof schema.additionalProperties === "object") {
      for (const valueKey of unknownKeys) {
        if (knownKeys.includes(valueKey))
          continue;
        yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
    for (const knownKey of knownKeys) {
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
        if (Types.ExtendsUndefined.Check(schema) && !(knownKey in value)) {
          yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
        }
      } else {
        if (system_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
          yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
        }
      }
    }
  }
  function* TPromise(schema, references, path, value) {
    if (!(0, guard_1.IsPromise)(value))
      yield Create(ValueErrorType.Promise, schema, path, value);
  }
  function* TRecord(schema, references, path, value) {
    if (!system_1.TypeSystemPolicy.IsRecordLike(value))
      return yield Create(ValueErrorType.Object, schema, path, value);
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
    }
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const regex = new RegExp(patternKey);
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
    if (typeof schema.additionalProperties === "object") {
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (!regex.test(propertyKey))
          yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
      }
    }
    if (schema.additionalProperties === false) {
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (regex.test(propertyKey))
          continue;
        return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
      }
    }
  }
  function* TRef(schema, references, path, value) {
    yield* Visit((0, deref_1.Deref)(schema, references), references, path, value);
  }
  function* TString(schema, references, path, value) {
    if (!(0, guard_1.IsString)(value))
      return yield Create(ValueErrorType.String, schema, path, value);
    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
      yield Create(ValueErrorType.StringMinLength, schema, path, value);
    }
    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
      yield Create(ValueErrorType.StringMaxLength, schema, path, value);
    }
    if ((0, guard_1.IsString)(schema.pattern)) {
      const regex = new RegExp(schema.pattern);
      if (!regex.test(value)) {
        yield Create(ValueErrorType.StringPattern, schema, path, value);
      }
    }
    if ((0, guard_1.IsString)(schema.format)) {
      if (!Types.FormatRegistry.Has(schema.format)) {
        yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
      } else {
        const format = Types.FormatRegistry.Get(schema.format);
        if (!format(value)) {
          yield Create(ValueErrorType.StringFormat, schema, path, value);
        }
      }
    }
  }
  function* TSymbol(schema, references, path, value) {
    if (!(0, guard_1.IsSymbol)(value))
      yield Create(ValueErrorType.Symbol, schema, path, value);
  }
  function* TTemplateLiteral(schema, references, path, value) {
    if (!(0, guard_1.IsString)(value))
      return yield Create(ValueErrorType.String, schema, path, value);
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
  }
  function* TThis(schema, references, path, value) {
    yield* Visit((0, deref_1.Deref)(schema, references), references, path, value);
  }
  function* TTuple(schema, references, path, value) {
    if (!(0, guard_1.IsArray)(value))
      return yield Create(ValueErrorType.Tuple, schema, path, value);
    if (schema.items === undefined && !(value.length === 0)) {
      return yield Create(ValueErrorType.TupleLength, schema, path, value);
    }
    if (!(value.length === schema.maxItems)) {
      return yield Create(ValueErrorType.TupleLength, schema, path, value);
    }
    if (!schema.items) {
      return;
    }
    for (let i = 0;i < schema.items.length; i++) {
      yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);
    }
  }
  function* TUndefined(schema, references, path, value) {
    if (!(0, guard_1.IsUndefined)(value))
      yield Create(ValueErrorType.Undefined, schema, path, value);
  }
  function* TUnion(schema, references, path, value) {
    let count = 0;
    for (const subschema of schema.anyOf) {
      const errors = [...Visit(subschema, references, path, value)];
      if (errors.length === 0)
        return;
      count += errors.length;
    }
    if (count > 0) {
      yield Create(ValueErrorType.Union, schema, path, value);
    }
  }
  function* TUint8Array(schema, references, path, value) {
    if (!(0, guard_1.IsUint8Array)(value))
      return yield Create(ValueErrorType.Uint8Array, schema, path, value);
    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
      yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
    }
    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
      yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
    }
  }
  function* TUnknown(schema, references, path, value) {
  }
  function* TVoid(schema, references, path, value) {
    if (!system_1.TypeSystemPolicy.IsVoidLike(value))
      yield Create(ValueErrorType.Void, schema, path, value);
  }
  function* TKind(schema, references, path, value) {
    const check = Types.TypeRegistry.Get(schema[Types.Kind]);
    if (!check(schema, value))
      yield Create(ValueErrorType.Kind, schema, path, value);
  }
  function* Visit(schema, references, path, value) {
    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[Types.Kind]) {
      case "Any":
        return yield* TAny(schema_, references_, path, value);
      case "Array":
        return yield* TArray(schema_, references_, path, value);
      case "AsyncIterator":
        return yield* TAsyncIterator(schema_, references_, path, value);
      case "BigInt":
        return yield* TBigInt(schema_, references_, path, value);
      case "Boolean":
        return yield* TBoolean(schema_, references_, path, value);
      case "Constructor":
        return yield* TConstructor(schema_, references_, path, value);
      case "Date":
        return yield* TDate(schema_, references_, path, value);
      case "Function":
        return yield* TFunction(schema_, references_, path, value);
      case "Integer":
        return yield* TInteger(schema_, references_, path, value);
      case "Intersect":
        return yield* TIntersect(schema_, references_, path, value);
      case "Iterator":
        return yield* TIterator(schema_, references_, path, value);
      case "Literal":
        return yield* TLiteral(schema_, references_, path, value);
      case "Never":
        return yield* TNever(schema_, references_, path, value);
      case "Not":
        return yield* TNot(schema_, references_, path, value);
      case "Null":
        return yield* TNull(schema_, references_, path, value);
      case "Number":
        return yield* TNumber(schema_, references_, path, value);
      case "Object":
        return yield* TObject(schema_, references_, path, value);
      case "Promise":
        return yield* TPromise(schema_, references_, path, value);
      case "Record":
        return yield* TRecord(schema_, references_, path, value);
      case "Ref":
        return yield* TRef(schema_, references_, path, value);
      case "String":
        return yield* TString(schema_, references_, path, value);
      case "Symbol":
        return yield* TSymbol(schema_, references_, path, value);
      case "TemplateLiteral":
        return yield* TTemplateLiteral(schema_, references_, path, value);
      case "This":
        return yield* TThis(schema_, references_, path, value);
      case "Tuple":
        return yield* TTuple(schema_, references_, path, value);
      case "Undefined":
        return yield* TUndefined(schema_, references_, path, value);
      case "Union":
        return yield* TUnion(schema_, references_, path, value);
      case "Uint8Array":
        return yield* TUint8Array(schema_, references_, path, value);
      case "Unknown":
        return yield* TUnknown(schema_, references_, path, value);
      case "Void":
        return yield* TVoid(schema_, references_, path, value);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
          throw new ValueErrorsUnknownTypeError(schema);
        return yield* TKind(schema_, references_, path, value);
    }
  }
  function Errors(...args) {
    const iterator = args.length === 3 ? Visit(args[0], args[1], "", args[2]) : Visit(args[0], [], "", args[1]);
    return new ValueErrorIterator(iterator);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Errors = exports.ValueErrorIterator = exports.EscapeKey = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = undefined;
  var guard_1 = require_guard();
  var system_1 = require_system();
  var deref_1 = require_deref();
  var hash_1 = require_hash();
  var Types = require_typebox();
  var ValueErrorType;
  (function(ValueErrorType2) {
    ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
    ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
    ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
    ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
    ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
    ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
    ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
    ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
    ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
    ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
    ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
    ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
    ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
    ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
    ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
    ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
    ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
    ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
    ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
    ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
    ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
    ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
    ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
    ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
    ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
    ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
    ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
    ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
    ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
    ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
    ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
    ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 48] = "StringFormatUnknown";
    ValueErrorType2[ValueErrorType2["StringFormat"] = 49] = "StringFormat";
    ValueErrorType2[ValueErrorType2["StringMaxLength"] = 50] = "StringMaxLength";
    ValueErrorType2[ValueErrorType2["StringMinLength"] = 51] = "StringMinLength";
    ValueErrorType2[ValueErrorType2["StringPattern"] = 52] = "StringPattern";
    ValueErrorType2[ValueErrorType2["String"] = 53] = "String";
    ValueErrorType2[ValueErrorType2["Symbol"] = 54] = "Symbol";
    ValueErrorType2[ValueErrorType2["TupleLength"] = 55] = "TupleLength";
    ValueErrorType2[ValueErrorType2["Tuple"] = 56] = "Tuple";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 57] = "Uint8ArrayMaxByteLength";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 58] = "Uint8ArrayMinByteLength";
    ValueErrorType2[ValueErrorType2["Uint8Array"] = 59] = "Uint8Array";
    ValueErrorType2[ValueErrorType2["Undefined"] = 60] = "Undefined";
    ValueErrorType2[ValueErrorType2["Union"] = 61] = "Union";
    ValueErrorType2[ValueErrorType2["Void"] = 62] = "Void";
  })(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));

  class ValueErrorsUnknownTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  exports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;
  exports.EscapeKey = EscapeKey;

  class ValueErrorIterator {
    constructor(iterator) {
      this.iterator = iterator;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      const next = this.iterator.next();
      return next.done ? undefined : next.value;
    }
  }
  exports.ValueErrorIterator = ValueErrorIterator;
  exports.Errors = Errors;
});

// node_modules/@sinclair/typebox/errors/index.js
var require_errors2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_errors(), exports);
});

// node_modules/@sinclair/typebox/value/pointer.js
var require_pointer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValuePointer = exports.ValuePointerRootDeleteError = exports.ValuePointerRootSetError = undefined;

  class ValuePointerRootSetError extends Error {
    constructor(value, path, update) {
      super("Cannot set root value");
      this.value = value;
      this.path = path;
      this.update = update;
    }
  }
  exports.ValuePointerRootSetError = ValuePointerRootSetError;

  class ValuePointerRootDeleteError extends Error {
    constructor(value, path) {
      super("Cannot delete root value");
      this.value = value;
      this.path = path;
    }
  }
  exports.ValuePointerRootDeleteError = ValuePointerRootDeleteError;
  var ValuePointer;
  (function(ValuePointer2) {
    function Escape(component) {
      return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function* Format(pointer) {
      if (pointer === "")
        return;
      let [start, end] = [0, 0];
      for (let i = 0;i < pointer.length; i++) {
        const char = pointer.charAt(i);
        if (char === "/") {
          if (i === 0) {
            start = i + 1;
          } else {
            end = i;
            yield Escape(pointer.slice(start, end));
            start = i + 1;
          }
        } else {
          end = i;
        }
      }
      yield Escape(pointer.slice(start));
    }
    ValuePointer2.Format = Format;
    function Set2(value, pointer, update) {
      if (pointer === "")
        throw new ValuePointerRootSetError(value, pointer, update);
      let [owner, next, key] = [null, value, ""];
      for (const component of Format(pointer)) {
        if (next[component] === undefined)
          next[component] = {};
        owner = next;
        next = next[component];
        key = component;
      }
      owner[key] = update;
    }
    ValuePointer2.Set = Set2;
    function Delete(value, pointer) {
      if (pointer === "")
        throw new ValuePointerRootDeleteError(value, pointer);
      let [owner, next, key] = [null, value, ""];
      for (const component of Format(pointer)) {
        if (next[component] === undefined || next[component] === null)
          return;
        owner = next;
        next = next[component];
        key = component;
      }
      if (Array.isArray(owner)) {
        const index = parseInt(key);
        owner.splice(index, 1);
      } else {
        delete owner[key];
      }
    }
    ValuePointer2.Delete = Delete;
    function Has(value, pointer) {
      if (pointer === "")
        return true;
      let [owner, next, key] = [null, value, ""];
      for (const component of Format(pointer)) {
        if (next[component] === undefined)
          return false;
        owner = next;
        next = next[component];
        key = component;
      }
      return Object.getOwnPropertyNames(owner).includes(key);
    }
    ValuePointer2.Has = Has;
    function Get(value, pointer) {
      if (pointer === "")
        return value;
      let current = value;
      for (const component of Format(pointer)) {
        if (current[component] === undefined)
          return;
        current = current[component];
      }
      return current;
    }
    ValuePointer2.Get = Get;
  })(ValuePointer || (exports.ValuePointer = ValuePointer = {}));
});

// node_modules/@sinclair/typebox/value/clone.js
var require_clone = __commonJS((exports) => {
  function ObjectType(value) {
    const keys = [...Object.getOwnPropertyNames(value), ...Object.getOwnPropertySymbols(value)];
    return keys.reduce((acc, key) => ({ ...acc, [key]: Clone(value[key]) }), {});
  }
  function ArrayType(value) {
    return value.map((element) => Clone(element));
  }
  function TypedArrayType(value) {
    return value.slice();
  }
  function DateType(value) {
    return new Date(value.toISOString());
  }
  function ValueType(value) {
    return value;
  }
  function Clone(value) {
    if ((0, guard_1.IsArray)(value))
      return ArrayType(value);
    if ((0, guard_1.IsDate)(value))
      return DateType(value);
    if ((0, guard_1.IsPlainObject)(value))
      return ObjectType(value);
    if ((0, guard_1.IsTypedArray)(value))
      return TypedArrayType(value);
    if ((0, guard_1.IsValueType)(value))
      return ValueType(value);
    throw new Error("ValueClone: Unable to clone value");
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Clone = undefined;
  var guard_1 = require_guard();
  exports.Clone = Clone;
});

// node_modules/@sinclair/typebox/value/delta.js
var require_delta = __commonJS((exports) => {
  function CreateUpdate(path, value) {
    return { type: "update", path, value };
  }
  function CreateInsert(path, value) {
    return { type: "insert", path, value };
  }
  function CreateDelete(path) {
    return { type: "delete", path };
  }
  function* ObjectType(path, current, next) {
    if (!(0, guard_1.IsPlainObject)(next))
      return yield CreateUpdate(path, next);
    const currentKeys = [...Object.keys(current), ...Object.getOwnPropertySymbols(current)];
    const nextKeys = [...Object.keys(next), ...Object.getOwnPropertySymbols(next)];
    for (const key of currentKeys) {
      if ((0, guard_1.IsSymbol)(key))
        throw new ValueDeltaObjectWithSymbolKeyError(key);
      if ((0, guard_1.IsUndefined)(next[key]) && nextKeys.includes(key))
        yield CreateUpdate(`${path}/${String(key)}`, undefined);
    }
    for (const key of nextKeys) {
      if ((0, guard_1.IsUndefined)(current[key]) || (0, guard_1.IsUndefined)(next[key]))
        continue;
      if ((0, guard_1.IsSymbol)(key))
        throw new ValueDeltaObjectWithSymbolKeyError(key);
      yield* Visit(`${path}/${String(key)}`, current[key], next[key]);
    }
    for (const key of nextKeys) {
      if ((0, guard_1.IsSymbol)(key))
        throw new ValueDeltaObjectWithSymbolKeyError(key);
      if ((0, guard_1.IsUndefined)(current[key]))
        yield CreateInsert(`${path}/${String(key)}`, next[key]);
    }
    for (const key of currentKeys.reverse()) {
      if ((0, guard_1.IsSymbol)(key))
        throw new ValueDeltaObjectWithSymbolKeyError(key);
      if ((0, guard_1.IsUndefined)(next[key]) && !nextKeys.includes(key))
        yield CreateDelete(`${path}/${String(key)}`);
    }
  }
  function* ArrayType(path, current, next) {
    if (!(0, guard_1.IsArray)(next))
      return yield CreateUpdate(path, next);
    for (let i = 0;i < Math.min(current.length, next.length); i++) {
      yield* Visit(`${path}/${i}`, current[i], next[i]);
    }
    for (let i = 0;i < next.length; i++) {
      if (i < current.length)
        continue;
      yield CreateInsert(`${path}/${i}`, next[i]);
    }
    for (let i = current.length - 1;i >= 0; i--) {
      if (i < next.length)
        continue;
      yield CreateDelete(`${path}/${i}`);
    }
  }
  function* TypedArrayType(path, current, next) {
    if (!(0, guard_1.IsTypedArray)(next) || current.length !== next.length || Object.getPrototypeOf(current).constructor.name !== Object.getPrototypeOf(next).constructor.name)
      return yield CreateUpdate(path, next);
    for (let i = 0;i < Math.min(current.length, next.length); i++) {
      yield* Visit(`${path}/${i}`, current[i], next[i]);
    }
  }
  function* ValueType(path, current, next) {
    if (current === next)
      return;
    yield CreateUpdate(path, next);
  }
  function* Visit(path, current, next) {
    if ((0, guard_1.IsPlainObject)(current))
      return yield* ObjectType(path, current, next);
    if ((0, guard_1.IsArray)(current))
      return yield* ArrayType(path, current, next);
    if ((0, guard_1.IsTypedArray)(current))
      return yield* TypedArrayType(path, current, next);
    if ((0, guard_1.IsValueType)(current))
      return yield* ValueType(path, current, next);
    throw new ValueDeltaUnableToDiffUnknownValue(current);
  }
  function Diff(current, next) {
    return [...Visit("", current, next)];
  }
  function IsRootUpdate(edits) {
    return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
  }
  function IsIdentity(edits) {
    return edits.length === 0;
  }
  function Patch(current, edits) {
    if (IsRootUpdate(edits)) {
      return (0, clone_1.Clone)(edits[0].value);
    }
    if (IsIdentity(edits)) {
      return (0, clone_1.Clone)(current);
    }
    const clone = (0, clone_1.Clone)(current);
    for (const edit of edits) {
      switch (edit.type) {
        case "insert": {
          pointer_1.ValuePointer.Set(clone, edit.path, edit.value);
          break;
        }
        case "update": {
          pointer_1.ValuePointer.Set(clone, edit.path, edit.value);
          break;
        }
        case "delete": {
          pointer_1.ValuePointer.Delete(clone, edit.path);
          break;
        }
      }
    }
    return clone;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Patch = exports.Diff = exports.ValueDeltaUnableToDiffUnknownValue = exports.ValueDeltaObjectWithSymbolKeyError = exports.Edit = exports.Delete = exports.Update = exports.Insert = undefined;
  var guard_1 = require_guard();
  var typebox_1 = require_typebox();
  var pointer_1 = require_pointer();
  var clone_1 = require_clone();
  exports.Insert = typebox_1.Type.Object({
    type: typebox_1.Type.Literal("insert"),
    path: typebox_1.Type.String(),
    value: typebox_1.Type.Unknown()
  });
  exports.Update = typebox_1.Type.Object({
    type: typebox_1.Type.Literal("update"),
    path: typebox_1.Type.String(),
    value: typebox_1.Type.Unknown()
  });
  exports.Delete = typebox_1.Type.Object({
    type: typebox_1.Type.Literal("delete"),
    path: typebox_1.Type.String()
  });
  exports.Edit = typebox_1.Type.Union([exports.Insert, exports.Update, exports.Delete]);

  class ValueDeltaObjectWithSymbolKeyError extends Error {
    constructor(key) {
      super("Cannot diff objects with symbol keys");
      this.key = key;
    }
  }
  exports.ValueDeltaObjectWithSymbolKeyError = ValueDeltaObjectWithSymbolKeyError;

  class ValueDeltaUnableToDiffUnknownValue extends Error {
    constructor(value) {
      super("Unable to create diff edits for unknown value");
      this.value = value;
    }
  }
  exports.ValueDeltaUnableToDiffUnknownValue = ValueDeltaUnableToDiffUnknownValue;
  exports.Diff = Diff;
  exports.Patch = Patch;
});

// node_modules/@sinclair/typebox/value/mutate.js
var require_mutate = __commonJS((exports) => {
  function ObjectType(root, path, current, next) {
    if (!(0, guard_1.IsPlainObject)(current)) {
      pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));
    } else {
      const currentKeys = Object.keys(current);
      const nextKeys = Object.keys(next);
      for (const currentKey of currentKeys) {
        if (!nextKeys.includes(currentKey)) {
          delete current[currentKey];
        }
      }
      for (const nextKey of nextKeys) {
        if (!currentKeys.includes(nextKey)) {
          current[nextKey] = null;
        }
      }
      for (const nextKey of nextKeys) {
        Visit(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
      }
    }
  }
  function ArrayType(root, path, current, next) {
    if (!(0, guard_1.IsArray)(current)) {
      pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));
    } else {
      for (let index = 0;index < next.length; index++) {
        Visit(root, `${path}/${index}`, current[index], next[index]);
      }
      current.splice(next.length);
    }
  }
  function TypedArrayType(root, path, current, next) {
    if ((0, guard_1.IsTypedArray)(current) && current.length === next.length) {
      for (let i = 0;i < current.length; i++) {
        current[i] = next[i];
      }
    } else {
      pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));
    }
  }
  function ValueType(root, path, current, next) {
    if (current === next)
      return;
    pointer_1.ValuePointer.Set(root, path, next);
  }
  function Visit(root, path, current, next) {
    if ((0, guard_1.IsArray)(next))
      return ArrayType(root, path, current, next);
    if ((0, guard_1.IsTypedArray)(next))
      return TypedArrayType(root, path, current, next);
    if ((0, guard_1.IsPlainObject)(next))
      return ObjectType(root, path, current, next);
    if ((0, guard_1.IsValueType)(next))
      return ValueType(root, path, current, next);
  }
  function IsNonMutableValue(value) {
    return (0, guard_1.IsTypedArray)(value) || (0, guard_1.IsValueType)(value);
  }
  function IsMismatchedValue(current, next) {
    return (0, guard_1.IsPlainObject)(current) && (0, guard_1.IsArray)(next) || (0, guard_1.IsArray)(current) && (0, guard_1.IsPlainObject)(next);
  }
  function Mutate(current, next) {
    if (IsNonMutableValue(current) || IsNonMutableValue(next))
      throw new ValueMutateInvalidRootMutationError;
    if (IsMismatchedValue(current, next))
      throw new ValueMutateTypeMismatchError;
    Visit(current, "", current, next);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Mutate = exports.ValueMutateInvalidRootMutationError = exports.ValueMutateTypeMismatchError = undefined;
  var guard_1 = require_guard();
  var pointer_1 = require_pointer();
  var clone_1 = require_clone();

  class ValueMutateTypeMismatchError extends Error {
    constructor() {
      super("Cannot assign due type mismatch of assignable values");
    }
  }
  exports.ValueMutateTypeMismatchError = ValueMutateTypeMismatchError;

  class ValueMutateInvalidRootMutationError extends Error {
    constructor() {
      super("Only object and array types can be mutated at the root level");
    }
  }
  exports.ValueMutateInvalidRootMutationError = ValueMutateInvalidRootMutationError;
  exports.Mutate = Mutate;
});

// node_modules/@sinclair/typebox/value/equal.js
var require_equal = __commonJS((exports) => {
  function ObjectType(left, right) {
    if (!(0, guard_1.IsPlainObject)(right))
      return false;
    const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
    const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
    if (leftKeys.length !== rightKeys.length)
      return false;
    return leftKeys.every((key) => Equal(left[key], right[key]));
  }
  function DateType(left, right) {
    return (0, guard_1.IsDate)(right) && left.getTime() === right.getTime();
  }
  function ArrayType(left, right) {
    if (!(0, guard_1.IsArray)(right) || left.length !== right.length)
      return false;
    return left.every((value, index) => Equal(value, right[index]));
  }
  function TypedArrayType(left, right) {
    if (!(0, guard_1.IsTypedArray)(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
      return false;
    return left.every((value, index) => Equal(value, right[index]));
  }
  function ValueType(left, right) {
    return left === right;
  }
  function Equal(left, right) {
    if ((0, guard_1.IsPlainObject)(left))
      return ObjectType(left, right);
    if ((0, guard_1.IsDate)(left))
      return DateType(left, right);
    if ((0, guard_1.IsTypedArray)(left))
      return TypedArrayType(left, right);
    if ((0, guard_1.IsArray)(left))
      return ArrayType(left, right);
    if ((0, guard_1.IsValueType)(left))
      return ValueType(left, right);
    throw new Error("ValueEquals: Unable to compare value");
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Equal = undefined;
  var guard_1 = require_guard();
  exports.Equal = Equal;
});

// node_modules/@sinclair/typebox/system/index.js
var require_system2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueErrorType = undefined;
  var errors_1 = require_errors();
  Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
    return errors_1.ValueErrorType;
  } });
  __exportStar(require_system(), exports);
});

// node_modules/@sinclair/typebox/value/check.js
var require_check = __commonJS((exports) => {
  function IsAnyOrUnknown(schema) {
    return schema[Types.Kind] === "Any" || schema[Types.Kind] === "Unknown";
  }
  function IsDefined(value) {
    return value !== undefined;
  }
  function TAny(schema, references, value) {
    return true;
  }
  function TArray(schema, references, value) {
    if (!(0, guard_1.IsArray)(value))
      return false;
    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
      return false;
    }
    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
      return false;
    }
    if (!value.every((value2) => Visit(schema.items, references, value2))) {
      return false;
    }
    if (schema.uniqueItems === true && !function() {
      const set = new Set;
      for (const element of value) {
        const hashed = (0, hash_1.Hash)(element);
        if (set.has(hashed)) {
          return false;
        } else {
          set.add(hashed);
        }
      }
      return true;
    }()) {
      return false;
    }
    if (!(IsDefined(schema.contains) || (0, guard_1.IsNumber)(schema.minContains) || (0, guard_1.IsNumber)(schema.maxContains))) {
      return true;
    }
    const containsSchema = IsDefined(schema.contains) ? schema.contains : Types.Type.Never();
    const containsCount = value.reduce((acc, value2) => Visit(containsSchema, references, value2) ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      return false;
    }
    if ((0, guard_1.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
      return false;
    }
    if ((0, guard_1.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
      return false;
    }
    return true;
  }
  function TAsyncIterator(schema, references, value) {
    return (0, guard_1.IsAsyncIterator)(value);
  }
  function TBigInt(schema, references, value) {
    if (!(0, guard_1.IsBigInt)(value))
      return false;
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
      return false;
    }
    return true;
  }
  function TBoolean(schema, references, value) {
    return (0, guard_1.IsBoolean)(value);
  }
  function TConstructor(schema, references, value) {
    return Visit(schema.returns, references, value.prototype);
  }
  function TDate(schema, references, value) {
    if (!(0, guard_1.IsDate)(value))
      return false;
    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
      return false;
    }
    return true;
  }
  function TFunction(schema, references, value) {
    return (0, guard_1.IsFunction)(value);
  }
  function TInteger(schema, references, value) {
    if (!(0, guard_1.IsInteger)(value)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      return false;
    }
    return true;
  }
  function TIntersect(schema, references, value) {
    const check1 = schema.allOf.every((schema2) => Visit(schema2, references, value));
    if (schema.unevaluatedProperties === false) {
      const keyPattern = new RegExp(Types.KeyResolver.ResolvePattern(schema));
      const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
      return check1 && check2;
    } else if (Types.TypeGuard.TSchema(schema.unevaluatedProperties)) {
      const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));
      const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit(schema.unevaluatedProperties, references, value[key]));
      return check1 && check2;
    } else {
      return check1;
    }
  }
  function TIterator(schema, references, value) {
    return (0, guard_1.IsIterator)(value);
  }
  function TLiteral(schema, references, value) {
    return value === schema.const;
  }
  function TNever(schema, references, value) {
    return false;
  }
  function TNot(schema, references, value) {
    return !Visit(schema.not, references, value);
  }
  function TNull(schema, references, value) {
    return (0, guard_1.IsNull)(value);
  }
  function TNumber(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsNumberLike(value))
      return false;
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      return false;
    }
    return true;
  }
  function TObject(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsObjectLike(value))
      return false;
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      return false;
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      return false;
    }
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        if (!Visit(property, references, value[knownKey])) {
          return false;
        }
        if ((Types.ExtendsUndefined.Check(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
          return false;
        }
      } else {
        if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) {
          return false;
        }
      }
    }
    if (schema.additionalProperties === false) {
      const valueKeys = Object.getOwnPropertyNames(value);
      if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
        return true;
      } else {
        return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
      }
    } else if (typeof schema.additionalProperties === "object") {
      const valueKeys = Object.getOwnPropertyNames(value);
      return valueKeys.every((key) => knownKeys.includes(key) || Visit(schema.additionalProperties, references, value[key]));
    } else {
      return true;
    }
  }
  function TPromise(schema, references, value) {
    return (0, guard_1.IsPromise)(value);
  }
  function TRecord(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsRecordLike(value)) {
      return false;
    }
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      return false;
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      return false;
    }
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const regex = new RegExp(patternKey);
    const check1 = Object.entries(value).every(([key, value2]) => {
      return regex.test(key) ? Visit(patternSchema, references, value2) : true;
    });
    const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
      return !regex.test(key) ? Visit(schema.additionalProperties, references, value2) : true;
    }) : true;
    const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
      return regex.test(key);
    }) : true;
    return check1 && check2 && check3;
  }
  function TRef(schema, references, value) {
    return Visit((0, deref_1.Deref)(schema, references), references, value);
  }
  function TString(schema, references, value) {
    if (!(0, guard_1.IsString)(value)) {
      return false;
    }
    if (IsDefined(schema.minLength)) {
      if (!(value.length >= schema.minLength))
        return false;
    }
    if (IsDefined(schema.maxLength)) {
      if (!(value.length <= schema.maxLength))
        return false;
    }
    if (IsDefined(schema.pattern)) {
      const regex = new RegExp(schema.pattern);
      if (!regex.test(value))
        return false;
    }
    if (IsDefined(schema.format)) {
      if (!Types.FormatRegistry.Has(schema.format))
        return false;
      const func = Types.FormatRegistry.Get(schema.format);
      return func(value);
    }
    return true;
  }
  function TSymbol(schema, references, value) {
    return (0, guard_1.IsSymbol)(value);
  }
  function TTemplateLiteral(schema, references, value) {
    return (0, guard_1.IsString)(value) && new RegExp(schema.pattern).test(value);
  }
  function TThis(schema, references, value) {
    return Visit((0, deref_1.Deref)(schema, references), references, value);
  }
  function TTuple(schema, references, value) {
    if (!(0, guard_1.IsArray)(value)) {
      return false;
    }
    if (schema.items === undefined && !(value.length === 0)) {
      return false;
    }
    if (!(value.length === schema.maxItems)) {
      return false;
    }
    if (!schema.items) {
      return true;
    }
    for (let i = 0;i < schema.items.length; i++) {
      if (!Visit(schema.items[i], references, value[i]))
        return false;
    }
    return true;
  }
  function TUndefined(schema, references, value) {
    return (0, guard_1.IsUndefined)(value);
  }
  function TUnion(schema, references, value) {
    return schema.anyOf.some((inner) => Visit(inner, references, value));
  }
  function TUint8Array(schema, references, value) {
    if (!(0, guard_1.IsUint8Array)(value)) {
      return false;
    }
    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
      return false;
    }
    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
      return false;
    }
    return true;
  }
  function TUnknown(schema, references, value) {
    return true;
  }
  function TVoid(schema, references, value) {
    return index_1.TypeSystemPolicy.IsVoidLike(value);
  }
  function TKind(schema, references, value) {
    if (!Types.TypeRegistry.Has(schema[Types.Kind]))
      return false;
    const func = Types.TypeRegistry.Get(schema[Types.Kind]);
    return func(schema, value);
  }
  function Visit(schema, references, value) {
    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[Types.Kind]) {
      case "Any":
        return TAny(schema_, references_, value);
      case "Array":
        return TArray(schema_, references_, value);
      case "AsyncIterator":
        return TAsyncIterator(schema_, references_, value);
      case "BigInt":
        return TBigInt(schema_, references_, value);
      case "Boolean":
        return TBoolean(schema_, references_, value);
      case "Constructor":
        return TConstructor(schema_, references_, value);
      case "Date":
        return TDate(schema_, references_, value);
      case "Function":
        return TFunction(schema_, references_, value);
      case "Integer":
        return TInteger(schema_, references_, value);
      case "Intersect":
        return TIntersect(schema_, references_, value);
      case "Iterator":
        return TIterator(schema_, references_, value);
      case "Literal":
        return TLiteral(schema_, references_, value);
      case "Never":
        return TNever(schema_, references_, value);
      case "Not":
        return TNot(schema_, references_, value);
      case "Null":
        return TNull(schema_, references_, value);
      case "Number":
        return TNumber(schema_, references_, value);
      case "Object":
        return TObject(schema_, references_, value);
      case "Promise":
        return TPromise(schema_, references_, value);
      case "Record":
        return TRecord(schema_, references_, value);
      case "Ref":
        return TRef(schema_, references_, value);
      case "String":
        return TString(schema_, references_, value);
      case "Symbol":
        return TSymbol(schema_, references_, value);
      case "TemplateLiteral":
        return TTemplateLiteral(schema_, references_, value);
      case "This":
        return TThis(schema_, references_, value);
      case "Tuple":
        return TTuple(schema_, references_, value);
      case "Undefined":
        return TUndefined(schema_, references_, value);
      case "Union":
        return TUnion(schema_, references_, value);
      case "Uint8Array":
        return TUint8Array(schema_, references_, value);
      case "Unknown":
        return TUnknown(schema_, references_, value);
      case "Void":
        return TVoid(schema_, references_, value);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
          throw new ValueCheckUnknownTypeError(schema_);
        return TKind(schema_, references_, value);
    }
  }
  function Check(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Check = exports.ValueCheckUnknownTypeError = undefined;
  var guard_1 = require_guard();
  var index_1 = require_system2();
  var deref_1 = require_deref();
  var hash_1 = require_hash();
  var Types = require_typebox();

  class ValueCheckUnknownTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super(`Unknown type`);
      this.schema = schema;
    }
  }
  exports.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;
  exports.Check = Check;
});

// node_modules/@sinclair/typebox/value/create.js
var require_create = __commonJS((exports) => {
  function TAny(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return {};
    }
  }
  function TArray(schema, references) {
    if (schema.uniqueItems === true && !(0, guard_1.HasPropertyKey)(schema, "default")) {
      throw new Error("ValueCreate.Array: Array with the uniqueItems constraint requires a default value");
    } else if ("contains" in schema && !(0, guard_1.HasPropertyKey)(schema, "default")) {
      throw new Error("ValueCreate.Array: Array with the contains constraint requires a default value");
    } else if ("default" in schema) {
      return schema.default;
    } else if (schema.minItems !== undefined) {
      return Array.from({ length: schema.minItems }).map((item) => {
        return Visit(schema.items, references);
      });
    } else {
      return [];
    }
  }
  function TAsyncIterator(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return async function* () {
      }();
    }
  }
  function TBigInt(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return BigInt(0);
    }
  }
  function TBoolean(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return false;
    }
  }
  function TConstructor(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      const value = Visit(schema.returns, references);
      if (typeof value === "object" && !Array.isArray(value)) {
        return class {
          constructor() {
            for (const [key, val] of Object.entries(value)) {
              const self2 = this;
              self2[key] = val;
            }
          }
        };
      } else {
        return class {
        };
      }
    }
  }
  function TDate(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else if (schema.minimumTimestamp !== undefined) {
      return new Date(schema.minimumTimestamp);
    } else {
      return new Date;
    }
  }
  function TFunction(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return () => Visit(schema.returns, references);
    }
  }
  function TInteger(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else if (schema.minimum !== undefined) {
      return schema.minimum;
    } else {
      return 0;
    }
  }
  function TIntersect(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      const value = schema.allOf.reduce((acc, schema2) => {
        const next = Visit(schema2, references);
        return typeof next === "object" ? { ...acc, ...next } : next;
      }, {});
      if (!(0, check_1.Check)(schema, references, value))
        throw new ValueCreateIntersectTypeError(schema);
      return value;
    }
  }
  function TIterator(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return function* () {
      }();
    }
  }
  function TLiteral(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return schema.const;
    }
  }
  function TNever(schema, references) {
    throw new ValueCreateNeverTypeError(schema);
  }
  function TNot(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      throw new ValueCreateNotTypeError(schema);
    }
  }
  function TNull(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return null;
    }
  }
  function TNumber(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else if (schema.minimum !== undefined) {
      return schema.minimum;
    } else {
      return 0;
    }
  }
  function TObject(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      const required = new Set(schema.required);
      return schema.default || Object.entries(schema.properties).reduce((acc, [key, schema2]) => {
        return required.has(key) ? { ...acc, [key]: Visit(schema2, references) } : { ...acc };
      }, {});
    }
  }
  function TPromise(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return Promise.resolve(Visit(schema.item, references));
    }
  }
  function TRecord(schema, references) {
    const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else if (!(keyPattern === Types.PatternStringExact || keyPattern === Types.PatternNumberExact)) {
      const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
      return propertyKeys.reduce((acc, key) => {
        return { ...acc, [key]: Visit(valueSchema, references) };
      }, {});
    } else {
      return {};
    }
  }
  function TRef(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return Visit((0, deref_1.Deref)(schema, references), references);
    }
  }
  function TString(schema, references) {
    if (schema.pattern !== undefined) {
      if (!(0, guard_1.HasPropertyKey)(schema, "default")) {
        throw new Error("ValueCreate.String: String types with patterns must specify a default value");
      } else {
        return schema.default;
      }
    } else if (schema.format !== undefined) {
      if (!(0, guard_1.HasPropertyKey)(schema, "default")) {
        throw new Error("ValueCreate.String: String types with formats must specify a default value");
      } else {
        return schema.default;
      }
    } else {
      if ((0, guard_1.HasPropertyKey)(schema, "default")) {
        return schema.default;
      } else if (schema.minLength !== undefined) {
        return Array.from({ length: schema.minLength }).map(() => ".").join("");
      } else {
        return "";
      }
    }
  }
  function TSymbol(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else if ("value" in schema) {
      return Symbol.for(schema.value);
    } else {
      return Symbol();
    }
  }
  function TTemplateLiteral(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    }
    const expression = Types.TemplateLiteralParser.ParseExact(schema.pattern);
    if (!Types.TemplateLiteralFinite.Check(expression))
      throw new ValueCreateTempateLiteralTypeError(schema);
    const sequence = Types.TemplateLiteralGenerator.Generate(expression);
    return sequence.next().value;
  }
  function TThis(schema, references) {
    if (recursiveDepth++ > recursiveMaxDepth)
      throw new ValueCreateRecursiveInstantiationError(schema, recursiveMaxDepth);
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return Visit((0, deref_1.Deref)(schema, references), references);
    }
  }
  function TTuple(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    }
    if (schema.items === undefined) {
      return [];
    } else {
      return Array.from({ length: schema.minItems }).map((_, index) => Visit(schema.items[index], references));
    }
  }
  function TUndefined(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return;
    }
  }
  function TUnion(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else if (schema.anyOf.length === 0) {
      throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    } else {
      return Visit(schema.anyOf[0], references);
    }
  }
  function TUint8Array(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else if (schema.minByteLength !== undefined) {
      return new Uint8Array(schema.minByteLength);
    } else {
      return new Uint8Array(0);
    }
  }
  function TUnknown(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return {};
    }
  }
  function TVoid(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return;
    }
  }
  function TKind(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      throw new Error("User defined types must specify a default value");
    }
  }
  function Visit(schema, references) {
    const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[Types.Kind]) {
      case "Any":
        return TAny(schema_, references_);
      case "Array":
        return TArray(schema_, references_);
      case "AsyncIterator":
        return TAsyncIterator(schema_, references_);
      case "BigInt":
        return TBigInt(schema_, references_);
      case "Boolean":
        return TBoolean(schema_, references_);
      case "Constructor":
        return TConstructor(schema_, references_);
      case "Date":
        return TDate(schema_, references_);
      case "Function":
        return TFunction(schema_, references_);
      case "Integer":
        return TInteger(schema_, references_);
      case "Intersect":
        return TIntersect(schema_, references_);
      case "Iterator":
        return TIterator(schema_, references_);
      case "Literal":
        return TLiteral(schema_, references_);
      case "Never":
        return TNever(schema_, references_);
      case "Not":
        return TNot(schema_, references_);
      case "Null":
        return TNull(schema_, references_);
      case "Number":
        return TNumber(schema_, references_);
      case "Object":
        return TObject(schema_, references_);
      case "Promise":
        return TPromise(schema_, references_);
      case "Record":
        return TRecord(schema_, references_);
      case "Ref":
        return TRef(schema_, references_);
      case "String":
        return TString(schema_, references_);
      case "Symbol":
        return TSymbol(schema_, references_);
      case "TemplateLiteral":
        return TTemplateLiteral(schema_, references_);
      case "This":
        return TThis(schema_, references_);
      case "Tuple":
        return TTuple(schema_, references_);
      case "Undefined":
        return TUndefined(schema_, references_);
      case "Union":
        return TUnion(schema_, references_);
      case "Uint8Array":
        return TUint8Array(schema_, references_);
      case "Unknown":
        return TUnknown(schema_, references_);
      case "Void":
        return TVoid(schema_, references_);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
          throw new ValueCreateUnknownTypeError(schema_);
        return TKind(schema_, references_);
    }
  }
  function Create(...args) {
    recursiveDepth = 0;
    return args.length === 2 ? Visit(args[0], args[1]) : Visit(args[0], []);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Create = exports.ValueCreateRecursiveInstantiationError = exports.ValueCreateTempateLiteralTypeError = exports.ValueCreateIntersectTypeError = exports.ValueCreateNotTypeError = exports.ValueCreateNeverTypeError = exports.ValueCreateUnknownTypeError = undefined;
  var guard_1 = require_guard();
  var check_1 = require_check();
  var deref_1 = require_deref();
  var Types = require_typebox();

  class ValueCreateUnknownTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  exports.ValueCreateUnknownTypeError = ValueCreateUnknownTypeError;

  class ValueCreateNeverTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Never types cannot be created");
      this.schema = schema;
    }
  }
  exports.ValueCreateNeverTypeError = ValueCreateNeverTypeError;

  class ValueCreateNotTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Not types must have a default value");
      this.schema = schema;
    }
  }
  exports.ValueCreateNotTypeError = ValueCreateNotTypeError;

  class ValueCreateIntersectTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Intersect produced invalid value. Consider using a default value.");
      this.schema = schema;
    }
  }
  exports.ValueCreateIntersectTypeError = ValueCreateIntersectTypeError;

  class ValueCreateTempateLiteralTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Can only create template literal values from patterns that produce finite sequences. Consider using a default value.");
      this.schema = schema;
    }
  }
  exports.ValueCreateTempateLiteralTypeError = ValueCreateTempateLiteralTypeError;

  class ValueCreateRecursiveInstantiationError extends Types.TypeBoxError {
    constructor(schema, recursiveMaxDepth2) {
      super("Value cannot be created as recursive type may produce value of infinite size. Consider using a default.");
      this.schema = schema;
      this.recursiveMaxDepth = recursiveMaxDepth2;
    }
  }
  exports.ValueCreateRecursiveInstantiationError = ValueCreateRecursiveInstantiationError;
  var recursiveMaxDepth = 512;
  var recursiveDepth = 0;
  exports.Create = Create;
});

// node_modules/@sinclair/typebox/value/cast.js
var require_cast = __commonJS((exports) => {
  function DefaultClone(schema, references, value) {
    return (0, check_1.Check)(schema, references, value) ? (0, clone_1.Clone)(value) : (0, create_1.Create)(schema, references);
  }
  function Default(schema, references, value) {
    return (0, check_1.Check)(schema, references, value) ? value : (0, create_1.Create)(schema, references);
  }
  function TArray(schema, references, value) {
    if ((0, check_1.Check)(schema, references, value))
      return (0, clone_1.Clone)(value);
    const created = (0, guard_1.IsArray)(value) ? (0, clone_1.Clone)(value) : (0, create_1.Create)(schema, references);
    const minimum = (0, guard_1.IsNumber)(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
    const maximum = (0, guard_1.IsNumber)(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
    const casted = maximum.map((value2) => Visit(schema.items, references, value2));
    if (schema.uniqueItems !== true)
      return casted;
    const unique = [...new Set(casted)];
    if (!(0, check_1.Check)(schema, references, unique))
      throw new ValueCastArrayUniqueItemsTypeError(schema, unique);
    return unique;
  }
  function TConstructor(schema, references, value) {
    if ((0, check_1.Check)(schema, references, value))
      return (0, create_1.Create)(schema, references);
    const required = new Set(schema.returns.required || []);
    const result = function() {
    };
    for (const [key, property] of Object.entries(schema.returns.properties)) {
      if (!required.has(key) && value.prototype[key] === undefined)
        continue;
      result.prototype[key] = Visit(property, references, value.prototype[key]);
    }
    return result;
  }
  function TIntersect(schema, references, value) {
    const created = (0, create_1.Create)(schema, references);
    const mapped = (0, guard_1.IsPlainObject)(created) && (0, guard_1.IsPlainObject)(value) ? { ...created, ...value } : value;
    return (0, check_1.Check)(schema, references, mapped) ? mapped : (0, create_1.Create)(schema, references);
  }
  function TNever(schema, references, value) {
    throw new ValueCastNeverTypeError(schema);
  }
  function TObject(schema, references, value) {
    if ((0, check_1.Check)(schema, references, value))
      return value;
    if (value === null || typeof value !== "object")
      return (0, create_1.Create)(schema, references);
    const required = new Set(schema.required || []);
    const result = {};
    for (const [key, property] of Object.entries(schema.properties)) {
      if (!required.has(key) && value[key] === undefined)
        continue;
      result[key] = Visit(property, references, value[key]);
    }
    if (typeof schema.additionalProperties === "object") {
      const propertyNames = Object.getOwnPropertyNames(schema.properties);
      for (const propertyName of Object.getOwnPropertyNames(value)) {
        if (propertyNames.includes(propertyName))
          continue;
        result[propertyName] = Visit(schema.additionalProperties, references, value[propertyName]);
      }
    }
    return result;
  }
  function TRecord(schema, references, value) {
    if ((0, check_1.Check)(schema, references, value))
      return (0, clone_1.Clone)(value);
    if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
      return (0, create_1.Create)(schema, references);
    const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const subschema = schema.patternProperties[subschemaPropertyName];
    const result = {};
    for (const [propKey, propValue] of Object.entries(value)) {
      result[propKey] = Visit(subschema, references, propValue);
    }
    return result;
  }
  function TRef(schema, references, value) {
    return Visit((0, deref_1.Deref)(schema, references), references, value);
  }
  function TThis(schema, references, value) {
    return Visit((0, deref_1.Deref)(schema, references), references, value);
  }
  function TTuple(schema, references, value) {
    if ((0, check_1.Check)(schema, references, value))
      return (0, clone_1.Clone)(value);
    if (!(0, guard_1.IsArray)(value))
      return (0, create_1.Create)(schema, references);
    if (schema.items === undefined)
      return [];
    return schema.items.map((schema2, index) => Visit(schema2, references, value[index]));
  }
  function TUnion(schema, references, value) {
    return (0, check_1.Check)(schema, references, value) ? (0, clone_1.Clone)(value) : UnionCastCreate.Create(schema, references, value);
  }
  function Visit(schema, references, value) {
    const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[Types.Kind]) {
      case "Array":
        return TArray(schema_, references_, value);
      case "Constructor":
        return TConstructor(schema_, references_, value);
      case "Intersect":
        return TIntersect(schema_, references_, value);
      case "Never":
        return TNever(schema_, references_, value);
      case "Object":
        return TObject(schema_, references_, value);
      case "Record":
        return TRecord(schema_, references_, value);
      case "Ref":
        return TRef(schema_, references_, value);
      case "This":
        return TThis(schema_, references_, value);
      case "Tuple":
        return TTuple(schema_, references_, value);
      case "Union":
        return TUnion(schema_, references_, value);
      case "Date":
      case "Symbol":
      case "Uint8Array":
        return DefaultClone(schema, references, value);
      case "Any":
      case "AsyncIterator":
      case "BigInt":
      case "Boolean":
      case "Function":
      case "Integer":
      case "Iterator":
      case "Literal":
      case "Not":
      case "Null":
      case "Number":
      case "Promise":
      case "String":
      case "TemplateLiteral":
      case "Undefined":
      case "Unknown":
      case "Void":
        return Default(schema_, references_, value);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
          throw new ValueCastUnknownTypeError(schema_);
        return Default(schema_, references_, value);
    }
  }
  function Cast(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Cast = exports.Default = exports.DefaultClone = exports.ValueCastUnknownTypeError = exports.ValueCastRecursiveTypeError = exports.ValueCastNeverTypeError = exports.ValueCastArrayUniqueItemsTypeError = undefined;
  var guard_1 = require_guard();
  var create_1 = require_create();
  var check_1 = require_check();
  var clone_1 = require_clone();
  var deref_1 = require_deref();
  var Types = require_typebox();

  class ValueCastArrayUniqueItemsTypeError extends Types.TypeBoxError {
    constructor(schema, value) {
      super("Array cast produced invalid data due to uniqueItems constraint");
      this.schema = schema;
      this.value = value;
    }
  }
  exports.ValueCastArrayUniqueItemsTypeError = ValueCastArrayUniqueItemsTypeError;

  class ValueCastNeverTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Never types cannot be cast");
      this.schema = schema;
    }
  }
  exports.ValueCastNeverTypeError = ValueCastNeverTypeError;

  class ValueCastRecursiveTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Cannot cast recursive schemas");
      this.schema = schema;
    }
  }
  exports.ValueCastRecursiveTypeError = ValueCastRecursiveTypeError;

  class ValueCastUnknownTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  exports.ValueCastUnknownTypeError = ValueCastUnknownTypeError;
  var UnionCastCreate;
  (function(UnionCastCreate2) {
    function Score(schema, references, value) {
      if (schema[Types.Kind] === "Object" && typeof value === "object" && !(0, guard_1.IsNull)(value)) {
        const object = schema;
        const keys = Object.getOwnPropertyNames(value);
        const entries = Object.entries(object.properties);
        const [point, max] = [1 / entries.length, entries.length];
        return entries.reduce((acc, [key, schema2]) => {
          const literal = schema2[Types.Kind] === "Literal" && schema2.const === value[key] ? max : 0;
          const checks = (0, check_1.Check)(schema2, references, value[key]) ? point : 0;
          const exists = keys.includes(key) ? point : 0;
          return acc + (literal + checks + exists);
        }, 0);
      } else {
        return (0, check_1.Check)(schema, references, value) ? 1 : 0;
      }
    }
    function Select(union, references, value) {
      let [select, best] = [union.anyOf[0], 0];
      for (const schema of union.anyOf) {
        const score = Score(schema, references, value);
        if (score > best) {
          select = schema;
          best = score;
        }
      }
      return select;
    }
    function Create(union, references, value) {
      if ("default" in union) {
        return union.default;
      } else {
        const schema = Select(union, references, value);
        return Cast(schema, references, value);
      }
    }
    UnionCastCreate2.Create = Create;
  })(UnionCastCreate || (UnionCastCreate = {}));
  exports.DefaultClone = DefaultClone;
  exports.Default = Default;
  exports.Cast = Cast;
});

// node_modules/@sinclair/typebox/value/convert.js
var require_convert = __commonJS((exports) => {
  function IsStringNumeric(value) {
    return (0, guard_1.IsString)(value) && !isNaN(value) && !isNaN(parseFloat(value));
  }
  function IsValueToString(value) {
    return (0, guard_1.IsBigInt)(value) || (0, guard_1.IsBoolean)(value) || (0, guard_1.IsNumber)(value);
  }
  function IsValueTrue(value) {
    return value === true || (0, guard_1.IsNumber)(value) && value === 1 || (0, guard_1.IsBigInt)(value) && value === BigInt("1") || (0, guard_1.IsString)(value) && (value.toLowerCase() === "true" || value === "1");
  }
  function IsValueFalse(value) {
    return value === false || (0, guard_1.IsNumber)(value) && (value === 0 || Object.is(value, -0)) || (0, guard_1.IsBigInt)(value) && value === BigInt("0") || (0, guard_1.IsString)(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
  }
  function IsTimeStringWithTimeZone(value) {
    return (0, guard_1.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
  }
  function IsTimeStringWithoutTimeZone(value) {
    return (0, guard_1.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
  }
  function IsDateTimeStringWithTimeZone(value) {
    return (0, guard_1.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
  }
  function IsDateTimeStringWithoutTimeZone(value) {
    return (0, guard_1.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
  }
  function IsDateString(value) {
    return (0, guard_1.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
  }
  function TryConvertLiteralString(value, target) {
    const conversion = TryConvertString(value);
    return conversion === target ? conversion : value;
  }
  function TryConvertLiteralNumber(value, target) {
    const conversion = TryConvertNumber(value);
    return conversion === target ? conversion : value;
  }
  function TryConvertLiteralBoolean(value, target) {
    const conversion = TryConvertBoolean(value);
    return conversion === target ? conversion : value;
  }
  function TryConvertLiteral(schema, value) {
    if (typeof schema.const === "string") {
      return TryConvertLiteralString(value, schema.const);
    } else if (typeof schema.const === "number") {
      return TryConvertLiteralNumber(value, schema.const);
    } else if (typeof schema.const === "boolean") {
      return TryConvertLiteralBoolean(value, schema.const);
    } else {
      return (0, clone_1.Clone)(value);
    }
  }
  function TryConvertBoolean(value) {
    return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
  }
  function TryConvertBigInt(value) {
    return IsStringNumeric(value) ? BigInt(parseInt(value)) : (0, guard_1.IsNumber)(value) ? BigInt(value | 0) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
  }
  function TryConvertString(value) {
    return IsValueToString(value) ? value.toString() : (0, guard_1.IsSymbol)(value) && value.description !== undefined ? value.description.toString() : value;
  }
  function TryConvertNumber(value) {
    return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
  }
  function TryConvertInteger(value) {
    return IsStringNumeric(value) ? parseInt(value) : (0, guard_1.IsNumber)(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
  }
  function TryConvertNull(value) {
    return (0, guard_1.IsString)(value) && value.toLowerCase() === "null" ? null : value;
  }
  function TryConvertUndefined(value) {
    return (0, guard_1.IsString)(value) && value === "undefined" ? undefined : value;
  }
  function TryConvertDate(value) {
    return (0, guard_1.IsDate)(value) ? value : (0, guard_1.IsNumber)(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
  }
  function Default(value) {
    return value;
  }
  function TArray(schema, references, value) {
    if ((0, guard_1.IsArray)(value)) {
      return value.map((value2) => Visit(schema.items, references, value2));
    }
    return value;
  }
  function TBigInt(schema, references, value) {
    return TryConvertBigInt(value);
  }
  function TBoolean(schema, references, value) {
    return TryConvertBoolean(value);
  }
  function TDate(schema, references, value) {
    return TryConvertDate(value);
  }
  function TInteger(schema, references, value) {
    return TryConvertInteger(value);
  }
  function TIntersect(schema, references, value) {
    return schema.allOf.every((schema2) => Types.TypeGuard.TObject(schema2)) ? Visit(Types.Type.Composite(schema.allOf), references, value) : Visit(schema.allOf[0], references, value);
  }
  function TLiteral(schema, references, value) {
    return TryConvertLiteral(schema, value);
  }
  function TNull(schema, references, value) {
    return TryConvertNull(value);
  }
  function TNumber(schema, references, value) {
    return TryConvertNumber(value);
  }
  function TObject(schema, references, value) {
    if ((0, guard_1.IsObject)(value))
      return Object.getOwnPropertyNames(schema.properties).reduce((acc, key) => {
        return value[key] !== undefined ? { ...acc, [key]: Visit(schema.properties[key], references, value[key]) } : { ...acc };
      }, value);
    return value;
  }
  function TRecord(schema, references, value) {
    const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const property = schema.patternProperties[propertyKey];
    const result = {};
    for (const [propKey, propValue] of Object.entries(value)) {
      result[propKey] = Visit(property, references, propValue);
    }
    return result;
  }
  function TRef(schema, references, value) {
    return Visit((0, deref_1.Deref)(schema, references), references, value);
  }
  function TString(schema, references, value) {
    return TryConvertString(value);
  }
  function TSymbol(schema, references, value) {
    return (0, guard_1.IsString)(value) || (0, guard_1.IsNumber)(value) ? Symbol(value) : value;
  }
  function TThis(schema, references, value) {
    return Visit((0, deref_1.Deref)(schema, references), references, value);
  }
  function TTuple(schema, references, value) {
    if ((0, guard_1.IsArray)(value) && !(0, guard_1.IsUndefined)(schema.items)) {
      return value.map((value2, index) => {
        return index < schema.items.length ? Visit(schema.items[index], references, value2) : value2;
      });
    }
    return value;
  }
  function TUndefined(schema, references, value) {
    return TryConvertUndefined(value);
  }
  function TUnion(schema, references, value) {
    for (const subschema of schema.anyOf) {
      const converted = Visit(subschema, references, value);
      if ((0, check_1.Check)(subschema, references, converted)) {
        return converted;
      }
    }
    return value;
  }
  function Visit(schema, references, value) {
    const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[Types.Kind]) {
      case "Array":
        return TArray(schema_, references_, value);
      case "BigInt":
        return TBigInt(schema_, references_, value);
      case "Boolean":
        return TBoolean(schema_, references_, value);
      case "Date":
        return TDate(schema_, references_, value);
      case "Integer":
        return TInteger(schema_, references_, value);
      case "Intersect":
        return TIntersect(schema_, references_, value);
      case "Literal":
        return TLiteral(schema_, references_, value);
      case "Null":
        return TNull(schema_, references_, value);
      case "Number":
        return TNumber(schema_, references_, value);
      case "Object":
        return TObject(schema_, references_, value);
      case "Record":
        return TRecord(schema_, references_, value);
      case "Ref":
        return TRef(schema_, references_, value);
      case "String":
        return TString(schema_, references_, value);
      case "Symbol":
        return TSymbol(schema_, references_, value);
      case "This":
        return TThis(schema_, references_, value);
      case "Tuple":
        return TTuple(schema_, references_, value);
      case "Undefined":
        return TUndefined(schema_, references_, value);
      case "Union":
        return TUnion(schema_, references_, value);
      case "Any":
      case "AsyncIterator":
      case "Constructor":
      case "Function":
      case "Iterator":
      case "Never":
      case "Promise":
      case "TemplateLiteral":
      case "Uint8Array":
      case "Unknown":
      case "Void":
        return Default(value);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
          throw new ValueConvertUnknownTypeError(schema_);
        return Default(value);
    }
  }
  function Convert(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Convert = exports.Default = exports.ValueConvertUnknownTypeError = undefined;
  var guard_1 = require_guard();
  var clone_1 = require_clone();
  var check_1 = require_check();
  var deref_1 = require_deref();
  var Types = require_typebox();

  class ValueConvertUnknownTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  exports.ValueConvertUnknownTypeError = ValueConvertUnknownTypeError;
  exports.Default = Default;
  exports.Convert = Convert;
});

// node_modules/@sinclair/typebox/value/transform.js
var require_transform = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EncodeTransform = exports.DecodeTransform = exports.HasTransform = exports.TransformEncodeError = exports.TransformDecodeError = exports.TransformEncodeCheckError = exports.TransformDecodeCheckError = undefined;
  var guard_1 = require_guard();
  var deref_1 = require_deref();
  var check_1 = require_check();
  var Types = require_typebox();

  class TransformDecodeCheckError extends Types.TypeBoxError {
    constructor(schema, value, error) {
      super(`Unable to decode due to invalid value`);
      this.schema = schema;
      this.value = value;
      this.error = error;
    }
  }
  exports.TransformDecodeCheckError = TransformDecodeCheckError;

  class TransformEncodeCheckError extends Types.TypeBoxError {
    constructor(schema, value, error) {
      super(`Unable to encode due to invalid value`);
      this.schema = schema;
      this.value = value;
      this.error = error;
    }
  }
  exports.TransformEncodeCheckError = TransformEncodeCheckError;

  class TransformDecodeError extends Types.TypeBoxError {
    constructor(schema, value, error) {
      super(`${error instanceof Error ? error.message : "Unknown error"}`);
      this.schema = schema;
      this.value = value;
    }
  }
  exports.TransformDecodeError = TransformDecodeError;

  class TransformEncodeError extends Types.TypeBoxError {
    constructor(schema, value, error) {
      super(`${error instanceof Error ? error.message : "Unknown error"}`);
      this.schema = schema;
      this.value = value;
    }
  }
  exports.TransformEncodeError = TransformEncodeError;
  var HasTransform;
  (function(HasTransform2) {
    function TArray(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Visit(schema.items, references);
    }
    function TAsyncIterator(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Visit(schema.items, references);
    }
    function TConstructor(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Visit(schema.returns, references) || schema.parameters.some((schema2) => Visit(schema2, references));
    }
    function TFunction(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Visit(schema.returns, references) || schema.parameters.some((schema2) => Visit(schema2, references));
    }
    function TIntersect(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Types.TypeGuard.TTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit(schema2, references));
    }
    function TIterator(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Visit(schema.items, references);
    }
    function TNot(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Visit(schema.not, references);
    }
    function TObject(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Object.values(schema.properties).some((schema2) => Visit(schema2, references)) || Types.TypeGuard.TSchema(schema.additionalProperties) && Visit(schema.additionalProperties, references);
    }
    function TPromise(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Visit(schema.item, references);
    }
    function TRecord(schema, references) {
      const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
      const property = schema.patternProperties[pattern];
      return Types.TypeGuard.TTransform(schema) || Visit(property, references) || Types.TypeGuard.TSchema(schema.additionalProperties) && Types.TypeGuard.TTransform(schema.additionalProperties);
    }
    function TRef(schema, references) {
      if (Types.TypeGuard.TTransform(schema))
        return true;
      return Visit((0, deref_1.Deref)(schema, references), references);
    }
    function TThis(schema, references) {
      if (Types.TypeGuard.TTransform(schema))
        return true;
      return Visit((0, deref_1.Deref)(schema, references), references);
    }
    function TTuple(schema, references) {
      return Types.TypeGuard.TTransform(schema) || !(0, guard_1.IsUndefined)(schema.items) && schema.items.some((schema2) => Visit(schema2, references));
    }
    function TUnion(schema, references) {
      return Types.TypeGuard.TTransform(schema) || schema.anyOf.some((schema2) => Visit(schema2, references));
    }
    function Visit(schema, references) {
      const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;
      const schema_ = schema;
      if (schema.$id && visited.has(schema.$id))
        return false;
      if (schema.$id)
        visited.add(schema.$id);
      switch (schema[Types.Kind]) {
        case "Array":
          return TArray(schema_, references_);
        case "AsyncIterator":
          return TAsyncIterator(schema_, references_);
        case "Constructor":
          return TConstructor(schema_, references_);
        case "Function":
          return TFunction(schema_, references_);
        case "Intersect":
          return TIntersect(schema_, references_);
        case "Iterator":
          return TIterator(schema_, references_);
        case "Not":
          return TNot(schema_, references_);
        case "Object":
          return TObject(schema_, references_);
        case "Promise":
          return TPromise(schema_, references_);
        case "Record":
          return TRecord(schema_, references_);
        case "Ref":
          return TRef(schema_, references_);
        case "This":
          return TThis(schema_, references_);
        case "Tuple":
          return TTuple(schema_, references_);
        case "Union":
          return TUnion(schema_, references_);
        default:
          return Types.TypeGuard.TTransform(schema);
      }
    }
    const visited = new Set;
    function Has(schema, references) {
      visited.clear();
      return Visit(schema, references);
    }
    HasTransform2.Has = Has;
  })(HasTransform || (exports.HasTransform = HasTransform = {}));
  var DecodeTransform;
  (function(DecodeTransform2) {
    function Default(schema, value) {
      try {
        return Types.TypeGuard.TTransform(schema) ? schema[Types.Transform].Decode(value) : value;
      } catch (error) {
        throw new TransformDecodeError(schema, value, error);
      }
    }
    function TArray(schema, references, value) {
      return (0, guard_1.IsArray)(value) ? Default(schema, value.map((value2) => Visit(schema.items, references, value2))) : Default(schema, value);
    }
    function TIntersect(schema, references, value) {
      if (!(0, guard_1.IsPlainObject)(value) || (0, guard_1.IsValueType)(value))
        return Default(schema, value);
      const knownKeys = Types.KeyResolver.ResolveKeys(schema, { includePatterns: false });
      const knownProperties = knownKeys.reduce((value2, key) => {
        return key in value2 ? { ...value2, [key]: Visit(Types.IndexedAccessor.Resolve(schema, [key]), references, value2[key]) } : value2;
      }, value);
      if (!Types.TypeGuard.TTransform(schema.unevaluatedProperties)) {
        return Default(schema, knownProperties);
      }
      const unknownKeys = Object.getOwnPropertyNames(knownProperties);
      const unevaluatedProperties = schema.unevaluatedProperties;
      const unknownProperties = unknownKeys.reduce((value2, key) => {
        return !knownKeys.includes(key) ? { ...value2, [key]: Default(unevaluatedProperties, value2[key]) } : value2;
      }, knownProperties);
      return Default(schema, unknownProperties);
    }
    function TNot(schema, references, value) {
      return Default(schema, Visit(schema.not, references, value));
    }
    function TObject(schema, references, value) {
      if (!(0, guard_1.IsPlainObject)(value))
        return Default(schema, value);
      const knownKeys = Types.KeyResolver.ResolveKeys(schema, { includePatterns: false });
      const knownProperties = knownKeys.reduce((value2, key) => {
        return key in value2 ? { ...value2, [key]: Visit(schema.properties[key], references, value2[key]) } : value2;
      }, value);
      if (!Types.TypeGuard.TSchema(schema.additionalProperties)) {
        return Default(schema, knownProperties);
      }
      const unknownKeys = Object.getOwnPropertyNames(knownProperties);
      const additionalProperties = schema.additionalProperties;
      const unknownProperties = unknownKeys.reduce((value2, key) => {
        return !knownKeys.includes(key) ? { ...value2, [key]: Default(additionalProperties, value2[key]) } : value2;
      }, knownProperties);
      return Default(schema, unknownProperties);
    }
    function TRecord(schema, references, value) {
      if (!(0, guard_1.IsPlainObject)(value))
        return Default(schema, value);
      const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
      const knownKeys = new RegExp(pattern);
      const knownProperties = Object.getOwnPropertyNames(value).reduce((value2, key) => {
        return knownKeys.test(key) ? { ...value2, [key]: Visit(schema.patternProperties[pattern], references, value2[key]) } : value2;
      }, value);
      if (!Types.TypeGuard.TSchema(schema.additionalProperties)) {
        return Default(schema, knownProperties);
      }
      const unknownKeys = Object.getOwnPropertyNames(knownProperties);
      const additionalProperties = schema.additionalProperties;
      const unknownProperties = unknownKeys.reduce((value2, key) => {
        return !knownKeys.test(key) ? { ...value2, [key]: Default(additionalProperties, value2[key]) } : value2;
      }, knownProperties);
      return Default(schema, unknownProperties);
    }
    function TRef(schema, references, value) {
      const target = (0, deref_1.Deref)(schema, references);
      return Default(schema, Visit(target, references, value));
    }
    function TThis(schema, references, value) {
      const target = (0, deref_1.Deref)(schema, references);
      return Default(schema, Visit(target, references, value));
    }
    function TTuple(schema, references, value) {
      return (0, guard_1.IsArray)(value) && (0, guard_1.IsArray)(schema.items) ? Default(schema, schema.items.map((schema2, index) => Visit(schema2, references, value[index]))) : Default(schema, value);
    }
    function TUnion(schema, references, value) {
      const defaulted = Default(schema, value);
      for (const subschema of schema.anyOf) {
        if (!(0, check_1.Check)(subschema, references, defaulted))
          continue;
        return Visit(subschema, references, defaulted);
      }
      return defaulted;
    }
    function Visit(schema, references, value) {
      const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
      const schema_ = schema;
      switch (schema[Types.Kind]) {
        case "Array":
          return TArray(schema_, references_, value);
        case "Intersect":
          return TIntersect(schema_, references_, value);
        case "Not":
          return TNot(schema_, references_, value);
        case "Object":
          return TObject(schema_, references_, value);
        case "Record":
          return TRecord(schema_, references_, value);
        case "Ref":
          return TRef(schema_, references_, value);
        case "Symbol":
          return Default(schema_, value);
        case "This":
          return TThis(schema_, references_, value);
        case "Tuple":
          return TTuple(schema_, references_, value);
        case "Union":
          return TUnion(schema_, references_, value);
        default:
          return Default(schema_, value);
      }
    }
    function Decode(schema, references, value) {
      return Visit(schema, references, value);
    }
    DecodeTransform2.Decode = Decode;
  })(DecodeTransform || (exports.DecodeTransform = DecodeTransform = {}));
  var EncodeTransform;
  (function(EncodeTransform2) {
    function Default(schema, value) {
      try {
        return Types.TypeGuard.TTransform(schema) ? schema[Types.Transform].Encode(value) : value;
      } catch (error) {
        throw new TransformEncodeError(schema, value, error);
      }
    }
    function TArray(schema, references, value) {
      const defaulted = Default(schema, value);
      return (0, guard_1.IsArray)(defaulted) ? defaulted.map((value2) => Visit(schema.items, references, value2)) : defaulted;
    }
    function TIntersect(schema, references, value) {
      const defaulted = Default(schema, value);
      if (!(0, guard_1.IsPlainObject)(value) || (0, guard_1.IsValueType)(value))
        return defaulted;
      const knownKeys = Types.KeyResolver.ResolveKeys(schema, { includePatterns: false });
      const knownProperties = knownKeys.reduce((value2, key) => {
        return key in defaulted ? { ...value2, [key]: Visit(Types.IndexedAccessor.Resolve(schema, [key]), references, value2[key]) } : value2;
      }, defaulted);
      if (!Types.TypeGuard.TTransform(schema.unevaluatedProperties)) {
        return Default(schema, knownProperties);
      }
      const unknownKeys = Object.getOwnPropertyNames(knownProperties);
      const unevaluatedProperties = schema.unevaluatedProperties;
      return unknownKeys.reduce((value2, key) => {
        return !knownKeys.includes(key) ? { ...value2, [key]: Default(unevaluatedProperties, value2[key]) } : value2;
      }, knownProperties);
    }
    function TNot(schema, references, value) {
      return Default(schema.not, Default(schema, value));
    }
    function TObject(schema, references, value) {
      const defaulted = Default(schema, value);
      if (!(0, guard_1.IsPlainObject)(value))
        return defaulted;
      const knownKeys = Types.KeyResolver.ResolveKeys(schema, { includePatterns: false });
      const knownProperties = knownKeys.reduce((value2, key) => {
        return key in value2 ? { ...value2, [key]: Visit(schema.properties[key], references, value2[key]) } : value2;
      }, defaulted);
      if (!Types.TypeGuard.TSchema(schema.additionalProperties)) {
        return knownProperties;
      }
      const unknownKeys = Object.getOwnPropertyNames(knownProperties);
      const additionalProperties = schema.additionalProperties;
      return unknownKeys.reduce((value2, key) => {
        return !knownKeys.includes(key) ? { ...value2, [key]: Default(additionalProperties, value2[key]) } : value2;
      }, knownProperties);
    }
    function TRecord(schema, references, value) {
      const defaulted = Default(schema, value);
      if (!(0, guard_1.IsPlainObject)(value))
        return defaulted;
      const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
      const knownKeys = new RegExp(pattern);
      const knownProperties = Object.getOwnPropertyNames(value).reduce((value2, key) => {
        return knownKeys.test(key) ? { ...value2, [key]: Visit(schema.patternProperties[pattern], references, value2[key]) } : value2;
      }, defaulted);
      if (!Types.TypeGuard.TSchema(schema.additionalProperties)) {
        return Default(schema, knownProperties);
      }
      const unknownKeys = Object.getOwnPropertyNames(knownProperties);
      const additionalProperties = schema.additionalProperties;
      return unknownKeys.reduce((value2, key) => {
        return !knownKeys.test(key) ? { ...value2, [key]: Default(additionalProperties, value2[key]) } : value2;
      }, knownProperties);
    }
    function TRef(schema, references, value) {
      const target = (0, deref_1.Deref)(schema, references);
      const resolved = Visit(target, references, value);
      return Default(schema, resolved);
    }
    function TThis(schema, references, value) {
      const target = (0, deref_1.Deref)(schema, references);
      const resolved = Visit(target, references, value);
      return Default(schema, resolved);
    }
    function TTuple(schema, references, value) {
      const value1 = Default(schema, value);
      return (0, guard_1.IsArray)(schema.items) ? schema.items.map((schema2, index) => Visit(schema2, references, value1[index])) : [];
    }
    function TUnion(schema, references, value) {
      for (const subschema of schema.anyOf) {
        if (!(0, check_1.Check)(subschema, references, value))
          continue;
        const value1 = Visit(subschema, references, value);
        return Default(schema, value1);
      }
      for (const subschema of schema.anyOf) {
        const value1 = Visit(subschema, references, value);
        if (!(0, check_1.Check)(schema, references, value1))
          continue;
        return Default(schema, value1);
      }
      return Default(schema, value);
    }
    function Visit(schema, references, value) {
      const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
      const schema_ = schema;
      switch (schema[Types.Kind]) {
        case "Array":
          return TArray(schema_, references_, value);
        case "Intersect":
          return TIntersect(schema_, references_, value);
        case "Not":
          return TNot(schema_, references_, value);
        case "Object":
          return TObject(schema_, references_, value);
        case "Record":
          return TRecord(schema_, references_, value);
        case "Ref":
          return TRef(schema_, references_, value);
        case "This":
          return TThis(schema_, references_, value);
        case "Tuple":
          return TTuple(schema_, references_, value);
        case "Union":
          return TUnion(schema_, references_, value);
        default:
          return Default(schema_, value);
      }
    }
    function Encode(schema, references, value) {
      return Visit(schema, references, value);
    }
    EncodeTransform2.Encode = Encode;
  })(EncodeTransform || (exports.EncodeTransform = EncodeTransform = {}));
});

// node_modules/@sinclair/typebox/value/value.js
var require_value = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Value = undefined;
  var ValueErrors = require_errors2();
  var ValueMutate = require_mutate();
  var ValueHash = require_hash();
  var ValueEqual = require_equal();
  var ValueCast = require_cast();
  var ValueClone = require_clone();
  var ValueConvert = require_convert();
  var ValueCreate = require_create();
  var ValueCheck = require_check();
  var ValueDelta = require_delta();
  var ValueTransform = require_transform();
  var Value;
  (function(Value2) {
    function Cast(...args) {
      return ValueCast.Cast.apply(ValueCast, args);
    }
    Value2.Cast = Cast;
    function Create(...args) {
      return ValueCreate.Create.apply(ValueCreate, args);
    }
    Value2.Create = Create;
    function Check(...args) {
      return ValueCheck.Check.apply(ValueCheck, args);
    }
    Value2.Check = Check;
    function Convert(...args) {
      return ValueConvert.Convert.apply(ValueConvert, args);
    }
    Value2.Convert = Convert;
    function Clone(value) {
      return ValueClone.Clone(value);
    }
    Value2.Clone = Clone;
    function Decode(...args) {
      const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
      if (!Check(schema, references, value))
        throw new ValueTransform.TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());
      return ValueTransform.DecodeTransform.Decode(schema, references, value);
    }
    Value2.Decode = Decode;
    function Encode(...args) {
      const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
      const encoded = ValueTransform.EncodeTransform.Encode(schema, references, value);
      if (!Check(schema, references, encoded))
        throw new ValueTransform.TransformEncodeCheckError(schema, value, Errors(schema, references, value).First());
      return encoded;
    }
    Value2.Encode = Encode;
    function Errors(...args) {
      return ValueErrors.Errors.apply(ValueErrors, args);
    }
    Value2.Errors = Errors;
    function Equal(left, right) {
      return ValueEqual.Equal(left, right);
    }
    Value2.Equal = Equal;
    function Diff(current, next) {
      return ValueDelta.Diff(current, next);
    }
    Value2.Diff = Diff;
    function Hash(value) {
      return ValueHash.Hash(value);
    }
    Value2.Hash = Hash;
    function Patch(current, edits) {
      return ValueDelta.Patch(current, edits);
    }
    Value2.Patch = Patch;
    function Mutate(current, next) {
      ValueMutate.Mutate(current, next);
    }
    Value2.Mutate = Mutate;
  })(Value || (exports.Value = Value = {}));
});

// node_modules/@sinclair/typebox/value/index.js
var require_value2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Value = exports.ValuePointer = exports.Delete = exports.Update = exports.Insert = exports.Edit = exports.ValueErrorIterator = exports.ValueErrorType = undefined;
  var index_1 = require_errors2();
  Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
    return index_1.ValueErrorType;
  } });
  Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
    return index_1.ValueErrorIterator;
  } });
  var delta_1 = require_delta();
  Object.defineProperty(exports, "Edit", { enumerable: true, get: function() {
    return delta_1.Edit;
  } });
  Object.defineProperty(exports, "Insert", { enumerable: true, get: function() {
    return delta_1.Insert;
  } });
  Object.defineProperty(exports, "Update", { enumerable: true, get: function() {
    return delta_1.Update;
  } });
  Object.defineProperty(exports, "Delete", { enumerable: true, get: function() {
    return delta_1.Delete;
  } });
  var pointer_1 = require_pointer();
  Object.defineProperty(exports, "ValuePointer", { enumerable: true, get: function() {
    return pointer_1.ValuePointer;
  } });
  var value_1 = require_value();
  Object.defineProperty(exports, "Value", { enumerable: true, get: function() {
    return value_1.Value;
  } });
});

// node_modules/elysia/dist/cjs/error.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValidationError = exports.InvalidCookieSignature = exports.ParseError = exports.NotFoundError = exports.InternalServerError = exports.isProduction = exports.ERROR_CODE = undefined;
  var value_1 = require_value2();
  var env = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
  exports.ERROR_CODE = Symbol("ErrorCode");
  exports.isProduction = (env?.NODE_ENV ?? env?.ENV) === "production";

  class InternalServerError extends Error {
    constructor(message) {
      super(message ?? "INTERNAL_SERVER_ERROR");
      this.code = "INTERNAL_SERVER_ERROR";
      this.status = 500;
    }
  }
  exports.InternalServerError = InternalServerError;

  class NotFoundError extends Error {
    constructor(message) {
      super(message ?? "NOT_FOUND");
      this.code = "NOT_FOUND";
      this.status = 404;
    }
  }
  exports.NotFoundError = NotFoundError;

  class ParseError extends Error {
    constructor(message) {
      super(message ?? "PARSE");
      this.code = "PARSE";
      this.status = 400;
    }
  }
  exports.ParseError = ParseError;

  class InvalidCookieSignature extends Error {
    constructor(key, message) {
      super(message ?? `"${key}" has invalid cookie signature`);
      this.key = key;
      this.code = "INVALID_COOKIE_SIGNATURE";
      this.status = 400;
    }
  }
  exports.InvalidCookieSignature = InvalidCookieSignature;

  class ValidationError extends Error {
    constructor(type, validator, value) {
      const error = exports.isProduction ? undefined : ("Errors" in validator) ? validator.Errors(value).First() : value_1.Value.Errors(validator, value).First();
      const customError = error?.schema.error ? typeof error.schema.error === "function" ? error.schema.error(type, validator, value) : error.schema.error : undefined;
      const message = exports.isProduction ? customError ?? `Invalid ${type ?? error?.schema.error ?? error?.message}` : customError ?? `Invalid ${type}, '${error?.path?.slice(1) || "type"}': ${error?.message}` + "\n\n" + "Expected: " + JSON.stringify(ValidationError.simplifyModel(validator), null, 2) + "\n\n" + "Found: " + JSON.stringify(value, null, 2);
      super(message);
      this.type = type;
      this.validator = validator;
      this.value = value;
      this.code = "VALIDATION";
      this.status = 400;
      Object.setPrototypeOf(this, ValidationError.prototype);
    }
    get all() {
      return [...this.validator.Errors(this.value)];
    }
    static simplifyModel(validator) {
      const model = "schema" in validator ? validator.schema : validator;
      try {
        return value_1.Value.Create(model);
      } catch {
        return model;
      }
    }
    get model() {
      return ValidationError.simplifyModel(this.validator);
    }
    toResponse(headers) {
      return new Response(this.message, {
        status: 400,
        headers
      });
    }
  }
  exports.ValidationError = ValidationError;
});

// node_modules/elysia/dist/cjs/ws/index.js
var require_ws = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ElysiaWS = exports.websocket = undefined;
  var error_1 = require_error();
  exports.websocket = {
    open(ws) {
      ws.data.open?.(ws);
    },
    message(ws, message) {
      ws.data.message?.(ws, message);
    },
    drain(ws) {
      ws.data.drain?.(ws);
    },
    close(ws, code, reason) {
      ws.data.close?.(ws, code, reason);
    }
  };

  class ElysiaWS {
    constructor(raw, data) {
      this.raw = raw;
      this.data = data;
      this.validator = raw.data.validator;
      this.id = Date.now();
    }
    get publish() {
      return (topic, data = undefined, compress) => {
        if (this.validator?.Check(data) === false)
          throw new error_1.ValidationError("message", this.validator, data);
        if (typeof data === "object")
          data = JSON.stringify(data);
        this.raw.publish(topic, data, compress);
        return this;
      };
    }
    get send() {
      return (data) => {
        if (this.validator?.Check(data) === false)
          throw new error_1.ValidationError("message", this.validator, data);
        if (Buffer.isBuffer(data)) {
          this.raw.send(data);
          return this;
        }
        if (typeof data === "object")
          data = JSON.stringify(data);
        this.raw.send(data);
        return this;
      };
    }
    get subscribe() {
      return (room) => {
        this.raw.subscribe(room);
        return this;
      };
    }
    get unsubscribe() {
      return (room) => {
        this.raw.unsubscribe(room);
        return this;
      };
    }
    get cork() {
      return (callback) => {
        this.raw.cork(callback);
        return this;
      };
    }
    get close() {
      return () => {
        this.raw.close();
        return this;
      };
    }
    get terminate() {
      return this.raw.terminate.bind(this.raw);
    }
    get isSubscribed() {
      return this.raw.isSubscribed.bind(this.raw);
    }
    get remoteAddress() {
      return this.raw.remoteAddress;
    }
  }
  exports.ElysiaWS = ElysiaWS;
});

// node_modules/elysia/node_modules/cookie/index.js
var require_cookie = __commonJS((exports) => {
  function parse(str, options) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var opt = options || {};
    var dec = opt.decode || decode;
    var index = 0;
    while (index < str.length) {
      var eqIdx = str.indexOf("=", index);
      if (eqIdx === -1) {
        break;
      }
      var endIdx = str.indexOf(";", index);
      if (endIdx === -1) {
        endIdx = str.length;
      } else if (endIdx < eqIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      var key = str.slice(index, eqIdx).trim();
      if (obj[key] === undefined) {
        var val = str.slice(eqIdx + 1, endIdx).trim();
        if (val.charCodeAt(0) === 34) {
          val = val.slice(1, -1);
        }
        obj[key] = tryDecode(val, dec);
      }
      index = endIdx + 1;
    }
    return obj;
  }
  function serialize(name, val, options) {
    var opt = options || {};
    var enc = opt.encode || encode;
    if (typeof enc !== "function") {
      throw new TypeError("option encode is invalid");
    }
    if (!fieldContentRegExp.test(name)) {
      throw new TypeError("argument name is invalid");
    }
    var value = enc(val);
    if (value && !fieldContentRegExp.test(value)) {
      throw new TypeError("argument val is invalid");
    }
    var str = name + "=" + value;
    if (opt.maxAge != null) {
      var maxAge = opt.maxAge - 0;
      if (isNaN(maxAge) || !isFinite(maxAge)) {
        throw new TypeError("option maxAge is invalid");
      }
      str += "; Max-Age=" + Math.floor(maxAge);
    }
    if (opt.domain) {
      if (!fieldContentRegExp.test(opt.domain)) {
        throw new TypeError("option domain is invalid");
      }
      str += "; Domain=" + opt.domain;
    }
    if (opt.path) {
      if (!fieldContentRegExp.test(opt.path)) {
        throw new TypeError("option path is invalid");
      }
      str += "; Path=" + opt.path;
    }
    if (opt.expires) {
      var expires = opt.expires;
      if (!isDate(expires) || isNaN(expires.valueOf())) {
        throw new TypeError("option expires is invalid");
      }
      str += "; Expires=" + expires.toUTCString();
    }
    if (opt.httpOnly) {
      str += "; HttpOnly";
    }
    if (opt.secure) {
      str += "; Secure";
    }
    if (opt.partitioned) {
      str += "; Partitioned";
    }
    if (opt.priority) {
      var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError("option priority is invalid");
      }
    }
    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
      switch (sameSite) {
        case true:
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return str;
  }
  function decode(str) {
    return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
  }
  function encode(val) {
    return encodeURIComponent(val);
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]" || val instanceof Date;
  }
  function tryDecode(str, decode2) {
    try {
      return decode2(str);
    } catch (e) {
      return str;
    }
  }
  /*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  exports.parse = parse;
  exports.serialize = serialize;
  var __toString = Object.prototype.toString;
  var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
});

// node_modules/@sinclair/typebox/compiler/compiler.js
var require_compiler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeCompiler = exports.Policy = exports.TypeCompilerTypeGuardError = exports.TypeCompilerUnknownTypeError = exports.TypeCheck = undefined;
  var transform_1 = require_transform();
  var guard_1 = require_guard();
  var errors_1 = require_errors();
  var index_1 = require_system2();
  var deref_1 = require_deref();
  var hash_1 = require_hash();
  var Types = require_typebox();

  class TypeCheck {
    constructor(schema, references, checkFunc, code) {
      this.schema = schema;
      this.references = references;
      this.checkFunc = checkFunc;
      this.code = code;
      this.hasTransform = transform_1.HasTransform.Has(schema, references);
    }
    Code() {
      return this.code;
    }
    Errors(value) {
      return (0, errors_1.Errors)(this.schema, this.references, value);
    }
    Check(value) {
      return this.checkFunc(value);
    }
    Decode(value) {
      if (!this.checkFunc(value))
        throw new transform_1.TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
      return this.hasTransform ? transform_1.DecodeTransform.Decode(this.schema, this.references, value) : value;
    }
    Encode(value) {
      const encoded = this.hasTransform ? transform_1.EncodeTransform.Encode(this.schema, this.references, value) : value;
      if (!this.checkFunc(encoded))
        throw new transform_1.TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
      return encoded;
    }
  }
  exports.TypeCheck = TypeCheck;
  var Character;
  (function(Character2) {
    function DollarSign(code) {
      return code === 36;
    }
    Character2.DollarSign = DollarSign;
    function IsUnderscore(code) {
      return code === 95;
    }
    Character2.IsUnderscore = IsUnderscore;
    function IsAlpha(code) {
      return code >= 65 && code <= 90 || code >= 97 && code <= 122;
    }
    Character2.IsAlpha = IsAlpha;
    function IsNumeric(code) {
      return code >= 48 && code <= 57;
    }
    Character2.IsNumeric = IsNumeric;
  })(Character || (Character = {}));
  var MemberExpression;
  (function(MemberExpression2) {
    function IsFirstCharacterNumeric(value) {
      if (value.length === 0)
        return false;
      return Character.IsNumeric(value.charCodeAt(0));
    }
    function IsAccessor(value) {
      if (IsFirstCharacterNumeric(value))
        return false;
      for (let i = 0;i < value.length; i++) {
        const code = value.charCodeAt(i);
        const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
        if (!check)
          return false;
      }
      return true;
    }
    function EscapeHyphen(key) {
      return key.replace(/'/g, "\\'");
    }
    function Encode(object, key) {
      return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
    }
    MemberExpression2.Encode = Encode;
  })(MemberExpression || (MemberExpression = {}));
  var Identifier;
  (function(Identifier2) {
    function Encode($id) {
      const buffer = [];
      for (let i = 0;i < $id.length; i++) {
        const code = $id.charCodeAt(i);
        if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
          buffer.push($id.charAt(i));
        } else {
          buffer.push(`_${code}_`);
        }
      }
      return buffer.join("").replace(/__/g, "_");
    }
    Identifier2.Encode = Encode;
  })(Identifier || (Identifier = {}));
  var LiteralString;
  (function(LiteralString2) {
    function Escape(content) {
      return content.replace(/'/g, "\\'");
    }
    LiteralString2.Escape = Escape;
  })(LiteralString || (LiteralString = {}));

  class TypeCompilerUnknownTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  exports.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError;

  class TypeCompilerTypeGuardError extends Types.TypeBoxError {
    constructor(schema) {
      super("Preflight validation check failed to guard for the given schema");
      this.schema = schema;
    }
  }
  exports.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError;
  var Policy;
  (function(Policy2) {
    function IsExactOptionalProperty(value, key, expression) {
      return index_1.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
    }
    Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
    function IsObjectLike(value) {
      return !index_1.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
    }
    Policy2.IsObjectLike = IsObjectLike;
    function IsRecordLike(value) {
      return !index_1.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
    }
    Policy2.IsRecordLike = IsRecordLike;
    function IsNumberLike(value) {
      return !index_1.TypeSystemPolicy.AllowNaN ? `(typeof ${value} === 'number' && Number.isFinite(${value}))` : `typeof ${value} === 'number'`;
    }
    Policy2.IsNumberLike = IsNumberLike;
    function IsVoidLike(value) {
      return index_1.TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
    }
    Policy2.IsVoidLike = IsVoidLike;
  })(Policy || (exports.Policy = Policy = {}));
  var TypeCompiler;
  (function(TypeCompiler2) {
    function IsAnyOrUnknown(schema) {
      return schema[Types.Kind] === "Any" || schema[Types.Kind] === "Unknown";
    }
    function* TAny(schema, references, value) {
      yield "true";
    }
    function* TArray(schema, references, value) {
      yield `Array.isArray(${value})`;
      const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
      if ((0, guard_1.IsNumber)(schema.maxItems))
        yield `${value}.length <= ${schema.maxItems}`;
      if ((0, guard_1.IsNumber)(schema.minItems))
        yield `${value}.length >= ${schema.minItems}`;
      const elementExpression = CreateExpression(schema.items, references, "value");
      yield `${value}.every((${parameter}) => ${elementExpression})`;
      if (Types.TypeGuard.TSchema(schema.contains) || (0, guard_1.IsNumber)(schema.minContains) || (0, guard_1.IsNumber)(schema.maxContains)) {
        const containsSchema = Types.TypeGuard.TSchema(schema.contains) ? schema.contains : Types.Type.Never();
        const checkExpression = CreateExpression(containsSchema, references, "value");
        const checkMinContains = (0, guard_1.IsNumber)(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
        const checkMaxContains = (0, guard_1.IsNumber)(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
        const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
        const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
        yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;
      }
      if (schema.uniqueItems === true) {
        const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
        const block = `const set = new Set(); for(const element of value) { ${check} }`;
        yield `((${parameter}) => { ${block} )(${value})`;
      }
    }
    function* TAsyncIterator(schema, references, value) {
      yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
    }
    function* TBigInt(schema, references, value) {
      yield `(typeof ${value} === 'bigint')`;
      if ((0, guard_1.IsBigInt)(schema.exclusiveMaximum))
        yield `${value} < BigInt(${schema.exclusiveMaximum})`;
      if ((0, guard_1.IsBigInt)(schema.exclusiveMinimum))
        yield `${value} > BigInt(${schema.exclusiveMinimum})`;
      if ((0, guard_1.IsBigInt)(schema.maximum))
        yield `${value} <= BigInt(${schema.maximum})`;
      if ((0, guard_1.IsBigInt)(schema.minimum))
        yield `${value} >= BigInt(${schema.minimum})`;
      if ((0, guard_1.IsBigInt)(schema.multipleOf))
        yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
    }
    function* TBoolean(schema, references, value) {
      yield `(typeof ${value} === 'boolean')`;
    }
    function* TConstructor(schema, references, value) {
      yield* Visit(schema.returns, references, `${value}.prototype`);
    }
    function* TDate(schema, references, value) {
      yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
      if ((0, guard_1.IsNumber)(schema.exclusiveMaximumTimestamp))
        yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
      if ((0, guard_1.IsNumber)(schema.exclusiveMinimumTimestamp))
        yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
      if ((0, guard_1.IsNumber)(schema.maximumTimestamp))
        yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
      if ((0, guard_1.IsNumber)(schema.minimumTimestamp))
        yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
      if ((0, guard_1.IsNumber)(schema.multipleOfTimestamp))
        yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
    }
    function* TFunction(schema, references, value) {
      yield `(typeof ${value} === 'function')`;
    }
    function* TInteger(schema, references, value) {
      yield `(typeof ${value} === 'number' && Number.isInteger(${value}))`;
      if ((0, guard_1.IsNumber)(schema.exclusiveMaximum))
        yield `${value} < ${schema.exclusiveMaximum}`;
      if ((0, guard_1.IsNumber)(schema.exclusiveMinimum))
        yield `${value} > ${schema.exclusiveMinimum}`;
      if ((0, guard_1.IsNumber)(schema.maximum))
        yield `${value} <= ${schema.maximum}`;
      if ((0, guard_1.IsNumber)(schema.minimum))
        yield `${value} >= ${schema.minimum}`;
      if ((0, guard_1.IsNumber)(schema.multipleOf))
        yield `(${value} % ${schema.multipleOf}) === 0`;
    }
    function* TIntersect(schema, references, value) {
      const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value)).join(" && ");
      if (schema.unevaluatedProperties === false) {
        const keyCheck = CreateVariable(`${new RegExp(Types.KeyResolver.ResolvePattern(schema))};`);
        const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
        yield `(${check1} && ${check2})`;
      } else if (Types.TypeGuard.TSchema(schema.unevaluatedProperties)) {
        const keyCheck = CreateVariable(`${new RegExp(Types.KeyResolver.ResolvePattern(schema))};`);
        const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
        yield `(${check1} && ${check2})`;
      } else {
        yield `(${check1})`;
      }
    }
    function* TIterator(schema, references, value) {
      yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
    }
    function* TLiteral(schema, references, value) {
      if (typeof schema.const === "number" || typeof schema.const === "boolean") {
        yield `(${value} === ${schema.const})`;
      } else {
        yield `(${value} === '${LiteralString.Escape(schema.const)}')`;
      }
    }
    function* TNever(schema, references, value) {
      yield `false`;
    }
    function* TNot(schema, references, value) {
      const expression = CreateExpression(schema.not, references, value);
      yield `(!${expression})`;
    }
    function* TNull(schema, references, value) {
      yield `(${value} === null)`;
    }
    function* TNumber(schema, references, value) {
      yield Policy.IsNumberLike(value);
      if ((0, guard_1.IsNumber)(schema.exclusiveMaximum))
        yield `${value} < ${schema.exclusiveMaximum}`;
      if ((0, guard_1.IsNumber)(schema.exclusiveMinimum))
        yield `${value} > ${schema.exclusiveMinimum}`;
      if ((0, guard_1.IsNumber)(schema.maximum))
        yield `${value} <= ${schema.maximum}`;
      if ((0, guard_1.IsNumber)(schema.minimum))
        yield `${value} >= ${schema.minimum}`;
      if ((0, guard_1.IsNumber)(schema.multipleOf))
        yield `(${value} % ${schema.multipleOf}) === 0`;
    }
    function* TObject(schema, references, value) {
      yield Policy.IsObjectLike(value);
      if ((0, guard_1.IsNumber)(schema.minProperties))
        yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
      if ((0, guard_1.IsNumber)(schema.maxProperties))
        yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
      const knownKeys = Object.getOwnPropertyNames(schema.properties);
      for (const knownKey of knownKeys) {
        const memberExpression = MemberExpression.Encode(value, knownKey);
        const property = schema.properties[knownKey];
        if (schema.required && schema.required.includes(knownKey)) {
          yield* Visit(property, references, memberExpression);
          if (Types.ExtendsUndefined.Check(property) || IsAnyOrUnknown(property))
            yield `('${knownKey}' in ${value})`;
        } else {
          const expression = CreateExpression(property, references, memberExpression);
          yield Policy.IsExactOptionalProperty(value, knownKey, expression);
        }
      }
      if (schema.additionalProperties === false) {
        if (schema.required && schema.required.length === knownKeys.length) {
          yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
        } else {
          const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
          yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
        }
      }
      if (typeof schema.additionalProperties === "object") {
        const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
      }
    }
    function* TPromise(schema, references, value) {
      yield `(typeof value === 'object' && typeof ${value}.then === 'function')`;
    }
    function* TRecord(schema, references, value) {
      yield Policy.IsRecordLike(value);
      if ((0, guard_1.IsNumber)(schema.minProperties))
        yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
      if ((0, guard_1.IsNumber)(schema.maxProperties))
        yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
      const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
      const variable = CreateVariable(`${new RegExp(patternKey)}`);
      const check1 = CreateExpression(patternSchema, references, "value");
      const check2 = Types.TypeGuard.TSchema(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? "false" : "true";
      const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
      yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
    }
    function* TRef(schema, references, value) {
      const target = (0, deref_1.Deref)(schema, references);
      if (state.functions.has(schema.$ref))
        return yield `${CreateFunctionName(schema.$ref)}(${value})`;
      yield* Visit(target, references, value);
    }
    function* TString(schema, references, value) {
      yield `(typeof ${value} === 'string')`;
      if ((0, guard_1.IsNumber)(schema.maxLength))
        yield `${value}.length <= ${schema.maxLength}`;
      if ((0, guard_1.IsNumber)(schema.minLength))
        yield `${value}.length >= ${schema.minLength}`;
      if (schema.pattern !== undefined) {
        const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
        yield `${variable}.test(${value})`;
      }
      if (schema.format !== undefined) {
        yield `format('${schema.format}', ${value})`;
      }
    }
    function* TSymbol(schema, references, value) {
      yield `(typeof ${value} === 'symbol')`;
    }
    function* TTemplateLiteral(schema, references, value) {
      yield `(typeof ${value} === 'string')`;
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value})`;
    }
    function* TThis(schema, references, value) {
      yield `${CreateFunctionName(schema.$ref)}(${value})`;
    }
    function* TTuple(schema, references, value) {
      yield `Array.isArray(${value})`;
      if (schema.items === undefined)
        return yield `${value}.length === 0`;
      yield `(${value}.length === ${schema.maxItems})`;
      for (let i = 0;i < schema.items.length; i++) {
        const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);
        yield `${expression}`;
      }
    }
    function* TUndefined(schema, references, value) {
      yield `${value} === undefined`;
    }
    function* TUnion(schema, references, value) {
      const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
      yield `(${expressions.join(" || ")})`;
    }
    function* TUint8Array(schema, references, value) {
      yield `${value} instanceof Uint8Array`;
      if ((0, guard_1.IsNumber)(schema.maxByteLength))
        yield `(${value}.length <= ${schema.maxByteLength})`;
      if ((0, guard_1.IsNumber)(schema.minByteLength))
        yield `(${value}.length >= ${schema.minByteLength})`;
    }
    function* TUnknown(schema, references, value) {
      yield "true";
    }
    function* TVoid(schema, references, value) {
      yield Policy.IsVoidLike(value);
    }
    function* TKind(schema, references, value) {
      const instance = state.instances.size;
      state.instances.set(instance, schema);
      yield `kind('${schema[Types.Kind]}', ${instance}, ${value})`;
    }
    function* Visit(schema, references, value, useHoisting = true) {
      const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;
      const schema_ = schema;
      if (useHoisting && (0, guard_1.IsString)(schema.$id)) {
        const functionName = CreateFunctionName(schema.$id);
        if (state.functions.has(functionName)) {
          return yield `${functionName}(${value})`;
        } else {
          const functionCode = CreateFunction(functionName, schema, references, "value", false);
          state.functions.set(functionName, functionCode);
          return yield `${functionName}(${value})`;
        }
      }
      switch (schema_[Types.Kind]) {
        case "Any":
          return yield* TAny(schema_, references_, value);
        case "Array":
          return yield* TArray(schema_, references_, value);
        case "AsyncIterator":
          return yield* TAsyncIterator(schema_, references_, value);
        case "BigInt":
          return yield* TBigInt(schema_, references_, value);
        case "Boolean":
          return yield* TBoolean(schema_, references_, value);
        case "Constructor":
          return yield* TConstructor(schema_, references_, value);
        case "Date":
          return yield* TDate(schema_, references_, value);
        case "Function":
          return yield* TFunction(schema_, references_, value);
        case "Integer":
          return yield* TInteger(schema_, references_, value);
        case "Intersect":
          return yield* TIntersect(schema_, references_, value);
        case "Iterator":
          return yield* TIterator(schema_, references_, value);
        case "Literal":
          return yield* TLiteral(schema_, references_, value);
        case "Never":
          return yield* TNever(schema_, references_, value);
        case "Not":
          return yield* TNot(schema_, references_, value);
        case "Null":
          return yield* TNull(schema_, references_, value);
        case "Number":
          return yield* TNumber(schema_, references_, value);
        case "Object":
          return yield* TObject(schema_, references_, value);
        case "Promise":
          return yield* TPromise(schema_, references_, value);
        case "Record":
          return yield* TRecord(schema_, references_, value);
        case "Ref":
          return yield* TRef(schema_, references_, value);
        case "String":
          return yield* TString(schema_, references_, value);
        case "Symbol":
          return yield* TSymbol(schema_, references_, value);
        case "TemplateLiteral":
          return yield* TTemplateLiteral(schema_, references_, value);
        case "This":
          return yield* TThis(schema_, references_, value);
        case "Tuple":
          return yield* TTuple(schema_, references_, value);
        case "Undefined":
          return yield* TUndefined(schema_, references_, value);
        case "Union":
          return yield* TUnion(schema_, references_, value);
        case "Uint8Array":
          return yield* TUint8Array(schema_, references_, value);
        case "Unknown":
          return yield* TUnknown(schema_, references_, value);
        case "Void":
          return yield* TVoid(schema_, references_, value);
        default:
          if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
            throw new TypeCompilerUnknownTypeError(schema);
          return yield* TKind(schema_, references_, value);
      }
    }
    const state = {
      language: "javascript",
      functions: new Map,
      variables: new Map,
      instances: new Map
    };
    function CreateExpression(schema, references, value, useHoisting = true) {
      return `(${[...Visit(schema, references, value, useHoisting)].join(" && ")})`;
    }
    function CreateFunctionName($id) {
      return `check_${Identifier.Encode($id)}`;
    }
    function CreateVariable(expression) {
      const variableName = `local_${state.variables.size}`;
      state.variables.set(variableName, `const ${variableName} = ${expression}`);
      return variableName;
    }
    function CreateFunction(name, schema, references, value, useHoisting = true) {
      const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
      const parameter = CreateParameter("value", "any");
      const returns = CreateReturns("boolean");
      const expression = [...Visit(schema, references, value, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
      return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\n}`;
    }
    function CreateParameter(name, type) {
      const annotation = state.language === "typescript" ? `: ${type}` : "";
      return `${name}${annotation}`;
    }
    function CreateReturns(type) {
      return state.language === "typescript" ? `: ${type}` : "";
    }
    function Build(schema, references, options) {
      const functionCode = CreateFunction("check", schema, references, "value");
      const parameter = CreateParameter("value", "any");
      const returns = CreateReturns("boolean");
      const functions = [...state.functions.values()];
      const variables = [...state.variables.values()];
      const checkFunction = (0, guard_1.IsString)(schema.$id) ? `return function check(${parameter})${returns} {\n  return ${CreateFunctionName(schema.$id)}(value)\n}` : `return ${functionCode}`;
      return [...variables, ...functions, checkFunction].join("\n");
    }
    function Code(...args) {
      const defaults = { language: "javascript" };
      const [schema, references, options] = args.length === 2 && (0, guard_1.IsArray)(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !(0, guard_1.IsArray)(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
      state.language = options.language;
      state.variables.clear();
      state.functions.clear();
      state.instances.clear();
      if (!Types.TypeGuard.TSchema(schema))
        throw new TypeCompilerTypeGuardError(schema);
      for (const schema2 of references)
        if (!Types.TypeGuard.TSchema(schema2))
          throw new TypeCompilerTypeGuardError(schema2);
      return Build(schema, references, options);
    }
    TypeCompiler2.Code = Code;
    function Compile(schema, references = []) {
      const generatedCode = Code(schema, references, { language: "javascript" });
      const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
      const instances = new Map(state.instances);
      function typeRegistryFunction(kind, instance, value) {
        if (!Types.TypeRegistry.Has(kind) || !instances.has(instance))
          return false;
        const checkFunc = Types.TypeRegistry.Get(kind);
        const schema2 = instances.get(instance);
        return checkFunc(schema2, value);
      }
      function formatRegistryFunction(format, value) {
        if (!Types.FormatRegistry.Has(format))
          return false;
        const checkFunc = Types.FormatRegistry.Get(format);
        return checkFunc(value);
      }
      function hashFunction(value) {
        return (0, hash_1.Hash)(value);
      }
      const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
      return new TypeCheck(schema, references, checkFunction, generatedCode);
    }
    TypeCompiler2.Compile = Compile;
  })(TypeCompiler || (exports.TypeCompiler = TypeCompiler = {}));
});

// node_modules/@sinclair/typebox/compiler/index.js
var require_compiler2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueErrorIterator = exports.ValueErrorType = undefined;
  var index_1 = require_errors2();
  Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
    return index_1.ValueErrorType;
  } });
  Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
    return index_1.ValueErrorIterator;
  } });
  __exportStar(require_compiler(), exports);
});

// node_modules/elysia/dist/cjs/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unsignCookie = exports.signCookie = exports.StatusMap = exports.filterGlobalHook = exports.asGlobal = exports.asGlobalHook = exports.mergeLifeCycle = exports.checksum = exports.getResponseSchemaValidator = exports.getSchemaValidator = exports.mergeHook = exports.mergeObjectArray = exports.mergeCookie = exports.mergeDeep = exports.getHostname = undefined;
  var typebox_1 = require_typebox();
  var value_1 = require_value2();
  var compiler_1 = require_compiler2();
  var handler_1 = require_handler();
  var isObject = (item) => item && typeof item === "object" && !Array.isArray(item);
  var getHostname = (url) => url.slice(0, url.indexOf("/", 11));
  exports.getHostname = getHostname;
  var isClass = (v) => typeof v === "function" && /^\s*class\s+/.test(v.toString()) || v.toString().startsWith("[object ") || (0, handler_1.isNotEmpty)(Object.getPrototypeOf(v));
  var mergeDeep = (target, source, { skipKeys } = {}) => {
    if (isObject(target) && isObject(source))
      for (const [key, value] of Object.entries(source)) {
        if (skipKeys?.includes(key))
          continue;
        if (!isObject(value)) {
          target[key] = value;
          continue;
        }
        if (!(key in target)) {
          target[key] = value;
          continue;
        }
        if (isClass(value)) {
          target[key] = value;
          continue;
        }
        target[key] = (0, exports.mergeDeep)(target[key], value);
      }
    return target;
  };
  exports.mergeDeep = mergeDeep;
  var mergeCookie = (target, source) => (0, exports.mergeDeep)(target, source, {
    skipKeys: ["properties"]
  });
  exports.mergeCookie = mergeCookie;
  var mergeObjectArray = (a, b) => {
    const array = [...Array.isArray(a) ? a : [a]];
    const checksums = [];
    for (const item of array) {
      if (item.$elysiaChecksum)
        checksums.push(item.$elysiaChecksum);
    }
    for (const item of Array.isArray(b) ? b : [b]) {
      if (!checksums.includes(item?.$elysiaChecksum))
        array.push(item);
    }
    return array;
  };
  exports.mergeObjectArray = mergeObjectArray;
  var mergeHook = (a, b) => {
    return {
      body: b?.body ?? a?.body,
      headers: b?.headers ?? a?.headers,
      params: b?.params ?? a?.params,
      query: b?.query ?? a?.query,
      response: b?.response ?? a?.response,
      type: a?.type || b?.type,
      detail: (0, exports.mergeDeep)(b?.detail ?? {}, a?.detail ?? {}),
      parse: (0, exports.mergeObjectArray)(a?.parse ?? [], b?.parse ?? []),
      transform: (0, exports.mergeObjectArray)(a?.transform ?? [], b?.transform ?? []),
      beforeHandle: (0, exports.mergeObjectArray)(a?.beforeHandle ?? [], b?.beforeHandle ?? []),
      afterHandle: (0, exports.mergeObjectArray)(a?.afterHandle ?? [], b?.afterHandle ?? []),
      onResponse: (0, exports.mergeObjectArray)(a?.onResponse ?? [], b?.onResponse ?? []),
      trace: (0, exports.mergeObjectArray)(a?.trace ?? [], b?.trace ?? []),
      error: (0, exports.mergeObjectArray)(a?.error ?? [], b?.error ?? [])
    };
  };
  exports.mergeHook = mergeHook;
  var getSchemaValidator = (s, { models = {}, additionalProperties = false, dynamic = false }) => {
    if (!s)
      return;
    if (typeof s === "string" && !(s in models))
      return;
    const schema = typeof s === "string" ? models[s] : s;
    if (schema.type === "object" && "additionalProperties" in schema === false)
      schema.additionalProperties = additionalProperties;
    if (dynamic)
      return {
        schema,
        references: "",
        checkFunc: () => {
        },
        code: "",
        Check: (value) => value_1.Value.Check(schema, value),
        Errors: (value) => value_1.Value.Errors(schema, value),
        Code: () => ""
      };
    return compiler_1.TypeCompiler.Compile(schema, Object.values(models));
  };
  exports.getSchemaValidator = getSchemaValidator;
  var getResponseSchemaValidator = (s, { models = {}, additionalProperties = false, dynamic = false }) => {
    if (!s)
      return;
    if (typeof s === "string" && !(s in models))
      return;
    const maybeSchemaOrRecord = typeof s === "string" ? models[s] : s;
    const compile = (schema, references) => {
      if (dynamic)
        return {
          schema,
          references: "",
          checkFunc: () => {
          },
          code: "",
          Check: (value) => value_1.Value.Check(schema, value),
          Errors: (value) => value_1.Value.Errors(schema, value),
          Code: () => ""
        };
      return compiler_1.TypeCompiler.Compile(schema, references);
    };
    if (typebox_1.Kind in maybeSchemaOrRecord) {
      if ("additionalProperties" in maybeSchemaOrRecord === false)
        maybeSchemaOrRecord.additionalProperties = additionalProperties;
      return {
        200: compile(maybeSchemaOrRecord, Object.values(models))
      };
    }
    const record = {};
    Object.keys(maybeSchemaOrRecord).forEach((status) => {
      const maybeNameOrSchema = maybeSchemaOrRecord[+status];
      if (typeof maybeNameOrSchema === "string") {
        if (maybeNameOrSchema in models) {
          const schema = models[maybeNameOrSchema];
          schema.type === "object" && "additionalProperties" in schema;
          record[+status] = typebox_1.Kind in schema ? compile(schema, Object.values(models)) : schema;
        }
        return;
      }
      if (maybeNameOrSchema.type === "object" && "additionalProperties" in maybeNameOrSchema === false)
        maybeNameOrSchema.additionalProperties = additionalProperties;
      record[+status] = typebox_1.Kind in maybeNameOrSchema ? compile(maybeNameOrSchema, Object.values(models)) : maybeNameOrSchema;
    });
    return record;
  };
  exports.getResponseSchemaValidator = getResponseSchemaValidator;
  var checksum = (s) => {
    let h = 9;
    for (let i = 0;i < s.length; )
      h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);
    return h = h ^ h >>> 9;
  };
  exports.checksum = checksum;
  var mergeLifeCycle = (a, b, checksum2) => {
    const injectChecksum = (x) => {
      if (checksum2 && !x.$elysiaChecksum)
        x.$elysiaChecksum = checksum2;
      return x;
    };
    return {
      start: (0, exports.mergeObjectArray)(a.start, ("start" in b ? b.start ?? [] : []).map(injectChecksum)),
      request: (0, exports.mergeObjectArray)(a.request, ("request" in b ? b.request ?? [] : []).map(injectChecksum)),
      parse: (0, exports.mergeObjectArray)(a.parse, "parse" in b ? b?.parse ?? [] : []).map(injectChecksum),
      transform: (0, exports.mergeObjectArray)(a.transform, (b?.transform ?? []).map(injectChecksum)),
      beforeHandle: (0, exports.mergeObjectArray)(a.beforeHandle, (b?.beforeHandle ?? []).map(injectChecksum)),
      afterHandle: (0, exports.mergeObjectArray)(a.afterHandle, (b?.afterHandle ?? []).map(injectChecksum)),
      onResponse: (0, exports.mergeObjectArray)(a.onResponse, (b?.onResponse ?? []).map(injectChecksum)),
      trace: a.trace,
      error: (0, exports.mergeObjectArray)(a.error, (b?.error ?? []).map(injectChecksum)),
      stop: (0, exports.mergeObjectArray)(a.stop, ("stop" in b ? b.stop ?? [] : []).map(injectChecksum))
    };
  };
  exports.mergeLifeCycle = mergeLifeCycle;
  var asGlobalHook = (hook, inject = true) => {
    return {
      ...hook,
      type: hook?.type,
      detail: hook?.detail,
      parse: (0, exports.asGlobal)(hook?.parse, inject),
      transform: (0, exports.asGlobal)(hook?.transform, inject),
      beforeHandle: (0, exports.asGlobal)(hook?.beforeHandle, inject),
      afterHandle: (0, exports.asGlobal)(hook?.afterHandle, inject),
      onResponse: (0, exports.asGlobal)(hook?.onResponse, inject),
      error: (0, exports.asGlobal)(hook?.error, inject)
    };
  };
  exports.asGlobalHook = asGlobalHook;
  var asGlobal = (fn, inject = true) => {
    if (!fn)
      return fn;
    if (typeof fn === "function") {
      if (inject)
        fn.$elysiaHookType = "global";
      else
        fn.$elysiaHookType = undefined;
      return fn;
    }
    return fn.map((x) => {
      if (inject)
        x.$elysiaHookType = "global";
      else
        x.$elysiaHookType = undefined;
      return x;
    });
  };
  exports.asGlobal = asGlobal;
  var filterGlobal = (fn) => {
    if (!fn)
      return fn;
    if (typeof fn === "function") {
      return fn.$elysiaHookType === "global" ? fn : undefined;
    }
    return fn.filter((x) => x.$elysiaHookType === "global");
  };
  var filterGlobalHook = (hook) => {
    return {
      ...hook,
      type: hook?.type,
      detail: hook?.detail,
      parse: filterGlobal(hook?.parse),
      transform: filterGlobal(hook?.transform),
      beforeHandle: filterGlobal(hook?.beforeHandle),
      afterHandle: filterGlobal(hook?.afterHandle),
      onResponse: filterGlobal(hook?.onResponse),
      error: filterGlobal(hook?.error)
    };
  };
  exports.filterGlobalHook = filterGlobalHook;
  exports.StatusMap = {
    Continue: 100,
    "Switching Protocols": 101,
    Processing: 102,
    "Early Hints": 103,
    OK: 200,
    Created: 201,
    Accepted: 202,
    "Non-Authoritative Information": 203,
    "No Content": 204,
    "Reset Content": 205,
    "Partial Content": 206,
    "Multi-Status": 207,
    "Already Reported": 208,
    "Multiple Choices": 300,
    "Moved Permanently": 301,
    Found: 302,
    "See Other": 303,
    "Not Modified": 304,
    "Temporary Redirect": 307,
    "Permanent Redirect": 308,
    "Bad Request": 400,
    Unauthorized: 401,
    "Payment Required": 402,
    Forbidden: 403,
    "Not Found": 404,
    "Method Not Allowed": 405,
    "Not Acceptable": 406,
    "Proxy Authentication Required": 407,
    "Request Timeout": 408,
    Conflict: 409,
    Gone: 410,
    "Length Required": 411,
    "Precondition Failed": 412,
    "Payload Too Large": 413,
    "URI Too Long": 414,
    "Unsupported Media Type": 415,
    "Range Not Satisfiable": 416,
    "Expectation Failed": 417,
    "I'm a teapot": 418,
    "Misdirected Request": 421,
    "Unprocessable Content": 422,
    Locked: 423,
    "Failed Dependency": 424,
    "Too Early": 425,
    "Upgrade Required": 426,
    "Precondition Required": 428,
    "Too Many Requests": 429,
    "Request Header Fields Too Large": 431,
    "Unavailable For Legal Reasons": 451,
    "Internal Server Error": 500,
    "Not Implemented": 501,
    "Bad Gateway": 502,
    "Service Unavailable": 503,
    "Gateway Timeout": 504,
    "HTTP Version Not Supported": 505,
    "Variant Also Negotiates": 506,
    "Insufficient Storage": 507,
    "Loop Detected": 508,
    "Not Extended": 510,
    "Network Authentication Required": 511
  };
  var signCookie = async (val, secret) => {
    if (typeof val !== "string")
      throw new TypeError("Cookie value must be provided as a string.");
    if (secret === null)
      throw new TypeError("Secret key must be provided.");
    const encoder = new TextEncoder;
    const secretKey = await crypto.subtle.importKey("raw", encoder.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    const hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder.encode(val));
    const hmacArray = Array.from(new Uint8Array(hmacBuffer));
    const digest = btoa(String.fromCharCode(...hmacArray));
    return `${val}.${digest.replace(/=+$/, "")}`;
  };
  exports.signCookie = signCookie;
  var unsignCookie = async (input, secret) => {
    if (typeof input !== "string")
      throw new TypeError("Signed cookie string must be provided.");
    if (secret === null)
      throw new TypeError("Secret key must be provided.");
    const tentativeValue = input.slice(0, input.lastIndexOf("."));
    const expectedInput = await (0, exports.signCookie)(tentativeValue, secret);
    return expectedInput === input ? tentativeValue : false;
  };
  exports.unsignCookie = unsignCookie;
});

// node_modules/elysia/dist/cjs/cookie.js
var require_cookie2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseCookie = exports.createCookieJar = exports.Cookie = undefined;
  var cookie_1 = require_cookie();
  var utils_1 = require_utils();
  var error_1 = require_error();

  class Cookie {
    constructor(_value, property = {}) {
      this._value = _value;
      this.property = property;
    }
    get() {
      return this._value;
    }
    get value() {
      return this._value;
    }
    set value(value) {
      if (typeof value === "object") {
        if (JSON.stringify(this.value) === JSON.stringify(value))
          return;
      } else if (this.value === value)
        return;
      this._value = value;
      this.sync();
    }
    add(config) {
      const updated = Object.assign(this.property, typeof config === "function" ? config(Object.assign(this.property, this.value)) : config);
      if ("value" in updated) {
        this._value = updated.value;
        delete updated.value;
      }
      this.property = updated;
      return this.sync();
    }
    set(config) {
      const updated = typeof config === "function" ? config(Object.assign(this.property, this.value)) : config;
      if ("value" in updated) {
        this._value = updated.value;
        delete updated.value;
      }
      this.property = updated;
      return this.sync();
    }
    remove(options) {
      if (this.value === undefined)
        return;
      this.set({
        domain: options?.domain,
        expires: new Date(0),
        maxAge: 0,
        path: options?.path,
        sameSite: options?.sameSite,
        secure: options?.secure,
        value: ""
      });
    }
    get domain() {
      return this.property.domain;
    }
    set domain(value) {
      if (this.property.domain === value)
        return;
      this.property.domain = value;
      this.sync();
    }
    get expires() {
      return this.property.expires;
    }
    set expires(value) {
      if (this.property.expires?.getTime() === value?.getTime())
        return;
      this.property.expires = value;
      this.sync();
    }
    get httpOnly() {
      return this.property.httpOnly;
    }
    set httpOnly(value) {
      if (this.property.domain === value)
        return;
      this.property.httpOnly = value;
      this.sync();
    }
    get maxAge() {
      return this.property.maxAge;
    }
    set maxAge(value) {
      if (this.property.maxAge === value)
        return;
      this.property.maxAge = value;
      this.sync();
    }
    get path() {
      return this.property.path;
    }
    set path(value) {
      if (this.property.path === value)
        return;
      this.property.path = value;
      this.sync();
    }
    get priority() {
      return this.property.priority;
    }
    set priority(value) {
      if (this.property.priority === value)
        return;
      this.property.priority = value;
      this.sync();
    }
    get sameSite() {
      return this.property.sameSite;
    }
    set sameSite(value) {
      if (this.property.sameSite === value)
        return;
      this.property.sameSite = value;
      this.sync();
    }
    get secure() {
      return this.property.secure;
    }
    set secure(value) {
      if (this.property.secure === value)
        return;
      this.property.secure = value;
      this.sync();
    }
    toString() {
      return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
    }
    sync() {
      if (!this.name || !this.setter)
        return this;
      if (!this.setter.cookie)
        this.setter.cookie = {
          [this.name]: Object.assign(this.property, {
            value: this.toString()
          })
        };
      else
        this.setter.cookie[this.name] = Object.assign(this.property, {
          value: this.toString()
        });
      return this;
    }
  }
  exports.Cookie = Cookie;
  var createCookieJar = (initial, set, properties) => new Proxy(initial, {
    get(target, key) {
      if (key in target)
        return target[key];
      const cookie = new Cookie(undefined, properties ? { ...properties } : undefined);
      cookie.setter = set;
      cookie.name = key;
      return cookie;
    },
    set(target, key, value) {
      if (!(value instanceof Cookie))
        return false;
      if (!set.cookie)
        set.cookie = {};
      value.setter = set;
      value.name = key;
      value.sync();
      target[key] = value;
      return true;
    }
  });
  exports.createCookieJar = createCookieJar;
  var parseCookie = async (set, cookieString, { secret, sign, ...properties } = {}) => {
    if (!cookieString)
      return (0, exports.createCookieJar)({}, set, properties);
    const jar = {};
    const isStringKey = typeof secret === "string";
    if (sign && sign !== true && !Array.isArray(sign))
      sign = [sign];
    const cookieKeys = Object.keys((0, cookie_1.parse)(cookieString));
    for (let i = 0;i < cookieKeys.length; i++) {
      const key = cookieKeys[i];
      let value = (0, cookie_1.parse)(cookieString)[key];
      if (sign === true || sign?.includes(key)) {
        if (!secret)
          throw new Error("No secret is provided to cookie plugin");
        if (isStringKey) {
          value = await (0, utils_1.unsignCookie)(value, secret);
          if (value === false)
            throw new error_1.InvalidCookieSignature(key);
        } else {
          let fail = true;
          for (let i2 = 0;i2 < secret.length; i2++) {
            const temp = await (0, utils_1.unsignCookie)(value, secret[i2]);
            if (temp !== false) {
              value = temp;
              fail = false;
              break;
            }
          }
          if (fail)
            throw new error_1.InvalidCookieSignature(key);
        }
      }
      if (value === undefined)
        continue;
      const start = value.charCodeAt(0);
      if (start === 123 || start === 91)
        try {
          const cookie2 = new Cookie(JSON.parse(value));
          cookie2.setter = set;
          cookie2.name = key;
          jar[key] = cookie2;
          continue;
        } catch {
        }
      if (!Number.isNaN(+value))
        value = +value;
      else if (value === "true")
        value = true;
      else if (value === "false")
        value = false;
      const cookie = new Cookie(value, properties);
      cookie.setter = set;
      cookie.name = key;
      jar[key] = cookie;
    }
    return (0, exports.createCookieJar)(jar, set);
  };
  exports.parseCookie = parseCookie;
});

// node_modules/elysia/dist/cjs/handler.js
var require_handler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.errorToResponse = exports.mapCompactResponse = exports.mapEarlyResponse = exports.mapResponse = exports.cookieToHeader = exports.parseSetCookies = exports.isNotEmpty = undefined;
  var cookie_1 = require_cookie();
  var utils_1 = require_utils();
  var cookie_2 = require_cookie2();
  var hasHeaderShorthand = "toJSON" in new Headers;
  var isNotEmpty = (obj) => {
    for (const x in obj)
      return true;
    return false;
  };
  exports.isNotEmpty = isNotEmpty;
  var parseSetCookies = (headers, setCookie) => {
    if (!headers || !Array.isArray(setCookie))
      return headers;
    headers.delete("Set-Cookie");
    for (let i = 0;i < setCookie.length; i++) {
      const index = setCookie[i].indexOf("=");
      headers.append("Set-Cookie", `${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1)}`);
    }
    return headers;
  };
  exports.parseSetCookies = parseSetCookies;
  var cookieToHeader = (cookies) => {
    if (!cookies || typeof cookies !== "object" || !(0, exports.isNotEmpty)(cookies))
      return;
    const set = [];
    for (const [key, property] of Object.entries(cookies)) {
      if (!key || !property)
        continue;
      if (Array.isArray(property.value)) {
        for (let i = 0;i < property.value.length; i++) {
          let value = property.value[i];
          if (value === undefined || value === null)
            continue;
          if (typeof value === "object")
            value = JSON.stringify(value);
          set.push((0, cookie_1.serialize)(key, value, property));
        }
      } else {
        let value = property.value;
        if (value === undefined || value === null)
          continue;
        if (typeof value === "object")
          value = JSON.stringify(value);
        set.push((0, cookie_1.serialize)(key, property.value, property));
      }
    }
    if (set.length === 0)
      return;
    if (set.length === 1)
      return set[0];
    return set;
  };
  exports.cookieToHeader = cookieToHeader;
  var mapResponse = (response, set) => {
    if (response?.$passthrough)
      response = response[response.$passthrough];
    if ((0, exports.isNotEmpty)(set.headers) || set.status !== 200 || set.redirect || set.cookie) {
      if (typeof set.status === "string")
        set.status = utils_1.StatusMap[set.status];
      if (set.redirect) {
        set.headers.Location = set.redirect;
        if (!set.status || set.status < 300 || set.status >= 400)
          set.status = 302;
      }
      if (set.cookie && (0, exports.isNotEmpty)(set.cookie))
        set.headers["Set-Cookie"] = (0, exports.cookieToHeader)(set.cookie);
      if (set.headers["Set-Cookie"] && Array.isArray(set.headers["Set-Cookie"]))
        set.headers = (0, exports.parseSetCookies)(new Headers(set.headers), set.headers["Set-Cookie"]);
      switch (response?.constructor?.name) {
        case "String":
        case "Blob":
          return new Response(response, {
            status: set.status,
            headers: set.headers
          });
        case "Object":
        case "Array":
          return Response.json(response, set);
        case "ReadableStream":
          if (!set.headers["content-type"]?.startsWith("text/event-stream"))
            set.headers["content-type"] = "text/event-stream; charset=utf-8";
          return new Response(response, set);
        case undefined:
          if (!response)
            return new Response("", set);
          return Response.json(response, set);
        case "Response":
          const inherits = { ...set.headers };
          if (hasHeaderShorthand)
            set.headers = response.headers.toJSON();
          else
            for (const [key, value] of response.headers.entries())
              if (key in set.headers)
                set.headers[key] = value;
          for (const key in inherits)
            response.headers.append(key, inherits[key]);
          return response;
        case "Error":
          return (0, exports.errorToResponse)(response, set);
        case "Promise":
          return response.then((x) => (0, exports.mapResponse)(x, set));
        case "Function":
          return (0, exports.mapResponse)(response(), set);
        case "Number":
        case "Boolean":
          return new Response(response.toString(), set);
        case "Cookie":
          if (response instanceof cookie_2.Cookie)
            return new Response(response.value, set);
          return new Response(response?.toString(), set);
        default:
          const r = JSON.stringify(response);
          if (r.charCodeAt(0) === 123) {
            if (!set.headers["Content-Type"])
              set.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set);
          }
          return new Response(r, set);
      }
    } else
      switch (response?.constructor?.name) {
        case "String":
        case "Blob":
          return new Response(response);
        case "Object":
        case "Array":
          return new Response(JSON.stringify(response), {
            headers: {
              "content-type": "application/json"
            }
          });
        case "ReadableStream":
          return new Response(response, {
            headers: {
              "Content-Type": "text/event-stream; charset=utf-8"
            }
          });
        case undefined:
          if (!response)
            return new Response("");
          return new Response(JSON.stringify(response), {
            headers: {
              "content-type": "application/json"
            }
          });
        case "Response":
          return response;
        case "Error":
          return (0, exports.errorToResponse)(response, set);
        case "Promise":
          return response.then((x) => {
            const r2 = (0, exports.mapCompactResponse)(x);
            if (r2 !== undefined)
              return r2;
            return new Response("");
          });
        case "Function":
          return (0, exports.mapCompactResponse)(response());
        case "Number":
        case "Boolean":
          return new Response(response.toString());
        case "Cookie":
          if (response instanceof cookie_2.Cookie)
            return new Response(response.value, set);
          return new Response(response?.toString(), set);
        default:
          const r = JSON.stringify(response);
          if (r.charCodeAt(0) === 123)
            return new Response(JSON.stringify(response), {
              headers: {
                "Content-Type": "application/json"
              }
            });
          return new Response(r);
      }
  };
  exports.mapResponse = mapResponse;
  var mapEarlyResponse = (response, set) => {
    if (response === undefined || response === null)
      return;
    if (response?.$passthrough)
      response = response[response.$passthrough];
    if ((0, exports.isNotEmpty)(set.headers) || set.status !== 200 || set.redirect || set.cookie) {
      if (typeof set.status === "string")
        set.status = utils_1.StatusMap[set.status];
      if (set.redirect) {
        set.headers.Location = set.redirect;
        if (!set.status || set.status < 300 || set.status >= 400)
          set.status = 302;
      }
      if (set.cookie && (0, exports.isNotEmpty)(set.cookie))
        set.headers["Set-Cookie"] = (0, exports.cookieToHeader)(set.cookie);
      if (set.headers["Set-Cookie"] && Array.isArray(set.headers["Set-Cookie"]))
        set.headers = (0, exports.parseSetCookies)(new Headers(set.headers), set.headers["Set-Cookie"]);
      switch (response?.constructor?.name) {
        case "String":
        case "Blob":
          return new Response(response, set);
        case "Object":
        case "Array":
          return Response.json(response, set);
        case "ReadableStream":
          if (!set.headers["content-type"]?.startsWith("text/event-stream"))
            set.headers["content-type"] = "text/event-stream; charset=utf-8";
          return new Response(response, set);
        case undefined:
          if (!response)
            return;
          return Response.json(response, set);
        case "Response":
          const inherits = Object.assign({}, set.headers);
          if (hasHeaderShorthand)
            set.headers = response.headers.toJSON();
          else
            for (const [key, value] of response.headers.entries())
              if (!(key in set.headers))
                set.headers[key] = value;
          for (const key in inherits)
            response.headers.append(key, inherits[key]);
          if (response.status !== set.status)
            set.status = response.status;
          return response;
        case "Promise":
          return response.then((x) => {
            const r2 = (0, exports.mapEarlyResponse)(x, set);
            if (r2 !== undefined)
              return r2;
            return;
          });
        case "Error":
          return (0, exports.errorToResponse)(response, set);
        case "Function":
          return (0, exports.mapEarlyResponse)(response(), set);
        case "Number":
        case "Boolean":
          return new Response(response.toString(), set);
        case "Cookie":
          if (response instanceof cookie_2.Cookie)
            return new Response(response.value, set);
          return new Response(response?.toString(), set);
        default:
          const r = JSON.stringify(response);
          if (r.charCodeAt(0) === 123) {
            if (!set.headers["Content-Type"])
              set.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set);
          }
          return new Response(r, set);
      }
    } else
      switch (response?.constructor?.name) {
        case "String":
        case "Blob":
          return new Response(response);
        case "Object":
        case "Array":
          return new Response(JSON.stringify(response), {
            headers: {
              "content-type": "application/json"
            }
          });
        case "ReadableStream":
          return new Response(response, {
            headers: {
              "Content-Type": "text/event-stream; charset=utf-8"
            }
          });
        case undefined:
          if (!response)
            return new Response("");
          return new Response(JSON.stringify(response), {
            headers: {
              "content-type": "application/json"
            }
          });
        case "Response":
          return response;
        case "Promise":
          return response.then((x) => {
            const r2 = (0, exports.mapEarlyResponse)(x, set);
            if (r2 !== undefined)
              return r2;
            return;
          });
        case "Error":
          return (0, exports.errorToResponse)(response, set);
        case "Function":
          return (0, exports.mapCompactResponse)(response());
        case "Number":
        case "Boolean":
          return new Response(response.toString());
        case "Cookie":
          if (response instanceof cookie_2.Cookie)
            return new Response(response.value, set);
          return new Response(response?.toString(), set);
        default:
          const r = JSON.stringify(response);
          if (r.charCodeAt(0) === 123)
            return new Response(JSON.stringify(response), {
              headers: {
                "Content-Type": "application/json"
              }
            });
          return new Response(r);
      }
  };
  exports.mapEarlyResponse = mapEarlyResponse;
  var mapCompactResponse = (response) => {
    if (response?.$passthrough)
      response = response[response.$passthrough];
    switch (response?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response(response);
      case "Object":
      case "Array":
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "ReadableStream":
        return new Response(response, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8"
          }
        });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "Response":
        return response;
      case "Error":
        return (0, exports.errorToResponse)(response);
      case "Promise":
        return response.then((x) => {
          const r2 = (0, exports.mapCompactResponse)(x);
          if (r2 !== undefined)
            return r2;
          return new Response("");
        });
      case "Function":
        return (0, exports.mapCompactResponse)(response());
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      default:
        const r = JSON.stringify(response);
        if (r.charCodeAt(0) === 123)
          return new Response(JSON.stringify(response), {
            headers: {
              "Content-Type": "application/json"
            }
          });
        return new Response(r);
    }
  };
  exports.mapCompactResponse = mapCompactResponse;
  var errorToResponse = (error, set) => new Response(JSON.stringify({
    name: error?.name,
    message: error?.message,
    cause: error?.cause
  }), {
    status: set?.status !== 200 ? set?.status ?? 500 : 500,
    headers: set?.headers
  });
  exports.errorToResponse = errorToResponse;
});

// node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS((exports, module) => {
  function decodeURIComponent2(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1)
      return uri;
    var length = uri.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri[percentPosition + 1], 4);
      var low = hexCodeToInt(uri[percentPosition + 2], 0);
      var byte = high | low;
      var type = UTF8_DATA[byte];
      state = UTF8_DATA[256 + state + type];
      codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type];
      if (state === UTF8_ACCEPT) {
        decoded += uri.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        codepoint = 0;
        last = percentPosition + 3;
        percentPosition = startOfOctets = uri.indexOf("%", last);
      } else if (state === UTF8_REJECT) {
        return null;
      } else {
        percentPosition += 3;
        if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri.slice(last);
  }
  function hexCodeToInt(c, shift) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift;
  }
  var UTF8_ACCEPT = 12;
  var UTF8_REJECT = 0;
  var UTF8_DATA = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  module.exports = decodeURIComponent2;
});

// node_modules/fast-querystring/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  function parse(input) {
    const result = new Empty;
    if (typeof input !== "string") {
      return result;
    }
    let inputLength = input.length;
    let key = "";
    let value = "";
    let startingIndex = -1;
    let equalityIndex = -1;
    let shouldDecodeKey = false;
    let shouldDecodeValue = false;
    let keyHasPlus = false;
    let valueHasPlus = false;
    let hasBothKeyValuePair = false;
    let c = 0;
    for (let i = 0;i < inputLength + 1; i++) {
      c = i !== inputLength ? input.charCodeAt(i) : 38;
      if (c === 38) {
        hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair) {
          equalityIndex = i;
        }
        key = input.slice(startingIndex + 1, equalityIndex);
        if (hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus) {
            key = key.replace(plusRegex, " ");
          }
          if (shouldDecodeKey) {
            key = fastDecode(key) || key;
          }
          if (hasBothKeyValuePair) {
            value = input.slice(equalityIndex + 1, i);
            if (valueHasPlus) {
              value = value.replace(plusRegex, " ");
            }
            if (shouldDecodeValue) {
              value = fastDecode(value) || value;
            }
          }
          const currentValue = result[key];
          if (currentValue === undefined) {
            result[key] = value;
          } else {
            if (currentValue.pop) {
              currentValue.push(value);
            } else {
              result[key] = [currentValue, value];
            }
          }
        }
        value = "";
        startingIndex = i;
        equalityIndex = i;
        shouldDecodeKey = false;
        shouldDecodeValue = false;
        keyHasPlus = false;
        valueHasPlus = false;
      } else if (c === 61) {
        if (equalityIndex <= startingIndex) {
          equalityIndex = i;
        } else {
          shouldDecodeValue = true;
        }
      } else if (c === 43) {
        if (equalityIndex > startingIndex) {
          valueHasPlus = true;
        } else {
          keyHasPlus = true;
        }
      } else if (c === 37) {
        if (equalityIndex > startingIndex) {
          shouldDecodeValue = true;
        } else {
          shouldDecodeKey = true;
        }
      }
    }
    return result;
  }
  var fastDecode = require_fast_decode_uri_component();
  var plusRegex = /\+/g;
  var Empty = function() {
  };
  Empty.prototype = Object.create(null);
  module.exports = parse;
});

// node_modules/fast-querystring/lib/internals/querystring.js
var require_querystring = __commonJS((exports, module) => {
  function encodeString(str) {
    const len = str.length;
    if (len === 0)
      return "";
    let out = "";
    let lastPos = 0;
    let i = 0;
    outer:
      for (;i < len; i++) {
        let c = str.charCodeAt(i);
        while (c < 128) {
          if (noEscape[c] !== 1) {
            if (lastPos < i)
              out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c];
          }
          if (++i === len)
            break outer;
          c = str.charCodeAt(i);
        }
        if (lastPos < i)
          out += str.slice(lastPos, i);
        if (c < 2048) {
          lastPos = i + 1;
          out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          lastPos = i + 1;
          out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new Error("URI malformed");
        }
        const c2 = str.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c = 65536 + ((c & 1023) << 10 | c2);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
    if (lastPos === 0)
      return str;
    if (lastPos < len)
      return out + str.slice(lastPos);
    return out;
  }
  var hexTable = Array.from({ length: 256 }, (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  var noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  module.exports = { encodeString };
});

// node_modules/fast-querystring/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  function getAsPrimitive(value) {
    const type = typeof value;
    if (type === "string") {
      return encodeString(value);
    } else if (type === "bigint") {
      return value.toString();
    } else if (type === "boolean") {
      return value ? "true" : "false";
    } else if (type === "number" && Number.isFinite(value)) {
      return value < 1000000000000000000000 ? "" + value : encodeString("" + value);
    }
    return "";
  }
  function stringify(input) {
    let result = "";
    if (input === null || typeof input !== "object") {
      return result;
    }
    const separator = "&";
    const keys = Object.keys(input);
    const keyLength = keys.length;
    let valueLength = 0;
    for (let i = 0;i < keyLength; i++) {
      const key = keys[i];
      const value = input[key];
      const encodedKey = encodeString(key) + "=";
      if (i) {
        result += separator;
      }
      if (Array.isArray(value)) {
        valueLength = value.length;
        for (let j = 0;j < valueLength; j++) {
          if (j) {
            result += separator;
          }
          result += encodedKey;
          result += getAsPrimitive(value[j]);
        }
      } else {
        result += encodedKey;
        result += getAsPrimitive(value);
      }
    }
    return result;
  }
  var { encodeString } = require_querystring();
  module.exports = stringify;
});

// node_modules/fast-querystring/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var parse = require_parse();
  var stringify = require_stringify();
  var fastQuerystring = {
    parse,
    stringify
  };
  module.exports = fastQuerystring;
  module.exports.default = fastQuerystring;
  module.exports.parse = parse;
  module.exports.stringify = stringify;
});

// node_modules/elysia/dist/cjs/compose.js
var require_compose = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.composeErrorHandler = exports.composeGeneralHandler = exports.composeHandler = exports.isAsync = exports.hasTransform = exports.hasType = exports.isFnUse = exports.hasReturn = undefined;
  var fast_querystring_1 = require_lib();
  var utils_1 = require_utils();
  var handler_1 = require_handler();
  var error_1 = require_error();
  var cookie_1 = require_cookie2();
  var headersHasToJSON = new Headers().toJSON;
  var findAliases = new RegExp(` (\\w+) = context`, "g");
  var requestId = { value: 0 };
  var createReport = ({ hasTrace, hasTraceSet = false, addFn, condition = {} }) => {
    addFn(`\nconst reporter = getReporter()\n`);
    if (hasTrace) {
      return (event, { name, attribute = "", unit = 0 } = {}) => {
        const dotIndex = event.indexOf(".");
        const isGroup = dotIndex === -1;
        if (event !== "request" && event !== "response" && !condition[isGroup ? event : event.slice(0, dotIndex)])
          return () => {
            if (hasTraceSet && event === "afterHandle") {
              addFn(`reporter.emit('event',{id,event:'exit',type:'begin',time:0})`);
              addFn(`\nawait traceDone\n`);
            }
          };
        if (isGroup)
          name ||= event;
        else
          name ||= "anonymous";
        addFn("\n" + `reporter.emit('event', { 
					id,
					event: '${event}',
					type: 'begin',
					name: '${name}',
					time: performance.now(),
					${isGroup ? `unit: ${unit},` : ""}
					${attribute}
				})`.replace(/(\t| |\n)/g, "") + "\n");
        let handled = false;
        return () => {
          if (handled)
            return;
          handled = true;
          addFn("\n" + `reporter.emit('event', {
							id,
							event: '${event}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n");
          if (hasTraceSet && event === "afterHandle") {
            addFn(`\nreporter.emit('event',{id,event:'exit',type:'begin',time:0})\n`);
            addFn("\nawait traceDone\n");
          }
        };
      };
    } else {
      return () => () => {
      };
    }
  };
  var hasReturn = (fnLiteral) => {
    const parenthesisEnd = fnLiteral.indexOf(")");
    if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123) {
      return true;
    }
    return fnLiteral.includes("return");
  };
  exports.hasReturn = hasReturn;
  var composeValidationFactory = (hasErrorHandler, { injectResponse = "" } = {}) => ({
    composeValidation: (type, value = `c.${type}`) => hasErrorHandler ? `c.set.status = 400; throw new ValidationError(
'${type}',
${type},
${value}
)` : `c.set.status = 400; return new ValidationError(
	'${type}',
	${type},
	${value}
).toResponse(c.set.headers)`,
    composeResponseValidation: (name = "r") => {
      const returnError = hasErrorHandler ? `throw new ValidationError(
'response',
response[c.set.status],
${name}
)` : `return new ValidationError(
'response',
response[c.set.status],
${name}
).toResponse(c.set.headers)`;
      return `\n${injectResponse}
		if(response[c.set.status]?.Check(${name}) === false) { 
	if(!(response instanceof Error))
		${returnError}
}\n`;
    }
  });
  var isFnUse = (keyword, fnLiteral) => {
    fnLiteral = fnLiteral.trimStart();
    fnLiteral = fnLiteral.replaceAll(/^async /g, "");
    if (/^(\w+)\(/g.test(fnLiteral))
      fnLiteral = fnLiteral.slice(fnLiteral.indexOf("("));
    const argument = fnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith("function") ? fnLiteral.slice(fnLiteral.indexOf("(") + 1, fnLiteral.indexOf(")")) : fnLiteral.slice(0, fnLiteral.indexOf("=") - 1);
    if (argument === "")
      return false;
    const restIndex = argument.charCodeAt(0) === 123 ? argument.indexOf("...") : -1;
    if (argument.charCodeAt(0) === 123) {
      if (argument.includes(keyword))
        return true;
      if (restIndex === -1)
        return false;
    }
    if (fnLiteral.match(new RegExp(`${argument}(.${keyword}|\\["${keyword}"\\])`))) {
      return true;
    }
    const restAlias = restIndex !== -1 ? argument.slice(restIndex + 3, argument.indexOf(" ", restIndex + 3)) : undefined;
    if (fnLiteral.match(new RegExp(`${restAlias}(.${keyword}|\\["${keyword}"\\])`)))
      return true;
    const aliases = [argument];
    if (restAlias)
      aliases.push(restAlias);
    for (const found of fnLiteral.matchAll(findAliases))
      aliases.push(found[1]);
    const destructuringRegex = new RegExp(`{.*?} = (${aliases.join("|")})`, "g");
    for (const [params] of fnLiteral.matchAll(destructuringRegex))
      if (params.includes(`{ ${keyword}`) || params.includes(`, ${keyword}`))
        return true;
    return false;
  };
  exports.isFnUse = isFnUse;
  var isContextPassToFunction = (fnLiteral) => {
    fnLiteral = fnLiteral.trimStart();
    fnLiteral = fnLiteral.replaceAll(/^async /g, "");
    if (/^(\w+)\(/g.test(fnLiteral))
      fnLiteral = fnLiteral.slice(fnLiteral.indexOf("("));
    const argument = fnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith("function") ? fnLiteral.slice(fnLiteral.indexOf("(") + 1, fnLiteral.indexOf(")")) : fnLiteral.slice(0, fnLiteral.indexOf("=") - 1);
    if (argument === "")
      return false;
    const restIndex = argument.charCodeAt(0) === 123 ? argument.indexOf("...") : -1;
    const restAlias = restIndex !== -1 ? argument.slice(restIndex + 3, argument.indexOf(" ", restIndex + 3)) : undefined;
    const aliases = [argument];
    if (restAlias)
      aliases.push(restAlias);
    for (const found of fnLiteral.matchAll(findAliases))
      aliases.push(found[1]);
    for (const alias of aliases)
      if (new RegExp(`\\b\\w+\\([^)]*\\b${alias}\\b[^)]*\\)`).test(fnLiteral))
        return true;
    const destructuringRegex = new RegExp(`{.*?} = (${aliases.join("|")})`, "g");
    for (const [renamed] of fnLiteral.matchAll(destructuringRegex))
      if (new RegExp(`\\b\\w+\\([^)]*\\b${renamed}\\b[^)]*\\)`).test(fnLiteral))
        return true;
    return false;
  };
  var KindSymbol = Symbol.for("TypeBox.Kind");
  var hasType = (type, schema) => {
    if (!schema)
      return;
    if (KindSymbol in schema && schema[KindSymbol] === type)
      return true;
    if (schema.type === "object") {
      const properties = schema.properties;
      for (const key of Object.keys(properties)) {
        const property = properties[key];
        if (property.type === "object") {
          if ((0, exports.hasType)(type, property))
            return true;
        } else if (property.anyOf) {
          for (let i = 0;i < property.anyOf.length; i++)
            if ((0, exports.hasType)(type, property.anyOf[i]))
              return true;
        }
        if (KindSymbol in property && property[KindSymbol] === type)
          return true;
      }
      return false;
    }
    return schema.properties && KindSymbol in schema.properties && schema.properties[KindSymbol] === type;
  };
  exports.hasType = hasType;
  var TransformSymbol = Symbol.for("TypeBox.Transform");
  var hasTransform = (schema) => {
    if (!schema)
      return;
    if (schema.type === "object" && schema.properties) {
      const properties = schema.properties;
      for (const key of Object.keys(properties)) {
        const property = properties[key];
        if (property.type === "object") {
          if ((0, exports.hasTransform)(property))
            return true;
        } else if (property.anyOf) {
          for (let i = 0;i < property.anyOf.length; i++)
            if ((0, exports.hasTransform)(property.anyOf[i]))
              return true;
        }
        const hasTransformSymbol = TransformSymbol in property;
        if (hasTransformSymbol)
          return true;
      }
      return false;
    }
    return TransformSymbol in schema || schema.properties && TransformSymbol in schema.properties;
  };
  exports.hasTransform = hasTransform;
  var getUnionedType = (validator) => {
    if (!validator)
      return;
    const schema = validator?.schema;
    if (schema && "anyOf" in schema) {
      let foundDifference = false;
      const type = schema.anyOf[0].type;
      for (const validator2 of schema.anyOf) {
        if (validator2.type !== type) {
          foundDifference = true;
          break;
        }
      }
      if (!foundDifference)
        return type;
    }
    return validator.schema?.type;
  };
  var matchFnReturn = /(?:return|=>) \S*\(/g;
  var isAsync = (fn) => {
    if (fn.constructor.name === "AsyncFunction")
      return true;
    return fn.toString().match(matchFnReturn);
  };
  exports.isAsync = isAsync;
  var composeHandler = ({ path, method, hooks, validator, handler, handleError, definitions, schema, onRequest, config, getReporter }) => {
    const hasErrorHandler = config.forceErrorEncapsulation || hooks.error.length > 0 || typeof Bun === "undefined" || hooks.onResponse.length > 0 || !!hooks.trace.length;
    const handleResponse = hooks.onResponse.length ? `\n;(async () => {${hooks.onResponse.map((_, i) => `await res${i}(c)`).join(";")}})();\n` : "";
    const traceLiteral = hooks.trace.map((x) => x.toString());
    let hasUnknownContext = false;
    if (isContextPassToFunction(handler.toString()))
      hasUnknownContext = true;
    if (!hasUnknownContext)
      for (const [key, value] of Object.entries(hooks)) {
        if (!Array.isArray(value) || !value.length || ![
          "parse",
          "transform",
          "beforeHandle",
          "afterHandle",
          "onResponse"
        ].includes(key))
          continue;
        for (const handle of value) {
          if (typeof handle !== "function")
            continue;
          if (isContextPassToFunction(handle.toString())) {
            hasUnknownContext = true;
            break;
          }
        }
        if (hasUnknownContext)
          break;
      }
    const traceConditions = {
      parse: traceLiteral.some((x) => (0, exports.isFnUse)("parse", x)),
      transform: traceLiteral.some((x) => (0, exports.isFnUse)("transform", x)),
      handle: traceLiteral.some((x) => (0, exports.isFnUse)("handle", x)),
      beforeHandle: traceLiteral.some((x) => (0, exports.isFnUse)("beforeHandle", x)),
      afterHandle: traceLiteral.some((x) => (0, exports.isFnUse)("afterHandle", x)),
      error: hasErrorHandler || traceLiteral.some((x) => (0, exports.isFnUse)("error", x))
    };
    const hasTrace = hooks.trace.length > 0;
    let fnLiteral = "";
    const lifeCycleLiteral = validator || method !== "GET" && method !== "HEAD" ? [
      handler,
      ...hooks.transform,
      ...hooks.beforeHandle,
      ...hooks.afterHandle
    ].map((x) => x.toString()) : [];
    const hasBody = method !== "GET" && method !== "HEAD" && (hasUnknownContext || hooks.type !== "none" && (!!validator.body || !!hooks.type || lifeCycleLiteral.some((fn) => (0, exports.isFnUse)("body", fn))));
    const hasHeaders = hasUnknownContext || validator.headers || lifeCycleLiteral.some((fn) => (0, exports.isFnUse)("headers", fn));
    const hasCookie = hasUnknownContext || validator.cookie || lifeCycleLiteral.some((fn) => (0, exports.isFnUse)("cookie", fn));
    const cookieMeta = validator?.cookie?.schema;
    let encodeCookie = "";
    if (cookieMeta?.sign) {
      if (!cookieMeta.secrets)
        throw new Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
      const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
      encodeCookie += `const _setCookie = c.set.cookie
		if(_setCookie) {`;
      if (cookieMeta.sign === true) {
        encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${secret}')
			}`;
      } else
        for (const name of cookieMeta.sign) {
          encodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }\n`;
        }
      encodeCookie += "}\n";
    }
    const { composeValidation, composeResponseValidation } = composeValidationFactory(hasErrorHandler);
    if (hasHeaders) {
      fnLiteral += headersHasToJSON ? `c.headers = c.request.headers.toJSON()\n` : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
    }
    if (hasCookie) {
      const get = (name, defaultValue) => {
        const value = cookieMeta?.[name] ?? defaultValue;
        if (!value)
          return typeof defaultValue === "string" ? `${name}: "${defaultValue}",` : `${name}: ${defaultValue},`;
        if (typeof value === "string")
          return `${name}: '${value}',`;
        if (value instanceof Date)
          return `${name}: new Date(${value.getTime()}),`;
        return `${name}: ${value},`;
      };
      const options = cookieMeta ? `{
			secret: ${cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},
			sign: ${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},
			${get("domain")}
			${get("expires")}
			${get("httpOnly")}
			${get("maxAge")}
			${get("path", "/")}
			${get("priority")}
			${get("sameSite")}
			${get("secure")}
		}` : "undefined";
      if (hasHeaders)
        fnLiteral += `\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${options})\n`;
      else
        fnLiteral += `\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})\n`;
    }
    const hasQuery = hasUnknownContext || validator.query || lifeCycleLiteral.some((fn) => (0, exports.isFnUse)("query", fn));
    if (hasQuery) {
      fnLiteral += `const url = c.request.url

		if(c.qi !== -1) {
			c.query ??= parseQuery(url.substring(c.qi + 1))
		} else {
			c.query ??= {}
		}
		`;
    }
    const traceLiterals = hooks.trace.map((x) => x.toString());
    const hasTraceSet = traceLiterals.some((fn) => (0, exports.isFnUse)("set", fn) || isContextPassToFunction(fn));
    hasUnknownContext || hooks.trace.some((fn) => (0, exports.isFnUse)("set", fn.toString()));
    const hasSet = hasTraceSet || hasCookie || lifeCycleLiteral.some((fn) => (0, exports.isFnUse)("set", fn)) || onRequest.some((fn) => (0, exports.isFnUse)("set", fn.toString()));
    if (hasTrace)
      fnLiteral += "\nconst id = c.$$requestId\n";
    const report = createReport({
      hasTrace,
      hasTraceSet,
      condition: traceConditions,
      addFn: (word) => {
        fnLiteral += word;
      }
    });
    fnLiteral += hasErrorHandler ? "try {\n" : "";
    if (hasTrace) {
      fnLiteral += `\nconst traceDone = Promise.all([`;
      for (let i = 0;i < hooks.trace.length; i++) {
        fnLiteral += `new Promise(r => { reporter.once(\`res\${id}.${i}\`, r) }),`;
      }
      fnLiteral += `])\n`;
    }
    const maybeAsync = hasCookie || hasBody || hasTraceSet || (0, exports.isAsync)(handler) || hooks.parse.length > 0 || hooks.afterHandle.some(exports.isAsync) || hooks.beforeHandle.some(exports.isAsync) || hooks.transform.some(exports.isAsync);
    const endParse = report("parse", {
      unit: hooks.parse.length
    });
    if (hasBody) {
      const type = getUnionedType(validator?.body);
      if (hooks.type && !Array.isArray(hooks.type)) {
        if (hooks.type) {
          switch (hooks.type) {
            case "json":
            case "application/json":
              fnLiteral += `c.body = await c.request.json()\n`;
              break;
            case "text":
            case "text/plain":
              fnLiteral += `c.body = await c.request.text()\n`;
              break;
            case "urlencoded":
            case "application/x-www-form-urlencoded":
              fnLiteral += `c.body = parseQuery(await c.request.text())\n`;
              break;
            case "arrayBuffer":
            case "application/octet-stream":
              fnLiteral += `c.body = await c.request.arrayBuffer()\n`;
              break;
            case "formdata":
            case "multipart/form-data":
              fnLiteral += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}\n`;
              break;
          }
        }
        if (hooks.parse.length)
          fnLiteral += "}}";
      } else {
        const getAotParser = () => {
          if (hooks.parse.length && type && !Array.isArray(hooks.type)) {
            const schema2 = validator?.body?.schema;
            switch (type) {
              case "object":
                if ((0, exports.hasType)("File", schema2) || (0, exports.hasType)("Files", schema2))
                  return `c.body = {}
		
								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue
			
									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
                break;
              default:
                break;
            }
          }
        };
        const aotParse = getAotParser();
        if (aotParse)
          fnLiteral += aotParse;
        else {
          fnLiteral += "\n";
          fnLiteral += hasHeaders ? `let contentType = c.headers['content-type']` : `let contentType = c.request.headers.get('content-type')`;
          fnLiteral += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n`;
          if (hooks.parse.length) {
            fnLiteral += `let used = false\n`;
            const endReport = report("parse", {
              unit: hooks.parse.length
            });
            for (let i = 0;i < hooks.parse.length; i++) {
              const endUnit = report("parse.unit", {
                name: hooks.parse[i].name
              });
              const name = `bo${i}`;
              if (i !== 0)
                fnLiteral += `if(!used) {\n`;
              fnLiteral += `let ${name} = parse[${i}](c, contentType)\n`;
              fnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}\n`;
              fnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }\n`;
              endUnit();
              if (i !== 0)
                fnLiteral += `}`;
            }
            endReport();
          }
          if (hooks.parse.length)
            fnLiteral += `if (!used)`;
          fnLiteral += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break
				
					case 'text/plain':
						c.body = await c.request.text()
						break
				
					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break
				
					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break
				
					case 'multipart/form-data':
						c.body = {}
				
						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue
				
							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
				
						break
					}\n`;
          fnLiteral += "}\n";
        }
      }
      fnLiteral += "\n";
    }
    endParse();
    if (hooks?.transform) {
      const endTransform = report("transform", {
        unit: hooks.transform.length
      });
      for (let i = 0;i < hooks.transform.length; i++) {
        const transform = hooks.transform[i];
        const endUnit = report("transform.unit", {
          name: transform.name
        });
        if (transform.$elysia === "derive")
          fnLiteral += (0, exports.isAsync)(hooks.transform[i]) ? `Object.assign(c, await transform[${i}](c));` : `Object.assign(c, transform[${i}](c));`;
        else
          fnLiteral += (0, exports.isAsync)(hooks.transform[i]) ? `await transform[${i}](c);` : `transform[${i}](c);`;
        endUnit();
      }
      endTransform();
    }
    if (validator) {
      fnLiteral += "\n";
      if (validator.headers) {
        fnLiteral += `if(headers.Check(c.headers) === false) {
				${composeValidation("headers")}
			}`;
        if ((0, exports.hasTransform)(validator.headers.schema))
          fnLiteral += `\nc.headers = headers.Decode(c.headers)\n`;
      }
      if (validator.params) {
        fnLiteral += `if(params.Check(c.params) === false) {
				${composeValidation("params")}
			}`;
        if ((0, exports.hasTransform)(validator.params.schema))
          fnLiteral += `\nc.params = params.Decode(c.params)\n`;
      }
      if (validator.query) {
        fnLiteral += `if(query.Check(c.query) === false) {
				${composeValidation("query")} 
			}`;
        if ((0, exports.hasTransform)(validator.query.schema))
          fnLiteral += `\nc.query = query.Decode(Object.assign({}, c.query))\n`;
      }
      if (validator.body) {
        fnLiteral += `if(body.Check(c.body) === false) { 
				${composeValidation("body")}
			}`;
        if ((0, exports.hasTransform)(validator.body.schema))
          fnLiteral += `\nc.body = body.Decode(c.body)\n`;
      }
      if ((0, handler_1.isNotEmpty)(validator.cookie?.schema.properties ?? {})) {
        fnLiteral += `const cookieValue = {}
			for(const [key, value] of Object.entries(c.cookie))
				cookieValue[key] = value.value

			if(cookie.Check(cookieValue) === false) {
				${composeValidation("cookie", "cookieValue")}
			}`;
        if ((0, exports.hasTransform)(validator.cookie.schema))
          fnLiteral += `\nc.cookie = params.Decode(c.cookie)\n`;
      }
    }
    if (hooks?.beforeHandle) {
      const endBeforeHandle = report("beforeHandle", {
        unit: hooks.beforeHandle.length
      });
      for (let i = 0;i < hooks.beforeHandle.length; i++) {
        const endUnit = report("beforeHandle.unit", {
          name: hooks.beforeHandle[i].name
        });
        const name = `be${i}`;
        const returning = (0, exports.hasReturn)(hooks.beforeHandle[i].toString());
        if (!returning) {
          fnLiteral += (0, exports.isAsync)(hooks.beforeHandle[i]) ? `await beforeHandle[${i}](c);\n` : `beforeHandle[${i}](c);\n`;
          endUnit();
        } else {
          fnLiteral += (0, exports.isAsync)(hooks.beforeHandle[i]) ? `let ${name} = await beforeHandle[${i}](c);\n` : `let ${name} = beforeHandle[${i}](c);\n`;
          endUnit();
          fnLiteral += `if(${name} !== undefined) {\n`;
          const endAfterHandle = report("afterHandle", {
            unit: hooks.transform.length
          });
          if (hooks.afterHandle) {
            const beName = name;
            for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
              const returning2 = (0, exports.hasReturn)(hooks.afterHandle[i2].toString());
              const endUnit2 = report("afterHandle.unit", {
                name: hooks.afterHandle[i2].name
              });
              fnLiteral += `c.response = ${beName}\n`;
              if (!returning2) {
                fnLiteral += (0, exports.isAsync)(hooks.afterHandle[i2]) ? `await afterHandle[${i2}](c, ${beName});\n` : `afterHandle[${i2}](c, ${beName});\n`;
              } else {
                const name2 = `af${i2}`;
                fnLiteral += (0, exports.isAsync)(hooks.afterHandle[i2]) ? `const ${name2} = await afterHandle[${i2}](c);\n` : `const ${name2} = afterHandle[${i2}](c);\n`;
                fnLiteral += `if(${name2} !== undefined) { c.response = ${beName} = ${name2} }\n`;
              }
              endUnit2();
            }
          }
          endAfterHandle();
          if (validator.response)
            fnLiteral += composeResponseValidation(name);
          fnLiteral += encodeCookie;
          fnLiteral += `return mapEarlyResponse(${name}, c.set)}\n`;
        }
      }
      endBeforeHandle();
    }
    if (hooks?.afterHandle.length) {
      const endHandle = report("handle", {
        name: handler.name
      });
      if (hooks.afterHandle.length)
        fnLiteral += (0, exports.isAsync)(handler) ? `let r = c.response = await handler(c);\n` : `let r = c.response = handler(c);\n`;
      else
        fnLiteral += (0, exports.isAsync)(handler) ? `let r = await handler(c);\n` : `let r = handler(c);\n`;
      endHandle();
      const endAfterHandle = report("afterHandle", {
        unit: hooks.afterHandle.length
      });
      for (let i = 0;i < hooks.afterHandle.length; i++) {
        const name = `af${i}`;
        const returning = (0, exports.hasReturn)(hooks.afterHandle[i].toString());
        const endUnit = report("afterHandle.unit", {
          name: hooks.afterHandle[i].name
        });
        if (!returning) {
          fnLiteral += (0, exports.isAsync)(hooks.afterHandle[i]) ? `await afterHandle[${i}](c)\n` : `afterHandle[${i}](c)\n`;
          endUnit();
        } else {
          if (validator.response)
            fnLiteral += (0, exports.isAsync)(hooks.afterHandle[i]) ? `let ${name} = await afterHandle[${i}](c)\n` : `let ${name} = afterHandle[${i}](c)\n`;
          else
            fnLiteral += (0, exports.isAsync)(hooks.afterHandle[i]) ? `let ${name} = mapEarlyResponse(await afterHandle[${i}](c), c.set)\n` : `let ${name} = mapEarlyResponse(afterHandle[${i}](c), c.set)\n`;
          endUnit();
          if (validator.response) {
            fnLiteral += `if(${name} !== undefined) {`;
            fnLiteral += composeResponseValidation(name);
            fnLiteral += `${name} = mapEarlyResponse(${name}, c.set)\n`;
            fnLiteral += `if(${name}) {`;
            endAfterHandle();
            if (hasTraceSet)
              fnLiteral += `${name} = mapEarlyResponse(${name}, c.set)\n`;
            fnLiteral += `return ${name} } }`;
          } else {
            fnLiteral += `if(${name}) {`;
            endAfterHandle();
            fnLiteral += `return ${name}}\n`;
          }
        }
      }
      endAfterHandle();
      fnLiteral += `r = c.response\n`;
      if (validator.response)
        fnLiteral += composeResponseValidation();
      fnLiteral += encodeCookie;
      if (hasSet)
        fnLiteral += `return mapResponse(r, c.set)\n`;
      else
        fnLiteral += `return mapCompactResponse(r)\n`;
    } else {
      const endHandle = report("handle", {
        name: handler.name
      });
      if (validator.response) {
        fnLiteral += (0, exports.isAsync)(handler) ? `const r = await handler(c);\n` : `const r = handler(c);\n`;
        endHandle();
        fnLiteral += composeResponseValidation();
        report("afterHandle")();
        fnLiteral += encodeCookie;
        if (hasSet)
          fnLiteral += `return mapResponse(r, c.set)\n`;
        else
          fnLiteral += `return mapCompactResponse(r)\n`;
      } else {
        if (traceConditions.handle || hasCookie) {
          fnLiteral += (0, exports.isAsync)(handler) ? `let r = await handler(c);\n` : `let r = handler(c);\n`;
          endHandle();
          report("afterHandle")();
          fnLiteral += encodeCookie;
          if (hasSet)
            fnLiteral += `return mapResponse(r, c.set)\n`;
          else
            fnLiteral += `return mapCompactResponse(r)\n`;
        } else {
          endHandle();
          const handled = (0, exports.isAsync)(handler) ? "await handler(c) " : "handler(c)";
          report("afterHandle")();
          if (hasSet)
            fnLiteral += `return mapResponse(${handled}, c.set)\n`;
          else
            fnLiteral += `return mapCompactResponse(${handled})\n`;
        }
      }
    }
    if (hasErrorHandler || handleResponse) {
      fnLiteral += `
} catch(error) {`;
      if (!maybeAsync)
        fnLiteral += `return (async () => {`;
      fnLiteral += `const set = c.set

		if (!set.status || set.status < 300) set.status = error?.status || 500
	`;
      const endError = report("error", {
        unit: hooks.error.length
      });
      if (hooks.error.length) {
        fnLiteral += `
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
			`;
        for (let i = 0;i < hooks.error.length; i++) {
          const name = `er${i}`;
          const endUnit = report("error.unit", {
            name: hooks.error[i].name
          });
          fnLiteral += `\nlet ${name} = handleErrors[${i}](c)\n`;
          if ((0, exports.isAsync)(hooks.error[i]))
            fnLiteral += `if (${name} instanceof Promise) ${name} = await ${name}\n`;
          endUnit();
          fnLiteral += `${name} = mapEarlyResponse(${name}, set)\n`;
          fnLiteral += `if (${name}) {`;
          fnLiteral += `return ${name} }\n`;
        }
      }
      endError();
      fnLiteral += `return handleError(c, error)\n\n`;
      if (!maybeAsync)
        fnLiteral += "})()";
      fnLiteral += "}";
      if (handleResponse || hasTrace) {
        fnLiteral += ` finally { `;
        const endResponse = report("response", {
          unit: hooks.onResponse.length
        });
        fnLiteral += handleResponse;
        endResponse();
        fnLiteral += `}`;
      }
    }
    fnLiteral = `const { 
		handler,
		handleError,
		hooks: {
			transform,
			beforeHandle,
			afterHandle,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie
	} = hooks

	${hooks.onResponse.length ? `const ${hooks.onResponse.map((x, i) => `res${i} = onResponse[${i}]`).join(",")}` : ""}

	return ${maybeAsync ? "async" : ""} function(c) {
		${schema && definitions ? "c.schema = schema; c.defs = definitions;" : ""}
		${fnLiteral}
	}`;
    const createHandler = Function("hooks", fnLiteral);
    return createHandler({
      handler,
      hooks,
      validator,
      handleError,
      utils: {
        mapResponse: handler_1.mapResponse,
        mapCompactResponse: handler_1.mapCompactResponse,
        mapEarlyResponse: handler_1.mapEarlyResponse,
        parseQuery: fast_querystring_1.parse
      },
      error: {
        NotFoundError: error_1.NotFoundError,
        ValidationError: error_1.ValidationError,
        InternalServerError: error_1.InternalServerError
      },
      schema,
      definitions,
      ERROR_CODE: error_1.ERROR_CODE,
      getReporter,
      requestId,
      parseCookie: cookie_1.parseCookie,
      signCookie: utils_1.signCookie
    });
  };
  exports.composeHandler = composeHandler;
  var composeGeneralHandler = (app) => {
    let decoratorsLiteral = "";
    let fnLiteral = "";
    for (const key of Object.keys(app.decorators))
      decoratorsLiteral += `,${key}: app.decorators.${key}`;
    const { router, staticRouter } = app;
    const hasTrace = app.event.trace.length > 0;
    const findDynamicRoute = `
	const route = find(request.method, path) ${router.root.ALL ? '?? find("ALL", path)' : ""}
	if (route === null)
		return ${app.event.error.length ? `app.handleError(ctx, notFound)` : `new Response(error404, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})`}

	ctx.params = route.params

	return route.store(ctx)`;
    let switchMap = ``;
    for (const [path, { code, all }] of Object.entries(staticRouter.map))
      switchMap += `case '${path}':\nswitch(request.method) {\n${code}\n${all ?? `default: break map`}}\n\n`;
    const maybeAsync = app.event.request.some(exports.isAsync);
    fnLiteral += `const {
		app,
		app: { store, router, staticRouter, wsRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter
	} = data

	const notFound = new NotFoundError()

	${app.event.request.length ? `const onRequest = app.event.request` : ""}

	${staticRouter.variables}

	const find = router.find.bind(router)
	const findWs = wsRouter.find.bind(wsRouter)
	const handleError = app.handleError.bind(this)

	${app.event.error.length ? "" : `const error404 = notFound.message.toString()`}

	return ${maybeAsync ? "async" : ""} function map(request) {
	`;
    const traceLiteral = app.event.trace.map((x) => x.toString());
    const report = createReport({
      hasTrace,
      hasTraceSet: app.event.trace.some((fn) => {
        const literal = fn.toString();
        return (0, exports.isFnUse)("set", literal) || isContextPassToFunction(literal);
      }),
      condition: {
        request: traceLiteral.some((x) => (0, exports.isFnUse)("request", x) || isContextPassToFunction(x))
      },
      addFn: (word) => {
        fnLiteral += word;
      }
    });
    if (app.event.request.length) {
      fnLiteral += `
			${hasTrace ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					cookie: {},
					headers: {},
					status: 200
				}
				${hasTrace ? ",$$requestId: +id" : ""}
				${decoratorsLiteral}
			}
		`;
      const endReport = report("request", {
        attribute: "ctx",
        unit: app.event.request.length
      });
      fnLiteral += `try {\n`;
      for (let i = 0;i < app.event.request.length; i++) {
        const fn = app.event.request[i];
        const withReturn = (0, exports.hasReturn)(fn.toString());
        const maybeAsync2 = (0, exports.isAsync)(fn);
        const endUnit = report("request.unit", {
          name: app.event.request[i].name
        });
        const name = `re${i}`;
        if (withReturn) {
          fnLiteral += `const ${name} = mapEarlyResponse(
					${maybeAsync2 ? "await" : ""} onRequest[${i}](ctx),
					ctx.set
				)\n`;
          endUnit();
          fnLiteral += `if(${name}) return ${name}\n`;
        } else {
          fnLiteral += `${maybeAsync2 ? "await" : ""} onRequest[${i}](ctx)\n`;
          endUnit();
        }
      }
      fnLiteral += `} catch (error) {
			return app.handleError(ctx, error)
		}`;
      endReport();
      fnLiteral += `
		const url = request.url,
		s = url.indexOf('/', 11),
		i = ctx.qi = url.indexOf('?', s + 1),
		path = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`;
    } else {
      fnLiteral += `
		const url = request.url,
			s = url.indexOf('/', 11),
			qi = url.indexOf('?', s + 1),
			path = qi === -1
				? url.substring(s)
				: url.substring(s, qi)

		${hasTrace ? "const id = +requestId.value++" : ""}

		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: {},
				status: 200
			}
			${hasTrace ? ",$$requestId: id" : ""}
			${decoratorsLiteral}
		}`;
      report("request", {
        unit: app.event.request.length,
        attribute: traceLiteral.some((x) => (0, exports.isFnUse)("context", x)) || traceLiteral.some((x) => (0, exports.isFnUse)("store", x)) || traceLiteral.some((x) => (0, exports.isFnUse)("set", x)) ? "ctx" : ""
      })();
    }
    const wsPaths = app.wsPaths;
    const wsRouter = app.wsRouter;
    if (Object.keys(wsPaths).length || wsRouter.history.length) {
      fnLiteral += `
			if(request.method === 'GET') {
				switch(path) {`;
      for (const [path, index] of Object.entries(wsPaths)) {
        fnLiteral += `
					case '${path}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${index}(ctx)
							
						break`;
      }
      fnLiteral += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = findWs('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}\n`;
    }
    fnLiteral += `
		map: switch(path) {
			${switchMap}

			default:
				break
		}

		${findDynamicRoute}
	}`;
    app.handleError = (0, exports.composeErrorHandler)(app);
    return Function("data", fnLiteral)({
      app,
      mapEarlyResponse: handler_1.mapEarlyResponse,
      NotFoundError: error_1.NotFoundError,
      getReporter: () => app.reporter,
      requestId
    });
  };
  exports.composeGeneralHandler = composeGeneralHandler;
  var composeErrorHandler = (app) => {
    let fnLiteral = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE
	} = inject

	return ${app.event.error.find(exports.isAsync) ? "async" : ""} function(context, error) {
		const { set } = context

		context.code = error.code
		context.error = error
		`;
    for (let i = 0;i < app.event.error.length; i++) {
      const handler = app.event.error[i];
      const response = `${(0, exports.isAsync)(handler) ? "await " : ""}onError[${i}](context)`;
      if ((0, exports.hasReturn)(handler.toString()))
        fnLiteral += `const r${i} = ${response}; if(r${i} !== undefined) {
				if(set.status === 200) set.status = error.status
				return mapResponse(r${i}, set)
			}\n`;
      else
        fnLiteral += response + "\n";
    }
    fnLiteral += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 400
		return new Response(
			error.message, 
			{ headers: set.headers, status: set.status }
		)
	} else {
		return new Response(error.message, { headers: set.headers, status: error.status ?? 500 })
	}
}`;
    return Function("inject", fnLiteral)({
      app,
      mapResponse: handler_1.mapResponse,
      ERROR_CODE: error_1.ERROR_CODE
    });
  };
  exports.composeErrorHandler = composeErrorHandler;
});

// node_modules/elysia/dist/cjs/dynamic-handle.js
var require_dynamic_handle = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDynamicErrorHandler = exports.createDynamicHandler = undefined;
  var handler_1 = require_handler();
  var error_1 = require_error();
  var fast_querystring_1 = require_lib();
  var utils_1 = require_utils();
  var cookie_1 = require_cookie2();
  var createDynamicHandler = (app) => async (request) => {
    const set = {
      cookie: {},
      status: 200,
      headers: {}
    };
    let context;
    if (app.decorators) {
      context = app.decorators;
      context.request = request;
      context.set = set;
      context.store = app.store;
    } else {
      context = {
        set,
        store: app.store,
        request
      };
    }
    const url = request.url, s = url.indexOf("/", 11), q = url.indexOf("?", s + 1), path = q === -1 ? url.substring(s) : url.substring(s, q);
    try {
      for (let i = 0;i < app.event.request.length; i++) {
        const onRequest = app.event.request[i];
        let response2 = onRequest(context);
        if (response2 instanceof Promise)
          response2 = await response2;
        response2 = (0, handler_1.mapEarlyResponse)(response2, set);
        if (response2)
          return response2;
      }
      const handler = app.dynamicRouter.find(request.method, path) ?? app.dynamicRouter.find("ALL", path);
      if (!handler)
        throw new error_1.NotFoundError;
      const { handle, hooks, validator, content } = handler.store;
      let body;
      if (request.method !== "GET" && request.method !== "HEAD") {
        if (content) {
          switch (content) {
            case "application/json":
              body = await request.json();
              break;
            case "text/plain":
              body = await request.text();
              break;
            case "application/x-www-form-urlencoded":
              body = (0, fast_querystring_1.parse)(await request.text());
              break;
            case "application/octet-stream":
              body = await request.arrayBuffer();
              break;
            case "multipart/form-data":
              body = {};
              const form = await request.formData();
              for (const key of form.keys()) {
                if (body[key])
                  continue;
                const value = form.getAll(key);
                if (value.length === 1)
                  body[key] = value[0];
                else
                  body[key] = value;
              }
              break;
          }
        } else {
          let contentType = request.headers.get("content-type");
          if (contentType) {
            const index = contentType.indexOf(";");
            if (index !== -1)
              contentType = contentType.slice(0, index);
            for (let i = 0;i < app.event.parse.length; i++) {
              let temp = app.event.parse[i](context, contentType);
              if (temp instanceof Promise)
                temp = await temp;
              if (temp) {
                body = temp;
                break;
              }
            }
            if (body === undefined) {
              switch (contentType) {
                case "application/json":
                  body = await request.json();
                  break;
                case "text/plain":
                  body = await request.text();
                  break;
                case "application/x-www-form-urlencoded":
                  body = (0, fast_querystring_1.parse)(await request.text());
                  break;
                case "application/octet-stream":
                  body = await request.arrayBuffer();
                  break;
                case "multipart/form-data":
                  body = {};
                  const form = await request.formData();
                  for (const key of form.keys()) {
                    if (body[key])
                      continue;
                    const value = form.getAll(key);
                    if (value.length === 1)
                      body[key] = value[0];
                    else
                      body[key] = value;
                  }
                  break;
              }
            }
          }
        }
      }
      context.body = body;
      context.params = handler?.params || undefined;
      context.query = q === -1 ? {} : (0, fast_querystring_1.parse)(url.substring(q + 1));
      context.headers = {};
      for (const [key, value] of request.headers.entries())
        context.headers[key] = value;
      const cookieMeta = validator?.cookie?.schema;
      context.cookie = await (0, cookie_1.parseCookie)(context.set, context.headers.cookie, cookieMeta ? {
        secret: cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets.join(",") : undefined,
        sign: cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? typeof cookieMeta.sign === "string" ? cookieMeta.sign : cookieMeta.sign.join(",") : undefined
      } : undefined);
      for (let i = 0;i < hooks.transform.length; i++) {
        const operation = hooks.transform[i](context);
        if (hooks.transform[i].$elysia === "derive") {
          if (operation instanceof Promise)
            Object.assign(context, await operation);
          else
            Object.assign(context, operation);
        } else if (operation instanceof Promise)
          await operation;
      }
      if (validator) {
        if (validator.headers) {
          const _header = {};
          for (const key in request.headers)
            _header[key] = request.headers.get(key);
          if (validator.headers.Check(_header) === false)
            throw new error_1.ValidationError("header", validator.headers, _header);
        }
        if (validator.params?.Check(context.params) === false)
          throw new error_1.ValidationError("params", validator.params, context.params);
        if (validator.query?.Check(context.query) === false)
          throw new error_1.ValidationError("query", validator.query, context.query);
        if (validator.cookie) {
          const cookieValue = {};
          for (const [key, value] of Object.entries(context.cookie))
            cookieValue[key] = value.value;
          if (validator.cookie?.Check(cookieValue) === false)
            throw new error_1.ValidationError("cookie", validator.cookie, cookieValue);
        }
        if (validator.body?.Check(body) === false)
          throw new error_1.ValidationError("body", validator.body, body);
      }
      for (let i = 0;i < hooks.beforeHandle.length; i++) {
        let response2 = hooks.beforeHandle[i](context);
        if (response2 instanceof Promise)
          response2 = await response2;
        if (response2 !== undefined) {
          context.response = response2;
          for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
            let newResponse = hooks.afterHandle[i2](context);
            if (newResponse instanceof Promise)
              newResponse = await newResponse;
            if (newResponse)
              response2 = newResponse;
          }
          const result = (0, handler_1.mapEarlyResponse)(response2, context.set);
          if (result)
            return result;
        }
      }
      let response = handle(context);
      if (response instanceof Promise)
        response = await response;
      if (!hooks.afterHandle.length) {
        const responseValidator = validator?.response?.[response.status];
        if (responseValidator?.Check(response) === false)
          throw new error_1.ValidationError("response", responseValidator, response);
      } else {
        context.response = response;
        for (let i = 0;i < hooks.afterHandle.length; i++) {
          let newResponse = hooks.afterHandle[i](context);
          if (newResponse instanceof Promise)
            newResponse = await newResponse;
          const result = (0, handler_1.mapEarlyResponse)(newResponse, context.set);
          if (result !== undefined) {
            const responseValidator = validator?.response?.[response.status];
            if (responseValidator?.Check(result) === false)
              throw new error_1.ValidationError("response", responseValidator, result);
            return result;
          }
        }
      }
      if (context.set.cookie && cookieMeta?.sign) {
        const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
        if (cookieMeta.sign === true)
          for (const [key, cookie] of Object.entries(context.set.cookie))
            context.set.cookie[key].value = await (0, utils_1.signCookie)(cookie.value, "${secret}");
        else
          for (const name of cookieMeta.sign) {
            if (!(name in cookieMeta.properties))
              continue;
            if (context.set.cookie[name]?.value) {
              context.set.cookie[name].value = await (0, utils_1.signCookie)(context.set.cookie[name].value, secret);
            }
          }
      }
      return (0, handler_1.mapResponse)(response, context.set);
    } catch (error) {
      if (error.status)
        set.status = error.status;
      return app.handleError(context, error);
    } finally {
      for (const onResponse of app.event.onResponse)
        await onResponse(context);
    }
  };
  exports.createDynamicHandler = createDynamicHandler;
  var createDynamicErrorHandler = (app) => async (context, error) => {
    const errorContext = Object.assign(context, { error, code: error.code });
    errorContext.set = context.set;
    for (let i = 0;i < app.event.error.length; i++) {
      let response = app.event.error[i](errorContext);
      if (response instanceof Promise)
        response = await response;
      if (response !== undefined && response !== null)
        return (0, handler_1.mapResponse)(response, context.set);
    }
    return new Response(typeof error.cause === "string" ? error.cause : error.message, {
      headers: context.set.headers,
      status: error.status ?? 500
    });
  };
  exports.createDynamicErrorHandler = createDynamicErrorHandler;
});

// node_modules/elysia/dist/cjs/type-system.js
var require_type_system = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.t = exports.ElysiaType = undefined;
  var system_1 = require_system2();
  var typebox_1 = require_typebox();
  Object.defineProperty(exports, "t", { enumerable: true, get: function() {
    return typebox_1.Type;
  } });
  var value_1 = require_value2();
  var error_1 = require_error();
  try {
    system_1.TypeSystem.Format("email", (value) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(value));
    system_1.TypeSystem.Format("uuid", (value) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value));
    system_1.TypeSystem.Format("date", (value) => !Number.isNaN(new Date(value).getTime()));
    system_1.TypeSystem.Format("date-time", (value) => !Number.isNaN(new Date(value).getTime()));
  } catch (error) {
  }
  var parseFileUnit = (size) => {
    if (typeof size === "string")
      switch (size.slice(-1)) {
        case "k":
          return +size.slice(0, size.length - 1) * 1024;
        case "m":
          return +size.slice(0, size.length - 1) * 1048576;
        default:
          return +size;
      }
    return size;
  };
  var validateFile = (options, value) => {
    if (!(value instanceof Blob))
      return false;
    if (options.minSize && value.size < parseFileUnit(options.minSize))
      return false;
    if (options.maxSize && value.size > parseFileUnit(options.maxSize))
      return false;
    if (options.extension)
      if (typeof options.extension === "string") {
        if (!value.type.startsWith(options.extension))
          return false;
      } else {
        for (let i = 0;i < options.extension.length; i++)
          if (value.type.startsWith(options.extension[i]))
            return true;
        return false;
      }
    return true;
  };
  var Files = system_1.TypeSystem.Type("Files", (options, value) => {
    if (!Array.isArray(value))
      return validateFile(options, value);
    if (options.minItems && value.length < options.minItems)
      return false;
    if (options.maxItems && value.length > options.maxItems)
      return false;
    for (let i = 0;i < value.length; i++)
      if (!validateFile(options, value[i]))
        return false;
    return true;
  });
  typebox_1.FormatRegistry.Set("numeric", (value) => !!value && !isNaN(+value));
  typebox_1.FormatRegistry.Set("ObjectString", (value) => {
    let start = value.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      JSON.parse(value);
      return true;
    } catch {
      return false;
    }
  });
  exports.ElysiaType = {
    Numeric: (property) => {
      const schema = typebox_1.Type.Number(property);
      return typebox_1.Type.Transform(typebox_1.Type.Union([
        typebox_1.Type.String({
          format: "numeric",
          default: 0
        }),
        schema
      ])).Decode((value) => {
        const number = +value;
        if (isNaN(number))
          return value;
        if (property && !value_1.Value.Check(schema, number))
          throw new error_1.ValidationError("property", schema, number);
        return number;
      }).Encode((value) => value);
    },
    ObjectString: (properties, options) => typebox_1.Type.Transform(typebox_1.Type.Union([
      typebox_1.Type.String({
        format: "ObjectString",
        default: ""
      }),
      typebox_1.Type.Object(properties, options)
    ])).Decode((value) => {
      if (typeof value === "string")
        try {
          return JSON.parse(value);
        } catch {
          return value;
        }
      return value;
    }).Encode((value) => JSON.stringify(value)),
    File: system_1.TypeSystem.Type("File", validateFile),
    Files: (options = {}) => typebox_1.Type.Transform(Files(options)).Decode((value) => {
      if (Array.isArray(value))
        return value;
      return [value];
    }).Encode((value) => value),
    Nullable: (schema) => typebox_1.Type.Union([typebox_1.Type.Null(), schema]),
    MaybeEmpty: (schema) => typebox_1.Type.Union([typebox_1.Type.Null(), typebox_1.Type.Undefined(), schema]),
    Cookie: (properties, options) => typebox_1.Type.Object(properties, options)
  };
  typebox_1.Type.ObjectString = exports.ElysiaType.ObjectString;
  typebox_1.Type.Numeric = exports.ElysiaType.Numeric;
  typebox_1.Type.File = (arg = {}) => exports.ElysiaType.File({
    default: "File",
    ...arg,
    extension: arg?.type,
    type: "string",
    format: "binary"
  });
  typebox_1.Type.Files = (arg = {}) => exports.ElysiaType.Files({
    ...arg,
    elysiaMeta: "Files",
    default: "Files",
    extension: arg?.type,
    type: "array",
    items: {
      ...arg,
      default: "Files",
      type: "string",
      format: "binary"
    }
  });
  typebox_1.Type.Nullable = (schema) => exports.ElysiaType.Nullable(schema);
  typebox_1.Type.MaybeEmpty = exports.ElysiaType.MaybeEmpty;
  typebox_1.Type.Cookie = exports.ElysiaType.Cookie;
  __exportStar(require_system2(), exports);
  __exportStar(require_compiler2(), exports);
});

// node_modules/elysia/dist/cjs/index.js
var require_cjs2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InvalidCookieSignature = exports.InternalServerError = exports.ValidationError = exports.NotFoundError = exports.ParseError = exports.getResponseSchemaValidator = exports.mergeObjectArray = exports.mergeHook = exports.mergeDeep = exports.getSchemaValidator = exports.Cookie = exports.t = exports.mapEarlyResponse = exports.mapCompactResponse = exports.mapResponse = exports.Elysia = undefined;
  var memoirist_1 = require_cjs();
  var eventemitter3_1 = __importDefault(require_eventemitter3());
  var trace_1 = require_trace();
  var ws_1 = require_ws();
  var handler_1 = require_handler();
  var compose_1 = require_compose();
  var utils_1 = require_utils();
  var dynamic_handle_1 = require_dynamic_handle();
  var error_1 = require_error();
  var type_system_1 = require_type_system();

  class Elysia {
    getServer() {
      return this.server;
    }
    constructor(config) {
      this.dependencies = {};
      this.store = {};
      this.decorators = {};
      this.definitions = {
        type: {},
        error: {}
      };
      this.schema = {};
      this.event = {
        start: [],
        request: [],
        parse: [],
        transform: [],
        beforeHandle: [],
        afterHandle: [],
        onResponse: [],
        trace: [],
        error: [],
        stop: []
      };
      this.reporter = new eventemitter3_1.default;
      this.server = null;
      this.validator = null;
      this.router = new memoirist_1.Memoirist;
      this.wsRouter = new memoirist_1.Memoirist;
      this.routes = [];
      this.staticRouter = {
        handlers: [],
        variables: "",
        map: {},
        all: ""
      };
      this.wsPaths = {};
      this.dynamicRouter = new memoirist_1.Memoirist;
      this.lazyLoadModules = [];
      this.path = "";
      this.handle = async (request) => this.fetch(request);
      this.fetch = (request) => (this.fetch = this.config.aot ? (0, compose_1.composeGeneralHandler)(this) : (0, dynamic_handle_1.createDynamicHandler)(this))(request);
      this.handleError = async (context, error) => (this.handleError = this.config.aot ? (0, compose_1.composeErrorHandler)(this) : (0, dynamic_handle_1.createDynamicErrorHandler)(this))(context, error);
      this.outerErrorHandler = (error) => new Response(error.message || error.name || "Error", {
        status: error?.status ?? 500
      });
      this.listen = (options, callback) => {
        if (!Bun)
          throw new Error("Bun to run");
        this.compile();
        if (typeof options === "string") {
          options = +options.trim();
          if (Number.isNaN(options))
            throw new Error("Port must be a numeric value");
        }
        const fetch = this.fetch;
        const serve = typeof options === "object" ? {
          development: !error_1.isProduction,
          ...this.config.serve,
          ...options,
          websocket: {
            ...this.config.websocket,
            ...ws_1.websocket
          },
          fetch,
          error: this.outerErrorHandler
        } : {
          development: !error_1.isProduction,
          ...this.config.serve,
          websocket: {
            ...this.config.websocket,
            ...ws_1.websocket
          },
          port: options,
          fetch,
          error: this.outerErrorHandler
        };
        if (typeof Bun === "undefined")
          throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
        this.server = Bun?.serve(serve);
        if (this.event.start.length) {
          (async () => {
            const context = Object.assign(this.decorators, {
              store: this.store,
              app: this
            });
            for (let i = 0;i < this.event.transform.length; i++) {
              const operation = this.event.transform[i](context);
              if (this.event.transform[i].$elysia === "derive") {
                if (operation instanceof Promise)
                  Object.assign(context, await operation);
                else
                  Object.assign(context, operation);
              }
            }
            for (let i = 0;i < this.event.start.length; i++)
              this.event.start[i](context);
          })();
        }
        if (callback)
          callback(this.server);
        Promise.all(this.lazyLoadModules).then(() => {
          Bun?.gc(false);
        });
        return this;
      };
      this.stop = async () => {
        if (!this.server)
          throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
        this.server.stop();
        if (this.event.stop.length) {
          (async () => {
            const context = Object.assign(this.decorators, {
              store: this.store,
              app: this
            });
            for (let i = 0;i < this.event.transform.length; i++) {
              const operation = this.event.transform[i](context);
              if (this.event.transform[i].$elysia === "derive") {
                if (operation instanceof Promise)
                  Object.assign(context, await operation);
                else
                  Object.assign(context, operation);
              }
            }
            for (let i = 0;i < this.event.stop.length; i++)
              this.event.stop[i](context);
          })();
        }
      };
      this.config = {
        forceErrorEncapsulation: true,
        prefix: "",
        aot: true,
        strictPath: false,
        scoped: false,
        cookie: {},
        ...config,
        seed: config?.seed === undefined ? "" : config?.seed
      };
    }
    add(method, paths, handler, hook, { allowMeta = false, skipPrefix = false } = {
      allowMeta: false,
      skipPrefix: false
    }) {
      if (typeof paths === "string")
        paths = [paths];
      for (let path of paths) {
        path = path === "" ? path : path.charCodeAt(0) === 47 ? path : `/${path}`;
        if (this.config.prefix && !skipPrefix)
          path = this.config.prefix + path;
        if (hook?.type)
          switch (hook.type) {
            case "text":
              hook.type = "text/plain";
              break;
            case "json":
              hook.type = "application/json";
              break;
            case "formdata":
              hook.type = "multipart/form-data";
              break;
            case "urlencoded":
              hook.type = "application/x-www-form-urlencoded";
              break;
            case "arrayBuffer":
              hook.type = "application/octet-stream";
              break;
            default:
              break;
          }
        const models = this.definitions.type;
        let cookieValidator = (0, utils_1.getSchemaValidator)(hook?.cookie ?? this.validator?.cookie, {
          dynamic: !this.config.aot,
          models,
          additionalProperties: true
        });
        if ((0, handler_1.isNotEmpty)(this.config.cookie ?? {})) {
          if (cookieValidator) {
            cookieValidator.schema = (0, utils_1.mergeCookie)(cookieValidator.schema, this.config.cookie ?? {});
          } else {
            cookieValidator = (0, utils_1.getSchemaValidator)(type_system_1.t.Cookie({}, this.config.cookie), {
              dynamic: !this.config.aot,
              models,
              additionalProperties: true
            });
          }
        }
        const validator = {
          body: (0, utils_1.getSchemaValidator)(hook?.body ?? this.validator?.body, {
            dynamic: !this.config.aot,
            models
          }),
          headers: (0, utils_1.getSchemaValidator)(hook?.headers ?? this.validator?.headers, {
            dynamic: !this.config.aot,
            models,
            additionalProperties: true
          }),
          params: (0, utils_1.getSchemaValidator)(hook?.params ?? this.validator?.params, {
            dynamic: !this.config.aot,
            models
          }),
          query: (0, utils_1.getSchemaValidator)(hook?.query ?? this.validator?.query, {
            dynamic: !this.config.aot,
            models
          }),
          cookie: cookieValidator,
          response: (0, utils_1.getResponseSchemaValidator)(hook?.response ?? this.validator?.response, {
            dynamic: !this.config.aot,
            models
          })
        };
        const hooks = (0, utils_1.mergeHook)(this.event, hook);
        const loosePath = path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/";
        if (this.config.aot === false) {
          this.dynamicRouter.add(method, path, {
            validator,
            hooks,
            content: hook?.type,
            handle: handler
          });
          if (this.config.strictPath === false) {
            this.dynamicRouter.add(method, loosePath, {
              validator,
              hooks,
              content: hook?.type,
              handle: handler
            });
          }
          this.routes.push({
            method,
            path,
            composed: null,
            handler,
            hooks
          });
          return;
        }
        const mainHandler = (0, compose_1.composeHandler)({
          path,
          method,
          hooks,
          validator,
          handler,
          handleError: this.handleError,
          onRequest: this.event.request,
          config: this.config,
          definitions: allowMeta ? this.definitions.type : undefined,
          schema: allowMeta ? this.schema : undefined,
          getReporter: () => this.reporter
        });
        const existingRouteIndex = this.routes.findIndex((route) => route.path === path && route.method === method);
        if (existingRouteIndex !== -1) {
          this.routes.splice(existingRouteIndex, 1);
        }
        this.routes.push({
          method,
          path,
          composed: mainHandler,
          handler,
          hooks
        });
        if (method === "$INTERNALWS") {
          const loose = this.config.strictPath ? undefined : path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/";
          if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
            const index = this.staticRouter.handlers.length;
            this.staticRouter.handlers.push(mainHandler);
            this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]\n`;
            this.wsPaths[path] = index;
            if (loose)
              this.wsPaths[loose] = index;
          } else {
            this.wsRouter.add("ws", path, mainHandler);
            if (loose)
              this.wsRouter.add("ws", loose, mainHandler);
          }
          return;
        }
        if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
          const index = this.staticRouter.handlers.length;
          this.staticRouter.handlers.push(mainHandler);
          this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]\n`;
          if (!this.staticRouter.map[path])
            this.staticRouter.map[path] = {
              code: ""
            };
          if (method === "ALL")
            this.staticRouter.map[path].all = `default: return st${index}(ctx)\n`;
          else
            this.staticRouter.map[path].code = `case '${method}': return st${index}(ctx)\n${this.staticRouter.map[path].code}`;
          if (!this.config.strictPath) {
            if (!this.staticRouter.map[loosePath])
              this.staticRouter.map[loosePath] = {
                code: ""
              };
            if (method === "ALL")
              this.staticRouter.map[loosePath].all = `default: return st${index}(ctx)\n`;
            else
              this.staticRouter.map[loosePath].code = `case '${method}': return st${index}(ctx)\n${this.staticRouter.map[loosePath].code}`;
          }
        } else {
          this.router.add(method, path, mainHandler);
          if (!this.config.strictPath)
            this.router.add(method, path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/", mainHandler);
        }
      }
    }
    onStart(handler) {
      this.on("start", handler);
      return this;
    }
    onRequest(handler) {
      this.on("request", handler);
      return this;
    }
    onParse(parser) {
      this.on("parse", parser);
      return this;
    }
    onTransform(handler) {
      this.on("transform", handler);
      return this;
    }
    onBeforeHandle(handler) {
      this.on("beforeHandle", handler);
      return this;
    }
    onAfterHandle(handler) {
      this.on("afterHandle", handler);
      return this;
    }
    onResponse(handler) {
      this.on("response", handler);
      return this;
    }
    trace(handler) {
      this.reporter.on("event", (0, trace_1.createTraceListener)(() => this.reporter, this.event.trace.length, handler));
      this.on("trace", handler);
      return this;
    }
    addError(name, error) {
      return this.error(name, error);
    }
    error(name, error) {
      switch (typeof name) {
        case "string":
          error.prototype[error_1.ERROR_CODE] = name;
          this.definitions.error[name] = error;
          return this;
        case "function":
          this.definitions.error = name(this.definitions.error);
          return this;
      }
      for (const [code, error2] of Object.entries(name)) {
        error2.prototype[error_1.ERROR_CODE] = code;
        this.definitions.error[code] = error2;
      }
      return this;
    }
    onError(handler) {
      this.on("error", handler);
      return this;
    }
    onStop(handler) {
      this.on("stop", handler);
      return this;
    }
    on(type, handlers) {
      for (let handler of Array.isArray(handlers) ? handlers : [handlers]) {
        handler = (0, utils_1.asGlobal)(handler);
        switch (type) {
          case "start":
            this.event.start.push(handler);
            break;
          case "request":
            this.event.request.push(handler);
            break;
          case "response":
            this.event.onResponse.push(handler);
            break;
          case "parse":
            this.event.parse.splice(this.event.parse.length - 1, 0, handler);
            break;
          case "transform":
            this.event.transform.push(handler);
            break;
          case "beforeHandle":
            this.event.beforeHandle.push(handler);
            break;
          case "afterHandle":
            this.event.afterHandle.push(handler);
            break;
          case "trace":
            this.event.trace.push(handler);
            break;
          case "error":
            this.event.error.push(handler);
            break;
          case "stop":
            this.event.stop.push(handler);
            break;
        }
      }
      return this;
    }
    group(prefix, schemaOrRun, run) {
      const instance = new Elysia({
        ...this.config,
        prefix: ""
      });
      instance.store = this.store;
      instance.getServer = () => this.server;
      const isSchema = typeof schemaOrRun === "object";
      const sandbox = (isSchema ? run : schemaOrRun)(instance);
      this.decorators = (0, utils_1.mergeDeep)(this.decorators, instance.decorators);
      if (sandbox.event.request.length)
        this.event.request = [
          ...this.event.request,
          ...sandbox.event.request
        ];
      if (sandbox.event.onResponse.length)
        this.event.onResponse = [
          ...this.event.onResponse,
          ...sandbox.event.onResponse
        ];
      this.model(sandbox.definitions.type);
      Object.values(instance.routes).forEach(({ method, path, handler, hooks }) => {
        path = (isSchema ? "" : this.config.prefix) + prefix + path;
        if (isSchema) {
          const hook = schemaOrRun;
          const localHook = hooks;
          this.add(method, path, handler, (0, utils_1.mergeHook)(hook, {
            ...localHook,
            error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [...localHook.error, ...sandbox.event.error] : [localHook.error, ...sandbox.event.error]
          }));
        } else {
          this.add(method, path, handler, (0, utils_1.mergeHook)(hooks, {
            error: sandbox.event.error
          }), {
            skipPrefix: true
          });
        }
      });
      return this;
    }
    guard(hook, run) {
      if (!run) {
        this.event = (0, utils_1.mergeLifeCycle)(this.event, hook);
        this.validator = {
          body: hook.body,
          headers: hook.headers,
          params: hook.params,
          query: hook.query,
          response: hook.response
        };
        return this;
      }
      const instance = new Elysia;
      instance.store = this.store;
      const sandbox = run(instance);
      this.decorators = (0, utils_1.mergeDeep)(this.decorators, instance.decorators);
      if (sandbox.event.request.length)
        this.event.request = [
          ...this.event.request,
          ...sandbox.event.request
        ];
      if (sandbox.event.onResponse.length)
        this.event.onResponse = [
          ...this.event.onResponse,
          ...sandbox.event.onResponse
        ];
      this.model(sandbox.definitions.type);
      Object.values(instance.routes).forEach(({ method, path, handler, hooks: localHook }) => {
        this.add(method, path, handler, (0, utils_1.mergeHook)(hook, {
          ...localHook,
          error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [...localHook.error, ...sandbox.event.error] : [localHook.error, ...sandbox.event.error]
        }));
      });
      return this;
    }
    use(plugin) {
      if (plugin instanceof Promise) {
        this.lazyLoadModules.push(plugin.then((plugin2) => {
          if (typeof plugin2 === "function") {
            return plugin2(this);
          }
          if (typeof plugin2.default === "function")
            return plugin2.default(this);
          return this._use(plugin2);
        }).then((x) => x.compile()));
        return this;
      } else
        return this._use(plugin);
      return this;
    }
    _use(plugin) {
      if (typeof plugin === "function") {
        const instance = plugin(this);
        if (instance instanceof Promise) {
          this.lazyLoadModules.push(instance.then((plugin2) => {
            if (plugin2 instanceof Elysia) {
              this.compile();
              for (const { method, path, handler, hooks } of Object.values(plugin2.routes)) {
                this.add(method, path, handler, (0, utils_1.mergeHook)(hooks, {
                  error: plugin2.event.error
                }));
              }
              return plugin2;
            }
            if (typeof plugin2 === "function")
              return plugin2(this);
            if (typeof plugin2.default === "function")
              return plugin2.default(this);
            return this._use(plugin2);
          }).then((x) => x.compile()));
          return this;
        }
        return instance;
      }
      const { name, seed } = plugin.config;
      plugin.getServer = () => this.getServer();
      const isScoped = plugin.config.scoped;
      if (isScoped) {
        if (name) {
          if (!(name in this.dependencies))
            this.dependencies[name] = [];
          const current = seed !== undefined ? (0, utils_1.checksum)(name + JSON.stringify(seed)) : 0;
          if (this.dependencies[name].some((checksum) => current === checksum))
            return this;
          this.dependencies[name].push(current);
        }
        plugin.model(this.definitions.type);
        plugin.error(this.definitions.error);
        plugin.onRequest((context) => {
          Object.assign(context, this.decorators);
          Object.assign(context.store, this.store);
        });
        plugin.event.trace = [...this.event.trace, ...plugin.event.trace];
        if (plugin.config.aot)
          plugin.compile();
        const instance = this.mount(plugin.fetch);
        this.routes = this.routes.concat(instance.routes);
        return this;
      } else {
        plugin.reporter = this.reporter;
        for (const trace of plugin.event.trace)
          this.trace(trace);
      }
      this.decorate(plugin.decorators);
      this.state(plugin.store);
      this.model(plugin.definitions.type);
      this.error(plugin.definitions.error);
      for (const { method, path, handler, hooks } of Object.values(plugin.routes)) {
        this.add(method, path, handler, (0, utils_1.mergeHook)(hooks, {
          error: plugin.event.error
        }));
      }
      if (!isScoped)
        if (name) {
          if (!(name in this.dependencies))
            this.dependencies[name] = [];
          const current = seed !== undefined ? (0, utils_1.checksum)(name + JSON.stringify(seed)) : 0;
          if (this.dependencies[name].some((checksum) => current === checksum))
            return this;
          this.dependencies[name].push(current);
          this.event = (0, utils_1.mergeLifeCycle)(this.event, (0, utils_1.filterGlobalHook)(plugin.event), current);
        } else
          this.event = (0, utils_1.mergeLifeCycle)(this.event, (0, utils_1.filterGlobalHook)(plugin.event));
      return this;
    }
    mount(path, handle) {
      if (typeof path === "function" || path.length === 0 || path === "/") {
        const run = typeof path === "function" ? path : handle;
        const handler2 = async ({ request, path: path2 }) => run(new Request((0, utils_1.getHostname)(request.url) + path2 || "/", request));
        this.all("/", handler2, {
          type: "none"
        });
        this.all("/*", handler2, {
          type: "none"
        });
        return this;
      }
      const length = path.length;
      const handler = async ({ request, path: path2 }) => handle(new Request((0, utils_1.getHostname)(request.url) + path2.slice(length) || "/", request));
      this.all(path, handler, {
        type: "none"
      });
      this.all(path + (path.endsWith("/") ? "*" : "/*"), handler, {
        type: "none"
      });
      return this;
    }
    get(path, handler, hook) {
      this.add("GET", path, handler, hook);
      return this;
    }
    post(path, handler, hook) {
      this.add("POST", path, handler, hook);
      return this;
    }
    put(path, handler, hook) {
      this.add("PUT", path, handler, hook);
      return this;
    }
    patch(path, handler, hook) {
      this.add("PATCH", path, handler, hook);
      return this;
    }
    delete(path, handler, hook) {
      this.add("DELETE", path, handler, hook);
      return this;
    }
    options(path, handler, hook) {
      this.add("OPTIONS", path, handler, hook);
      return this;
    }
    all(path, handler, hook) {
      this.add("ALL", path, handler, hook);
      return this;
    }
    head(path, handler, hook) {
      this.add("HEAD", path, handler, hook);
      return this;
    }
    connect(path, handler, hook) {
      this.add("CONNECT", path, handler, hook);
      return this;
    }
    ws(path, options) {
      const transform = options.transformMessage ? Array.isArray(options.transformMessage) ? options.transformMessage : [options.transformMessage] : undefined;
      let server = null;
      const validateMessage = (0, utils_1.getSchemaValidator)(options?.body, {
        models: this.definitions.type
      });
      const validateResponse = (0, utils_1.getSchemaValidator)(options?.response, {
        models: this.definitions.type
      });
      const parseMessage = (message) => {
        if (typeof message === "string") {
          const start = message?.charCodeAt(0);
          if (start === 47 || start === 123)
            try {
              message = JSON.parse(message);
            } catch {
            }
          else if (!Number.isNaN(+message))
            message = +message;
        }
        if (transform?.length)
          for (let i = 0;i < transform.length; i++) {
            const temp = transform[i](message);
            if (temp !== undefined)
              message = temp;
          }
        return message;
      };
      this.route("$INTERNALWS", path, (context) => {
        const { set, path: path2, qi, headers, query, params } = context;
        if (server === null)
          server = this.getServer();
        if (server?.upgrade(context.request, {
          headers: typeof options.upgrade === "function" ? options.upgrade(context) : options.upgrade,
          data: {
            validator: validateResponse,
            open(ws) {
              options.open?.(new ws_1.ElysiaWS(ws, context));
            },
            message: (ws, msg) => {
              const message = parseMessage(msg);
              if (validateMessage?.Check(message) === false)
                return void ws.send(new error_1.ValidationError("message", validateMessage, message).message);
              options.message?.(new ws_1.ElysiaWS(ws, context), message);
            },
            drain(ws) {
              options.drain?.(new ws_1.ElysiaWS(ws, context));
            },
            close(ws, code, reason) {
              options.close?.(new ws_1.ElysiaWS(ws, context), code, reason);
            }
          }
        }))
          return;
        set.status = 400;
        return "Expected a websocket connection";
      }, {
        beforeHandle: options.beforeHandle,
        transform: options.transform,
        headers: options.headers,
        params: options.params,
        query: options.query
      });
      return this;
    }
    route(method, path, handler, { config, ...hook } = {
      config: {
        allowMeta: false
      }
    }) {
      this.add(method, path, handler, hook, config);
      return this;
    }
    state(name, value) {
      switch (typeof name) {
        case "object":
          this.store = (0, utils_1.mergeDeep)(this.store, name);
          return this;
        case "function":
          this.store = name(this.store);
          return this;
      }
      if (!(name in this.store)) {
        this.store[name] = value;
      }
      return this;
    }
    decorate(name, value) {
      switch (typeof name) {
        case "object":
          this.decorators = (0, utils_1.mergeDeep)(this.decorators, name);
          return this;
        case "function":
          this.decorators = name(this.decorators);
          return this;
      }
      if (!(name in this.decorators))
        this.decorators[name] = value;
      return this;
    }
    derive(transform) {
      transform.$elysia = "derive";
      return this.onTransform(transform);
    }
    model(name, model) {
      switch (typeof name) {
        case "object":
          Object.entries(name).forEach(([key, value]) => {
            if (!(key in this.definitions.type))
              this.definitions.type[key] = value;
          });
          return this;
        case "function":
          this.definitions.type = name(this.definitions.type);
          return this;
      }
      this.definitions.type[name] = model;
      return this;
    }
    mapDerive(mapper) {
      mapper.$elysia = "derive";
      return this.onTransform(mapper);
    }
    affix(base, type, word) {
      if (word === "")
        return this;
      const delimieter = ["_", "-", " "];
      const capitalize = (word2) => word2[0].toUpperCase() + word2.slice(1);
      const joinKey = base === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize(suffix);
      const remap = (type2) => {
        const store = {};
        switch (type2) {
          case "decorator":
            for (const key in this.decorators)
              store[joinKey(word, key)] = this.decorators[key];
            this.decorators = store;
            break;
          case "state":
            for (const key in this.store)
              store[joinKey(word, key)] = this.store[key];
            this.store = store;
            break;
          case "model":
            for (const key in this.definitions.type)
              store[joinKey(word, key)] = this.definitions.type[key];
            this.definitions.type = store;
            break;
          case "error":
            for (const key in this.definitions.error)
              store[joinKey(word, key)] = this.definitions.error[key];
            this.definitions.error = store;
            break;
        }
      };
      const types = Array.isArray(type) ? type : [type];
      for (const type2 of types.some((x) => x === "all") ? ["decorator", "state", "model", "error"] : types)
        remap(type2);
      return this;
    }
    prefix(type, word) {
      return this.affix("prefix", type, word);
    }
    suffix(type, word) {
      return this.affix("suffix", type, word);
    }
    compile() {
      this.fetch = this.config.aot ? (0, compose_1.composeGeneralHandler)(this) : (0, dynamic_handle_1.createDynamicHandler)(this);
      if (typeof this.server?.reload === "function")
        this.server.reload({
          ...this.server,
          fetch: this.fetch
        });
      return this;
    }
    get modules() {
      return Promise.all(this.lazyLoadModules);
    }
  }
  exports.default = Elysia;
  exports.Elysia = Elysia;
  var handler_2 = require_handler();
  Object.defineProperty(exports, "mapResponse", { enumerable: true, get: function() {
    return handler_2.mapResponse;
  } });
  Object.defineProperty(exports, "mapCompactResponse", { enumerable: true, get: function() {
    return handler_2.mapCompactResponse;
  } });
  Object.defineProperty(exports, "mapEarlyResponse", { enumerable: true, get: function() {
    return handler_2.mapEarlyResponse;
  } });
  var type_system_2 = require_type_system();
  Object.defineProperty(exports, "t", { enumerable: true, get: function() {
    return type_system_2.t;
  } });
  var cookie_1 = require_cookie2();
  Object.defineProperty(exports, "Cookie", { enumerable: true, get: function() {
    return cookie_1.Cookie;
  } });
  var utils_2 = require_utils();
  Object.defineProperty(exports, "getSchemaValidator", { enumerable: true, get: function() {
    return utils_2.getSchemaValidator;
  } });
  Object.defineProperty(exports, "mergeDeep", { enumerable: true, get: function() {
    return utils_2.mergeDeep;
  } });
  Object.defineProperty(exports, "mergeHook", { enumerable: true, get: function() {
    return utils_2.mergeHook;
  } });
  Object.defineProperty(exports, "mergeObjectArray", { enumerable: true, get: function() {
    return utils_2.mergeObjectArray;
  } });
  Object.defineProperty(exports, "getResponseSchemaValidator", { enumerable: true, get: function() {
    return utils_2.getResponseSchemaValidator;
  } });
  var error_2 = require_error();
  Object.defineProperty(exports, "ParseError", { enumerable: true, get: function() {
    return error_2.ParseError;
  } });
  Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function() {
    return error_2.NotFoundError;
  } });
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return error_2.ValidationError;
  } });
  Object.defineProperty(exports, "InternalServerError", { enumerable: true, get: function() {
    return error_2.InternalServerError;
  } });
  Object.defineProperty(exports, "InvalidCookieSignature", { enumerable: true, get: function() {
    return error_2.InvalidCookieSignature;
  } });
});

// node_modules/@elysiajs/cors/dist/cjs/index.js
var require_cjs3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cors = undefined;
  var elysia_1 = require_cjs2();
  var cors = (config = {
    origin: true,
    methods: "*",
    allowedHeaders: "*",
    exposedHeaders: "*",
    credentials: false,
    maxAge: 5,
    preflight: true
  }) => {
    const { origin = true, methods = "*", allowedHeaders = "*", exposedHeaders = "*", credentials = false, maxAge = 5, preflight = true } = config;
    const app = new elysia_1.Elysia({
      name: "@elysiajs/cors",
      seed: config
    });
    const origins = typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
    const processOrigin = (origin2, request, from) => {
      switch (typeof origin2) {
        case "string":
          const protocolStart = from.indexOf("://");
          if (protocolStart === -1)
            return false;
          return origin2 === from.slice(protocolStart + 3);
        case "function":
          return origin2(request);
        case "object":
          return origin2.test(from);
      }
    };
    const handleOrigin = (set, request) => {
      if (origin === true) {
        set.headers["Vary"] = "*";
        set.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
        return;
      }
      if (!origins?.length)
        return;
      const headers = [];
      if (origins.length) {
        const from = request.headers.get("Origin") ?? "";
        for (let i = 0;i < origins.length; i++) {
          const value = processOrigin(origins[i], request, from);
          if (value === true) {
            set.headers["Vary"] = origin ? "Origin" : "*";
            set.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
            return;
          }
          if (value)
            headers.push(value);
        }
      }
      set.headers["Vary"] = "Origin";
      set.headers["Access-Control-Allow-Origin"] = headers.join(", ");
    };
    const handleMethod = (set) => {
      if (!methods?.length)
        return;
      if (methods === "*")
        return set.headers["Access-Control-Allow-Methods"] = "*";
      if (!Array.isArray(methods))
        return set.headers["Access-Control-Allow-Methods"] = methods;
      set.headers["Access-Control-Allow-Methods"] = methods.join(", ");
    };
    if (preflight)
      app.options("/", ({ set, request }) => {
        handleOrigin(set, request);
        handleMethod(set);
        if (exposedHeaders.length)
          set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
        if (maxAge)
          set.headers["Access-Control-Max-Age"] = maxAge.toString();
        return new Response("", {
          status: 204
        });
      }).options("/*", ({ set, request }) => {
        handleOrigin(set, request);
        handleMethod(set);
        if (exposedHeaders.length)
          set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
        if (maxAge)
          set.headers["Access-Control-Max-Age"] = maxAge.toString();
        return new Response("", {
          status: 204
        });
      });
    return app.onRequest(({ set, request }) => {
      handleOrigin(set, request);
      handleMethod(set);
      if (allowedHeaders.length)
        set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (exposedHeaders.length)
        set.headers["Access-Control-Exposed-Headers"] = typeof exposedHeaders === "string" ? exposedHeaders : exposedHeaders.join(", ");
      if (credentials)
        set.headers["Access-Control-Allow-Credentials"] = "true";
    });
  };
  exports.cors = cors;
  exports.default = exports.cors;
});

// node_modules/@noble/hashes/_assert.js
var require__assert = __commonJS((exports) => {
  function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  }
  function bool(b) {
    if (typeof b !== "boolean")
      throw new Error(`Expected boolean, not ${b}`);
  }
  function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  }
  function hash(hash2) {
    if (typeof hash2 !== "function" || typeof hash2.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash2.outputLen);
    number(hash2.blockLen);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = undefined;
  exports.number = number;
  exports.bool = bool;
  exports.bytes = bytes;
  exports.hash = hash;
  exports.exists = exists;
  exports.output = output;
  var assert = { number, bool, bytes, hash, exists, output };
  exports.default = assert;
});

// node_modules/@noble/hashes/_u64.js
var require__u64 = __commonJS((exports) => {
  function fromBig(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0;i < lst.length; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = undefined;
  var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n = /* @__PURE__ */ BigInt(32);
  exports.fromBig = fromBig;
  exports.split = split;
  var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
  exports.toBig = toBig;
  var shrSH = (h, _l, s) => h >>> s;
  exports.shrSH = shrSH;
  var shrSL = (h, l, s) => h << 32 - s | l >>> s;
  exports.shrSL = shrSL;
  var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
  exports.rotrSH = rotrSH;
  var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
  exports.rotrSL = rotrSL;
  var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
  exports.rotrBH = rotrBH;
  var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
  exports.rotrBL = rotrBL;
  var rotr32H = (_h, l) => l;
  exports.rotr32H = rotr32H;
  var rotr32L = (h, _l) => h;
  exports.rotr32L = rotr32L;
  var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  exports.rotlSH = rotlSH;
  var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  exports.rotlSL = rotlSL;
  var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  exports.rotlBH = rotlBH;
  var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
  exports.rotlBL = rotlBL;
  exports.add = add;
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  exports.add3L = add3L;
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  exports.add3H = add3H;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  exports.add4L = add4L;
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  exports.add4H = add4H;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  exports.add5L = add5L;
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  exports.add5H = add5H;
  var u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  exports.default = u64;
});

// node_modules/@noble/hashes/cryptoNode.js
var require_cryptoNode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.crypto = undefined;
  var nc = __require("node:crypto");
  exports.crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : undefined;
});

// node_modules/@noble/hashes/utils.js
var require_utils2 = __commonJS((exports) => {
  function bytesToHex(bytes) {
    if (!u8a(bytes))
      throw new Error("Uint8Array expected");
    let hex = "";
    for (let i = 0;i < bytes.length; i++) {
      hex += hexes[bytes[i]];
    }
    return hex;
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const len = hex.length;
    if (len % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0;i < array.length; i++) {
      const j = i * 2;
      const hexByte = hex.slice(j, j + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i] = byte;
    }
    return array;
  }
  async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0;i < iters; i++) {
      cb(i);
      const diff = Date.now() - ts;
      if (diff >= 0 && diff < tick)
        continue;
      await (0, exports.nextTick)();
      ts += diff;
    }
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    if (!u8a(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  }
  function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0;
    arrays.forEach((a) => {
      if (!u8a(a))
        throw new Error("Uint8Array expected");
      r.set(a, pad);
      pad += a.length;
    });
    return r;
  }
  function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
      return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = undefined;
  var crypto_1 = require_cryptoNode();
  var u8a = (a) => a instanceof Uint8Array;
  var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.u8 = u8;
  var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  exports.u32 = u32;
  var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.createView = createView;
  var rotr = (word, shift) => word << 32 - shift | word >>> shift;
  exports.rotr = rotr;
  exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!exports.isLE)
    throw new Error("Non little-endian hardware is not supported");
  var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  exports.bytesToHex = bytesToHex;
  exports.hexToBytes = hexToBytes;
  var nextTick = async () => {
  };
  exports.nextTick = nextTick;
  exports.asyncLoop = asyncLoop;
  exports.utf8ToBytes = utf8ToBytes;
  exports.toBytes = toBytes;
  exports.concatBytes = concatBytes;

  class Hash {
    clone() {
      return this._cloneInto();
    }
  }
  exports.Hash = Hash;
  var toStr = {}.toString;
  exports.checkOpts = checkOpts;
  exports.wrapConstructor = wrapConstructor;
  exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
  exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
  exports.randomBytes = randomBytes;
});

// node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS((exports) => {
  function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds;round < 24; round++) {
      for (let x = 0;x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0;x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0;y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0;t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0;y < 50; y += 10) {
        for (let x = 0;x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0;x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H[round];
      s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = undefined;
  var _assert_js_1 = require__assert();
  var _u64_js_1 = require__u64();
  var utils_js_1 = require_utils2();
  var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
  var _0n = /* @__PURE__ */ BigInt(0);
  var _1n = /* @__PURE__ */ BigInt(1);
  var _2n = /* @__PURE__ */ BigInt(2);
  var _7n = /* @__PURE__ */ BigInt(7);
  var _256n = /* @__PURE__ */ BigInt(256);
  var _0x71n = /* @__PURE__ */ BigInt(113);
  for (let round = 0, R = _1n, x = 1, y = 0;round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n;
    for (let j = 0;j < 7; j++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
  var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
  var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
  exports.keccakP = keccakP;

  class Keccak extends utils_js_1.Hash {
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      (0, _assert_js_1.number)(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
      keccakP(this.state32, this.rounds);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      (0, _assert_js_1.exists)(this);
      const { blockLen, state } = this;
      data = (0, utils_js_1.toBytes)(data);
      const len = data.length;
      for (let pos = 0;pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0;i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      (0, _assert_js_1.exists)(this, false);
      (0, _assert_js_1.bytes)(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length;pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes) {
      (0, _assert_js_1.number)(bytes);
      return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
      (0, _assert_js_1.output)(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  }
  exports.Keccak = Keccak;
  var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
  exports.sha3_224 = gen(6, 144, 224 / 8);
  exports.sha3_256 = gen(6, 136, 256 / 8);
  exports.sha3_384 = gen(6, 104, 384 / 8);
  exports.sha3_512 = gen(6, 72, 512 / 8);
  exports.keccak_224 = gen(1, 144, 224 / 8);
  exports.keccak_256 = gen(1, 136, 256 / 8);
  exports.keccak_384 = gen(1, 104, 384 / 8);
  exports.keccak_512 = gen(1, 72, 512 / 8);
  var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
  exports.shake128 = genShake(31, 168, 128 / 8);
  exports.shake256 = genShake(31, 136, 256 / 8);
});

// node_modules/@paralleldrive/cuid2/src/index.js
var require_src = __commonJS((exports, module) => {
  function bufToBigInt(buf) {
    let bits = 8n;
    let value = 0n;
    for (const i of buf.values()) {
      const bi = BigInt(i);
      value = (value << bits) + bi;
    }
    return value;
  }
  var { sha3_512: sha3 } = require_sha3();
  var defaultLength = 24;
  var bigLength = 32;
  var createEntropy = (length = 4, random = Math.random) => {
    let entropy = "";
    while (entropy.length < length) {
      entropy = entropy + Math.floor(random() * 36).toString(36);
    }
    return entropy;
  };
  var hash = (input = "") => {
    return bufToBigInt(sha3(input)).toString(36).slice(1);
  };
  var alphabet = Array.from({ length: 26 }, (x, i) => String.fromCharCode(i + 97));
  var randomLetter = (random) => alphabet[Math.floor(random() * alphabet.length)];
  var createFingerprint = ({
    globalObj = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : {},
    random = Math.random
  } = {}) => {
    const globals = Object.keys(globalObj).toString();
    const sourceString = globals.length ? globals + createEntropy(bigLength, random) : createEntropy(bigLength, random);
    return hash(sourceString).substring(0, bigLength);
  };
  var createCounter = (count) => () => {
    return count++;
  };
  var initialCountMax = 476782367;
  var init = ({
    random = Math.random,
    counter = createCounter(Math.floor(random() * initialCountMax)),
    length = defaultLength,
    fingerprint = createFingerprint({ random })
  } = {}) => {
    return function cuid2() {
      const firstLetter = randomLetter(random);
      const time = Date.now().toString(36);
      const count = counter().toString(36);
      const salt = createEntropy(length, random);
      const hashInput = `${time + salt + count + fingerprint}`;
      return `${firstLetter + hash(hashInput).substring(1, length)}`;
    };
  };
  var createId = init();
  var isCuid = (id, { minLength = 2, maxLength = bigLength } = {}) => {
    const length = id.length;
    const regex = /^[0-9a-z]+$/;
    try {
      if (typeof id === "string" && length >= minLength && length <= maxLength && regex.test(id))
        return true;
    } finally {
    }
    return false;
  };
  exports.getConstants = () => ({ defaultLength, bigLength });
  exports.init = init;
  exports.createId = createId;
  exports.bufToBigInt = bufToBigInt;
  exports.createCounter = createCounter;
  exports.createFingerprint = createFingerprint;
  exports.isCuid = isCuid;
});

// node_modules/nodemailer/lib/fetch/cookies.js
var require_cookies = __commonJS((exports, module) => {
  var urllib = __require("url");
  var SESSION_TIMEOUT = 1800;

  class Cookies {
    constructor(options) {
      this.options = options || {};
      this.cookies = [];
    }
    set(cookieStr, url) {
      let urlparts = urllib.parse(url || "");
      let cookie = this.parse(cookieStr);
      let domain;
      if (cookie.domain) {
        domain = cookie.domain.replace(/^\./, "");
        if (urlparts.hostname.length < domain.length || ("." + urlparts.hostname).substr(-domain.length + 1) !== "." + domain) {
          cookie.domain = urlparts.hostname;
        }
      } else {
        cookie.domain = urlparts.hostname;
      }
      if (!cookie.path) {
        cookie.path = this.getPath(urlparts.pathname);
      }
      if (!cookie.expires) {
        cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);
      }
      return this.add(cookie);
    }
    get(url) {
      return this.list(url).map((cookie) => cookie.name + "=" + cookie.value).join("; ");
    }
    list(url) {
      let result2 = [];
      let i;
      let cookie;
      for (i = this.cookies.length - 1;i >= 0; i--) {
        cookie = this.cookies[i];
        if (this.isExpired(cookie)) {
          this.cookies.splice(i, i);
          continue;
        }
        if (this.match(cookie, url)) {
          result2.unshift(cookie);
        }
      }
      return result2;
    }
    parse(cookieStr) {
      let cookie = {};
      (cookieStr || "").toString().split(";").forEach((cookiePart) => {
        let valueParts = cookiePart.split("=");
        let key = valueParts.shift().trim().toLowerCase();
        let value = valueParts.join("=").trim();
        let domain;
        if (!key) {
          return;
        }
        switch (key) {
          case "expires":
            value = new Date(value);
            if (value.toString() !== "Invalid Date") {
              cookie.expires = value;
            }
            break;
          case "path":
            cookie.path = value;
            break;
          case "domain":
            domain = value.toLowerCase();
            if (domain.length && domain.charAt(0) !== ".") {
              domain = "." + domain;
            }
            cookie.domain = domain;
            break;
          case "max-age":
            cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);
            break;
          case "secure":
            cookie.secure = true;
            break;
          case "httponly":
            cookie.httponly = true;
            break;
          default:
            if (!cookie.name) {
              cookie.name = key;
              cookie.value = value;
            }
        }
      });
      return cookie;
    }
    match(cookie, url) {
      let urlparts = urllib.parse(url || "");
      if (urlparts.hostname !== cookie.domain && (cookie.domain.charAt(0) !== "." || ("." + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)) {
        return false;
      }
      let path = this.getPath(urlparts.pathname);
      if (path.substr(0, cookie.path.length) !== cookie.path) {
        return false;
      }
      if (cookie.secure && urlparts.protocol !== "https:") {
        return false;
      }
      return true;
    }
    add(cookie) {
      let i;
      let len;
      if (!cookie || !cookie.name) {
        return false;
      }
      for (i = 0, len = this.cookies.length;i < len; i++) {
        if (this.compare(this.cookies[i], cookie)) {
          if (this.isExpired(cookie)) {
            this.cookies.splice(i, 1);
            return false;
          }
          this.cookies[i] = cookie;
          return true;
        }
      }
      if (!this.isExpired(cookie)) {
        this.cookies.push(cookie);
      }
      return true;
    }
    compare(a, b2) {
      return a.name === b2.name && a.path === b2.path && a.domain === b2.domain && a.secure === b2.secure && a.httponly === a.httponly;
    }
    isExpired(cookie) {
      return cookie.expires && cookie.expires < new Date || !cookie.value;
    }
    getPath(pathname) {
      let path = (pathname || "/").split("/");
      path.pop();
      path = path.join("/").trim();
      if (path.charAt(0) !== "/") {
        path = "/" + path;
      }
      if (path.substr(-1) !== "/") {
        path += "/";
      }
      return path;
    }
  }
  module.exports = Cookies;
});

// node_modules/nodemailer/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "nodemailer",
    version: "7.0.5",
    description: "Easy as cake e-mail sending from your Node.js applications",
    main: "lib/nodemailer.js",
    scripts: {
      test: "node --test --test-concurrency=1 test/**/*.test.js test/**/*-test.js",
      "test:coverage": "c8 node --test --test-concurrency=1 test/**/*.test.js test/**/*-test.js",
      lint: "eslint .",
      update: "rm -rf node_modules/ package-lock.json && ncu -u && npm install"
    },
    repository: {
      type: "git",
      url: "https://github.com/nodemailer/nodemailer.git"
    },
    keywords: [
      "Nodemailer"
    ],
    author: "Andris Reinman",
    license: "MIT-0",
    bugs: {
      url: "https://github.com/nodemailer/nodemailer/issues"
    },
    homepage: "https://nodemailer.com/",
    devDependencies: {
      "@aws-sdk/client-sesv2": "3.839.0",
      bunyan: "1.8.15",
      c8: "10.1.3",
      eslint: "8.57.0",
      "eslint-config-nodemailer": "1.2.0",
      "eslint-config-prettier": "9.1.0",
      libbase64: "1.3.0",
      libmime: "5.3.7",
      libqp: "2.1.1",
      "nodemailer-ntlm-auth": "1.0.4",
      proxy: "1.0.2",
      "proxy-test-server": "1.0.0",
      "smtp-server": "3.14.0"
    },
    engines: {
      node: ">=6.0.0"
    }
  };
});

// node_modules/nodemailer/lib/fetch/index.js
var require_fetch = __commonJS((exports, module) => {
  function nmfetch(url, options) {
    options = options || {};
    options.fetchRes = options.fetchRes || new PassThrough;
    options.cookies = options.cookies || new Cookies;
    options.redirects = options.redirects || 0;
    options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;
    if (options.cookie) {
      [].concat(options.cookie || []).forEach((cookie) => {
        options.cookies.set(cookie, url);
      });
      options.cookie = false;
    }
    let fetchRes = options.fetchRes;
    let parsed = urllib.parse(url);
    let method = (options.method || "").toString().trim().toUpperCase() || "GET";
    let finished = false;
    let cookies;
    let body;
    let handler = parsed.protocol === "https:" ? https : http;
    let headers = {
      "accept-encoding": "gzip,deflate",
      "user-agent": "nodemailer/" + packageData.version
    };
    Object.keys(options.headers || {}).forEach((key) => {
      headers[key.toLowerCase().trim()] = options.headers[key];
    });
    if (options.userAgent) {
      headers["user-agent"] = options.userAgent;
    }
    if (parsed.auth) {
      headers.Authorization = "Basic " + Buffer.from(parsed.auth).toString("base64");
    }
    if (cookies = options.cookies.get(url)) {
      headers.cookie = cookies;
    }
    if (options.body) {
      if (options.contentType !== false) {
        headers["Content-Type"] = options.contentType || "application/x-www-form-urlencoded";
      }
      if (typeof options.body.pipe === "function") {
        headers["Transfer-Encoding"] = "chunked";
        body = options.body;
        body.on("error", (err) => {
          if (finished) {
            return;
          }
          finished = true;
          err.type = "FETCH";
          err.sourceUrl = url;
          fetchRes.emit("error", err);
        });
      } else {
        if (options.body instanceof Buffer) {
          body = options.body;
        } else if (typeof options.body === "object") {
          try {
            body = Buffer.from(Object.keys(options.body).map((key) => {
              let value = options.body[key].toString().trim();
              return encodeURIComponent(key) + "=" + encodeURIComponent(value);
            }).join("&"));
          } catch (E) {
            if (finished) {
              return;
            }
            finished = true;
            E.type = "FETCH";
            E.sourceUrl = url;
            fetchRes.emit("error", E);
            return;
          }
        } else {
          body = Buffer.from(options.body.toString().trim());
        }
        headers["Content-Type"] = options.contentType || "application/x-www-form-urlencoded";
        headers["Content-Length"] = body.length;
      }
      method = (options.method || "").toString().trim().toUpperCase() || "POST";
    }
    let req;
    let reqOptions = {
      method,
      host: parsed.hostname,
      path: parsed.path,
      port: parsed.port ? parsed.port : parsed.protocol === "https:" ? 443 : 80,
      headers,
      rejectUnauthorized: false,
      agent: false
    };
    if (options.tls) {
      Object.keys(options.tls).forEach((key) => {
        reqOptions[key] = options.tls[key];
      });
    }
    if (parsed.protocol === "https:" && parsed.hostname && parsed.hostname !== reqOptions.host && !net2.isIP(parsed.hostname) && !reqOptions.servername) {
      reqOptions.servername = parsed.hostname;
    }
    try {
      req = handler.request(reqOptions);
    } catch (E) {
      finished = true;
      setImmediate(() => {
        E.type = "FETCH";
        E.sourceUrl = url;
        fetchRes.emit("error", E);
      });
      return fetchRes;
    }
    if (options.timeout) {
      req.setTimeout(options.timeout, () => {
        if (finished) {
          return;
        }
        finished = true;
        req.abort();
        let err = new Error("Request Timeout");
        err.type = "FETCH";
        err.sourceUrl = url;
        fetchRes.emit("error", err);
      });
    }
    req.on("error", (err) => {
      if (finished) {
        return;
      }
      finished = true;
      err.type = "FETCH";
      err.sourceUrl = url;
      fetchRes.emit("error", err);
    });
    req.on("response", (res) => {
      let inflate;
      if (finished) {
        return;
      }
      switch (res.headers["content-encoding"]) {
        case "gzip":
        case "deflate":
          inflate = zlib.createUnzip();
          break;
      }
      if (res.headers["set-cookie"]) {
        [].concat(res.headers["set-cookie"] || []).forEach((cookie) => {
          options.cookies.set(cookie, url);
        });
      }
      if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {
        options.redirects++;
        if (options.redirects > options.maxRedirects) {
          finished = true;
          let err = new Error("Maximum redirect count exceeded");
          err.type = "FETCH";
          err.sourceUrl = url;
          fetchRes.emit("error", err);
          req.abort();
          return;
        }
        options.method = "GET";
        options.body = false;
        return nmfetch(urllib.resolve(url, res.headers.location), options);
      }
      fetchRes.statusCode = res.statusCode;
      fetchRes.headers = res.headers;
      if (res.statusCode >= 300 && !options.allowErrorResponse) {
        finished = true;
        let err = new Error("Invalid status code " + res.statusCode);
        err.type = "FETCH";
        err.sourceUrl = url;
        fetchRes.emit("error", err);
        req.abort();
        return;
      }
      res.on("error", (err) => {
        if (finished) {
          return;
        }
        finished = true;
        err.type = "FETCH";
        err.sourceUrl = url;
        fetchRes.emit("error", err);
        req.abort();
      });
      if (inflate) {
        res.pipe(inflate).pipe(fetchRes);
        inflate.on("error", (err) => {
          if (finished) {
            return;
          }
          finished = true;
          err.type = "FETCH";
          err.sourceUrl = url;
          fetchRes.emit("error", err);
          req.abort();
        });
      } else {
        res.pipe(fetchRes);
      }
    });
    setImmediate(() => {
      if (body) {
        try {
          if (typeof body.pipe === "function") {
            return body.pipe(req);
          } else {
            req.write(body);
          }
        } catch (err) {
          finished = true;
          err.type = "FETCH";
          err.sourceUrl = url;
          fetchRes.emit("error", err);
          return;
        }
      }
      req.end();
    });
    return fetchRes;
  }
  var http = __require("http");
  var https = __require("https");
  var urllib = __require("url");
  var zlib = __require("zlib");
  var PassThrough = __require("stream").PassThrough;
  var Cookies = require_cookies();
  var packageData = require_package();
  var net2 = __require("net");
  var MAX_REDIRECTS = 5;
  module.exports = function(url, options) {
    return nmfetch(url, options);
  };
  module.exports.Cookies = Cookies;
});

// node_modules/nodemailer/lib/shared/index.js
var require_shared = __commonJS((exports, module) => {
  function resolveStream(stream, callback) {
    let responded = false;
    let chunks = [];
    let chunklen = 0;
    stream.on("error", (err) => {
      if (responded) {
        return;
      }
      responded = true;
      callback(err);
    });
    stream.on("readable", () => {
      let chunk;
      while ((chunk = stream.read()) !== null) {
        chunks.push(chunk);
        chunklen += chunk.length;
      }
    });
    stream.on("end", () => {
      if (responded) {
        return;
      }
      responded = true;
      let value;
      try {
        value = Buffer.concat(chunks, chunklen);
      } catch (E) {
        return callback(E);
      }
      callback(null, value);
    });
  }
  function createDefaultLogger(levels) {
    let levelMaxLen = 0;
    let levelNames = new Map;
    levels.forEach((level) => {
      if (level.length > levelMaxLen) {
        levelMaxLen = level.length;
      }
    });
    levels.forEach((level) => {
      let levelName = level.toUpperCase();
      if (levelName.length < levelMaxLen) {
        levelName += " ".repeat(levelMaxLen - levelName.length);
      }
      levelNames.set(level, levelName);
    });
    let print = (level, entry, message, ...args) => {
      let prefix = "";
      if (entry) {
        if (entry.tnx === "server") {
          prefix = "S: ";
        } else if (entry.tnx === "client") {
          prefix = "C: ";
        }
        if (entry.sid) {
          prefix = "[" + entry.sid + "] " + prefix;
        }
        if (entry.cid) {
          prefix = "[#" + entry.cid + "] " + prefix;
        }
      }
      message = util2.format(message, ...args);
      message.split(/\r?\n/).forEach((line) => {
        console.log("[%s] %s %s", new Date().toISOString().substr(0, 19).replace(/T/, " "), levelNames.get(level), prefix + line);
      });
    };
    let logger3 = {};
    levels.forEach((level) => {
      logger3[level] = print.bind(null, level);
    });
    return logger3;
  }
  var urllib = __require("url");
  var util2 = __require("util");
  var fs2 = __require("fs");
  var nmfetch = require_fetch();
  var dns = __require("dns");
  var net2 = __require("net");
  var os2 = __require("os");
  var DNS_TTL = 5 * 60 * 1000;
  var networkInterfaces;
  try {
    networkInterfaces = os2.networkInterfaces();
  } catch (err) {
  }
  exports.networkInterfaces = networkInterfaces;
  var isFamilySupported = (family, allowInternal) => {
    let networkInterfaces2 = exports.networkInterfaces;
    if (!networkInterfaces2) {
      return true;
    }
    const familySupported = Object.keys(networkInterfaces2).map((key) => networkInterfaces2[key]).reduce((acc, val) => acc.concat(val), []).filter((i) => !i.internal || allowInternal).filter((i) => i.family === "IPv" + family || i.family === family).length > 0;
    return familySupported;
  };
  var resolver = (family, hostname, options, callback) => {
    options = options || {};
    const familySupported = isFamilySupported(family, options.allowInternalNetworkInterfaces);
    if (!familySupported) {
      return callback(null, []);
    }
    const resolver2 = dns.Resolver ? new dns.Resolver(options) : dns;
    resolver2["resolve" + family](hostname, (err, addresses) => {
      if (err) {
        switch (err.code) {
          case dns.NODATA:
          case dns.NOTFOUND:
          case dns.NOTIMP:
          case dns.SERVFAIL:
          case dns.CONNREFUSED:
          case dns.REFUSED:
          case "EAI_AGAIN":
            return callback(null, []);
        }
        return callback(err);
      }
      return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));
    });
  };
  var dnsCache = exports.dnsCache = new Map;
  var formatDNSValue = (value, extra) => {
    if (!value) {
      return Object.assign({}, extra || {});
    }
    return Object.assign({
      servername: value.servername,
      host: !value.addresses || !value.addresses.length ? null : value.addresses.length === 1 ? value.addresses[0] : value.addresses[Math.floor(Math.random() * value.addresses.length)]
    }, extra || {});
  };
  exports.resolveHostname = (options, callback) => {
    options = options || {};
    if (!options.host && options.servername) {
      options.host = options.servername;
    }
    if (!options.host || net2.isIP(options.host)) {
      let value = {
        addresses: [options.host],
        servername: options.servername || false
      };
      return callback(null, formatDNSValue(value, {
        cached: false
      }));
    }
    let cached;
    if (dnsCache.has(options.host)) {
      cached = dnsCache.get(options.host);
      if (!cached.expires || cached.expires >= Date.now()) {
        return callback(null, formatDNSValue(cached.value, {
          cached: true
        }));
      }
    }
    resolver(4, options.host, options, (err, addresses) => {
      if (err) {
        if (cached) {
          return callback(null, formatDNSValue(cached.value, {
            cached: true,
            error: err
          }));
        }
        return callback(err);
      }
      if (addresses && addresses.length) {
        let value = {
          addresses,
          servername: options.servername || options.host
        };
        dnsCache.set(options.host, {
          value,
          expires: Date.now() + (options.dnsTtl || DNS_TTL)
        });
        return callback(null, formatDNSValue(value, {
          cached: false
        }));
      }
      resolver(6, options.host, options, (err2, addresses2) => {
        if (err2) {
          if (cached) {
            return callback(null, formatDNSValue(cached.value, {
              cached: true,
              error: err2
            }));
          }
          return callback(err2);
        }
        if (addresses2 && addresses2.length) {
          let value = {
            addresses: addresses2,
            servername: options.servername || options.host
          };
          dnsCache.set(options.host, {
            value,
            expires: Date.now() + (options.dnsTtl || DNS_TTL)
          });
          return callback(null, formatDNSValue(value, {
            cached: false
          }));
        }
        try {
          dns.lookup(options.host, { all: true }, (err3, addresses3) => {
            if (err3) {
              if (cached) {
                return callback(null, formatDNSValue(cached.value, {
                  cached: true,
                  error: err3
                }));
              }
              return callback(err3);
            }
            let address = addresses3 ? addresses3.filter((addr) => isFamilySupported(addr.family)).map((addr) => addr.address).shift() : false;
            if (addresses3 && addresses3.length && !address) {
              console.warn(`Failed to resolve IPv${addresses3[0].family} addresses with current network`);
            }
            if (!address && cached) {
              return callback(null, formatDNSValue(cached.value, {
                cached: true
              }));
            }
            let value = {
              addresses: address ? [address] : [options.host],
              servername: options.servername || options.host
            };
            dnsCache.set(options.host, {
              value,
              expires: Date.now() + (options.dnsTtl || DNS_TTL)
            });
            return callback(null, formatDNSValue(value, {
              cached: false
            }));
          });
        } catch (err3) {
          if (cached) {
            return callback(null, formatDNSValue(cached.value, {
              cached: true,
              error: err3
            }));
          }
          return callback(err3);
        }
      });
    });
  };
  exports.parseConnectionUrl = (str) => {
    str = str || "";
    let options = {};
    [urllib.parse(str, true)].forEach((url) => {
      let auth;
      switch (url.protocol) {
        case "smtp:":
          options.secure = false;
          break;
        case "smtps:":
          options.secure = true;
          break;
        case "direct:":
          options.direct = true;
          break;
      }
      if (!isNaN(url.port) && Number(url.port)) {
        options.port = Number(url.port);
      }
      if (url.hostname) {
        options.host = url.hostname;
      }
      if (url.auth) {
        auth = url.auth.split(":");
        if (!options.auth) {
          options.auth = {};
        }
        options.auth.user = auth.shift();
        options.auth.pass = auth.join(":");
      }
      Object.keys(url.query || {}).forEach((key) => {
        let obj = options;
        let lKey = key;
        let value = url.query[key];
        if (!isNaN(value)) {
          value = Number(value);
        }
        switch (value) {
          case "true":
            value = true;
            break;
          case "false":
            value = false;
            break;
        }
        if (key.indexOf("tls.") === 0) {
          lKey = key.substr(4);
          if (!options.tls) {
            options.tls = {};
          }
          obj = options.tls;
        } else if (key.indexOf(".") >= 0) {
          return;
        }
        if (!(lKey in obj)) {
          obj[lKey] = value;
        }
      });
    });
    return options;
  };
  exports._logFunc = (logger3, level, defaults, data, message, ...args) => {
    let entry = {};
    Object.keys(defaults || {}).forEach((key) => {
      if (key !== "level") {
        entry[key] = defaults[key];
      }
    });
    Object.keys(data || {}).forEach((key) => {
      if (key !== "level") {
        entry[key] = data[key];
      }
    });
    logger3[level](entry, message, ...args);
  };
  exports.getLogger = (options, defaults) => {
    options = options || {};
    let response = {};
    let levels = ["trace", "debug", "info", "warn", "error", "fatal"];
    if (!options.logger) {
      levels.forEach((level) => {
        response[level] = () => false;
      });
      return response;
    }
    let logger3 = options.logger;
    if (options.logger === true) {
      logger3 = createDefaultLogger(levels);
    }
    levels.forEach((level) => {
      response[level] = (data, message, ...args) => {
        exports._logFunc(logger3, level, defaults, data, message, ...args);
      };
    });
    return response;
  };
  exports.callbackPromise = (resolve, reject) => function() {
    let args = Array.from(arguments);
    let err = args.shift();
    if (err) {
      reject(err);
    } else {
      resolve(...args);
    }
  };
  exports.parseDataURI = (uri) => {
    let input = uri;
    let commaPos = input.indexOf(",");
    if (!commaPos) {
      return uri;
    }
    let data = input.substring(commaPos + 1);
    let metaStr = input.substring("data:".length, commaPos);
    let encoding;
    let metaEntries = metaStr.split(";");
    let lastMetaEntry = metaEntries.length > 1 ? metaEntries[metaEntries.length - 1] : false;
    if (lastMetaEntry && lastMetaEntry.indexOf("=") < 0) {
      encoding = lastMetaEntry.toLowerCase();
      metaEntries.pop();
    }
    let contentType = metaEntries.shift() || "application/octet-stream";
    let params = {};
    for (let entry of metaEntries) {
      let sep = entry.indexOf("=");
      if (sep >= 0) {
        let key = entry.substring(0, sep);
        let value = entry.substring(sep + 1);
        params[key] = value;
      }
    }
    switch (encoding) {
      case "base64":
        data = Buffer.from(data, "base64");
        break;
      case "utf8":
        data = Buffer.from(data);
        break;
      default:
        try {
          data = Buffer.from(decodeURIComponent(data));
        } catch (err) {
          data = Buffer.from(data);
        }
        data = Buffer.from(data);
    }
    return { data, encoding, contentType, params };
  };
  exports.resolveContent = (data, key, callback) => {
    let promise;
    if (!callback) {
      promise = new Promise((resolve, reject) => {
        callback = exports.callbackPromise(resolve, reject);
      });
    }
    let content = data && data[key] && data[key].content || data[key];
    let contentStream;
    let encoding = (typeof data[key] === "object" && data[key].encoding || "utf8").toString().toLowerCase().replace(/[-_\s]/g, "");
    if (!content) {
      return callback(null, content);
    }
    if (typeof content === "object") {
      if (typeof content.pipe === "function") {
        return resolveStream(content, (err, value) => {
          if (err) {
            return callback(err);
          }
          if (data[key].content) {
            data[key].content = value;
          } else {
            data[key] = value;
          }
          callback(null, value);
        });
      } else if (/^https?:\/\//i.test(content.path || content.href)) {
        contentStream = nmfetch(content.path || content.href);
        return resolveStream(contentStream, callback);
      } else if (/^data:/i.test(content.path || content.href)) {
        let parsedDataUri = exports.parseDataURI(content.path || content.href);
        if (!parsedDataUri || !parsedDataUri.data) {
          return callback(null, Buffer.from(0));
        }
        return callback(null, parsedDataUri.data);
      } else if (content.path) {
        return resolveStream(fs2.createReadStream(content.path), callback);
      }
    }
    if (typeof data[key].content === "string" && !["utf8", "usascii", "ascii"].includes(encoding)) {
      content = Buffer.from(data[key].content, encoding);
    }
    setImmediate(() => callback(null, content));
    return promise;
  };
  exports.assign = function() {
    let args = Array.from(arguments);
    let target = args.shift() || {};
    args.forEach((source) => {
      Object.keys(source || {}).forEach((key) => {
        if (["tls", "auth"].includes(key) && source[key] && typeof source[key] === "object") {
          if (!target[key]) {
            target[key] = {};
          }
          Object.keys(source[key]).forEach((subKey) => {
            target[key][subKey] = source[key][subKey];
          });
        } else {
          target[key] = source[key];
        }
      });
    });
    return target;
  };
  exports.encodeXText = (str) => {
    if (!/[^\x21-\x2A\x2C-\x3C\x3E-\x7E]/.test(str)) {
      return str;
    }
    let buf = Buffer.from(str);
    let result2 = "";
    for (let i = 0, len = buf.length;i < len; i++) {
      let c = buf[i];
      if (c < 33 || c > 126 || c === 43 || c === 61) {
        result2 += "+" + (c < 16 ? "0" : "") + c.toString(16).toUpperCase();
      } else {
        result2 += String.fromCharCode(c);
      }
    }
    return result2;
  };
});

// node_modules/nodemailer/lib/mime-funcs/mime-types.js
var require_mime_types = __commonJS((exports, module) => {
  var path = __require("path");
  var defaultMimeType = "application/octet-stream";
  var defaultExtension = "bin";
  var mimeTypes = new Map([
    ["application/acad", "dwg"],
    ["application/applixware", "aw"],
    ["application/arj", "arj"],
    ["application/atom+xml", "xml"],
    ["application/atomcat+xml", "atomcat"],
    ["application/atomsvc+xml", "atomsvc"],
    ["application/base64", ["mm", "mme"]],
    ["application/binhex", "hqx"],
    ["application/binhex4", "hqx"],
    ["application/book", ["book", "boo"]],
    ["application/ccxml+xml,", "ccxml"],
    ["application/cdf", "cdf"],
    ["application/cdmi-capability", "cdmia"],
    ["application/cdmi-container", "cdmic"],
    ["application/cdmi-domain", "cdmid"],
    ["application/cdmi-object", "cdmio"],
    ["application/cdmi-queue", "cdmiq"],
    ["application/clariscad", "ccad"],
    ["application/commonground", "dp"],
    ["application/cu-seeme", "cu"],
    ["application/davmount+xml", "davmount"],
    ["application/drafting", "drw"],
    ["application/dsptype", "tsp"],
    ["application/dssc+der", "dssc"],
    ["application/dssc+xml", "xdssc"],
    ["application/dxf", "dxf"],
    ["application/ecmascript", ["js", "es"]],
    ["application/emma+xml", "emma"],
    ["application/envoy", "evy"],
    ["application/epub+zip", "epub"],
    ["application/excel", ["xls", "xl", "xla", "xlb", "xlc", "xld", "xlk", "xll", "xlm", "xlt", "xlv", "xlw"]],
    ["application/exi", "exi"],
    ["application/font-tdpfr", "pfr"],
    ["application/fractals", "fif"],
    ["application/freeloader", "frl"],
    ["application/futuresplash", "spl"],
    ["application/geo+json", "geojson"],
    ["application/gnutar", "tgz"],
    ["application/groupwise", "vew"],
    ["application/hlp", "hlp"],
    ["application/hta", "hta"],
    ["application/hyperstudio", "stk"],
    ["application/i-deas", "unv"],
    ["application/iges", ["iges", "igs"]],
    ["application/inf", "inf"],
    ["application/internet-property-stream", "acx"],
    ["application/ipfix", "ipfix"],
    ["application/java", "class"],
    ["application/java-archive", "jar"],
    ["application/java-byte-code", "class"],
    ["application/java-serialized-object", "ser"],
    ["application/java-vm", "class"],
    ["application/javascript", "js"],
    ["application/json", "json"],
    ["application/lha", "lha"],
    ["application/lzx", "lzx"],
    ["application/mac-binary", "bin"],
    ["application/mac-binhex", "hqx"],
    ["application/mac-binhex40", "hqx"],
    ["application/mac-compactpro", "cpt"],
    ["application/macbinary", "bin"],
    ["application/mads+xml", "mads"],
    ["application/marc", "mrc"],
    ["application/marcxml+xml", "mrcx"],
    ["application/mathematica", "ma"],
    ["application/mathml+xml", "mathml"],
    ["application/mbedlet", "mbd"],
    ["application/mbox", "mbox"],
    ["application/mcad", "mcd"],
    ["application/mediaservercontrol+xml", "mscml"],
    ["application/metalink4+xml", "meta4"],
    ["application/mets+xml", "mets"],
    ["application/mime", "aps"],
    ["application/mods+xml", "mods"],
    ["application/mp21", "m21"],
    ["application/mp4", "mp4"],
    ["application/mspowerpoint", ["ppt", "pot", "pps", "ppz"]],
    ["application/msword", ["doc", "dot", "w6w", "wiz", "word"]],
    ["application/mswrite", "wri"],
    ["application/mxf", "mxf"],
    ["application/netmc", "mcp"],
    ["application/octet-stream", ["*"]],
    ["application/oda", "oda"],
    ["application/oebps-package+xml", "opf"],
    ["application/ogg", "ogx"],
    ["application/olescript", "axs"],
    ["application/onenote", "onetoc"],
    ["application/patch-ops-error+xml", "xer"],
    ["application/pdf", "pdf"],
    ["application/pgp-encrypted", "asc"],
    ["application/pgp-signature", "pgp"],
    ["application/pics-rules", "prf"],
    ["application/pkcs-12", "p12"],
    ["application/pkcs-crl", "crl"],
    ["application/pkcs10", "p10"],
    ["application/pkcs7-mime", ["p7c", "p7m"]],
    ["application/pkcs7-signature", "p7s"],
    ["application/pkcs8", "p8"],
    ["application/pkix-attr-cert", "ac"],
    ["application/pkix-cert", ["cer", "crt"]],
    ["application/pkix-crl", "crl"],
    ["application/pkix-pkipath", "pkipath"],
    ["application/pkixcmp", "pki"],
    ["application/plain", "text"],
    ["application/pls+xml", "pls"],
    ["application/postscript", ["ps", "ai", "eps"]],
    ["application/powerpoint", "ppt"],
    ["application/pro_eng", ["part", "prt"]],
    ["application/prs.cww", "cww"],
    ["application/pskc+xml", "pskcxml"],
    ["application/rdf+xml", "rdf"],
    ["application/reginfo+xml", "rif"],
    ["application/relax-ng-compact-syntax", "rnc"],
    ["application/resource-lists+xml", "rl"],
    ["application/resource-lists-diff+xml", "rld"],
    ["application/ringing-tones", "rng"],
    ["application/rls-services+xml", "rs"],
    ["application/rsd+xml", "rsd"],
    ["application/rss+xml", "xml"],
    ["application/rtf", ["rtf", "rtx"]],
    ["application/sbml+xml", "sbml"],
    ["application/scvp-cv-request", "scq"],
    ["application/scvp-cv-response", "scs"],
    ["application/scvp-vp-request", "spq"],
    ["application/scvp-vp-response", "spp"],
    ["application/sdp", "sdp"],
    ["application/sea", "sea"],
    ["application/set", "set"],
    ["application/set-payment-initiation", "setpay"],
    ["application/set-registration-initiation", "setreg"],
    ["application/shf+xml", "shf"],
    ["application/sla", "stl"],
    ["application/smil", ["smi", "smil"]],
    ["application/smil+xml", "smi"],
    ["application/solids", "sol"],
    ["application/sounder", "sdr"],
    ["application/sparql-query", "rq"],
    ["application/sparql-results+xml", "srx"],
    ["application/srgs", "gram"],
    ["application/srgs+xml", "grxml"],
    ["application/sru+xml", "sru"],
    ["application/ssml+xml", "ssml"],
    ["application/step", ["step", "stp"]],
    ["application/streamingmedia", "ssm"],
    ["application/tei+xml", "tei"],
    ["application/thraud+xml", "tfi"],
    ["application/timestamped-data", "tsd"],
    ["application/toolbook", "tbk"],
    ["application/vda", "vda"],
    ["application/vnd.3gpp.pic-bw-large", "plb"],
    ["application/vnd.3gpp.pic-bw-small", "psb"],
    ["application/vnd.3gpp.pic-bw-var", "pvb"],
    ["application/vnd.3gpp2.tcap", "tcap"],
    ["application/vnd.3m.post-it-notes", "pwn"],
    ["application/vnd.accpac.simply.aso", "aso"],
    ["application/vnd.accpac.simply.imp", "imp"],
    ["application/vnd.acucobol", "acu"],
    ["application/vnd.acucorp", "atc"],
    ["application/vnd.adobe.air-application-installer-package+zip", "air"],
    ["application/vnd.adobe.fxp", "fxp"],
    ["application/vnd.adobe.xdp+xml", "xdp"],
    ["application/vnd.adobe.xfdf", "xfdf"],
    ["application/vnd.ahead.space", "ahead"],
    ["application/vnd.airzip.filesecure.azf", "azf"],
    ["application/vnd.airzip.filesecure.azs", "azs"],
    ["application/vnd.amazon.ebook", "azw"],
    ["application/vnd.americandynamics.acc", "acc"],
    ["application/vnd.amiga.ami", "ami"],
    ["application/vnd.android.package-archive", "apk"],
    ["application/vnd.anser-web-certificate-issue-initiation", "cii"],
    ["application/vnd.anser-web-funds-transfer-initiation", "fti"],
    ["application/vnd.antix.game-component", "atx"],
    ["application/vnd.apple.installer+xml", "mpkg"],
    ["application/vnd.apple.mpegurl", "m3u8"],
    ["application/vnd.aristanetworks.swi", "swi"],
    ["application/vnd.audiograph", "aep"],
    ["application/vnd.blueice.multipass", "mpm"],
    ["application/vnd.bmi", "bmi"],
    ["application/vnd.businessobjects", "rep"],
    ["application/vnd.chemdraw+xml", "cdxml"],
    ["application/vnd.chipnuts.karaoke-mmd", "mmd"],
    ["application/vnd.cinderella", "cdy"],
    ["application/vnd.claymore", "cla"],
    ["application/vnd.cloanto.rp9", "rp9"],
    ["application/vnd.clonk.c4group", "c4g"],
    ["application/vnd.cluetrust.cartomobile-config", "c11amc"],
    ["application/vnd.cluetrust.cartomobile-config-pkg", "c11amz"],
    ["application/vnd.commonspace", "csp"],
    ["application/vnd.contact.cmsg", "cdbcmsg"],
    ["application/vnd.cosmocaller", "cmc"],
    ["application/vnd.crick.clicker", "clkx"],
    ["application/vnd.crick.clicker.keyboard", "clkk"],
    ["application/vnd.crick.clicker.palette", "clkp"],
    ["application/vnd.crick.clicker.template", "clkt"],
    ["application/vnd.crick.clicker.wordbank", "clkw"],
    ["application/vnd.criticaltools.wbs+xml", "wbs"],
    ["application/vnd.ctc-posml", "pml"],
    ["application/vnd.cups-ppd", "ppd"],
    ["application/vnd.curl.car", "car"],
    ["application/vnd.curl.pcurl", "pcurl"],
    ["application/vnd.data-vision.rdz", "rdz"],
    ["application/vnd.denovo.fcselayout-link", "fe_launch"],
    ["application/vnd.dna", "dna"],
    ["application/vnd.dolby.mlp", "mlp"],
    ["application/vnd.dpgraph", "dpg"],
    ["application/vnd.dreamfactory", "dfac"],
    ["application/vnd.dvb.ait", "ait"],
    ["application/vnd.dvb.service", "svc"],
    ["application/vnd.dynageo", "geo"],
    ["application/vnd.ecowin.chart", "mag"],
    ["application/vnd.enliven", "nml"],
    ["application/vnd.epson.esf", "esf"],
    ["application/vnd.epson.msf", "msf"],
    ["application/vnd.epson.quickanime", "qam"],
    ["application/vnd.epson.salt", "slt"],
    ["application/vnd.epson.ssf", "ssf"],
    ["application/vnd.eszigno3+xml", "es3"],
    ["application/vnd.ezpix-album", "ez2"],
    ["application/vnd.ezpix-package", "ez3"],
    ["application/vnd.fdf", "fdf"],
    ["application/vnd.fdsn.seed", "seed"],
    ["application/vnd.flographit", "gph"],
    ["application/vnd.fluxtime.clip", "ftc"],
    ["application/vnd.framemaker", "fm"],
    ["application/vnd.frogans.fnc", "fnc"],
    ["application/vnd.frogans.ltf", "ltf"],
    ["application/vnd.fsc.weblaunch", "fsc"],
    ["application/vnd.fujitsu.oasys", "oas"],
    ["application/vnd.fujitsu.oasys2", "oa2"],
    ["application/vnd.fujitsu.oasys3", "oa3"],
    ["application/vnd.fujitsu.oasysgp", "fg5"],
    ["application/vnd.fujitsu.oasysprs", "bh2"],
    ["application/vnd.fujixerox.ddd", "ddd"],
    ["application/vnd.fujixerox.docuworks", "xdw"],
    ["application/vnd.fujixerox.docuworks.binder", "xbd"],
    ["application/vnd.fuzzysheet", "fzs"],
    ["application/vnd.genomatix.tuxedo", "txd"],
    ["application/vnd.geogebra.file", "ggb"],
    ["application/vnd.geogebra.tool", "ggt"],
    ["application/vnd.geometry-explorer", "gex"],
    ["application/vnd.geonext", "gxt"],
    ["application/vnd.geoplan", "g2w"],
    ["application/vnd.geospace", "g3w"],
    ["application/vnd.gmx", "gmx"],
    ["application/vnd.google-earth.kml+xml", "kml"],
    ["application/vnd.google-earth.kmz", "kmz"],
    ["application/vnd.grafeq", "gqf"],
    ["application/vnd.groove-account", "gac"],
    ["application/vnd.groove-help", "ghf"],
    ["application/vnd.groove-identity-message", "gim"],
    ["application/vnd.groove-injector", "grv"],
    ["application/vnd.groove-tool-message", "gtm"],
    ["application/vnd.groove-tool-template", "tpl"],
    ["application/vnd.groove-vcard", "vcg"],
    ["application/vnd.hal+xml", "hal"],
    ["application/vnd.handheld-entertainment+xml", "zmm"],
    ["application/vnd.hbci", "hbci"],
    ["application/vnd.hhe.lesson-player", "les"],
    ["application/vnd.hp-hpgl", ["hgl", "hpg", "hpgl"]],
    ["application/vnd.hp-hpid", "hpid"],
    ["application/vnd.hp-hps", "hps"],
    ["application/vnd.hp-jlyt", "jlt"],
    ["application/vnd.hp-pcl", "pcl"],
    ["application/vnd.hp-pclxl", "pclxl"],
    ["application/vnd.hydrostatix.sof-data", "sfd-hdstx"],
    ["application/vnd.hzn-3d-crossword", "x3d"],
    ["application/vnd.ibm.minipay", "mpy"],
    ["application/vnd.ibm.modcap", "afp"],
    ["application/vnd.ibm.rights-management", "irm"],
    ["application/vnd.ibm.secure-container", "sc"],
    ["application/vnd.iccprofile", "icc"],
    ["application/vnd.igloader", "igl"],
    ["application/vnd.immervision-ivp", "ivp"],
    ["application/vnd.immervision-ivu", "ivu"],
    ["application/vnd.insors.igm", "igm"],
    ["application/vnd.intercon.formnet", "xpw"],
    ["application/vnd.intergeo", "i2g"],
    ["application/vnd.intu.qbo", "qbo"],
    ["application/vnd.intu.qfx", "qfx"],
    ["application/vnd.ipunplugged.rcprofile", "rcprofile"],
    ["application/vnd.irepository.package+xml", "irp"],
    ["application/vnd.is-xpr", "xpr"],
    ["application/vnd.isac.fcs", "fcs"],
    ["application/vnd.jam", "jam"],
    ["application/vnd.jcp.javame.midlet-rms", "rms"],
    ["application/vnd.jisp", "jisp"],
    ["application/vnd.joost.joda-archive", "joda"],
    ["application/vnd.kahootz", "ktz"],
    ["application/vnd.kde.karbon", "karbon"],
    ["application/vnd.kde.kchart", "chrt"],
    ["application/vnd.kde.kformula", "kfo"],
    ["application/vnd.kde.kivio", "flw"],
    ["application/vnd.kde.kontour", "kon"],
    ["application/vnd.kde.kpresenter", "kpr"],
    ["application/vnd.kde.kspread", "ksp"],
    ["application/vnd.kde.kword", "kwd"],
    ["application/vnd.kenameaapp", "htke"],
    ["application/vnd.kidspiration", "kia"],
    ["application/vnd.kinar", "kne"],
    ["application/vnd.koan", "skp"],
    ["application/vnd.kodak-descriptor", "sse"],
    ["application/vnd.las.las+xml", "lasxml"],
    ["application/vnd.llamagraphics.life-balance.desktop", "lbd"],
    ["application/vnd.llamagraphics.life-balance.exchange+xml", "lbe"],
    ["application/vnd.lotus-1-2-3", "123"],
    ["application/vnd.lotus-approach", "apr"],
    ["application/vnd.lotus-freelance", "pre"],
    ["application/vnd.lotus-notes", "nsf"],
    ["application/vnd.lotus-organizer", "org"],
    ["application/vnd.lotus-screencam", "scm"],
    ["application/vnd.lotus-wordpro", "lwp"],
    ["application/vnd.macports.portpkg", "portpkg"],
    ["application/vnd.mcd", "mcd"],
    ["application/vnd.medcalcdata", "mc1"],
    ["application/vnd.mediastation.cdkey", "cdkey"],
    ["application/vnd.mfer", "mwf"],
    ["application/vnd.mfmp", "mfm"],
    ["application/vnd.micrografx.flo", "flo"],
    ["application/vnd.micrografx.igx", "igx"],
    ["application/vnd.mif", "mif"],
    ["application/vnd.mobius.daf", "daf"],
    ["application/vnd.mobius.dis", "dis"],
    ["application/vnd.mobius.mbk", "mbk"],
    ["application/vnd.mobius.mqy", "mqy"],
    ["application/vnd.mobius.msl", "msl"],
    ["application/vnd.mobius.plc", "plc"],
    ["application/vnd.mobius.txf", "txf"],
    ["application/vnd.mophun.application", "mpn"],
    ["application/vnd.mophun.certificate", "mpc"],
    ["application/vnd.mozilla.xul+xml", "xul"],
    ["application/vnd.ms-artgalry", "cil"],
    ["application/vnd.ms-cab-compressed", "cab"],
    ["application/vnd.ms-excel", ["xls", "xla", "xlc", "xlm", "xlt", "xlw", "xlb", "xll"]],
    ["application/vnd.ms-excel.addin.macroenabled.12", "xlam"],
    ["application/vnd.ms-excel.sheet.binary.macroenabled.12", "xlsb"],
    ["application/vnd.ms-excel.sheet.macroenabled.12", "xlsm"],
    ["application/vnd.ms-excel.template.macroenabled.12", "xltm"],
    ["application/vnd.ms-fontobject", "eot"],
    ["application/vnd.ms-htmlhelp", "chm"],
    ["application/vnd.ms-ims", "ims"],
    ["application/vnd.ms-lrm", "lrm"],
    ["application/vnd.ms-officetheme", "thmx"],
    ["application/vnd.ms-outlook", "msg"],
    ["application/vnd.ms-pki.certstore", "sst"],
    ["application/vnd.ms-pki.pko", "pko"],
    ["application/vnd.ms-pki.seccat", "cat"],
    ["application/vnd.ms-pki.stl", "stl"],
    ["application/vnd.ms-pkicertstore", "sst"],
    ["application/vnd.ms-pkiseccat", "cat"],
    ["application/vnd.ms-pkistl", "stl"],
    ["application/vnd.ms-powerpoint", ["ppt", "pot", "pps", "ppa", "pwz"]],
    ["application/vnd.ms-powerpoint.addin.macroenabled.12", "ppam"],
    ["application/vnd.ms-powerpoint.presentation.macroenabled.12", "pptm"],
    ["application/vnd.ms-powerpoint.slide.macroenabled.12", "sldm"],
    ["application/vnd.ms-powerpoint.slideshow.macroenabled.12", "ppsm"],
    ["application/vnd.ms-powerpoint.template.macroenabled.12", "potm"],
    ["application/vnd.ms-project", "mpp"],
    ["application/vnd.ms-word.document.macroenabled.12", "docm"],
    ["application/vnd.ms-word.template.macroenabled.12", "dotm"],
    ["application/vnd.ms-works", ["wks", "wcm", "wdb", "wps"]],
    ["application/vnd.ms-wpl", "wpl"],
    ["application/vnd.ms-xpsdocument", "xps"],
    ["application/vnd.mseq", "mseq"],
    ["application/vnd.musician", "mus"],
    ["application/vnd.muvee.style", "msty"],
    ["application/vnd.neurolanguage.nlu", "nlu"],
    ["application/vnd.noblenet-directory", "nnd"],
    ["application/vnd.noblenet-sealer", "nns"],
    ["application/vnd.noblenet-web", "nnw"],
    ["application/vnd.nokia.configuration-message", "ncm"],
    ["application/vnd.nokia.n-gage.data", "ngdat"],
    ["application/vnd.nokia.n-gage.symbian.install", "n-gage"],
    ["application/vnd.nokia.radio-preset", "rpst"],
    ["application/vnd.nokia.radio-presets", "rpss"],
    ["application/vnd.nokia.ringing-tone", "rng"],
    ["application/vnd.novadigm.edm", "edm"],
    ["application/vnd.novadigm.edx", "edx"],
    ["application/vnd.novadigm.ext", "ext"],
    ["application/vnd.oasis.opendocument.chart", "odc"],
    ["application/vnd.oasis.opendocument.chart-template", "otc"],
    ["application/vnd.oasis.opendocument.database", "odb"],
    ["application/vnd.oasis.opendocument.formula", "odf"],
    ["application/vnd.oasis.opendocument.formula-template", "odft"],
    ["application/vnd.oasis.opendocument.graphics", "odg"],
    ["application/vnd.oasis.opendocument.graphics-template", "otg"],
    ["application/vnd.oasis.opendocument.image", "odi"],
    ["application/vnd.oasis.opendocument.image-template", "oti"],
    ["application/vnd.oasis.opendocument.presentation", "odp"],
    ["application/vnd.oasis.opendocument.presentation-template", "otp"],
    ["application/vnd.oasis.opendocument.spreadsheet", "ods"],
    ["application/vnd.oasis.opendocument.spreadsheet-template", "ots"],
    ["application/vnd.oasis.opendocument.text", "odt"],
    ["application/vnd.oasis.opendocument.text-master", "odm"],
    ["application/vnd.oasis.opendocument.text-template", "ott"],
    ["application/vnd.oasis.opendocument.text-web", "oth"],
    ["application/vnd.olpc-sugar", "xo"],
    ["application/vnd.oma.dd2+xml", "dd2"],
    ["application/vnd.openofficeorg.extension", "oxt"],
    ["application/vnd.openxmlformats-officedocument.presentationml.presentation", "pptx"],
    ["application/vnd.openxmlformats-officedocument.presentationml.slide", "sldx"],
    ["application/vnd.openxmlformats-officedocument.presentationml.slideshow", "ppsx"],
    ["application/vnd.openxmlformats-officedocument.presentationml.template", "potx"],
    ["application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "xlsx"],
    ["application/vnd.openxmlformats-officedocument.spreadsheetml.template", "xltx"],
    ["application/vnd.openxmlformats-officedocument.wordprocessingml.document", "docx"],
    ["application/vnd.openxmlformats-officedocument.wordprocessingml.template", "dotx"],
    ["application/vnd.osgeo.mapguide.package", "mgp"],
    ["application/vnd.osgi.dp", "dp"],
    ["application/vnd.palm", "pdb"],
    ["application/vnd.pawaafile", "paw"],
    ["application/vnd.pg.format", "str"],
    ["application/vnd.pg.osasli", "ei6"],
    ["application/vnd.picsel", "efif"],
    ["application/vnd.pmi.widget", "wg"],
    ["application/vnd.pocketlearn", "plf"],
    ["application/vnd.powerbuilder6", "pbd"],
    ["application/vnd.previewsystems.box", "box"],
    ["application/vnd.proteus.magazine", "mgz"],
    ["application/vnd.publishare-delta-tree", "qps"],
    ["application/vnd.pvi.ptid1", "ptid"],
    ["application/vnd.quark.quarkxpress", "qxd"],
    ["application/vnd.realvnc.bed", "bed"],
    ["application/vnd.recordare.musicxml", "mxl"],
    ["application/vnd.recordare.musicxml+xml", "musicxml"],
    ["application/vnd.rig.cryptonote", "cryptonote"],
    ["application/vnd.rim.cod", "cod"],
    ["application/vnd.rn-realmedia", "rm"],
    ["application/vnd.rn-realplayer", "rnx"],
    ["application/vnd.route66.link66+xml", "link66"],
    ["application/vnd.sailingtracker.track", "st"],
    ["application/vnd.seemail", "see"],
    ["application/vnd.sema", "sema"],
    ["application/vnd.semd", "semd"],
    ["application/vnd.semf", "semf"],
    ["application/vnd.shana.informed.formdata", "ifm"],
    ["application/vnd.shana.informed.formtemplate", "itp"],
    ["application/vnd.shana.informed.interchange", "iif"],
    ["application/vnd.shana.informed.package", "ipk"],
    ["application/vnd.simtech-mindmapper", "twd"],
    ["application/vnd.smaf", "mmf"],
    ["application/vnd.smart.teacher", "teacher"],
    ["application/vnd.solent.sdkm+xml", "sdkm"],
    ["application/vnd.spotfire.dxp", "dxp"],
    ["application/vnd.spotfire.sfs", "sfs"],
    ["application/vnd.stardivision.calc", "sdc"],
    ["application/vnd.stardivision.draw", "sda"],
    ["application/vnd.stardivision.impress", "sdd"],
    ["application/vnd.stardivision.math", "smf"],
    ["application/vnd.stardivision.writer", "sdw"],
    ["application/vnd.stardivision.writer-global", "sgl"],
    ["application/vnd.stepmania.stepchart", "sm"],
    ["application/vnd.sun.xml.calc", "sxc"],
    ["application/vnd.sun.xml.calc.template", "stc"],
    ["application/vnd.sun.xml.draw", "sxd"],
    ["application/vnd.sun.xml.draw.template", "std"],
    ["application/vnd.sun.xml.impress", "sxi"],
    ["application/vnd.sun.xml.impress.template", "sti"],
    ["application/vnd.sun.xml.math", "sxm"],
    ["application/vnd.sun.xml.writer", "sxw"],
    ["application/vnd.sun.xml.writer.global", "sxg"],
    ["application/vnd.sun.xml.writer.template", "stw"],
    ["application/vnd.sus-calendar", "sus"],
    ["application/vnd.svd", "svd"],
    ["application/vnd.symbian.install", "sis"],
    ["application/vnd.syncml+xml", "xsm"],
    ["application/vnd.syncml.dm+wbxml", "bdm"],
    ["application/vnd.syncml.dm+xml", "xdm"],
    ["application/vnd.tao.intent-module-archive", "tao"],
    ["application/vnd.tmobile-livetv", "tmo"],
    ["application/vnd.trid.tpt", "tpt"],
    ["application/vnd.triscape.mxs", "mxs"],
    ["application/vnd.trueapp", "tra"],
    ["application/vnd.ufdl", "ufd"],
    ["application/vnd.uiq.theme", "utz"],
    ["application/vnd.umajin", "umj"],
    ["application/vnd.unity", "unityweb"],
    ["application/vnd.uoml+xml", "uoml"],
    ["application/vnd.vcx", "vcx"],
    ["application/vnd.visio", "vsd"],
    ["application/vnd.visionary", "vis"],
    ["application/vnd.vsf", "vsf"],
    ["application/vnd.wap.wbxml", "wbxml"],
    ["application/vnd.wap.wmlc", "wmlc"],
    ["application/vnd.wap.wmlscriptc", "wmlsc"],
    ["application/vnd.webturbo", "wtb"],
    ["application/vnd.wolfram.player", "nbp"],
    ["application/vnd.wordperfect", "wpd"],
    ["application/vnd.wqd", "wqd"],
    ["application/vnd.wt.stf", "stf"],
    ["application/vnd.xara", ["web", "xar"]],
    ["application/vnd.xfdl", "xfdl"],
    ["application/vnd.yamaha.hv-dic", "hvd"],
    ["application/vnd.yamaha.hv-script", "hvs"],
    ["application/vnd.yamaha.hv-voice", "hvp"],
    ["application/vnd.yamaha.openscoreformat", "osf"],
    ["application/vnd.yamaha.openscoreformat.osfpvg+xml", "osfpvg"],
    ["application/vnd.yamaha.smaf-audio", "saf"],
    ["application/vnd.yamaha.smaf-phrase", "spf"],
    ["application/vnd.yellowriver-custom-menu", "cmp"],
    ["application/vnd.zul", "zir"],
    ["application/vnd.zzazz.deck+xml", "zaz"],
    ["application/vocaltec-media-desc", "vmd"],
    ["application/vocaltec-media-file", "vmf"],
    ["application/voicexml+xml", "vxml"],
    ["application/widget", "wgt"],
    ["application/winhlp", "hlp"],
    ["application/wordperfect", ["wp", "wp5", "wp6", "wpd"]],
    ["application/wordperfect6.0", ["w60", "wp5"]],
    ["application/wordperfect6.1", "w61"],
    ["application/wsdl+xml", "wsdl"],
    ["application/wspolicy+xml", "wspolicy"],
    ["application/x-123", "wk1"],
    ["application/x-7z-compressed", "7z"],
    ["application/x-abiword", "abw"],
    ["application/x-ace-compressed", "ace"],
    ["application/x-aim", "aim"],
    ["application/x-authorware-bin", "aab"],
    ["application/x-authorware-map", "aam"],
    ["application/x-authorware-seg", "aas"],
    ["application/x-bcpio", "bcpio"],
    ["application/x-binary", "bin"],
    ["application/x-binhex40", "hqx"],
    ["application/x-bittorrent", "torrent"],
    ["application/x-bsh", ["bsh", "sh", "shar"]],
    ["application/x-bytecode.elisp", "elc"],
    ["application/x-bytecode.python", "pyc"],
    ["application/x-bzip", "bz"],
    ["application/x-bzip2", ["boz", "bz2"]],
    ["application/x-cdf", "cdf"],
    ["application/x-cdlink", "vcd"],
    ["application/x-chat", ["cha", "chat"]],
    ["application/x-chess-pgn", "pgn"],
    ["application/x-cmu-raster", "ras"],
    ["application/x-cocoa", "cco"],
    ["application/x-compactpro", "cpt"],
    ["application/x-compress", "z"],
    ["application/x-compressed", ["tgz", "gz", "z", "zip"]],
    ["application/x-conference", "nsc"],
    ["application/x-cpio", "cpio"],
    ["application/x-cpt", "cpt"],
    ["application/x-csh", "csh"],
    ["application/x-debian-package", "deb"],
    ["application/x-deepv", "deepv"],
    ["application/x-director", ["dir", "dcr", "dxr"]],
    ["application/x-doom", "wad"],
    ["application/x-dtbncx+xml", "ncx"],
    ["application/x-dtbook+xml", "dtb"],
    ["application/x-dtbresource+xml", "res"],
    ["application/x-dvi", "dvi"],
    ["application/x-elc", "elc"],
    ["application/x-envoy", ["env", "evy"]],
    ["application/x-esrehber", "es"],
    ["application/x-excel", ["xls", "xla", "xlb", "xlc", "xld", "xlk", "xll", "xlm", "xlt", "xlv", "xlw"]],
    ["application/x-font-bdf", "bdf"],
    ["application/x-font-ghostscript", "gsf"],
    ["application/x-font-linux-psf", "psf"],
    ["application/x-font-otf", "otf"],
    ["application/x-font-pcf", "pcf"],
    ["application/x-font-snf", "snf"],
    ["application/x-font-ttf", "ttf"],
    ["application/x-font-type1", "pfa"],
    ["application/x-font-woff", "woff"],
    ["application/x-frame", "mif"],
    ["application/x-freelance", "pre"],
    ["application/x-futuresplash", "spl"],
    ["application/x-gnumeric", "gnumeric"],
    ["application/x-gsp", "gsp"],
    ["application/x-gss", "gss"],
    ["application/x-gtar", "gtar"],
    ["application/x-gzip", ["gz", "gzip"]],
    ["application/x-hdf", "hdf"],
    ["application/x-helpfile", ["help", "hlp"]],
    ["application/x-httpd-imap", "imap"],
    ["application/x-ima", "ima"],
    ["application/x-internet-signup", ["ins", "isp"]],
    ["application/x-internett-signup", "ins"],
    ["application/x-inventor", "iv"],
    ["application/x-ip2", "ip"],
    ["application/x-iphone", "iii"],
    ["application/x-java-class", "class"],
    ["application/x-java-commerce", "jcm"],
    ["application/x-java-jnlp-file", "jnlp"],
    ["application/x-javascript", "js"],
    ["application/x-koan", ["skd", "skm", "skp", "skt"]],
    ["application/x-ksh", "ksh"],
    ["application/x-latex", ["latex", "ltx"]],
    ["application/x-lha", "lha"],
    ["application/x-lisp", "lsp"],
    ["application/x-livescreen", "ivy"],
    ["application/x-lotus", "wq1"],
    ["application/x-lotusscreencam", "scm"],
    ["application/x-lzh", "lzh"],
    ["application/x-lzx", "lzx"],
    ["application/x-mac-binhex40", "hqx"],
    ["application/x-macbinary", "bin"],
    ["application/x-magic-cap-package-1.0", "mc$"],
    ["application/x-mathcad", "mcd"],
    ["application/x-meme", "mm"],
    ["application/x-midi", ["mid", "midi"]],
    ["application/x-mif", "mif"],
    ["application/x-mix-transfer", "nix"],
    ["application/x-mobipocket-ebook", "prc"],
    ["application/x-mplayer2", "asx"],
    ["application/x-ms-application", "application"],
    ["application/x-ms-wmd", "wmd"],
    ["application/x-ms-wmz", "wmz"],
    ["application/x-ms-xbap", "xbap"],
    ["application/x-msaccess", "mdb"],
    ["application/x-msbinder", "obd"],
    ["application/x-mscardfile", "crd"],
    ["application/x-msclip", "clp"],
    ["application/x-msdownload", ["exe", "dll"]],
    ["application/x-msexcel", ["xls", "xla", "xlw"]],
    ["application/x-msmediaview", ["mvb", "m13", "m14"]],
    ["application/x-msmetafile", "wmf"],
    ["application/x-msmoney", "mny"],
    ["application/x-mspowerpoint", "ppt"],
    ["application/x-mspublisher", "pub"],
    ["application/x-msschedule", "scd"],
    ["application/x-msterminal", "trm"],
    ["application/x-mswrite", "wri"],
    ["application/x-navi-animation", "ani"],
    ["application/x-navidoc", "nvd"],
    ["application/x-navimap", "map"],
    ["application/x-navistyle", "stl"],
    ["application/x-netcdf", ["cdf", "nc"]],
    ["application/x-newton-compatible-pkg", "pkg"],
    ["application/x-nokia-9000-communicator-add-on-software", "aos"],
    ["application/x-omc", "omc"],
    ["application/x-omcdatamaker", "omcd"],
    ["application/x-omcregerator", "omcr"],
    ["application/x-pagemaker", ["pm4", "pm5"]],
    ["application/x-pcl", "pcl"],
    ["application/x-perfmon", ["pma", "pmc", "pml", "pmr", "pmw"]],
    ["application/x-pixclscript", "plx"],
    ["application/x-pkcs10", "p10"],
    ["application/x-pkcs12", ["p12", "pfx"]],
    ["application/x-pkcs7-certificates", ["p7b", "spc"]],
    ["application/x-pkcs7-certreqresp", "p7r"],
    ["application/x-pkcs7-mime", ["p7m", "p7c"]],
    ["application/x-pkcs7-signature", ["p7s", "p7a"]],
    ["application/x-pointplus", "css"],
    ["application/x-portable-anymap", "pnm"],
    ["application/x-project", ["mpc", "mpt", "mpv", "mpx"]],
    ["application/x-qpro", "wb1"],
    ["application/x-rar-compressed", "rar"],
    ["application/x-rtf", "rtf"],
    ["application/x-sdp", "sdp"],
    ["application/x-sea", "sea"],
    ["application/x-seelogo", "sl"],
    ["application/x-sh", "sh"],
    ["application/x-shar", ["shar", "sh"]],
    ["application/x-shockwave-flash", "swf"],
    ["application/x-silverlight-app", "xap"],
    ["application/x-sit", "sit"],
    ["application/x-sprite", ["spr", "sprite"]],
    ["application/x-stuffit", "sit"],
    ["application/x-stuffitx", "sitx"],
    ["application/x-sv4cpio", "sv4cpio"],
    ["application/x-sv4crc", "sv4crc"],
    ["application/x-tar", "tar"],
    ["application/x-tbook", ["sbk", "tbk"]],
    ["application/x-tcl", "tcl"],
    ["application/x-tex", "tex"],
    ["application/x-tex-tfm", "tfm"],
    ["application/x-texinfo", ["texi", "texinfo"]],
    ["application/x-troff", ["roff", "t", "tr"]],
    ["application/x-troff-man", "man"],
    ["application/x-troff-me", "me"],
    ["application/x-troff-ms", "ms"],
    ["application/x-troff-msvideo", "avi"],
    ["application/x-ustar", "ustar"],
    ["application/x-visio", ["vsd", "vst", "vsw"]],
    ["application/x-vnd.audioexplosion.mzz", "mzz"],
    ["application/x-vnd.ls-xpix", "xpix"],
    ["application/x-vrml", "vrml"],
    ["application/x-wais-source", ["src", "wsrc"]],
    ["application/x-winhelp", "hlp"],
    ["application/x-wintalk", "wtk"],
    ["application/x-world", ["wrl", "svr"]],
    ["application/x-wpwin", "wpd"],
    ["application/x-wri", "wri"],
    ["application/x-x509-ca-cert", ["cer", "crt", "der"]],
    ["application/x-x509-user-cert", "crt"],
    ["application/x-xfig", "fig"],
    ["application/x-xpinstall", "xpi"],
    ["application/x-zip-compressed", "zip"],
    ["application/xcap-diff+xml", "xdf"],
    ["application/xenc+xml", "xenc"],
    ["application/xhtml+xml", "xhtml"],
    ["application/xml", "xml"],
    ["application/xml-dtd", "dtd"],
    ["application/xop+xml", "xop"],
    ["application/xslt+xml", "xslt"],
    ["application/xspf+xml", "xspf"],
    ["application/xv+xml", "mxml"],
    ["application/yang", "yang"],
    ["application/yin+xml", "yin"],
    ["application/ynd.ms-pkipko", "pko"],
    ["application/zip", "zip"],
    ["audio/adpcm", "adp"],
    ["audio/aiff", ["aiff", "aif", "aifc"]],
    ["audio/basic", ["snd", "au"]],
    ["audio/it", "it"],
    ["audio/make", ["funk", "my", "pfunk"]],
    ["audio/make.my.funk", "pfunk"],
    ["audio/mid", ["mid", "rmi"]],
    ["audio/midi", ["midi", "kar", "mid"]],
    ["audio/mod", "mod"],
    ["audio/mp4", "mp4a"],
    ["audio/mpeg", ["mpga", "mp3", "m2a", "mp2", "mpa", "mpg"]],
    ["audio/mpeg3", "mp3"],
    ["audio/nspaudio", ["la", "lma"]],
    ["audio/ogg", "oga"],
    ["audio/s3m", "s3m"],
    ["audio/tsp-audio", "tsi"],
    ["audio/tsplayer", "tsp"],
    ["audio/vnd.dece.audio", "uva"],
    ["audio/vnd.digital-winds", "eol"],
    ["audio/vnd.dra", "dra"],
    ["audio/vnd.dts", "dts"],
    ["audio/vnd.dts.hd", "dtshd"],
    ["audio/vnd.lucent.voice", "lvp"],
    ["audio/vnd.ms-playready.media.pya", "pya"],
    ["audio/vnd.nuera.ecelp4800", "ecelp4800"],
    ["audio/vnd.nuera.ecelp7470", "ecelp7470"],
    ["audio/vnd.nuera.ecelp9600", "ecelp9600"],
    ["audio/vnd.qcelp", "qcp"],
    ["audio/vnd.rip", "rip"],
    ["audio/voc", "voc"],
    ["audio/voxware", "vox"],
    ["audio/wav", "wav"],
    ["audio/webm", "weba"],
    ["audio/x-aac", "aac"],
    ["audio/x-adpcm", "snd"],
    ["audio/x-aiff", ["aiff", "aif", "aifc"]],
    ["audio/x-au", "au"],
    ["audio/x-gsm", ["gsd", "gsm"]],
    ["audio/x-jam", "jam"],
    ["audio/x-liveaudio", "lam"],
    ["audio/x-mid", ["mid", "midi"]],
    ["audio/x-midi", ["midi", "mid"]],
    ["audio/x-mod", "mod"],
    ["audio/x-mpeg", "mp2"],
    ["audio/x-mpeg-3", "mp3"],
    ["audio/x-mpegurl", "m3u"],
    ["audio/x-mpequrl", "m3u"],
    ["audio/x-ms-wax", "wax"],
    ["audio/x-ms-wma", "wma"],
    ["audio/x-nspaudio", ["la", "lma"]],
    ["audio/x-pn-realaudio", ["ra", "ram", "rm", "rmm", "rmp"]],
    ["audio/x-pn-realaudio-plugin", ["ra", "rmp", "rpm"]],
    ["audio/x-psid", "sid"],
    ["audio/x-realaudio", "ra"],
    ["audio/x-twinvq", "vqf"],
    ["audio/x-twinvq-plugin", ["vqe", "vql"]],
    ["audio/x-vnd.audioexplosion.mjuicemediafile", "mjf"],
    ["audio/x-voc", "voc"],
    ["audio/x-wav", "wav"],
    ["audio/xm", "xm"],
    ["chemical/x-cdx", "cdx"],
    ["chemical/x-cif", "cif"],
    ["chemical/x-cmdf", "cmdf"],
    ["chemical/x-cml", "cml"],
    ["chemical/x-csml", "csml"],
    ["chemical/x-pdb", ["pdb", "xyz"]],
    ["chemical/x-xyz", "xyz"],
    ["drawing/x-dwf", "dwf"],
    ["i-world/i-vrml", "ivr"],
    ["image/bmp", ["bmp", "bm"]],
    ["image/cgm", "cgm"],
    ["image/cis-cod", "cod"],
    ["image/cmu-raster", ["ras", "rast"]],
    ["image/fif", "fif"],
    ["image/florian", ["flo", "turbot"]],
    ["image/g3fax", "g3"],
    ["image/gif", "gif"],
    ["image/ief", ["ief", "iefs"]],
    ["image/jpeg", ["jpeg", "jpe", "jpg", "jfif", "jfif-tbnl"]],
    ["image/jutvision", "jut"],
    ["image/ktx", "ktx"],
    ["image/naplps", ["nap", "naplps"]],
    ["image/pict", ["pic", "pict"]],
    ["image/pipeg", "jfif"],
    ["image/pjpeg", ["jfif", "jpe", "jpeg", "jpg"]],
    ["image/png", ["png", "x-png"]],
    ["image/prs.btif", "btif"],
    ["image/svg+xml", "svg"],
    ["image/tiff", ["tif", "tiff"]],
    ["image/vasa", "mcf"],
    ["image/vnd.adobe.photoshop", "psd"],
    ["image/vnd.dece.graphic", "uvi"],
    ["image/vnd.djvu", "djvu"],
    ["image/vnd.dvb.subtitle", "sub"],
    ["image/vnd.dwg", ["dwg", "dxf", "svf"]],
    ["image/vnd.dxf", "dxf"],
    ["image/vnd.fastbidsheet", "fbs"],
    ["image/vnd.fpx", "fpx"],
    ["image/vnd.fst", "fst"],
    ["image/vnd.fujixerox.edmics-mmr", "mmr"],
    ["image/vnd.fujixerox.edmics-rlc", "rlc"],
    ["image/vnd.ms-modi", "mdi"],
    ["image/vnd.net-fpx", ["fpx", "npx"]],
    ["image/vnd.rn-realflash", "rf"],
    ["image/vnd.rn-realpix", "rp"],
    ["image/vnd.wap.wbmp", "wbmp"],
    ["image/vnd.xiff", "xif"],
    ["image/webp", "webp"],
    ["image/x-cmu-raster", "ras"],
    ["image/x-cmx", "cmx"],
    ["image/x-dwg", ["dwg", "dxf", "svf"]],
    ["image/x-freehand", "fh"],
    ["image/x-icon", "ico"],
    ["image/x-jg", "art"],
    ["image/x-jps", "jps"],
    ["image/x-niff", ["niff", "nif"]],
    ["image/x-pcx", "pcx"],
    ["image/x-pict", ["pct", "pic"]],
    ["image/x-portable-anymap", "pnm"],
    ["image/x-portable-bitmap", "pbm"],
    ["image/x-portable-graymap", "pgm"],
    ["image/x-portable-greymap", "pgm"],
    ["image/x-portable-pixmap", "ppm"],
    ["image/x-quicktime", ["qif", "qti", "qtif"]],
    ["image/x-rgb", "rgb"],
    ["image/x-tiff", ["tif", "tiff"]],
    ["image/x-windows-bmp", "bmp"],
    ["image/x-xbitmap", "xbm"],
    ["image/x-xbm", "xbm"],
    ["image/x-xpixmap", ["xpm", "pm"]],
    ["image/x-xwd", "xwd"],
    ["image/x-xwindowdump", "xwd"],
    ["image/xbm", "xbm"],
    ["image/xpm", "xpm"],
    ["message/rfc822", ["eml", "mht", "mhtml", "nws", "mime"]],
    ["model/iges", ["iges", "igs"]],
    ["model/mesh", "msh"],
    ["model/vnd.collada+xml", "dae"],
    ["model/vnd.dwf", "dwf"],
    ["model/vnd.gdl", "gdl"],
    ["model/vnd.gtw", "gtw"],
    ["model/vnd.mts", "mts"],
    ["model/vnd.vtu", "vtu"],
    ["model/vrml", ["vrml", "wrl", "wrz"]],
    ["model/x-pov", "pov"],
    ["multipart/x-gzip", "gzip"],
    ["multipart/x-ustar", "ustar"],
    ["multipart/x-zip", "zip"],
    ["music/crescendo", ["mid", "midi"]],
    ["music/x-karaoke", "kar"],
    ["paleovu/x-pv", "pvu"],
    ["text/asp", "asp"],
    ["text/calendar", "ics"],
    ["text/css", "css"],
    ["text/csv", "csv"],
    ["text/ecmascript", "js"],
    ["text/h323", "323"],
    ["text/html", ["html", "htm", "stm", "acgi", "htmls", "htx", "shtml"]],
    ["text/iuls", "uls"],
    ["text/javascript", "js"],
    ["text/mcf", "mcf"],
    ["text/n3", "n3"],
    ["text/pascal", "pas"],
    [
      "text/plain",
      [
        "txt",
        "bas",
        "c",
        "h",
        "c++",
        "cc",
        "com",
        "conf",
        "cxx",
        "def",
        "f",
        "f90",
        "for",
        "g",
        "hh",
        "idc",
        "jav",
        "java",
        "list",
        "log",
        "lst",
        "m",
        "mar",
        "pl",
        "sdml",
        "text"
      ]
    ],
    ["text/plain-bas", "par"],
    ["text/prs.lines.tag", "dsc"],
    ["text/richtext", ["rtx", "rt", "rtf"]],
    ["text/scriplet", "wsc"],
    ["text/scriptlet", "sct"],
    ["text/sgml", ["sgm", "sgml"]],
    ["text/tab-separated-values", "tsv"],
    ["text/troff", "t"],
    ["text/turtle", "ttl"],
    ["text/uri-list", ["uni", "unis", "uri", "uris"]],
    ["text/vnd.abc", "abc"],
    ["text/vnd.curl", "curl"],
    ["text/vnd.curl.dcurl", "dcurl"],
    ["text/vnd.curl.mcurl", "mcurl"],
    ["text/vnd.curl.scurl", "scurl"],
    ["text/vnd.fly", "fly"],
    ["text/vnd.fmi.flexstor", "flx"],
    ["text/vnd.graphviz", "gv"],
    ["text/vnd.in3d.3dml", "3dml"],
    ["text/vnd.in3d.spot", "spot"],
    ["text/vnd.rn-realtext", "rt"],
    ["text/vnd.sun.j2me.app-descriptor", "jad"],
    ["text/vnd.wap.wml", "wml"],
    ["text/vnd.wap.wmlscript", "wmls"],
    ["text/webviewhtml", "htt"],
    ["text/x-asm", ["asm", "s"]],
    ["text/x-audiosoft-intra", "aip"],
    ["text/x-c", ["c", "cc", "cpp"]],
    ["text/x-component", "htc"],
    ["text/x-fortran", ["for", "f", "f77", "f90"]],
    ["text/x-h", ["h", "hh"]],
    ["text/x-java-source", ["java", "jav"]],
    ["text/x-java-source,java", "java"],
    ["text/x-la-asf", "lsx"],
    ["text/x-m", "m"],
    ["text/x-pascal", "p"],
    ["text/x-script", "hlb"],
    ["text/x-script.csh", "csh"],
    ["text/x-script.elisp", "el"],
    ["text/x-script.guile", "scm"],
    ["text/x-script.ksh", "ksh"],
    ["text/x-script.lisp", "lsp"],
    ["text/x-script.perl", "pl"],
    ["text/x-script.perl-module", "pm"],
    ["text/x-script.phyton", "py"],
    ["text/x-script.rexx", "rexx"],
    ["text/x-script.scheme", "scm"],
    ["text/x-script.sh", "sh"],
    ["text/x-script.tcl", "tcl"],
    ["text/x-script.tcsh", "tcsh"],
    ["text/x-script.zsh", "zsh"],
    ["text/x-server-parsed-html", ["shtml", "ssi"]],
    ["text/x-setext", "etx"],
    ["text/x-sgml", ["sgm", "sgml"]],
    ["text/x-speech", ["spc", "talk"]],
    ["text/x-uil", "uil"],
    ["text/x-uuencode", ["uu", "uue"]],
    ["text/x-vcalendar", "vcs"],
    ["text/x-vcard", "vcf"],
    ["text/xml", "xml"],
    ["video/3gpp", "3gp"],
    ["video/3gpp2", "3g2"],
    ["video/animaflex", "afl"],
    ["video/avi", "avi"],
    ["video/avs-video", "avs"],
    ["video/dl", "dl"],
    ["video/fli", "fli"],
    ["video/gl", "gl"],
    ["video/h261", "h261"],
    ["video/h263", "h263"],
    ["video/h264", "h264"],
    ["video/jpeg", "jpgv"],
    ["video/jpm", "jpm"],
    ["video/mj2", "mj2"],
    ["video/mp4", "mp4"],
    ["video/mpeg", ["mpeg", "mp2", "mpa", "mpe", "mpg", "mpv2", "m1v", "m2v", "mp3"]],
    ["video/msvideo", "avi"],
    ["video/ogg", "ogv"],
    ["video/quicktime", ["mov", "qt", "moov"]],
    ["video/vdo", "vdo"],
    ["video/vivo", ["viv", "vivo"]],
    ["video/vnd.dece.hd", "uvh"],
    ["video/vnd.dece.mobile", "uvm"],
    ["video/vnd.dece.pd", "uvp"],
    ["video/vnd.dece.sd", "uvs"],
    ["video/vnd.dece.video", "uvv"],
    ["video/vnd.fvt", "fvt"],
    ["video/vnd.mpegurl", "mxu"],
    ["video/vnd.ms-playready.media.pyv", "pyv"],
    ["video/vnd.rn-realvideo", "rv"],
    ["video/vnd.uvvu.mp4", "uvu"],
    ["video/vnd.vivo", ["viv", "vivo"]],
    ["video/vosaic", "vos"],
    ["video/webm", "webm"],
    ["video/x-amt-demorun", "xdr"],
    ["video/x-amt-showrun", "xsr"],
    ["video/x-atomic3d-feature", "fmf"],
    ["video/x-dl", "dl"],
    ["video/x-dv", ["dif", "dv"]],
    ["video/x-f4v", "f4v"],
    ["video/x-fli", "fli"],
    ["video/x-flv", "flv"],
    ["video/x-gl", "gl"],
    ["video/x-isvideo", "isu"],
    ["video/x-la-asf", ["lsf", "lsx"]],
    ["video/x-m4v", "m4v"],
    ["video/x-motion-jpeg", "mjpg"],
    ["video/x-mpeg", ["mp3", "mp2"]],
    ["video/x-mpeq2a", "mp2"],
    ["video/x-ms-asf", ["asf", "asr", "asx"]],
    ["video/x-ms-asf-plugin", "asx"],
    ["video/x-ms-wm", "wm"],
    ["video/x-ms-wmv", "wmv"],
    ["video/x-ms-wmx", "wmx"],
    ["video/x-ms-wvx", "wvx"],
    ["video/x-msvideo", "avi"],
    ["video/x-qtc", "qtc"],
    ["video/x-scm", "scm"],
    ["video/x-sgi-movie", ["movie", "mv"]],
    ["windows/metafile", "wmf"],
    ["www/mime", "mime"],
    ["x-conference/x-cooltalk", "ice"],
    ["x-music/x-midi", ["mid", "midi"]],
    ["x-world/x-3dmf", ["3dm", "3dmf", "qd3", "qd3d"]],
    ["x-world/x-svr", "svr"],
    ["x-world/x-vrml", ["flr", "vrml", "wrl", "wrz", "xaf", "xof"]],
    ["x-world/x-vrt", "vrt"],
    ["xgl/drawing", "xgz"],
    ["xgl/movie", "xmz"]
  ]);
  var extensions = new Map([
    ["123", "application/vnd.lotus-1-2-3"],
    ["323", "text/h323"],
    ["*", "application/octet-stream"],
    ["3dm", "x-world/x-3dmf"],
    ["3dmf", "x-world/x-3dmf"],
    ["3dml", "text/vnd.in3d.3dml"],
    ["3g2", "video/3gpp2"],
    ["3gp", "video/3gpp"],
    ["7z", "application/x-7z-compressed"],
    ["a", "application/octet-stream"],
    ["aab", "application/x-authorware-bin"],
    ["aac", "audio/x-aac"],
    ["aam", "application/x-authorware-map"],
    ["aas", "application/x-authorware-seg"],
    ["abc", "text/vnd.abc"],
    ["abw", "application/x-abiword"],
    ["ac", "application/pkix-attr-cert"],
    ["acc", "application/vnd.americandynamics.acc"],
    ["ace", "application/x-ace-compressed"],
    ["acgi", "text/html"],
    ["acu", "application/vnd.acucobol"],
    ["acx", "application/internet-property-stream"],
    ["adp", "audio/adpcm"],
    ["aep", "application/vnd.audiograph"],
    ["afl", "video/animaflex"],
    ["afp", "application/vnd.ibm.modcap"],
    ["ahead", "application/vnd.ahead.space"],
    ["ai", "application/postscript"],
    ["aif", ["audio/aiff", "audio/x-aiff"]],
    ["aifc", ["audio/aiff", "audio/x-aiff"]],
    ["aiff", ["audio/aiff", "audio/x-aiff"]],
    ["aim", "application/x-aim"],
    ["aip", "text/x-audiosoft-intra"],
    ["air", "application/vnd.adobe.air-application-installer-package+zip"],
    ["ait", "application/vnd.dvb.ait"],
    ["ami", "application/vnd.amiga.ami"],
    ["ani", "application/x-navi-animation"],
    ["aos", "application/x-nokia-9000-communicator-add-on-software"],
    ["apk", "application/vnd.android.package-archive"],
    ["application", "application/x-ms-application"],
    ["apr", "application/vnd.lotus-approach"],
    ["aps", "application/mime"],
    ["arc", "application/octet-stream"],
    ["arj", ["application/arj", "application/octet-stream"]],
    ["art", "image/x-jg"],
    ["asf", "video/x-ms-asf"],
    ["asm", "text/x-asm"],
    ["aso", "application/vnd.accpac.simply.aso"],
    ["asp", "text/asp"],
    ["asr", "video/x-ms-asf"],
    ["asx", ["video/x-ms-asf", "application/x-mplayer2", "video/x-ms-asf-plugin"]],
    ["atc", "application/vnd.acucorp"],
    ["atomcat", "application/atomcat+xml"],
    ["atomsvc", "application/atomsvc+xml"],
    ["atx", "application/vnd.antix.game-component"],
    ["au", ["audio/basic", "audio/x-au"]],
    ["avi", ["video/avi", "video/msvideo", "application/x-troff-msvideo", "video/x-msvideo"]],
    ["avs", "video/avs-video"],
    ["aw", "application/applixware"],
    ["axs", "application/olescript"],
    ["azf", "application/vnd.airzip.filesecure.azf"],
    ["azs", "application/vnd.airzip.filesecure.azs"],
    ["azw", "application/vnd.amazon.ebook"],
    ["bas", "text/plain"],
    ["bcpio", "application/x-bcpio"],
    ["bdf", "application/x-font-bdf"],
    ["bdm", "application/vnd.syncml.dm+wbxml"],
    ["bed", "application/vnd.realvnc.bed"],
    ["bh2", "application/vnd.fujitsu.oasysprs"],
    ["bin", ["application/octet-stream", "application/mac-binary", "application/macbinary", "application/x-macbinary", "application/x-binary"]],
    ["bm", "image/bmp"],
    ["bmi", "application/vnd.bmi"],
    ["bmp", ["image/bmp", "image/x-windows-bmp"]],
    ["boo", "application/book"],
    ["book", "application/book"],
    ["box", "application/vnd.previewsystems.box"],
    ["boz", "application/x-bzip2"],
    ["bsh", "application/x-bsh"],
    ["btif", "image/prs.btif"],
    ["bz", "application/x-bzip"],
    ["bz2", "application/x-bzip2"],
    ["c", ["text/plain", "text/x-c"]],
    ["c++", "text/plain"],
    ["c11amc", "application/vnd.cluetrust.cartomobile-config"],
    ["c11amz", "application/vnd.cluetrust.cartomobile-config-pkg"],
    ["c4g", "application/vnd.clonk.c4group"],
    ["cab", "application/vnd.ms-cab-compressed"],
    ["car", "application/vnd.curl.car"],
    ["cat", ["application/vnd.ms-pkiseccat", "application/vnd.ms-pki.seccat"]],
    ["cc", ["text/plain", "text/x-c"]],
    ["ccad", "application/clariscad"],
    ["cco", "application/x-cocoa"],
    ["ccxml", "application/ccxml+xml,"],
    ["cdbcmsg", "application/vnd.contact.cmsg"],
    ["cdf", ["application/cdf", "application/x-cdf", "application/x-netcdf"]],
    ["cdkey", "application/vnd.mediastation.cdkey"],
    ["cdmia", "application/cdmi-capability"],
    ["cdmic", "application/cdmi-container"],
    ["cdmid", "application/cdmi-domain"],
    ["cdmio", "application/cdmi-object"],
    ["cdmiq", "application/cdmi-queue"],
    ["cdx", "chemical/x-cdx"],
    ["cdxml", "application/vnd.chemdraw+xml"],
    ["cdy", "application/vnd.cinderella"],
    ["cer", ["application/pkix-cert", "application/x-x509-ca-cert"]],
    ["cgm", "image/cgm"],
    ["cha", "application/x-chat"],
    ["chat", "application/x-chat"],
    ["chm", "application/vnd.ms-htmlhelp"],
    ["chrt", "application/vnd.kde.kchart"],
    ["cif", "chemical/x-cif"],
    ["cii", "application/vnd.anser-web-certificate-issue-initiation"],
    ["cil", "application/vnd.ms-artgalry"],
    ["cla", "application/vnd.claymore"],
    ["class", ["application/octet-stream", "application/java", "application/java-byte-code", "application/java-vm", "application/x-java-class"]],
    ["clkk", "application/vnd.crick.clicker.keyboard"],
    ["clkp", "application/vnd.crick.clicker.palette"],
    ["clkt", "application/vnd.crick.clicker.template"],
    ["clkw", "application/vnd.crick.clicker.wordbank"],
    ["clkx", "application/vnd.crick.clicker"],
    ["clp", "application/x-msclip"],
    ["cmc", "application/vnd.cosmocaller"],
    ["cmdf", "chemical/x-cmdf"],
    ["cml", "chemical/x-cml"],
    ["cmp", "application/vnd.yellowriver-custom-menu"],
    ["cmx", "image/x-cmx"],
    ["cod", ["image/cis-cod", "application/vnd.rim.cod"]],
    ["com", ["application/octet-stream", "text/plain"]],
    ["conf", "text/plain"],
    ["cpio", "application/x-cpio"],
    ["cpp", "text/x-c"],
    ["cpt", ["application/mac-compactpro", "application/x-compactpro", "application/x-cpt"]],
    ["crd", "application/x-mscardfile"],
    ["crl", ["application/pkix-crl", "application/pkcs-crl"]],
    ["crt", ["application/pkix-cert", "application/x-x509-user-cert", "application/x-x509-ca-cert"]],
    ["cryptonote", "application/vnd.rig.cryptonote"],
    ["csh", ["text/x-script.csh", "application/x-csh"]],
    ["csml", "chemical/x-csml"],
    ["csp", "application/vnd.commonspace"],
    ["css", ["text/css", "application/x-pointplus"]],
    ["csv", "text/csv"],
    ["cu", "application/cu-seeme"],
    ["curl", "text/vnd.curl"],
    ["cww", "application/prs.cww"],
    ["cxx", "text/plain"],
    ["dae", "model/vnd.collada+xml"],
    ["daf", "application/vnd.mobius.daf"],
    ["davmount", "application/davmount+xml"],
    ["dcr", "application/x-director"],
    ["dcurl", "text/vnd.curl.dcurl"],
    ["dd2", "application/vnd.oma.dd2+xml"],
    ["ddd", "application/vnd.fujixerox.ddd"],
    ["deb", "application/x-debian-package"],
    ["deepv", "application/x-deepv"],
    ["def", "text/plain"],
    ["der", "application/x-x509-ca-cert"],
    ["dfac", "application/vnd.dreamfactory"],
    ["dif", "video/x-dv"],
    ["dir", "application/x-director"],
    ["dis", "application/vnd.mobius.dis"],
    ["djvu", "image/vnd.djvu"],
    ["dl", ["video/dl", "video/x-dl"]],
    ["dll", "application/x-msdownload"],
    ["dms", "application/octet-stream"],
    ["dna", "application/vnd.dna"],
    ["doc", "application/msword"],
    ["docm", "application/vnd.ms-word.document.macroenabled.12"],
    ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
    ["dot", "application/msword"],
    ["dotm", "application/vnd.ms-word.template.macroenabled.12"],
    ["dotx", "application/vnd.openxmlformats-officedocument.wordprocessingml.template"],
    ["dp", ["application/commonground", "application/vnd.osgi.dp"]],
    ["dpg", "application/vnd.dpgraph"],
    ["dra", "audio/vnd.dra"],
    ["drw", "application/drafting"],
    ["dsc", "text/prs.lines.tag"],
    ["dssc", "application/dssc+der"],
    ["dtb", "application/x-dtbook+xml"],
    ["dtd", "application/xml-dtd"],
    ["dts", "audio/vnd.dts"],
    ["dtshd", "audio/vnd.dts.hd"],
    ["dump", "application/octet-stream"],
    ["dv", "video/x-dv"],
    ["dvi", "application/x-dvi"],
    ["dwf", ["model/vnd.dwf", "drawing/x-dwf"]],
    ["dwg", ["application/acad", "image/vnd.dwg", "image/x-dwg"]],
    ["dxf", ["application/dxf", "image/vnd.dwg", "image/vnd.dxf", "image/x-dwg"]],
    ["dxp", "application/vnd.spotfire.dxp"],
    ["dxr", "application/x-director"],
    ["ecelp4800", "audio/vnd.nuera.ecelp4800"],
    ["ecelp7470", "audio/vnd.nuera.ecelp7470"],
    ["ecelp9600", "audio/vnd.nuera.ecelp9600"],
    ["edm", "application/vnd.novadigm.edm"],
    ["edx", "application/vnd.novadigm.edx"],
    ["efif", "application/vnd.picsel"],
    ["ei6", "application/vnd.pg.osasli"],
    ["el", "text/x-script.elisp"],
    ["elc", ["application/x-elc", "application/x-bytecode.elisp"]],
    ["eml", "message/rfc822"],
    ["emma", "application/emma+xml"],
    ["env", "application/x-envoy"],
    ["eol", "audio/vnd.digital-winds"],
    ["eot", "application/vnd.ms-fontobject"],
    ["eps", "application/postscript"],
    ["epub", "application/epub+zip"],
    ["es", ["application/ecmascript", "application/x-esrehber"]],
    ["es3", "application/vnd.eszigno3+xml"],
    ["esf", "application/vnd.epson.esf"],
    ["etx", "text/x-setext"],
    ["evy", ["application/envoy", "application/x-envoy"]],
    ["exe", ["application/octet-stream", "application/x-msdownload"]],
    ["exi", "application/exi"],
    ["ext", "application/vnd.novadigm.ext"],
    ["ez2", "application/vnd.ezpix-album"],
    ["ez3", "application/vnd.ezpix-package"],
    ["f", ["text/plain", "text/x-fortran"]],
    ["f4v", "video/x-f4v"],
    ["f77", "text/x-fortran"],
    ["f90", ["text/plain", "text/x-fortran"]],
    ["fbs", "image/vnd.fastbidsheet"],
    ["fcs", "application/vnd.isac.fcs"],
    ["fdf", "application/vnd.fdf"],
    ["fe_launch", "application/vnd.denovo.fcselayout-link"],
    ["fg5", "application/vnd.fujitsu.oasysgp"],
    ["fh", "image/x-freehand"],
    ["fif", ["application/fractals", "image/fif"]],
    ["fig", "application/x-xfig"],
    ["fli", ["video/fli", "video/x-fli"]],
    ["flo", ["image/florian", "application/vnd.micrografx.flo"]],
    ["flr", "x-world/x-vrml"],
    ["flv", "video/x-flv"],
    ["flw", "application/vnd.kde.kivio"],
    ["flx", "text/vnd.fmi.flexstor"],
    ["fly", "text/vnd.fly"],
    ["fm", "application/vnd.framemaker"],
    ["fmf", "video/x-atomic3d-feature"],
    ["fnc", "application/vnd.frogans.fnc"],
    ["for", ["text/plain", "text/x-fortran"]],
    ["fpx", ["image/vnd.fpx", "image/vnd.net-fpx"]],
    ["frl", "application/freeloader"],
    ["fsc", "application/vnd.fsc.weblaunch"],
    ["fst", "image/vnd.fst"],
    ["ftc", "application/vnd.fluxtime.clip"],
    ["fti", "application/vnd.anser-web-funds-transfer-initiation"],
    ["funk", "audio/make"],
    ["fvt", "video/vnd.fvt"],
    ["fxp", "application/vnd.adobe.fxp"],
    ["fzs", "application/vnd.fuzzysheet"],
    ["g", "text/plain"],
    ["g2w", "application/vnd.geoplan"],
    ["g3", "image/g3fax"],
    ["g3w", "application/vnd.geospace"],
    ["gac", "application/vnd.groove-account"],
    ["gdl", "model/vnd.gdl"],
    ["geo", "application/vnd.dynageo"],
    ["geojson", "application/geo+json"],
    ["gex", "application/vnd.geometry-explorer"],
    ["ggb", "application/vnd.geogebra.file"],
    ["ggt", "application/vnd.geogebra.tool"],
    ["ghf", "application/vnd.groove-help"],
    ["gif", "image/gif"],
    ["gim", "application/vnd.groove-identity-message"],
    ["gl", ["video/gl", "video/x-gl"]],
    ["gmx", "application/vnd.gmx"],
    ["gnumeric", "application/x-gnumeric"],
    ["gph", "application/vnd.flographit"],
    ["gqf", "application/vnd.grafeq"],
    ["gram", "application/srgs"],
    ["grv", "application/vnd.groove-injector"],
    ["grxml", "application/srgs+xml"],
    ["gsd", "audio/x-gsm"],
    ["gsf", "application/x-font-ghostscript"],
    ["gsm", "audio/x-gsm"],
    ["gsp", "application/x-gsp"],
    ["gss", "application/x-gss"],
    ["gtar", "application/x-gtar"],
    ["gtm", "application/vnd.groove-tool-message"],
    ["gtw", "model/vnd.gtw"],
    ["gv", "text/vnd.graphviz"],
    ["gxt", "application/vnd.geonext"],
    ["gz", ["application/x-gzip", "application/x-compressed"]],
    ["gzip", ["multipart/x-gzip", "application/x-gzip"]],
    ["h", ["text/plain", "text/x-h"]],
    ["h261", "video/h261"],
    ["h263", "video/h263"],
    ["h264", "video/h264"],
    ["hal", "application/vnd.hal+xml"],
    ["hbci", "application/vnd.hbci"],
    ["hdf", "application/x-hdf"],
    ["help", "application/x-helpfile"],
    ["hgl", "application/vnd.hp-hpgl"],
    ["hh", ["text/plain", "text/x-h"]],
    ["hlb", "text/x-script"],
    ["hlp", ["application/winhlp", "application/hlp", "application/x-helpfile", "application/x-winhelp"]],
    ["hpg", "application/vnd.hp-hpgl"],
    ["hpgl", "application/vnd.hp-hpgl"],
    ["hpid", "application/vnd.hp-hpid"],
    ["hps", "application/vnd.hp-hps"],
    [
      "hqx",
      [
        "application/mac-binhex40",
        "application/binhex",
        "application/binhex4",
        "application/mac-binhex",
        "application/x-binhex40",
        "application/x-mac-binhex40"
      ]
    ],
    ["hta", "application/hta"],
    ["htc", "text/x-component"],
    ["htke", "application/vnd.kenameaapp"],
    ["htm", "text/html"],
    ["html", "text/html"],
    ["htmls", "text/html"],
    ["htt", "text/webviewhtml"],
    ["htx", "text/html"],
    ["hvd", "application/vnd.yamaha.hv-dic"],
    ["hvp", "application/vnd.yamaha.hv-voice"],
    ["hvs", "application/vnd.yamaha.hv-script"],
    ["i2g", "application/vnd.intergeo"],
    ["icc", "application/vnd.iccprofile"],
    ["ice", "x-conference/x-cooltalk"],
    ["ico", "image/x-icon"],
    ["ics", "text/calendar"],
    ["idc", "text/plain"],
    ["ief", "image/ief"],
    ["iefs", "image/ief"],
    ["ifm", "application/vnd.shana.informed.formdata"],
    ["iges", ["application/iges", "model/iges"]],
    ["igl", "application/vnd.igloader"],
    ["igm", "application/vnd.insors.igm"],
    ["igs", ["application/iges", "model/iges"]],
    ["igx", "application/vnd.micrografx.igx"],
    ["iif", "application/vnd.shana.informed.interchange"],
    ["iii", "application/x-iphone"],
    ["ima", "application/x-ima"],
    ["imap", "application/x-httpd-imap"],
    ["imp", "application/vnd.accpac.simply.imp"],
    ["ims", "application/vnd.ms-ims"],
    ["inf", "application/inf"],
    ["ins", ["application/x-internet-signup", "application/x-internett-signup"]],
    ["ip", "application/x-ip2"],
    ["ipfix", "application/ipfix"],
    ["ipk", "application/vnd.shana.informed.package"],
    ["irm", "application/vnd.ibm.rights-management"],
    ["irp", "application/vnd.irepository.package+xml"],
    ["isp", "application/x-internet-signup"],
    ["isu", "video/x-isvideo"],
    ["it", "audio/it"],
    ["itp", "application/vnd.shana.informed.formtemplate"],
    ["iv", "application/x-inventor"],
    ["ivp", "application/vnd.immervision-ivp"],
    ["ivr", "i-world/i-vrml"],
    ["ivu", "application/vnd.immervision-ivu"],
    ["ivy", "application/x-livescreen"],
    ["jad", "text/vnd.sun.j2me.app-descriptor"],
    ["jam", ["application/vnd.jam", "audio/x-jam"]],
    ["jar", "application/java-archive"],
    ["jav", ["text/plain", "text/x-java-source"]],
    ["java", ["text/plain", "text/x-java-source,java", "text/x-java-source"]],
    ["jcm", "application/x-java-commerce"],
    ["jfif", ["image/pipeg", "image/jpeg", "image/pjpeg"]],
    ["jfif-tbnl", "image/jpeg"],
    ["jisp", "application/vnd.jisp"],
    ["jlt", "application/vnd.hp-jlyt"],
    ["jnlp", "application/x-java-jnlp-file"],
    ["joda", "application/vnd.joost.joda-archive"],
    ["jpe", ["image/jpeg", "image/pjpeg"]],
    ["jpeg", ["image/jpeg", "image/pjpeg"]],
    ["jpg", ["image/jpeg", "image/pjpeg"]],
    ["jpgv", "video/jpeg"],
    ["jpm", "video/jpm"],
    ["jps", "image/x-jps"],
    ["js", ["application/javascript", "application/ecmascript", "text/javascript", "text/ecmascript", "application/x-javascript"]],
    ["json", "application/json"],
    ["jut", "image/jutvision"],
    ["kar", ["audio/midi", "music/x-karaoke"]],
    ["karbon", "application/vnd.kde.karbon"],
    ["kfo", "application/vnd.kde.kformula"],
    ["kia", "application/vnd.kidspiration"],
    ["kml", "application/vnd.google-earth.kml+xml"],
    ["kmz", "application/vnd.google-earth.kmz"],
    ["kne", "application/vnd.kinar"],
    ["kon", "application/vnd.kde.kontour"],
    ["kpr", "application/vnd.kde.kpresenter"],
    ["ksh", ["application/x-ksh", "text/x-script.ksh"]],
    ["ksp", "application/vnd.kde.kspread"],
    ["ktx", "image/ktx"],
    ["ktz", "application/vnd.kahootz"],
    ["kwd", "application/vnd.kde.kword"],
    ["la", ["audio/nspaudio", "audio/x-nspaudio"]],
    ["lam", "audio/x-liveaudio"],
    ["lasxml", "application/vnd.las.las+xml"],
    ["latex", "application/x-latex"],
    ["lbd", "application/vnd.llamagraphics.life-balance.desktop"],
    ["lbe", "application/vnd.llamagraphics.life-balance.exchange+xml"],
    ["les", "application/vnd.hhe.lesson-player"],
    ["lha", ["application/octet-stream", "application/lha", "application/x-lha"]],
    ["lhx", "application/octet-stream"],
    ["link66", "application/vnd.route66.link66+xml"],
    ["list", "text/plain"],
    ["lma", ["audio/nspaudio", "audio/x-nspaudio"]],
    ["log", "text/plain"],
    ["lrm", "application/vnd.ms-lrm"],
    ["lsf", "video/x-la-asf"],
    ["lsp", ["application/x-lisp", "text/x-script.lisp"]],
    ["lst", "text/plain"],
    ["lsx", ["video/x-la-asf", "text/x-la-asf"]],
    ["ltf", "application/vnd.frogans.ltf"],
    ["ltx", "application/x-latex"],
    ["lvp", "audio/vnd.lucent.voice"],
    ["lwp", "application/vnd.lotus-wordpro"],
    ["lzh", ["application/octet-stream", "application/x-lzh"]],
    ["lzx", ["application/lzx", "application/octet-stream", "application/x-lzx"]],
    ["m", ["text/plain", "text/x-m"]],
    ["m13", "application/x-msmediaview"],
    ["m14", "application/x-msmediaview"],
    ["m1v", "video/mpeg"],
    ["m21", "application/mp21"],
    ["m2a", "audio/mpeg"],
    ["m2v", "video/mpeg"],
    ["m3u", ["audio/x-mpegurl", "audio/x-mpequrl"]],
    ["m3u8", "application/vnd.apple.mpegurl"],
    ["m4v", "video/x-m4v"],
    ["ma", "application/mathematica"],
    ["mads", "application/mads+xml"],
    ["mag", "application/vnd.ecowin.chart"],
    ["man", "application/x-troff-man"],
    ["map", "application/x-navimap"],
    ["mar", "text/plain"],
    ["mathml", "application/mathml+xml"],
    ["mbd", "application/mbedlet"],
    ["mbk", "application/vnd.mobius.mbk"],
    ["mbox", "application/mbox"],
    ["mc$", "application/x-magic-cap-package-1.0"],
    ["mc1", "application/vnd.medcalcdata"],
    ["mcd", ["application/mcad", "application/vnd.mcd", "application/x-mathcad"]],
    ["mcf", ["image/vasa", "text/mcf"]],
    ["mcp", "application/netmc"],
    ["mcurl", "text/vnd.curl.mcurl"],
    ["mdb", "application/x-msaccess"],
    ["mdi", "image/vnd.ms-modi"],
    ["me", "application/x-troff-me"],
    ["meta4", "application/metalink4+xml"],
    ["mets", "application/mets+xml"],
    ["mfm", "application/vnd.mfmp"],
    ["mgp", "application/vnd.osgeo.mapguide.package"],
    ["mgz", "application/vnd.proteus.magazine"],
    ["mht", "message/rfc822"],
    ["mhtml", "message/rfc822"],
    ["mid", ["audio/mid", "audio/midi", "music/crescendo", "x-music/x-midi", "audio/x-midi", "application/x-midi", "audio/x-mid"]],
    ["midi", ["audio/midi", "music/crescendo", "x-music/x-midi", "audio/x-midi", "application/x-midi", "audio/x-mid"]],
    ["mif", ["application/vnd.mif", "application/x-mif", "application/x-frame"]],
    ["mime", ["message/rfc822", "www/mime"]],
    ["mj2", "video/mj2"],
    ["mjf", "audio/x-vnd.audioexplosion.mjuicemediafile"],
    ["mjpg", "video/x-motion-jpeg"],
    ["mlp", "application/vnd.dolby.mlp"],
    ["mm", ["application/base64", "application/x-meme"]],
    ["mmd", "application/vnd.chipnuts.karaoke-mmd"],
    ["mme", "application/base64"],
    ["mmf", "application/vnd.smaf"],
    ["mmr", "image/vnd.fujixerox.edmics-mmr"],
    ["mny", "application/x-msmoney"],
    ["mod", ["audio/mod", "audio/x-mod"]],
    ["mods", "application/mods+xml"],
    ["moov", "video/quicktime"],
    ["mov", "video/quicktime"],
    ["movie", "video/x-sgi-movie"],
    ["mp2", ["video/mpeg", "audio/mpeg", "video/x-mpeg", "audio/x-mpeg", "video/x-mpeq2a"]],
    ["mp3", ["audio/mpeg", "audio/mpeg3", "video/mpeg", "audio/x-mpeg-3", "video/x-mpeg"]],
    ["mp4", ["video/mp4", "application/mp4"]],
    ["mp4a", "audio/mp4"],
    ["mpa", ["video/mpeg", "audio/mpeg"]],
    ["mpc", ["application/vnd.mophun.certificate", "application/x-project"]],
    ["mpe", "video/mpeg"],
    ["mpeg", "video/mpeg"],
    ["mpg", ["video/mpeg", "audio/mpeg"]],
    ["mpga", "audio/mpeg"],
    ["mpkg", "application/vnd.apple.installer+xml"],
    ["mpm", "application/vnd.blueice.multipass"],
    ["mpn", "application/vnd.mophun.application"],
    ["mpp", "application/vnd.ms-project"],
    ["mpt", "application/x-project"],
    ["mpv", "application/x-project"],
    ["mpv2", "video/mpeg"],
    ["mpx", "application/x-project"],
    ["mpy", "application/vnd.ibm.minipay"],
    ["mqy", "application/vnd.mobius.mqy"],
    ["mrc", "application/marc"],
    ["mrcx", "application/marcxml+xml"],
    ["ms", "application/x-troff-ms"],
    ["mscml", "application/mediaservercontrol+xml"],
    ["mseq", "application/vnd.mseq"],
    ["msf", "application/vnd.epson.msf"],
    ["msg", "application/vnd.ms-outlook"],
    ["msh", "model/mesh"],
    ["msl", "application/vnd.mobius.msl"],
    ["msty", "application/vnd.muvee.style"],
    ["mts", "model/vnd.mts"],
    ["mus", "application/vnd.musician"],
    ["musicxml", "application/vnd.recordare.musicxml+xml"],
    ["mv", "video/x-sgi-movie"],
    ["mvb", "application/x-msmediaview"],
    ["mwf", "application/vnd.mfer"],
    ["mxf", "application/mxf"],
    ["mxl", "application/vnd.recordare.musicxml"],
    ["mxml", "application/xv+xml"],
    ["mxs", "application/vnd.triscape.mxs"],
    ["mxu", "video/vnd.mpegurl"],
    ["my", "audio/make"],
    ["mzz", "application/x-vnd.audioexplosion.mzz"],
    ["n-gage", "application/vnd.nokia.n-gage.symbian.install"],
    ["n3", "text/n3"],
    ["nap", "image/naplps"],
    ["naplps", "image/naplps"],
    ["nbp", "application/vnd.wolfram.player"],
    ["nc", "application/x-netcdf"],
    ["ncm", "application/vnd.nokia.configuration-message"],
    ["ncx", "application/x-dtbncx+xml"],
    ["ngdat", "application/vnd.nokia.n-gage.data"],
    ["nif", "image/x-niff"],
    ["niff", "image/x-niff"],
    ["nix", "application/x-mix-transfer"],
    ["nlu", "application/vnd.neurolanguage.nlu"],
    ["nml", "application/vnd.enliven"],
    ["nnd", "application/vnd.noblenet-directory"],
    ["nns", "application/vnd.noblenet-sealer"],
    ["nnw", "application/vnd.noblenet-web"],
    ["npx", "image/vnd.net-fpx"],
    ["nsc", "application/x-conference"],
    ["nsf", "application/vnd.lotus-notes"],
    ["nvd", "application/x-navidoc"],
    ["nws", "message/rfc822"],
    ["o", "application/octet-stream"],
    ["oa2", "application/vnd.fujitsu.oasys2"],
    ["oa3", "application/vnd.fujitsu.oasys3"],
    ["oas", "application/vnd.fujitsu.oasys"],
    ["obd", "application/x-msbinder"],
    ["oda", "application/oda"],
    ["odb", "application/vnd.oasis.opendocument.database"],
    ["odc", "application/vnd.oasis.opendocument.chart"],
    ["odf", "application/vnd.oasis.opendocument.formula"],
    ["odft", "application/vnd.oasis.opendocument.formula-template"],
    ["odg", "application/vnd.oasis.opendocument.graphics"],
    ["odi", "application/vnd.oasis.opendocument.image"],
    ["odm", "application/vnd.oasis.opendocument.text-master"],
    ["odp", "application/vnd.oasis.opendocument.presentation"],
    ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
    ["odt", "application/vnd.oasis.opendocument.text"],
    ["oga", "audio/ogg"],
    ["ogv", "video/ogg"],
    ["ogx", "application/ogg"],
    ["omc", "application/x-omc"],
    ["omcd", "application/x-omcdatamaker"],
    ["omcr", "application/x-omcregerator"],
    ["onetoc", "application/onenote"],
    ["opf", "application/oebps-package+xml"],
    ["org", "application/vnd.lotus-organizer"],
    ["osf", "application/vnd.yamaha.openscoreformat"],
    ["osfpvg", "application/vnd.yamaha.openscoreformat.osfpvg+xml"],
    ["otc", "application/vnd.oasis.opendocument.chart-template"],
    ["otf", "application/x-font-otf"],
    ["otg", "application/vnd.oasis.opendocument.graphics-template"],
    ["oth", "application/vnd.oasis.opendocument.text-web"],
    ["oti", "application/vnd.oasis.opendocument.image-template"],
    ["otp", "application/vnd.oasis.opendocument.presentation-template"],
    ["ots", "application/vnd.oasis.opendocument.spreadsheet-template"],
    ["ott", "application/vnd.oasis.opendocument.text-template"],
    ["oxt", "application/vnd.openofficeorg.extension"],
    ["p", "text/x-pascal"],
    ["p10", ["application/pkcs10", "application/x-pkcs10"]],
    ["p12", ["application/pkcs-12", "application/x-pkcs12"]],
    ["p7a", "application/x-pkcs7-signature"],
    ["p7b", "application/x-pkcs7-certificates"],
    ["p7c", ["application/pkcs7-mime", "application/x-pkcs7-mime"]],
    ["p7m", ["application/pkcs7-mime", "application/x-pkcs7-mime"]],
    ["p7r", "application/x-pkcs7-certreqresp"],
    ["p7s", ["application/pkcs7-signature", "application/x-pkcs7-signature"]],
    ["p8", "application/pkcs8"],
    ["par", "text/plain-bas"],
    ["part", "application/pro_eng"],
    ["pas", "text/pascal"],
    ["paw", "application/vnd.pawaafile"],
    ["pbd", "application/vnd.powerbuilder6"],
    ["pbm", "image/x-portable-bitmap"],
    ["pcf", "application/x-font-pcf"],
    ["pcl", ["application/vnd.hp-pcl", "application/x-pcl"]],
    ["pclxl", "application/vnd.hp-pclxl"],
    ["pct", "image/x-pict"],
    ["pcurl", "application/vnd.curl.pcurl"],
    ["pcx", "image/x-pcx"],
    ["pdb", ["application/vnd.palm", "chemical/x-pdb"]],
    ["pdf", "application/pdf"],
    ["pfa", "application/x-font-type1"],
    ["pfr", "application/font-tdpfr"],
    ["pfunk", ["audio/make", "audio/make.my.funk"]],
    ["pfx", "application/x-pkcs12"],
    ["pgm", ["image/x-portable-graymap", "image/x-portable-greymap"]],
    ["pgn", "application/x-chess-pgn"],
    ["pgp", "application/pgp-signature"],
    ["pic", ["image/pict", "image/x-pict"]],
    ["pict", "image/pict"],
    ["pkg", "application/x-newton-compatible-pkg"],
    ["pki", "application/pkixcmp"],
    ["pkipath", "application/pkix-pkipath"],
    ["pko", ["application/ynd.ms-pkipko", "application/vnd.ms-pki.pko"]],
    ["pl", ["text/plain", "text/x-script.perl"]],
    ["plb", "application/vnd.3gpp.pic-bw-large"],
    ["plc", "application/vnd.mobius.plc"],
    ["plf", "application/vnd.pocketlearn"],
    ["pls", "application/pls+xml"],
    ["plx", "application/x-pixclscript"],
    ["pm", ["text/x-script.perl-module", "image/x-xpixmap"]],
    ["pm4", "application/x-pagemaker"],
    ["pm5", "application/x-pagemaker"],
    ["pma", "application/x-perfmon"],
    ["pmc", "application/x-perfmon"],
    ["pml", ["application/vnd.ctc-posml", "application/x-perfmon"]],
    ["pmr", "application/x-perfmon"],
    ["pmw", "application/x-perfmon"],
    ["png", "image/png"],
    ["pnm", ["application/x-portable-anymap", "image/x-portable-anymap"]],
    ["portpkg", "application/vnd.macports.portpkg"],
    ["pot", ["application/vnd.ms-powerpoint", "application/mspowerpoint"]],
    ["potm", "application/vnd.ms-powerpoint.template.macroenabled.12"],
    ["potx", "application/vnd.openxmlformats-officedocument.presentationml.template"],
    ["pov", "model/x-pov"],
    ["ppa", "application/vnd.ms-powerpoint"],
    ["ppam", "application/vnd.ms-powerpoint.addin.macroenabled.12"],
    ["ppd", "application/vnd.cups-ppd"],
    ["ppm", "image/x-portable-pixmap"],
    ["pps", ["application/vnd.ms-powerpoint", "application/mspowerpoint"]],
    ["ppsm", "application/vnd.ms-powerpoint.slideshow.macroenabled.12"],
    ["ppsx", "application/vnd.openxmlformats-officedocument.presentationml.slideshow"],
    ["ppt", ["application/vnd.ms-powerpoint", "application/mspowerpoint", "application/powerpoint", "application/x-mspowerpoint"]],
    ["pptm", "application/vnd.ms-powerpoint.presentation.macroenabled.12"],
    ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
    ["ppz", "application/mspowerpoint"],
    ["prc", "application/x-mobipocket-ebook"],
    ["pre", ["application/vnd.lotus-freelance", "application/x-freelance"]],
    ["prf", "application/pics-rules"],
    ["prt", "application/pro_eng"],
    ["ps", "application/postscript"],
    ["psb", "application/vnd.3gpp.pic-bw-small"],
    ["psd", ["application/octet-stream", "image/vnd.adobe.photoshop"]],
    ["psf", "application/x-font-linux-psf"],
    ["pskcxml", "application/pskc+xml"],
    ["ptid", "application/vnd.pvi.ptid1"],
    ["pub", "application/x-mspublisher"],
    ["pvb", "application/vnd.3gpp.pic-bw-var"],
    ["pvu", "paleovu/x-pv"],
    ["pwn", "application/vnd.3m.post-it-notes"],
    ["pwz", "application/vnd.ms-powerpoint"],
    ["py", "text/x-script.phyton"],
    ["pya", "audio/vnd.ms-playready.media.pya"],
    ["pyc", "application/x-bytecode.python"],
    ["pyv", "video/vnd.ms-playready.media.pyv"],
    ["qam", "application/vnd.epson.quickanime"],
    ["qbo", "application/vnd.intu.qbo"],
    ["qcp", "audio/vnd.qcelp"],
    ["qd3", "x-world/x-3dmf"],
    ["qd3d", "x-world/x-3dmf"],
    ["qfx", "application/vnd.intu.qfx"],
    ["qif", "image/x-quicktime"],
    ["qps", "application/vnd.publishare-delta-tree"],
    ["qt", "video/quicktime"],
    ["qtc", "video/x-qtc"],
    ["qti", "image/x-quicktime"],
    ["qtif", "image/x-quicktime"],
    ["qxd", "application/vnd.quark.quarkxpress"],
    ["ra", ["audio/x-realaudio", "audio/x-pn-realaudio", "audio/x-pn-realaudio-plugin"]],
    ["ram", "audio/x-pn-realaudio"],
    ["rar", "application/x-rar-compressed"],
    ["ras", ["image/cmu-raster", "application/x-cmu-raster", "image/x-cmu-raster"]],
    ["rast", "image/cmu-raster"],
    ["rcprofile", "application/vnd.ipunplugged.rcprofile"],
    ["rdf", "application/rdf+xml"],
    ["rdz", "application/vnd.data-vision.rdz"],
    ["rep", "application/vnd.businessobjects"],
    ["res", "application/x-dtbresource+xml"],
    ["rexx", "text/x-script.rexx"],
    ["rf", "image/vnd.rn-realflash"],
    ["rgb", "image/x-rgb"],
    ["rif", "application/reginfo+xml"],
    ["rip", "audio/vnd.rip"],
    ["rl", "application/resource-lists+xml"],
    ["rlc", "image/vnd.fujixerox.edmics-rlc"],
    ["rld", "application/resource-lists-diff+xml"],
    ["rm", ["application/vnd.rn-realmedia", "audio/x-pn-realaudio"]],
    ["rmi", "audio/mid"],
    ["rmm", "audio/x-pn-realaudio"],
    ["rmp", ["audio/x-pn-realaudio-plugin", "audio/x-pn-realaudio"]],
    ["rms", "application/vnd.jcp.javame.midlet-rms"],
    ["rnc", "application/relax-ng-compact-syntax"],
    ["rng", ["application/ringing-tones", "application/vnd.nokia.ringing-tone"]],
    ["rnx", "application/vnd.rn-realplayer"],
    ["roff", "application/x-troff"],
    ["rp", "image/vnd.rn-realpix"],
    ["rp9", "application/vnd.cloanto.rp9"],
    ["rpm", "audio/x-pn-realaudio-plugin"],
    ["rpss", "application/vnd.nokia.radio-presets"],
    ["rpst", "application/vnd.nokia.radio-preset"],
    ["rq", "application/sparql-query"],
    ["rs", "application/rls-services+xml"],
    ["rsd", "application/rsd+xml"],
    ["rt", ["text/richtext", "text/vnd.rn-realtext"]],
    ["rtf", ["application/rtf", "text/richtext", "application/x-rtf"]],
    ["rtx", ["text/richtext", "application/rtf"]],
    ["rv", "video/vnd.rn-realvideo"],
    ["s", "text/x-asm"],
    ["s3m", "audio/s3m"],
    ["saf", "application/vnd.yamaha.smaf-audio"],
    ["saveme", "application/octet-stream"],
    ["sbk", "application/x-tbook"],
    ["sbml", "application/sbml+xml"],
    ["sc", "application/vnd.ibm.secure-container"],
    ["scd", "application/x-msschedule"],
    ["scm", ["application/vnd.lotus-screencam", "video/x-scm", "text/x-script.guile", "application/x-lotusscreencam", "text/x-script.scheme"]],
    ["scq", "application/scvp-cv-request"],
    ["scs", "application/scvp-cv-response"],
    ["sct", "text/scriptlet"],
    ["scurl", "text/vnd.curl.scurl"],
    ["sda", "application/vnd.stardivision.draw"],
    ["sdc", "application/vnd.stardivision.calc"],
    ["sdd", "application/vnd.stardivision.impress"],
    ["sdkm", "application/vnd.solent.sdkm+xml"],
    ["sdml", "text/plain"],
    ["sdp", ["application/sdp", "application/x-sdp"]],
    ["sdr", "application/sounder"],
    ["sdw", "application/vnd.stardivision.writer"],
    ["sea", ["application/sea", "application/x-sea"]],
    ["see", "application/vnd.seemail"],
    ["seed", "application/vnd.fdsn.seed"],
    ["sema", "application/vnd.sema"],
    ["semd", "application/vnd.semd"],
    ["semf", "application/vnd.semf"],
    ["ser", "application/java-serialized-object"],
    ["set", "application/set"],
    ["setpay", "application/set-payment-initiation"],
    ["setreg", "application/set-registration-initiation"],
    ["sfd-hdstx", "application/vnd.hydrostatix.sof-data"],
    ["sfs", "application/vnd.spotfire.sfs"],
    ["sgl", "application/vnd.stardivision.writer-global"],
    ["sgm", ["text/sgml", "text/x-sgml"]],
    ["sgml", ["text/sgml", "text/x-sgml"]],
    ["sh", ["application/x-shar", "application/x-bsh", "application/x-sh", "text/x-script.sh"]],
    ["shar", ["application/x-bsh", "application/x-shar"]],
    ["shf", "application/shf+xml"],
    ["shtml", ["text/html", "text/x-server-parsed-html"]],
    ["sid", "audio/x-psid"],
    ["sis", "application/vnd.symbian.install"],
    ["sit", ["application/x-stuffit", "application/x-sit"]],
    ["sitx", "application/x-stuffitx"],
    ["skd", "application/x-koan"],
    ["skm", "application/x-koan"],
    ["skp", ["application/vnd.koan", "application/x-koan"]],
    ["skt", "application/x-koan"],
    ["sl", "application/x-seelogo"],
    ["sldm", "application/vnd.ms-powerpoint.slide.macroenabled.12"],
    ["sldx", "application/vnd.openxmlformats-officedocument.presentationml.slide"],
    ["slt", "application/vnd.epson.salt"],
    ["sm", "application/vnd.stepmania.stepchart"],
    ["smf", "application/vnd.stardivision.math"],
    ["smi", ["application/smil", "application/smil+xml"]],
    ["smil", "application/smil"],
    ["snd", ["audio/basic", "audio/x-adpcm"]],
    ["snf", "application/x-font-snf"],
    ["sol", "application/solids"],
    ["spc", ["text/x-speech", "application/x-pkcs7-certificates"]],
    ["spf", "application/vnd.yamaha.smaf-phrase"],
    ["spl", ["application/futuresplash", "application/x-futuresplash"]],
    ["spot", "text/vnd.in3d.spot"],
    ["spp", "application/scvp-vp-response"],
    ["spq", "application/scvp-vp-request"],
    ["spr", "application/x-sprite"],
    ["sprite", "application/x-sprite"],
    ["src", "application/x-wais-source"],
    ["sru", "application/sru+xml"],
    ["srx", "application/sparql-results+xml"],
    ["sse", "application/vnd.kodak-descriptor"],
    ["ssf", "application/vnd.epson.ssf"],
    ["ssi", "text/x-server-parsed-html"],
    ["ssm", "application/streamingmedia"],
    ["ssml", "application/ssml+xml"],
    ["sst", ["application/vnd.ms-pkicertstore", "application/vnd.ms-pki.certstore"]],
    ["st", "application/vnd.sailingtracker.track"],
    ["stc", "application/vnd.sun.xml.calc.template"],
    ["std", "application/vnd.sun.xml.draw.template"],
    ["step", "application/step"],
    ["stf", "application/vnd.wt.stf"],
    ["sti", "application/vnd.sun.xml.impress.template"],
    ["stk", "application/hyperstudio"],
    ["stl", ["application/vnd.ms-pkistl", "application/sla", "application/vnd.ms-pki.stl", "application/x-navistyle"]],
    ["stm", "text/html"],
    ["stp", "application/step"],
    ["str", "application/vnd.pg.format"],
    ["stw", "application/vnd.sun.xml.writer.template"],
    ["sub", "image/vnd.dvb.subtitle"],
    ["sus", "application/vnd.sus-calendar"],
    ["sv4cpio", "application/x-sv4cpio"],
    ["sv4crc", "application/x-sv4crc"],
    ["svc", "application/vnd.dvb.service"],
    ["svd", "application/vnd.svd"],
    ["svf", ["image/vnd.dwg", "image/x-dwg"]],
    ["svg", "image/svg+xml"],
    ["svr", ["x-world/x-svr", "application/x-world"]],
    ["swf", "application/x-shockwave-flash"],
    ["swi", "application/vnd.aristanetworks.swi"],
    ["sxc", "application/vnd.sun.xml.calc"],
    ["sxd", "application/vnd.sun.xml.draw"],
    ["sxg", "application/vnd.sun.xml.writer.global"],
    ["sxi", "application/vnd.sun.xml.impress"],
    ["sxm", "application/vnd.sun.xml.math"],
    ["sxw", "application/vnd.sun.xml.writer"],
    ["t", ["text/troff", "application/x-troff"]],
    ["talk", "text/x-speech"],
    ["tao", "application/vnd.tao.intent-module-archive"],
    ["tar", "application/x-tar"],
    ["tbk", ["application/toolbook", "application/x-tbook"]],
    ["tcap", "application/vnd.3gpp2.tcap"],
    ["tcl", ["text/x-script.tcl", "application/x-tcl"]],
    ["tcsh", "text/x-script.tcsh"],
    ["teacher", "application/vnd.smart.teacher"],
    ["tei", "application/tei+xml"],
    ["tex", "application/x-tex"],
    ["texi", "application/x-texinfo"],
    ["texinfo", "application/x-texinfo"],
    ["text", ["application/plain", "text/plain"]],
    ["tfi", "application/thraud+xml"],
    ["tfm", "application/x-tex-tfm"],
    ["tgz", ["application/gnutar", "application/x-compressed"]],
    ["thmx", "application/vnd.ms-officetheme"],
    ["tif", ["image/tiff", "image/x-tiff"]],
    ["tiff", ["image/tiff", "image/x-tiff"]],
    ["tmo", "application/vnd.tmobile-livetv"],
    ["torrent", "application/x-bittorrent"],
    ["tpl", "application/vnd.groove-tool-template"],
    ["tpt", "application/vnd.trid.tpt"],
    ["tr", "application/x-troff"],
    ["tra", "application/vnd.trueapp"],
    ["trm", "application/x-msterminal"],
    ["tsd", "application/timestamped-data"],
    ["tsi", "audio/tsp-audio"],
    ["tsp", ["application/dsptype", "audio/tsplayer"]],
    ["tsv", "text/tab-separated-values"],
    ["ttf", "application/x-font-ttf"],
    ["ttl", "text/turtle"],
    ["turbot", "image/florian"],
    ["twd", "application/vnd.simtech-mindmapper"],
    ["txd", "application/vnd.genomatix.tuxedo"],
    ["txf", "application/vnd.mobius.txf"],
    ["txt", "text/plain"],
    ["ufd", "application/vnd.ufdl"],
    ["uil", "text/x-uil"],
    ["uls", "text/iuls"],
    ["umj", "application/vnd.umajin"],
    ["uni", "text/uri-list"],
    ["unis", "text/uri-list"],
    ["unityweb", "application/vnd.unity"],
    ["unv", "application/i-deas"],
    ["uoml", "application/vnd.uoml+xml"],
    ["uri", "text/uri-list"],
    ["uris", "text/uri-list"],
    ["ustar", ["application/x-ustar", "multipart/x-ustar"]],
    ["utz", "application/vnd.uiq.theme"],
    ["uu", ["application/octet-stream", "text/x-uuencode"]],
    ["uue", "text/x-uuencode"],
    ["uva", "audio/vnd.dece.audio"],
    ["uvh", "video/vnd.dece.hd"],
    ["uvi", "image/vnd.dece.graphic"],
    ["uvm", "video/vnd.dece.mobile"],
    ["uvp", "video/vnd.dece.pd"],
    ["uvs", "video/vnd.dece.sd"],
    ["uvu", "video/vnd.uvvu.mp4"],
    ["uvv", "video/vnd.dece.video"],
    ["vcd", "application/x-cdlink"],
    ["vcf", "text/x-vcard"],
    ["vcg", "application/vnd.groove-vcard"],
    ["vcs", "text/x-vcalendar"],
    ["vcx", "application/vnd.vcx"],
    ["vda", "application/vda"],
    ["vdo", "video/vdo"],
    ["vew", "application/groupwise"],
    ["vis", "application/vnd.visionary"],
    ["viv", ["video/vivo", "video/vnd.vivo"]],
    ["vivo", ["video/vivo", "video/vnd.vivo"]],
    ["vmd", "application/vocaltec-media-desc"],
    ["vmf", "application/vocaltec-media-file"],
    ["voc", ["audio/voc", "audio/x-voc"]],
    ["vos", "video/vosaic"],
    ["vox", "audio/voxware"],
    ["vqe", "audio/x-twinvq-plugin"],
    ["vqf", "audio/x-twinvq"],
    ["vql", "audio/x-twinvq-plugin"],
    ["vrml", ["model/vrml", "x-world/x-vrml", "application/x-vrml"]],
    ["vrt", "x-world/x-vrt"],
    ["vsd", ["application/vnd.visio", "application/x-visio"]],
    ["vsf", "application/vnd.vsf"],
    ["vst", "application/x-visio"],
    ["vsw", "application/x-visio"],
    ["vtu", "model/vnd.vtu"],
    ["vxml", "application/voicexml+xml"],
    ["w60", "application/wordperfect6.0"],
    ["w61", "application/wordperfect6.1"],
    ["w6w", "application/msword"],
    ["wad", "application/x-doom"],
    ["wav", ["audio/wav", "audio/x-wav"]],
    ["wax", "audio/x-ms-wax"],
    ["wb1", "application/x-qpro"],
    ["wbmp", "image/vnd.wap.wbmp"],
    ["wbs", "application/vnd.criticaltools.wbs+xml"],
    ["wbxml", "application/vnd.wap.wbxml"],
    ["wcm", "application/vnd.ms-works"],
    ["wdb", "application/vnd.ms-works"],
    ["web", "application/vnd.xara"],
    ["weba", "audio/webm"],
    ["webm", "video/webm"],
    ["webp", "image/webp"],
    ["wg", "application/vnd.pmi.widget"],
    ["wgt", "application/widget"],
    ["wiz", "application/msword"],
    ["wk1", "application/x-123"],
    ["wks", "application/vnd.ms-works"],
    ["wm", "video/x-ms-wm"],
    ["wma", "audio/x-ms-wma"],
    ["wmd", "application/x-ms-wmd"],
    ["wmf", ["windows/metafile", "application/x-msmetafile"]],
    ["wml", "text/vnd.wap.wml"],
    ["wmlc", "application/vnd.wap.wmlc"],
    ["wmls", "text/vnd.wap.wmlscript"],
    ["wmlsc", "application/vnd.wap.wmlscriptc"],
    ["wmv", "video/x-ms-wmv"],
    ["wmx", "video/x-ms-wmx"],
    ["wmz", "application/x-ms-wmz"],
    ["woff", "application/x-font-woff"],
    ["word", "application/msword"],
    ["wp", "application/wordperfect"],
    ["wp5", ["application/wordperfect", "application/wordperfect6.0"]],
    ["wp6", "application/wordperfect"],
    ["wpd", ["application/wordperfect", "application/vnd.wordperfect", "application/x-wpwin"]],
    ["wpl", "application/vnd.ms-wpl"],
    ["wps", "application/vnd.ms-works"],
    ["wq1", "application/x-lotus"],
    ["wqd", "application/vnd.wqd"],
    ["wri", ["application/mswrite", "application/x-wri", "application/x-mswrite"]],
    ["wrl", ["model/vrml", "x-world/x-vrml", "application/x-world"]],
    ["wrz", ["model/vrml", "x-world/x-vrml"]],
    ["wsc", "text/scriplet"],
    ["wsdl", "application/wsdl+xml"],
    ["wspolicy", "application/wspolicy+xml"],
    ["wsrc", "application/x-wais-source"],
    ["wtb", "application/vnd.webturbo"],
    ["wtk", "application/x-wintalk"],
    ["wvx", "video/x-ms-wvx"],
    ["x-png", "image/png"],
    ["x3d", "application/vnd.hzn-3d-crossword"],
    ["xaf", "x-world/x-vrml"],
    ["xap", "application/x-silverlight-app"],
    ["xar", "application/vnd.xara"],
    ["xbap", "application/x-ms-xbap"],
    ["xbd", "application/vnd.fujixerox.docuworks.binder"],
    ["xbm", ["image/xbm", "image/x-xbm", "image/x-xbitmap"]],
    ["xdf", "application/xcap-diff+xml"],
    ["xdm", "application/vnd.syncml.dm+xml"],
    ["xdp", "application/vnd.adobe.xdp+xml"],
    ["xdr", "video/x-amt-demorun"],
    ["xdssc", "application/dssc+xml"],
    ["xdw", "application/vnd.fujixerox.docuworks"],
    ["xenc", "application/xenc+xml"],
    ["xer", "application/patch-ops-error+xml"],
    ["xfdf", "application/vnd.adobe.xfdf"],
    ["xfdl", "application/vnd.xfdl"],
    ["xgz", "xgl/drawing"],
    ["xhtml", "application/xhtml+xml"],
    ["xif", "image/vnd.xiff"],
    ["xl", "application/excel"],
    ["xla", ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"]],
    ["xlam", "application/vnd.ms-excel.addin.macroenabled.12"],
    ["xlb", ["application/excel", "application/vnd.ms-excel", "application/x-excel"]],
    ["xlc", ["application/vnd.ms-excel", "application/excel", "application/x-excel"]],
    ["xld", ["application/excel", "application/x-excel"]],
    ["xlk", ["application/excel", "application/x-excel"]],
    ["xll", ["application/excel", "application/vnd.ms-excel", "application/x-excel"]],
    ["xlm", ["application/vnd.ms-excel", "application/excel", "application/x-excel"]],
    ["xls", ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"]],
    ["xlsb", "application/vnd.ms-excel.sheet.binary.macroenabled.12"],
    ["xlsm", "application/vnd.ms-excel.sheet.macroenabled.12"],
    ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
    ["xlt", ["application/vnd.ms-excel", "application/excel", "application/x-excel"]],
    ["xltm", "application/vnd.ms-excel.template.macroenabled.12"],
    ["xltx", "application/vnd.openxmlformats-officedocument.spreadsheetml.template"],
    ["xlv", ["application/excel", "application/x-excel"]],
    ["xlw", ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"]],
    ["xm", "audio/xm"],
    ["xml", ["application/xml", "text/xml", "application/atom+xml", "application/rss+xml"]],
    ["xmz", "xgl/movie"],
    ["xo", "application/vnd.olpc-sugar"],
    ["xof", "x-world/x-vrml"],
    ["xop", "application/xop+xml"],
    ["xpi", "application/x-xpinstall"],
    ["xpix", "application/x-vnd.ls-xpix"],
    ["xpm", ["image/xpm", "image/x-xpixmap"]],
    ["xpr", "application/vnd.is-xpr"],
    ["xps", "application/vnd.ms-xpsdocument"],
    ["xpw", "application/vnd.intercon.formnet"],
    ["xslt", "application/xslt+xml"],
    ["xsm", "application/vnd.syncml+xml"],
    ["xspf", "application/xspf+xml"],
    ["xsr", "video/x-amt-showrun"],
    ["xul", "application/vnd.mozilla.xul+xml"],
    ["xwd", ["image/x-xwd", "image/x-xwindowdump"]],
    ["xyz", ["chemical/x-xyz", "chemical/x-pdb"]],
    ["yang", "application/yang"],
    ["yin", "application/yin+xml"],
    ["z", ["application/x-compressed", "application/x-compress"]],
    ["zaz", "application/vnd.zzazz.deck+xml"],
    ["zip", ["application/zip", "multipart/x-zip", "application/x-zip-compressed", "application/x-compressed"]],
    ["zir", "application/vnd.zul"],
    ["zmm", "application/vnd.handheld-entertainment+xml"],
    ["zoo", "application/octet-stream"],
    ["zsh", "text/x-script.zsh"]
  ]);
  module.exports = {
    detectMimeType(filename) {
      if (!filename) {
        return defaultMimeType;
      }
      let parsed = path.parse(filename);
      let extension = (parsed.ext.substr(1) || parsed.name || "").split("?").shift().trim().toLowerCase();
      let value = defaultMimeType;
      if (extensions.has(extension)) {
        value = extensions.get(extension);
      }
      if (Array.isArray(value)) {
        return value[0];
      }
      return value;
    },
    detectExtension(mimeType) {
      if (!mimeType) {
        return defaultExtension;
      }
      let parts = (mimeType || "").toLowerCase().trim().split("/");
      let rootType = parts.shift().trim();
      let subType = parts.join("/").trim();
      if (mimeTypes.has(rootType + "/" + subType)) {
        let value = mimeTypes.get(rootType + "/" + subType);
        if (Array.isArray(value)) {
          return value[0];
        }
        return value;
      }
      switch (rootType) {
        case "text":
          return "txt";
        default:
          return "bin";
      }
    }
  };
});

// node_modules/nodemailer/lib/punycode/index.js
var require_punycode = __commonJS((exports, module) => {
  function error(type) {
    throw new RangeError(errors6[type]);
  }
  function map(array2, callback) {
    const result2 = [];
    let length = array2.length;
    while (length--) {
      result2[length] = callback(array2[length]);
    }
    return result2;
  }
  function mapDomain(domain, callback) {
    const parts = domain.split("@");
    let result2 = "";
    if (parts.length > 1) {
      result2 = parts[0] + "@";
      domain = parts[1];
    }
    domain = domain.replace(regexSeparators, ".");
    const labels = domain.split(".");
    const encoded = map(labels, callback).join(".");
    return result2 + encoded;
  }
  function ucs2decode(string) {
    const output = [];
    let counter = 0;
    const length = string.length;
    while (counter < length) {
      const value = string.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        const extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }
  var maxInt = 2147483647;
  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128;
  var delimiter = "-";
  var regexPunycode = /^xn--/;
  var regexNonASCII = /[^\0-\x7F]/;
  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
  var errors6 = {
    overflow: "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;
  var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
  var basicToDigit = function(codePoint) {
    if (codePoint >= 48 && codePoint < 58) {
      return 26 + (codePoint - 48);
    }
    if (codePoint >= 65 && codePoint < 91) {
      return codePoint - 65;
    }
    if (codePoint >= 97 && codePoint < 123) {
      return codePoint - 97;
    }
    return base;
  };
  var digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  var adapt = function(delta, numPoints, firstTime) {
    let k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (;delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  var decode = function(input) {
    const output = [];
    const inputLength = input.length;
    let i = 0;
    let n = initialN;
    let bias = initialBias;
    let basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
      basic = 0;
    }
    for (let j = 0;j < basic; ++j) {
      if (input.charCodeAt(j) >= 128) {
        error("not-basic");
      }
      output.push(input.charCodeAt(j));
    }
    for (let index2 = basic > 0 ? basic + 1 : 0;index2 < inputLength; ) {
      const oldi = i;
      for (let w = 1, k = base;; k += base) {
        if (index2 >= inputLength) {
          error("invalid-input");
        }
        const digit = basicToDigit(input.charCodeAt(index2++));
        if (digit >= base) {
          error("invalid-input");
        }
        if (digit > floor((maxInt - i) / w)) {
          error("overflow");
        }
        i += digit * w;
        const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
        if (digit < t2) {
          break;
        }
        const baseMinusT = base - t2;
        if (w > floor(maxInt / baseMinusT)) {
          error("overflow");
        }
        w *= baseMinusT;
      }
      const out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0);
      if (floor(i / out) > maxInt - n) {
        error("overflow");
      }
      n += floor(i / out);
      i %= out;
      output.splice(i++, 0, n);
    }
    return String.fromCodePoint(...output);
  };
  var encode = function(input) {
    const output = [];
    input = ucs2decode(input);
    const inputLength = input.length;
    let n = initialN;
    let delta = 0;
    let bias = initialBias;
    for (const currentValue of input) {
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter);
    }
    while (handledCPCount < inputLength) {
      let m = maxInt;
      for (const currentValue of input) {
        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      }
      const handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error("overflow");
      }
      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      for (const currentValue of input) {
        if (currentValue < n && ++delta > maxInt) {
          error("overflow");
        }
        if (currentValue === n) {
          let q = delta;
          for (let k = base;; k += base) {
            const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q < t2) {
              break;
            }
            const qMinusT = q - t2;
            const baseMinusT = base - t2;
            output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n;
    }
    return output.join("");
  };
  var toUnicode = function(input) {
    return mapDomain(input, function(string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  };
  var toASCII = function(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
    });
  };
  var punycode = {
    version: "2.3.1",
    ucs2: {
      decode: ucs2decode,
      encode: ucs2encode
    },
    decode,
    encode,
    toASCII,
    toUnicode
  };
  module.exports = punycode;
});

// node_modules/nodemailer/lib/base64/index.js
var require_base64 = __commonJS((exports, module) => {
  function encode(buffer2) {
    if (typeof buffer2 === "string") {
      buffer2 = Buffer.from(buffer2, "utf-8");
    }
    return buffer2.toString("base64");
  }
  function wrap(str, lineLength) {
    str = (str || "").toString();
    lineLength = lineLength || 76;
    if (str.length <= lineLength) {
      return str;
    }
    let result2 = [];
    let pos = 0;
    let chunkLength = lineLength * 1024;
    while (pos < str.length) {
      let wrappedLines = str.substr(pos, chunkLength).replace(new RegExp(".{" + lineLength + "}", "g"), "$&\r\n").trim();
      result2.push(wrappedLines);
      pos += chunkLength;
    }
    return result2.join("\r\n").trim();
  }
  var Transform = __require("stream").Transform;

  class Encoder extends Transform {
    constructor(options) {
      super();
      this.options = options || {};
      if (this.options.lineLength !== false) {
        this.options.lineLength = this.options.lineLength || 76;
      }
      this._curLine = "";
      this._remainingBytes = false;
      this.inputBytes = 0;
      this.outputBytes = 0;
    }
    _transform(chunk, encoding, done) {
      if (encoding !== "buffer") {
        chunk = Buffer.from(chunk, encoding);
      }
      if (!chunk || !chunk.length) {
        return setImmediate(done);
      }
      this.inputBytes += chunk.length;
      if (this._remainingBytes && this._remainingBytes.length) {
        chunk = Buffer.concat([this._remainingBytes, chunk], this._remainingBytes.length + chunk.length);
        this._remainingBytes = false;
      }
      if (chunk.length % 3) {
        this._remainingBytes = chunk.slice(chunk.length - chunk.length % 3);
        chunk = chunk.slice(0, chunk.length - chunk.length % 3);
      } else {
        this._remainingBytes = false;
      }
      let b64 = this._curLine + encode(chunk);
      if (this.options.lineLength) {
        b64 = wrap(b64, this.options.lineLength);
        let lastLF = b64.lastIndexOf("\n");
        if (lastLF < 0) {
          this._curLine = b64;
          b64 = "";
        } else if (lastLF === b64.length - 1) {
          this._curLine = "";
        } else {
          this._curLine = b64.substr(lastLF + 1);
          b64 = b64.substr(0, lastLF + 1);
        }
      }
      if (b64) {
        this.outputBytes += b64.length;
        this.push(Buffer.from(b64, "ascii"));
      }
      setImmediate(done);
    }
    _flush(done) {
      if (this._remainingBytes && this._remainingBytes.length) {
        this._curLine += encode(this._remainingBytes);
      }
      if (this._curLine) {
        this._curLine = wrap(this._curLine, this.options.lineLength);
        this.outputBytes += this._curLine.length;
        this.push(this._curLine, "ascii");
        this._curLine = "";
      }
      done();
    }
  }
  module.exports = {
    encode,
    wrap,
    Encoder
  };
});

// node_modules/nodemailer/lib/qp/index.js
var require_qp = __commonJS((exports, module) => {
  function encode(buffer2) {
    if (typeof buffer2 === "string") {
      buffer2 = Buffer.from(buffer2, "utf-8");
    }
    let ranges = [
      [9],
      [10],
      [13],
      [32, 60],
      [62, 126]
    ];
    let result2 = "";
    let ord;
    for (let i = 0, len = buffer2.length;i < len; i++) {
      ord = buffer2[i];
      if (checkRanges(ord, ranges) && !((ord === 32 || ord === 9) && (i === len - 1 || buffer2[i + 1] === 10 || buffer2[i + 1] === 13))) {
        result2 += String.fromCharCode(ord);
        continue;
      }
      result2 += "=" + (ord < 16 ? "0" : "") + ord.toString(16).toUpperCase();
    }
    return result2;
  }
  function wrap(str, lineLength) {
    str = (str || "").toString();
    lineLength = lineLength || 76;
    if (str.length <= lineLength) {
      return str;
    }
    let pos = 0;
    let len = str.length;
    let match, code, line;
    let lineMargin = Math.floor(lineLength / 3);
    let result2 = "";
    while (pos < len) {
      line = str.substr(pos, lineLength);
      if (match = line.match(/\r\n/)) {
        line = line.substr(0, match.index + match[0].length);
        result2 += line;
        pos += line.length;
        continue;
      }
      if (line.substr(-1) === "\n") {
        result2 += line;
        pos += line.length;
        continue;
      } else if (match = line.substr(-lineMargin).match(/\n.*?$/)) {
        line = line.substr(0, line.length - (match[0].length - 1));
        result2 += line;
        pos += line.length;
        continue;
      } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \t.,!?][^ \t.,!?]*$/))) {
        line = line.substr(0, line.length - (match[0].length - 1));
      } else if (line.match(/[=][\da-f]{0,2}$/i)) {
        if (match = line.match(/[=][\da-f]{0,1}$/i)) {
          line = line.substr(0, line.length - match[0].length);
        }
        while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\da-f]{2}){1,4}$/i) && (match = line.match(/[=][\da-f]{2}$/gi))) {
          code = parseInt(match[0].substr(1, 2), 16);
          if (code < 128) {
            break;
          }
          line = line.substr(0, line.length - 3);
          if (code >= 192) {
            break;
          }
        }
      }
      if (pos + line.length < len && line.substr(-1) !== "\n") {
        if (line.length === lineLength && line.match(/[=][\da-f]{2}$/i)) {
          line = line.substr(0, line.length - 3);
        } else if (line.length === lineLength) {
          line = line.substr(0, line.length - 1);
        }
        pos += line.length;
        line += "=\r\n";
      } else {
        pos += line.length;
      }
      result2 += line;
    }
    return result2;
  }
  function checkRanges(nr, ranges) {
    for (let i = ranges.length - 1;i >= 0; i--) {
      if (!ranges[i].length) {
        continue;
      }
      if (ranges[i].length === 1 && nr === ranges[i][0]) {
        return true;
      }
      if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {
        return true;
      }
    }
    return false;
  }
  var Transform = __require("stream").Transform;

  class Encoder extends Transform {
    constructor(options) {
      super();
      this.options = options || {};
      if (this.options.lineLength !== false) {
        this.options.lineLength = this.options.lineLength || 76;
      }
      this._curLine = "";
      this.inputBytes = 0;
      this.outputBytes = 0;
    }
    _transform(chunk, encoding, done) {
      let qp;
      if (encoding !== "buffer") {
        chunk = Buffer.from(chunk, encoding);
      }
      if (!chunk || !chunk.length) {
        return done();
      }
      this.inputBytes += chunk.length;
      if (this.options.lineLength) {
        qp = this._curLine + encode(chunk);
        qp = wrap(qp, this.options.lineLength);
        qp = qp.replace(/(^|\n)([^\n]*)$/, (match, lineBreak, lastLine) => {
          this._curLine = lastLine;
          return lineBreak;
        });
        if (qp) {
          this.outputBytes += qp.length;
          this.push(qp);
        }
      } else {
        qp = encode(chunk);
        this.outputBytes += qp.length;
        this.push(qp, "ascii");
      }
      done();
    }
    _flush(done) {
      if (this._curLine) {
        this.outputBytes += this._curLine.length;
        this.push(this._curLine, "ascii");
      }
      done();
    }
  }
  module.exports = {
    encode,
    wrap,
    Encoder
  };
});

// node_modules/nodemailer/lib/mime-funcs/index.js
var require_mime_funcs = __commonJS((exports, module) => {
  var base64 = require_base64();
  var qp = require_qp();
  var mimeTypes = require_mime_types();
  module.exports = {
    isPlainText(value, isParam) {
      const re = isParam ? /[\x00-\x08\x0b\x0c\x0e-\x1f"\u0080-\uFFFF]/ : /[\x00-\x08\x0b\x0c\x0e-\x1f\u0080-\uFFFF]/;
      if (typeof value !== "string" || re.test(value)) {
        return false;
      } else {
        return true;
      }
    },
    hasLongerLines(str, lineLength) {
      if (str.length > 128 * 1024) {
        return true;
      }
      return new RegExp("^.{" + (lineLength + 1) + ",}", "m").test(str);
    },
    encodeWord(data, mimeWordEncoding, maxLength) {
      mimeWordEncoding = (mimeWordEncoding || "Q").toString().toUpperCase().trim().charAt(0);
      maxLength = maxLength || 0;
      let encodedStr;
      let toCharset = "UTF-8";
      if (maxLength && maxLength > 7 + toCharset.length) {
        maxLength -= 7 + toCharset.length;
      }
      if (mimeWordEncoding === "Q") {
        encodedStr = qp.encode(data).replace(/[^a-z0-9!*+\-/=]/gi, (chr) => {
          let ord = chr.charCodeAt(0).toString(16).toUpperCase();
          if (chr === " ") {
            return "_";
          } else {
            return "=" + (ord.length === 1 ? "0" + ord : ord);
          }
        });
      } else if (mimeWordEncoding === "B") {
        encodedStr = typeof data === "string" ? data : base64.encode(data);
        maxLength = maxLength ? Math.max(3, (maxLength - maxLength % 4) / 4 * 3) : 0;
      }
      if (maxLength && (mimeWordEncoding !== "B" ? encodedStr : base64.encode(data)).length > maxLength) {
        if (mimeWordEncoding === "Q") {
          encodedStr = this.splitMimeEncodedString(encodedStr, maxLength).join("?= =?" + toCharset + "?" + mimeWordEncoding + "?");
        } else {
          let parts = [];
          let lpart = "";
          for (let i = 0, len = encodedStr.length;i < len; i++) {
            let chr = encodedStr.charAt(i);
            if (/[\ud83c\ud83d\ud83e]/.test(chr) && i < len - 1) {
              chr += encodedStr.charAt(++i);
            }
            if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {
              lpart += chr;
            } else {
              parts.push(base64.encode(lpart));
              lpart = chr;
            }
          }
          if (lpart) {
            parts.push(base64.encode(lpart));
          }
          if (parts.length > 1) {
            encodedStr = parts.join("?= =?" + toCharset + "?" + mimeWordEncoding + "?");
          } else {
            encodedStr = parts.join("");
          }
        }
      } else if (mimeWordEncoding === "B") {
        encodedStr = base64.encode(data);
      }
      return "=?" + toCharset + "?" + mimeWordEncoding + "?" + encodedStr + (encodedStr.substr(-2) === "?=" ? "" : "?=");
    },
    encodeWords(value, mimeWordEncoding, maxLength, encodeAll) {
      maxLength = maxLength || 0;
      let encodedValue;
      let firstMatch = value.match(/(?:^|\s)([^\s]*["\u0080-\uFFFF])/);
      if (!firstMatch) {
        return value;
      }
      if (encodeAll) {
        return this.encodeWord(value, mimeWordEncoding, maxLength);
      }
      let lastMatch = value.match(/(["\u0080-\uFFFF][^\s]*)[^"\u0080-\uFFFF]*$/);
      if (!lastMatch) {
        return value;
      }
      let startIndex = firstMatch.index + (firstMatch[0].match(/[^\s]/) || {
        index: 0
      }).index;
      let endIndex = lastMatch.index + (lastMatch[1] || "").length;
      encodedValue = (startIndex ? value.substr(0, startIndex) : "") + this.encodeWord(value.substring(startIndex, endIndex), mimeWordEncoding || "Q", maxLength) + (endIndex < value.length ? value.substr(endIndex) : "");
      return encodedValue;
    },
    buildHeaderValue(structured) {
      let paramsArray = [];
      Object.keys(structured.params || {}).forEach((param) => {
        let value = structured.params[param];
        if (!this.isPlainText(value, true) || value.length >= 75) {
          this.buildHeaderParam(param, value, 50).forEach((encodedParam) => {
            if (!/[\s"\\;:/=(),<>@[\]?]|^[-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === "*") {
              paramsArray.push(encodedParam.key + "=" + encodedParam.value);
            } else {
              paramsArray.push(encodedParam.key + "=" + JSON.stringify(encodedParam.value));
            }
          });
        } else if (/[\s'"\\;:/=(),<>@[\]?]|^-/.test(value)) {
          paramsArray.push(param + "=" + JSON.stringify(value));
        } else {
          paramsArray.push(param + "=" + value);
        }
      });
      return structured.value + (paramsArray.length ? "; " + paramsArray.join("; ") : "");
    },
    buildHeaderParam(key, data, maxLength) {
      let list = [];
      let encodedStr = typeof data === "string" ? data : (data || "").toString();
      let encodedStrArr;
      let chr, ord;
      let line;
      let startPos = 0;
      let i, len;
      maxLength = maxLength || 50;
      if (this.isPlainText(data, true)) {
        if (encodedStr.length <= maxLength) {
          return [
            {
              key,
              value: encodedStr
            }
          ];
        }
        encodedStr = encodedStr.replace(new RegExp(".{" + maxLength + "}", "g"), (str) => {
          list.push({
            line: str
          });
          return "";
        });
        if (encodedStr) {
          list.push({
            line: encodedStr
          });
        }
      } else {
        if (/[\uD800-\uDBFF]/.test(encodedStr)) {
          encodedStrArr = [];
          for (i = 0, len = encodedStr.length;i < len; i++) {
            chr = encodedStr.charAt(i);
            ord = chr.charCodeAt(0);
            if (ord >= 55296 && ord <= 56319 && i < len - 1) {
              chr += encodedStr.charAt(i + 1);
              encodedStrArr.push(chr);
              i++;
            } else {
              encodedStrArr.push(chr);
            }
          }
          encodedStr = encodedStrArr;
        }
        line = "utf-8''";
        let encoded = true;
        startPos = 0;
        for (i = 0, len = encodedStr.length;i < len; i++) {
          chr = encodedStr[i];
          if (encoded) {
            chr = this.safeEncodeURIComponent(chr);
          } else {
            chr = chr === " " ? chr : this.safeEncodeURIComponent(chr);
            if (chr !== encodedStr[i]) {
              if ((this.safeEncodeURIComponent(line) + chr).length >= maxLength) {
                list.push({
                  line,
                  encoded
                });
                line = "";
                startPos = i - 1;
              } else {
                encoded = true;
                i = startPos;
                line = "";
                continue;
              }
            }
          }
          if ((line + chr).length >= maxLength) {
            list.push({
              line,
              encoded
            });
            line = chr = encodedStr[i] === " " ? " " : this.safeEncodeURIComponent(encodedStr[i]);
            if (chr === encodedStr[i]) {
              encoded = false;
              startPos = i - 1;
            } else {
              encoded = true;
            }
          } else {
            line += chr;
          }
        }
        if (line) {
          list.push({
            line,
            encoded
          });
        }
      }
      return list.map((item, i2) => ({
        key: key + "*" + i2 + (item.encoded ? "*" : ""),
        value: item.line
      }));
    },
    parseHeaderValue(str) {
      let response = {
        value: false,
        params: {}
      };
      let key = false;
      let value = "";
      let type = "value";
      let quote = false;
      let escaped = false;
      let chr;
      for (let i = 0, len = str.length;i < len; i++) {
        chr = str.charAt(i);
        if (type === "key") {
          if (chr === "=") {
            key = value.trim().toLowerCase();
            type = "value";
            value = "";
            continue;
          }
          value += chr;
        } else {
          if (escaped) {
            value += chr;
          } else if (chr === "\\") {
            escaped = true;
            continue;
          } else if (quote && chr === quote) {
            quote = false;
          } else if (!quote && chr === '"') {
            quote = chr;
          } else if (!quote && chr === ";") {
            if (key === false) {
              response.value = value.trim();
            } else {
              response.params[key] = value.trim();
            }
            type = "key";
            value = "";
          } else {
            value += chr;
          }
          escaped = false;
        }
      }
      if (type === "value") {
        if (key === false) {
          response.value = value.trim();
        } else {
          response.params[key] = value.trim();
        }
      } else if (value.trim()) {
        response.params[value.trim().toLowerCase()] = "";
      }
      Object.keys(response.params).forEach((key2) => {
        let actualKey, nr, match, value2;
        if (match = key2.match(/(\*(\d+)|\*(\d+)\*|\*)$/)) {
          actualKey = key2.substr(0, match.index);
          nr = Number(match[2] || match[3]) || 0;
          if (!response.params[actualKey] || typeof response.params[actualKey] !== "object") {
            response.params[actualKey] = {
              charset: false,
              values: []
            };
          }
          value2 = response.params[key2];
          if (nr === 0 && match[0].substr(-1) === "*" && (match = value2.match(/^([^']*)'[^']*'(.*)$/))) {
            response.params[actualKey].charset = match[1] || "iso-8859-1";
            value2 = match[2];
          }
          response.params[actualKey].values[nr] = value2;
          delete response.params[key2];
        }
      });
      Object.keys(response.params).forEach((key2) => {
        let value2;
        if (response.params[key2] && Array.isArray(response.params[key2].values)) {
          value2 = response.params[key2].values.map((val) => val || "").join("");
          if (response.params[key2].charset) {
            response.params[key2] = "=?" + response.params[key2].charset + "?Q?" + value2.replace(/[=?_\s]/g, (s) => {
              let c = s.charCodeAt(0).toString(16);
              if (s === " ") {
                return "_";
              } else {
                return "%" + (c.length < 2 ? "0" : "") + c;
              }
            }).replace(/%/g, "=") + "?=";
          } else {
            response.params[key2] = value2;
          }
        }
      });
      return response;
    },
    detectExtension: (mimeType) => mimeTypes.detectExtension(mimeType),
    detectMimeType: (extension) => mimeTypes.detectMimeType(extension),
    foldLines(str, lineLength, afterSpace) {
      str = (str || "").toString();
      lineLength = lineLength || 76;
      let pos = 0, len = str.length, result2 = "", line, match;
      while (pos < len) {
        line = str.substr(pos, lineLength);
        if (line.length < lineLength) {
          result2 += line;
          break;
        }
        if (match = line.match(/^[^\n\r]*(\r?\n|\r)/)) {
          line = match[0];
          result2 += line;
          pos += line.length;
          continue;
        } else if ((match = line.match(/(\s+)[^\s]*$/)) && match[0].length - (afterSpace ? (match[1] || "").length : 0) < line.length) {
          line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || "").length : 0)));
        } else if (match = str.substr(pos + line.length).match(/^[^\s]+(\s*)/)) {
          line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || "").length : 0));
        }
        result2 += line;
        pos += line.length;
        if (pos < len) {
          result2 += "\r\n";
        }
      }
      return result2;
    },
    splitMimeEncodedString: (str, maxlen) => {
      let curLine, match, chr, done, lines = [];
      maxlen = Math.max(maxlen || 0, 12);
      while (str.length) {
        curLine = str.substr(0, maxlen);
        if (match = curLine.match(/[=][0-9A-F]?$/i)) {
          curLine = curLine.substr(0, match.index);
        }
        done = false;
        while (!done) {
          done = true;
          if (match = str.substr(curLine.length).match(/^[=]([0-9A-F]{2})/i)) {
            chr = parseInt(match[1], 16);
            if (chr < 194 && chr > 127) {
              curLine = curLine.substr(0, curLine.length - 3);
              done = false;
            }
          }
        }
        if (curLine.length) {
          lines.push(curLine);
        }
        str = str.substr(curLine.length);
      }
      return lines;
    },
    encodeURICharComponent: (chr) => {
      let res = "";
      let ord = chr.charCodeAt(0).toString(16).toUpperCase();
      if (ord.length % 2) {
        ord = "0" + ord;
      }
      if (ord.length > 2) {
        for (let i = 0, len = ord.length / 2;i < len; i++) {
          res += "%" + ord.substr(i, 2);
        }
      } else {
        res += "%" + ord;
      }
      return res;
    },
    safeEncodeURIComponent(str) {
      str = (str || "").toString();
      try {
        str = encodeURIComponent(str);
      } catch (E) {
        return str.replace(/[^\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]+/g, "");
      }
      return str.replace(/[\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]/g, (chr) => this.encodeURICharComponent(chr));
    }
  };
});

// node_modules/nodemailer/lib/addressparser/index.js
var require_addressparser = __commonJS((exports, module) => {
  function _handleAddress(tokens) {
    let isGroup = false;
    let state = "text";
    let address;
    let addresses = [];
    let data = {
      address: [],
      comment: [],
      group: [],
      text: []
    };
    let i;
    let len;
    for (i = 0, len = tokens.length;i < len; i++) {
      let token = tokens[i];
      let prevToken = i ? tokens[i - 1] : null;
      if (token.type === "operator") {
        switch (token.value) {
          case "<":
            state = "address";
            break;
          case "(":
            state = "comment";
            break;
          case ":":
            state = "group";
            isGroup = true;
            break;
          default:
            state = "text";
            break;
        }
      } else if (token.value) {
        if (state === "address") {
          token.value = token.value.replace(/^[^<]*<\s*/, "");
        }
        if (prevToken && prevToken.noBreak && data[state].length) {
          data[state][data[state].length - 1] += token.value;
        } else {
          data[state].push(token.value);
        }
      }
    }
    if (!data.text.length && data.comment.length) {
      data.text = data.comment;
      data.comment = [];
    }
    if (isGroup) {
      data.text = data.text.join(" ");
      addresses.push({
        name: data.text || address && address.name,
        group: data.group.length ? addressparser(data.group.join(",")) : []
      });
    } else {
      if (!data.address.length && data.text.length) {
        for (i = data.text.length - 1;i >= 0; i--) {
          if (data.text[i].match(/^[^@\s]+@[^@\s]+$/)) {
            data.address = data.text.splice(i, 1);
            break;
          }
        }
        let _regexHandler = function(address2) {
          if (!data.address.length) {
            data.address = [address2.trim()];
            return " ";
          } else {
            return address2;
          }
        };
        if (!data.address.length) {
          for (i = data.text.length - 1;i >= 0; i--) {
            data.text[i] = data.text[i].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/, _regexHandler).trim();
            if (data.address.length) {
              break;
            }
          }
        }
      }
      if (!data.text.length && data.comment.length) {
        data.text = data.comment;
        data.comment = [];
      }
      if (data.address.length > 1) {
        data.text = data.text.concat(data.address.splice(1));
      }
      data.text = data.text.join(" ");
      data.address = data.address.join(" ");
      if (!data.address && isGroup) {
        return [];
      } else {
        address = {
          address: data.address || data.text || "",
          name: data.text || data.address || ""
        };
        if (address.address === address.name) {
          if ((address.address || "").match(/@/)) {
            address.name = "";
          } else {
            address.address = "";
          }
        }
        addresses.push(address);
      }
    }
    return addresses;
  }
  function addressparser(str, options) {
    options = options || {};
    let tokenizer = new Tokenizer(str);
    let tokens = tokenizer.tokenize();
    let addresses = [];
    let address = [];
    let parsedAddresses = [];
    tokens.forEach((token) => {
      if (token.type === "operator" && (token.value === "," || token.value === ";")) {
        if (address.length) {
          addresses.push(address);
        }
        address = [];
      } else {
        address.push(token);
      }
    });
    if (address.length) {
      addresses.push(address);
    }
    addresses.forEach((address2) => {
      address2 = _handleAddress(address2);
      if (address2.length) {
        parsedAddresses = parsedAddresses.concat(address2);
      }
    });
    if (options.flatten) {
      let addresses2 = [];
      let walkAddressList = (list) => {
        list.forEach((address2) => {
          if (address2.group) {
            return walkAddressList(address2.group);
          } else {
            addresses2.push(address2);
          }
        });
      };
      walkAddressList(parsedAddresses);
      return addresses2;
    }
    return parsedAddresses;
  }

  class Tokenizer {
    constructor(str) {
      this.str = (str || "").toString();
      this.operatorCurrent = "";
      this.operatorExpecting = "";
      this.node = null;
      this.escaped = false;
      this.list = [];
      this.operators = {
        '"': '"',
        "(": ")",
        "<": ">",
        ",": "",
        ":": ";",
        ";": ""
      };
    }
    tokenize() {
      let list = [];
      for (let i = 0, len = this.str.length;i < len; i++) {
        let chr = this.str.charAt(i);
        let nextChr = i < len - 1 ? this.str.charAt(i + 1) : null;
        this.checkChar(chr, nextChr);
      }
      this.list.forEach((node) => {
        node.value = (node.value || "").toString().trim();
        if (node.value) {
          list.push(node);
        }
      });
      return list;
    }
    checkChar(chr, nextChr) {
      if (this.escaped) {
      } else if (chr === this.operatorExpecting) {
        this.node = {
          type: "operator",
          value: chr
        };
        if (nextChr && ![" ", "\t", "\r", "\n", ",", ";"].includes(nextChr)) {
          this.node.noBreak = true;
        }
        this.list.push(this.node);
        this.node = null;
        this.operatorExpecting = "";
        this.escaped = false;
        return;
      } else if (!this.operatorExpecting && chr in this.operators) {
        this.node = {
          type: "operator",
          value: chr
        };
        this.list.push(this.node);
        this.node = null;
        this.operatorExpecting = this.operators[chr];
        this.escaped = false;
        return;
      } else if (['"', "'"].includes(this.operatorExpecting) && chr === "\\") {
        this.escaped = true;
        return;
      }
      if (!this.node) {
        this.node = {
          type: "text",
          value: ""
        };
        this.list.push(this.node);
      }
      if (chr === "\n") {
        chr = " ";
      }
      if (chr.charCodeAt(0) >= 33 || [" ", "\t"].includes(chr)) {
        this.node.value += chr;
      }
      this.escaped = false;
    }
  }
  module.exports = addressparser;
});

// node_modules/nodemailer/lib/mime-node/last-newline.js
var require_last_newline = __commonJS((exports, module) => {
  var Transform = __require("stream").Transform;

  class LastNewline extends Transform {
    constructor() {
      super();
      this.lastByte = false;
    }
    _transform(chunk, encoding, done) {
      if (chunk.length) {
        this.lastByte = chunk[chunk.length - 1];
      }
      this.push(chunk);
      done();
    }
    _flush(done) {
      if (this.lastByte === 10) {
        return done();
      }
      if (this.lastByte === 13) {
        this.push(Buffer.from("\n"));
        return done();
      }
      this.push(Buffer.from("\r\n"));
      return done();
    }
  }
  module.exports = LastNewline;
});

// node_modules/nodemailer/lib/mime-node/le-windows.js
var require_le_windows = __commonJS((exports, module) => {
  var stream = __require("stream");
  var Transform = stream.Transform;

  class LeWindows extends Transform {
    constructor(options) {
      super(options);
      this.options = options || {};
      this.lastByte = false;
    }
    _transform(chunk, encoding, done) {
      let buf;
      let lastPos = 0;
      for (let i = 0, len = chunk.length;i < len; i++) {
        if (chunk[i] === 10) {
          if (i && chunk[i - 1] !== 13 || !i && this.lastByte !== 13) {
            if (i > lastPos) {
              buf = chunk.slice(lastPos, i);
              this.push(buf);
            }
            this.push(Buffer.from("\r\n"));
            lastPos = i + 1;
          }
        }
      }
      if (lastPos && lastPos < chunk.length) {
        buf = chunk.slice(lastPos);
        this.push(buf);
      } else if (!lastPos) {
        this.push(chunk);
      }
      this.lastByte = chunk[chunk.length - 1];
      done();
    }
  }
  module.exports = LeWindows;
});

// node_modules/nodemailer/lib/mime-node/le-unix.js
var require_le_unix = __commonJS((exports, module) => {
  var stream = __require("stream");
  var Transform = stream.Transform;

  class LeWindows extends Transform {
    constructor(options) {
      super(options);
      this.options = options || {};
    }
    _transform(chunk, encoding, done) {
      let buf;
      let lastPos = 0;
      for (let i = 0, len = chunk.length;i < len; i++) {
        if (chunk[i] === 13) {
          buf = chunk.slice(lastPos, i);
          lastPos = i + 1;
          this.push(buf);
        }
      }
      if (lastPos && lastPos < chunk.length) {
        buf = chunk.slice(lastPos);
        this.push(buf);
      } else if (!lastPos) {
        this.push(chunk);
      }
      done();
    }
  }
  module.exports = LeWindows;
});

// node_modules/nodemailer/lib/mime-node/index.js
var require_mime_node = __commonJS((exports, module) => {
  var crypto3 = __require("crypto");
  var fs2 = __require("fs");
  var punycode = require_punycode();
  var PassThrough = __require("stream").PassThrough;
  var shared = require_shared();
  var mimeFuncs = require_mime_funcs();
  var qp = require_qp();
  var base64 = require_base64();
  var addressparser = require_addressparser();
  var nmfetch = require_fetch();
  var LastNewline = require_last_newline();
  var LeWindows = require_le_windows();
  var LeUnix = require_le_unix();

  class MimeNode {
    constructor(contentType, options) {
      this.nodeCounter = 0;
      options = options || {};
      this.baseBoundary = options.baseBoundary || crypto3.randomBytes(8).toString("hex");
      this.boundaryPrefix = options.boundaryPrefix || "--_NmP";
      this.disableFileAccess = !!options.disableFileAccess;
      this.disableUrlAccess = !!options.disableUrlAccess;
      this.normalizeHeaderKey = options.normalizeHeaderKey;
      this.date = new Date;
      this.rootNode = options.rootNode || this;
      this.keepBcc = !!options.keepBcc;
      if (options.filename) {
        this.filename = options.filename;
        if (!contentType) {
          contentType = mimeFuncs.detectMimeType(this.filename.split(".").pop());
        }
      }
      this.textEncoding = (options.textEncoding || "").toString().trim().charAt(0).toUpperCase();
      this.parentNode = options.parentNode;
      this.hostname = options.hostname;
      this.newline = options.newline;
      this.childNodes = [];
      this._nodeId = ++this.rootNode.nodeCounter;
      this._headers = [];
      this._isPlainText = false;
      this._hasLongLines = false;
      this._envelope = false;
      this._raw = false;
      this._transforms = [];
      this._processFuncs = [];
      if (contentType) {
        this.setHeader("Content-Type", contentType);
      }
    }
    createChild(contentType, options) {
      if (!options && typeof contentType === "object") {
        options = contentType;
        contentType = undefined;
      }
      let node = new MimeNode(contentType, options);
      this.appendChild(node);
      return node;
    }
    appendChild(childNode) {
      if (childNode.rootNode !== this.rootNode) {
        childNode.rootNode = this.rootNode;
        childNode._nodeId = ++this.rootNode.nodeCounter;
      }
      childNode.parentNode = this;
      this.childNodes.push(childNode);
      return childNode;
    }
    replace(node) {
      if (node === this) {
        return this;
      }
      this.parentNode.childNodes.forEach((childNode, i) => {
        if (childNode === this) {
          node.rootNode = this.rootNode;
          node.parentNode = this.parentNode;
          node._nodeId = this._nodeId;
          this.rootNode = this;
          this.parentNode = undefined;
          node.parentNode.childNodes[i] = node;
        }
      });
      return node;
    }
    remove() {
      if (!this.parentNode) {
        return this;
      }
      for (let i = this.parentNode.childNodes.length - 1;i >= 0; i--) {
        if (this.parentNode.childNodes[i] === this) {
          this.parentNode.childNodes.splice(i, 1);
          this.parentNode = undefined;
          this.rootNode = this;
          return this;
        }
      }
    }
    setHeader(key, value) {
      let added = false, headerValue;
      if (!value && key && typeof key === "object") {
        if (key.key && "value" in key) {
          this.setHeader(key.key, key.value);
        } else if (Array.isArray(key)) {
          key.forEach((i) => {
            this.setHeader(i.key, i.value);
          });
        } else {
          Object.keys(key).forEach((i) => {
            this.setHeader(i, key[i]);
          });
        }
        return this;
      }
      key = this._normalizeHeaderKey(key);
      headerValue = {
        key,
        value
      };
      for (let i = 0, len = this._headers.length;i < len; i++) {
        if (this._headers[i].key === key) {
          if (!added) {
            this._headers[i] = headerValue;
            added = true;
          } else {
            this._headers.splice(i, 1);
            i--;
            len--;
          }
        }
      }
      if (!added) {
        this._headers.push(headerValue);
      }
      return this;
    }
    addHeader(key, value) {
      if (!value && key && typeof key === "object") {
        if (key.key && key.value) {
          this.addHeader(key.key, key.value);
        } else if (Array.isArray(key)) {
          key.forEach((i) => {
            this.addHeader(i.key, i.value);
          });
        } else {
          Object.keys(key).forEach((i) => {
            this.addHeader(i, key[i]);
          });
        }
        return this;
      } else if (Array.isArray(value)) {
        value.forEach((val) => {
          this.addHeader(key, val);
        });
        return this;
      }
      this._headers.push({
        key: this._normalizeHeaderKey(key),
        value
      });
      return this;
    }
    getHeader(key) {
      key = this._normalizeHeaderKey(key);
      for (let i = 0, len = this._headers.length;i < len; i++) {
        if (this._headers[i].key === key) {
          return this._headers[i].value;
        }
      }
    }
    setContent(content) {
      this.content = content;
      if (typeof this.content.pipe === "function") {
        this._contentErrorHandler = (err) => {
          this.content.removeListener("error", this._contentErrorHandler);
          this.content = err;
        };
        this.content.once("error", this._contentErrorHandler);
      } else if (typeof this.content === "string") {
        this._isPlainText = mimeFuncs.isPlainText(this.content);
        if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {
          this._hasLongLines = true;
        }
      }
      return this;
    }
    build(callback) {
      let promise;
      if (!callback) {
        promise = new Promise((resolve, reject) => {
          callback = shared.callbackPromise(resolve, reject);
        });
      }
      let stream = this.createReadStream();
      let buf = [];
      let buflen = 0;
      let returned = false;
      stream.on("readable", () => {
        let chunk;
        while ((chunk = stream.read()) !== null) {
          buf.push(chunk);
          buflen += chunk.length;
        }
      });
      stream.once("error", (err) => {
        if (returned) {
          return;
        }
        returned = true;
        return callback(err);
      });
      stream.once("end", (chunk) => {
        if (returned) {
          return;
        }
        returned = true;
        if (chunk && chunk.length) {
          buf.push(chunk);
          buflen += chunk.length;
        }
        return callback(null, Buffer.concat(buf, buflen));
      });
      return promise;
    }
    getTransferEncoding() {
      let transferEncoding = false;
      let contentType = (this.getHeader("Content-Type") || "").toString().toLowerCase().trim();
      if (this.content) {
        transferEncoding = (this.getHeader("Content-Transfer-Encoding") || "").toString().toLowerCase().trim();
        if (!transferEncoding || !["base64", "quoted-printable"].includes(transferEncoding)) {
          if (/^text\//i.test(contentType)) {
            if (this._isPlainText && !this._hasLongLines) {
              transferEncoding = "7bit";
            } else if (typeof this.content === "string" || this.content instanceof Buffer) {
              transferEncoding = this._getTextEncoding(this.content) === "Q" ? "quoted-printable" : "base64";
            } else {
              transferEncoding = this.textEncoding === "B" ? "base64" : "quoted-printable";
            }
          } else if (!/^(multipart|message)\//i.test(contentType)) {
            transferEncoding = transferEncoding || "base64";
          }
        }
      }
      return transferEncoding;
    }
    buildHeaders() {
      let transferEncoding = this.getTransferEncoding();
      let headers = [];
      if (transferEncoding) {
        this.setHeader("Content-Transfer-Encoding", transferEncoding);
      }
      if (this.filename && !this.getHeader("Content-Disposition")) {
        this.setHeader("Content-Disposition", "attachment");
      }
      if (this.rootNode === this) {
        if (!this.getHeader("Date")) {
          this.setHeader("Date", this.date.toUTCString().replace(/GMT/, "+0000"));
        }
        this.messageId();
        if (!this.getHeader("MIME-Version")) {
          this.setHeader("MIME-Version", "1.0");
        }
        for (let i = this._headers.length - 2;i >= 0; i--) {
          let header = this._headers[i];
          if (header.key === "Content-Type") {
            this._headers.splice(i, 1);
            this._headers.push(header);
          }
        }
      }
      this._headers.forEach((header) => {
        let key = header.key;
        let value = header.value;
        let structured;
        let param;
        let options = {};
        let formattedHeaders = ["From", "Sender", "To", "Cc", "Bcc", "Reply-To", "Date", "References"];
        if (value && typeof value === "object" && !formattedHeaders.includes(key)) {
          Object.keys(value).forEach((key2) => {
            if (key2 !== "value") {
              options[key2] = value[key2];
            }
          });
          value = (value.value || "").toString();
          if (!value.trim()) {
            return;
          }
        }
        if (options.prepared) {
          if (options.foldLines) {
            headers.push(mimeFuncs.foldLines(key + ": " + value));
          } else {
            headers.push(key + ": " + value);
          }
          return;
        }
        switch (header.key) {
          case "Content-Disposition":
            structured = mimeFuncs.parseHeaderValue(value);
            if (this.filename) {
              structured.params.filename = this.filename;
            }
            value = mimeFuncs.buildHeaderValue(structured);
            break;
          case "Content-Type":
            structured = mimeFuncs.parseHeaderValue(value);
            this._handleContentType(structured);
            if (structured.value.match(/^text\/plain\b/) && typeof this.content === "string" && /[\u0080-\uFFFF]/.test(this.content)) {
              structured.params.charset = "utf-8";
            }
            value = mimeFuncs.buildHeaderValue(structured);
            if (this.filename) {
              param = this._encodeWords(this.filename);
              if (param !== this.filename || /[\s'"\\;:/=(),<>@[\]?]|^-/.test(param)) {
                param = '"' + param + '"';
              }
              value += "; name=" + param;
            }
            break;
          case "Bcc":
            if (!this.keepBcc) {
              return;
            }
            break;
        }
        value = this._encodeHeaderValue(key, value);
        if (!(value || "").toString().trim()) {
          return;
        }
        if (typeof this.normalizeHeaderKey === "function") {
          let normalized = this.normalizeHeaderKey(key, value);
          if (normalized && typeof normalized === "string" && normalized.length) {
            key = normalized;
          }
        }
        headers.push(mimeFuncs.foldLines(key + ": " + value, 76));
      });
      return headers.join("\r\n");
    }
    createReadStream(options) {
      options = options || {};
      let stream = new PassThrough(options);
      let outputStream = stream;
      let transform;
      this.stream(stream, options, (err) => {
        if (err) {
          outputStream.emit("error", err);
          return;
        }
        stream.end();
      });
      for (let i = 0, len = this._transforms.length;i < len; i++) {
        transform = typeof this._transforms[i] === "function" ? this._transforms[i]() : this._transforms[i];
        outputStream.once("error", (err) => {
          transform.emit("error", err);
        });
        outputStream = outputStream.pipe(transform);
      }
      transform = new LastNewline;
      outputStream.once("error", (err) => {
        transform.emit("error", err);
      });
      outputStream = outputStream.pipe(transform);
      for (let i = 0, len = this._processFuncs.length;i < len; i++) {
        transform = this._processFuncs[i];
        outputStream = transform(outputStream);
      }
      if (this.newline) {
        const winbreak = ["win", "windows", "dos", "\r\n"].includes(this.newline.toString().toLowerCase());
        const newlineTransform = winbreak ? new LeWindows : new LeUnix;
        const stream2 = outputStream.pipe(newlineTransform);
        outputStream.on("error", (err) => stream2.emit("error", err));
        return stream2;
      }
      return outputStream;
    }
    transform(transform) {
      this._transforms.push(transform);
    }
    processFunc(processFunc) {
      this._processFuncs.push(processFunc);
    }
    stream(outputStream, options, done) {
      let transferEncoding = this.getTransferEncoding();
      let contentStream;
      let localStream;
      let returned = false;
      let callback = (err) => {
        if (returned) {
          return;
        }
        returned = true;
        done(err);
      };
      let finalize = () => {
        let childId = 0;
        let processChildNode = () => {
          if (childId >= this.childNodes.length) {
            outputStream.write("\r\n--" + this.boundary + "--\r\n");
            return callback();
          }
          let child = this.childNodes[childId++];
          outputStream.write((childId > 1 ? "\r\n" : "") + "--" + this.boundary + "\r\n");
          child.stream(outputStream, options, (err) => {
            if (err) {
              return callback(err);
            }
            setImmediate(processChildNode);
          });
        };
        if (this.multipart) {
          setImmediate(processChildNode);
        } else {
          return callback();
        }
      };
      let sendContent = () => {
        if (this.content) {
          if (Object.prototype.toString.call(this.content) === "[object Error]") {
            return callback(this.content);
          }
          if (typeof this.content.pipe === "function") {
            this.content.removeListener("error", this._contentErrorHandler);
            this._contentErrorHandler = (err) => callback(err);
            this.content.once("error", this._contentErrorHandler);
          }
          let createStream = () => {
            if (["quoted-printable", "base64"].includes(transferEncoding)) {
              contentStream = new (transferEncoding === "base64" ? base64 : qp).Encoder(options);
              contentStream.pipe(outputStream, {
                end: false
              });
              contentStream.once("end", finalize);
              contentStream.once("error", (err) => callback(err));
              localStream = this._getStream(this.content);
              localStream.pipe(contentStream);
            } else {
              localStream = this._getStream(this.content);
              localStream.pipe(outputStream, {
                end: false
              });
              localStream.once("end", finalize);
            }
            localStream.once("error", (err) => callback(err));
          };
          if (this.content._resolve) {
            let chunks = [];
            let chunklen = 0;
            let returned2 = false;
            let sourceStream = this._getStream(this.content);
            sourceStream.on("error", (err) => {
              if (returned2) {
                return;
              }
              returned2 = true;
              callback(err);
            });
            sourceStream.on("readable", () => {
              let chunk;
              while ((chunk = sourceStream.read()) !== null) {
                chunks.push(chunk);
                chunklen += chunk.length;
              }
            });
            sourceStream.on("end", () => {
              if (returned2) {
                return;
              }
              returned2 = true;
              this.content._resolve = false;
              this.content._resolvedValue = Buffer.concat(chunks, chunklen);
              setImmediate(createStream);
            });
          } else {
            setImmediate(createStream);
          }
          return;
        } else {
          return setImmediate(finalize);
        }
      };
      if (this._raw) {
        setImmediate(() => {
          if (Object.prototype.toString.call(this._raw) === "[object Error]") {
            return callback(this._raw);
          }
          if (typeof this._raw.pipe === "function") {
            this._raw.removeListener("error", this._contentErrorHandler);
          }
          let raw = this._getStream(this._raw);
          raw.pipe(outputStream, {
            end: false
          });
          raw.on("error", (err) => outputStream.emit("error", err));
          raw.on("end", finalize);
        });
      } else {
        outputStream.write(this.buildHeaders() + "\r\n\r\n");
        setImmediate(sendContent);
      }
    }
    setEnvelope(envelope) {
      let list;
      this._envelope = {
        from: false,
        to: []
      };
      if (envelope.from) {
        list = [];
        this._convertAddresses(this._parseAddresses(envelope.from), list);
        list = list.filter((address) => address && address.address);
        if (list.length && list[0]) {
          this._envelope.from = list[0].address;
        }
      }
      ["to", "cc", "bcc"].forEach((key) => {
        if (envelope[key]) {
          this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);
        }
      });
      this._envelope.to = this._envelope.to.map((to) => to.address).filter((address) => address);
      let standardFields = ["to", "cc", "bcc", "from"];
      Object.keys(envelope).forEach((key) => {
        if (!standardFields.includes(key)) {
          this._envelope[key] = envelope[key];
        }
      });
      return this;
    }
    getAddresses() {
      let addresses = {};
      this._headers.forEach((header) => {
        let key = header.key.toLowerCase();
        if (["from", "sender", "reply-to", "to", "cc", "bcc"].includes(key)) {
          if (!Array.isArray(addresses[key])) {
            addresses[key] = [];
          }
          this._convertAddresses(this._parseAddresses(header.value), addresses[key]);
        }
      });
      return addresses;
    }
    getEnvelope() {
      if (this._envelope) {
        return this._envelope;
      }
      let envelope = {
        from: false,
        to: []
      };
      this._headers.forEach((header) => {
        let list = [];
        if (header.key === "From" || !envelope.from && ["Reply-To", "Sender"].includes(header.key)) {
          this._convertAddresses(this._parseAddresses(header.value), list);
          if (list.length && list[0]) {
            envelope.from = list[0].address;
          }
        } else if (["To", "Cc", "Bcc"].includes(header.key)) {
          this._convertAddresses(this._parseAddresses(header.value), envelope.to);
        }
      });
      envelope.to = envelope.to.map((to) => to.address);
      return envelope;
    }
    messageId() {
      let messageId = this.getHeader("Message-ID");
      if (!messageId) {
        messageId = this._generateMessageId();
        this.setHeader("Message-ID", messageId);
      }
      return messageId;
    }
    setRaw(raw) {
      this._raw = raw;
      if (this._raw && typeof this._raw.pipe === "function") {
        this._contentErrorHandler = (err) => {
          this._raw.removeListener("error", this._contentErrorHandler);
          this._raw = err;
        };
        this._raw.once("error", this._contentErrorHandler);
      }
      return this;
    }
    _getStream(content) {
      let contentStream;
      if (content._resolvedValue) {
        contentStream = new PassThrough;
        setImmediate(() => {
          try {
            contentStream.end(content._resolvedValue);
          } catch (err) {
            contentStream.emit("error", err);
          }
        });
        return contentStream;
      } else if (typeof content.pipe === "function") {
        return content;
      } else if (content && typeof content.path === "string" && !content.href) {
        if (this.disableFileAccess) {
          contentStream = new PassThrough;
          setImmediate(() => contentStream.emit("error", new Error("File access rejected for " + content.path)));
          return contentStream;
        }
        return fs2.createReadStream(content.path);
      } else if (content && typeof content.href === "string") {
        if (this.disableUrlAccess) {
          contentStream = new PassThrough;
          setImmediate(() => contentStream.emit("error", new Error("Url access rejected for " + content.href)));
          return contentStream;
        }
        return nmfetch(content.href, { headers: content.httpHeaders });
      } else {
        contentStream = new PassThrough;
        setImmediate(() => {
          try {
            contentStream.end(content || "");
          } catch (err) {
            contentStream.emit("error", err);
          }
        });
        return contentStream;
      }
    }
    _parseAddresses(addresses) {
      return [].concat.apply([], [].concat(addresses).map((address) => {
        if (address && address.address) {
          address.address = this._normalizeAddress(address.address);
          address.name = address.name || "";
          return [address];
        }
        return addressparser(address);
      }));
    }
    _normalizeHeaderKey(key) {
      key = (key || "").toString().replace(/\r?\n|\r/g, " ").trim().toLowerCase().replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, (c) => c.toUpperCase()).replace(/^Content-Features$/i, "Content-features");
      return key;
    }
    _handleContentType(structured) {
      this.contentType = structured.value.trim().toLowerCase();
      this.multipart = /^multipart\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf("/") + 1) : false;
      if (this.multipart) {
        this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();
      } else {
        this.boundary = false;
      }
    }
    _generateBoundary() {
      return this.rootNode.boundaryPrefix + "-" + this.rootNode.baseBoundary + "-Part_" + this._nodeId;
    }
    _encodeHeaderValue(key, value) {
      key = this._normalizeHeaderKey(key);
      switch (key) {
        case "From":
        case "Sender":
        case "To":
        case "Cc":
        case "Bcc":
        case "Reply-To":
          return this._convertAddresses(this._parseAddresses(value));
        case "Message-ID":
        case "In-Reply-To":
        case "Content-Id":
          value = (value || "").toString().replace(/\r?\n|\r/g, " ");
          if (value.charAt(0) !== "<") {
            value = "<" + value;
          }
          if (value.charAt(value.length - 1) !== ">") {
            value = value + ">";
          }
          return value;
        case "References":
          value = [].concat.apply([], [].concat(value || "").map((elm) => {
            elm = (elm || "").toString().replace(/\r?\n|\r/g, " ").trim();
            return elm.replace(/<[^>]*>/g, (str) => str.replace(/\s/g, "")).split(/\s+/);
          })).map((elm) => {
            if (elm.charAt(0) !== "<") {
              elm = "<" + elm;
            }
            if (elm.charAt(elm.length - 1) !== ">") {
              elm = elm + ">";
            }
            return elm;
          });
          return value.join(" ").trim();
        case "Date":
          if (Object.prototype.toString.call(value) === "[object Date]") {
            return value.toUTCString().replace(/GMT/, "+0000");
          }
          value = (value || "").toString().replace(/\r?\n|\r/g, " ");
          return this._encodeWords(value);
        case "Content-Type":
        case "Content-Disposition":
          return (value || "").toString().replace(/\r?\n|\r/g, " ");
        default:
          value = (value || "").toString().replace(/\r?\n|\r/g, " ");
          return this._encodeWords(value);
      }
    }
    _convertAddresses(addresses, uniqueList) {
      let values2 = [];
      uniqueList = uniqueList || [];
      [].concat(addresses || []).forEach((address) => {
        if (address.address) {
          address.address = this._normalizeAddress(address.address);
          if (!address.name) {
            values2.push(address.address.indexOf(" ") >= 0 ? `<${address.address}>` : `${address.address}`);
          } else if (address.name) {
            values2.push(`${this._encodeAddressName(address.name)} <${address.address}>`);
          }
          if (address.address) {
            if (!uniqueList.filter((a) => a.address === address.address).length) {
              uniqueList.push(address);
            }
          }
        } else if (address.group) {
          let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : "").trim();
          values2.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);
        }
      });
      return values2.join(", ");
    }
    _normalizeAddress(address) {
      address = (address || "").toString().replace(/[\x00-\x1F<>]+/g, " ").trim();
      let lastAt = address.lastIndexOf("@");
      if (lastAt < 0) {
        return address;
      }
      let user = address.substr(0, lastAt);
      let domain = address.substr(lastAt + 1);
      let encodedDomain;
      try {
        encodedDomain = punycode.toASCII(domain.toLowerCase());
      } catch (err) {
      }
      if (user.indexOf(" ") >= 0) {
        if (user.charAt(0) !== '"') {
          user = '"' + user;
        }
        if (user.substr(-1) !== '"') {
          user = user + '"';
        }
      }
      return `${user}@${encodedDomain}`;
    }
    _encodeAddressName(name) {
      if (!/^[\w ]*$/.test(name)) {
        if (/^[\x20-\x7e]*$/.test(name)) {
          return '"' + name.replace(/([\\"])/g, "\\$1") + '"';
        } else {
          return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);
        }
      }
      return name;
    }
    _encodeWords(value) {
      return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);
    }
    _getTextEncoding(value) {
      value = (value || "").toString();
      let encoding = this.textEncoding;
      let latinLen;
      let nonLatinLen;
      if (!encoding) {
        nonLatinLen = (value.match(/[\x00-\x08\x0B\x0C\x0E-\x1F\u0080-\uFFFF]/g) || []).length;
        latinLen = (value.match(/[a-z]/gi) || []).length;
        encoding = nonLatinLen < latinLen ? "Q" : "B";
      }
      return encoding;
    }
    _generateMessageId() {
      return "<" + [2, 2, 2, 6].reduce((prev, len) => prev + "-" + crypto3.randomBytes(len).toString("hex"), crypto3.randomBytes(4).toString("hex")) + "@" + (this.getEnvelope().from || this.hostname || "localhost").split("@").pop() + ">";
    }
  }
  module.exports = MimeNode;
});

// node_modules/nodemailer/lib/mail-composer/index.js
var require_mail_composer = __commonJS((exports, module) => {
  var MimeNode = require_mime_node();
  var mimeFuncs = require_mime_funcs();
  var parseDataURI = require_shared().parseDataURI;

  class MailComposer {
    constructor(mail) {
      this.mail = mail || {};
      this.message = false;
    }
    compile() {
      this._alternatives = this.getAlternatives();
      this._htmlNode = this._alternatives.filter((alternative) => /^text\/html\b/i.test(alternative.contentType)).pop();
      this._attachments = this.getAttachments(!!this._htmlNode);
      this._useRelated = !!(this._htmlNode && this._attachments.related.length);
      this._useAlternative = this._alternatives.length > 1;
      this._useMixed = this._attachments.attached.length > 1 || this._alternatives.length && this._attachments.attached.length === 1;
      if (this.mail.raw) {
        this.message = new MimeNode("message/rfc822", { newline: this.mail.newline }).setRaw(this.mail.raw);
      } else if (this._useMixed) {
        this.message = this._createMixed();
      } else if (this._useAlternative) {
        this.message = this._createAlternative();
      } else if (this._useRelated) {
        this.message = this._createRelated();
      } else {
        this.message = this._createContentNode(false, [].concat(this._alternatives || []).concat(this._attachments.attached || []).shift() || {
          contentType: "text/plain",
          content: ""
        });
      }
      if (this.mail.headers) {
        this.message.addHeader(this.mail.headers);
      }
      ["from", "sender", "to", "cc", "bcc", "reply-to", "in-reply-to", "references", "subject", "message-id", "date"].forEach((header) => {
        let key = header.replace(/-(\w)/g, (o, c) => c.toUpperCase());
        if (this.mail[key]) {
          this.message.setHeader(header, this.mail[key]);
        }
      });
      if (this.mail.envelope) {
        this.message.setEnvelope(this.mail.envelope);
      }
      this.message.messageId();
      return this.message;
    }
    getAttachments(findRelated) {
      let icalEvent, eventObject;
      let attachments = [].concat(this.mail.attachments || []).map((attachment, i) => {
        let data;
        if (/^data:/i.test(attachment.path || attachment.href)) {
          attachment = this._processDataUrl(attachment);
        }
        let contentType = attachment.contentType || mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || "bin");
        let isImage = /^image\//i.test(contentType);
        let isMessageNode = /^message\//i.test(contentType);
        let contentDisposition = attachment.contentDisposition || (isMessageNode || isImage && attachment.cid ? "inline" : "attachment");
        let contentTransferEncoding;
        if ("contentTransferEncoding" in attachment) {
          contentTransferEncoding = attachment.contentTransferEncoding;
        } else if (isMessageNode) {
          contentTransferEncoding = "7bit";
        } else {
          contentTransferEncoding = "base64";
        }
        data = {
          contentType,
          contentDisposition,
          contentTransferEncoding
        };
        if (attachment.filename) {
          data.filename = attachment.filename;
        } else if (!isMessageNode && attachment.filename !== false) {
          data.filename = (attachment.path || attachment.href || "").split("/").pop().split("?").shift() || "attachment-" + (i + 1);
          if (data.filename.indexOf(".") < 0) {
            data.filename += "." + mimeFuncs.detectExtension(data.contentType);
          }
        }
        if (/^https?:\/\//i.test(attachment.path)) {
          attachment.href = attachment.path;
          attachment.path = undefined;
        }
        if (attachment.cid) {
          data.cid = attachment.cid;
        }
        if (attachment.raw) {
          data.raw = attachment.raw;
        } else if (attachment.path) {
          data.content = {
            path: attachment.path
          };
        } else if (attachment.href) {
          data.content = {
            href: attachment.href,
            httpHeaders: attachment.httpHeaders
          };
        } else {
          data.content = attachment.content || "";
        }
        if (attachment.encoding) {
          data.encoding = attachment.encoding;
        }
        if (attachment.headers) {
          data.headers = attachment.headers;
        }
        return data;
      });
      if (this.mail.icalEvent) {
        if (typeof this.mail.icalEvent === "object" && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {
          icalEvent = this.mail.icalEvent;
        } else {
          icalEvent = {
            content: this.mail.icalEvent
          };
        }
        eventObject = {};
        Object.keys(icalEvent).forEach((key) => {
          eventObject[key] = icalEvent[key];
        });
        eventObject.contentType = "application/ics";
        if (!eventObject.headers) {
          eventObject.headers = {};
        }
        eventObject.filename = eventObject.filename || "invite.ics";
        eventObject.headers["Content-Disposition"] = "attachment";
        eventObject.headers["Content-Transfer-Encoding"] = "base64";
      }
      if (!findRelated) {
        return {
          attached: attachments.concat(eventObject || []),
          related: []
        };
      } else {
        return {
          attached: attachments.filter((attachment) => !attachment.cid).concat(eventObject || []),
          related: attachments.filter((attachment) => !!attachment.cid)
        };
      }
    }
    getAlternatives() {
      let alternatives = [], text2, html, watchHtml, amp, icalEvent, eventObject;
      if (this.mail.text) {
        if (typeof this.mail.text === "object" && (this.mail.text.content || this.mail.text.path || this.mail.text.href || this.mail.text.raw)) {
          text2 = this.mail.text;
        } else {
          text2 = {
            content: this.mail.text
          };
        }
        text2.contentType = "text/plain; charset=utf-8";
      }
      if (this.mail.watchHtml) {
        if (typeof this.mail.watchHtml === "object" && (this.mail.watchHtml.content || this.mail.watchHtml.path || this.mail.watchHtml.href || this.mail.watchHtml.raw)) {
          watchHtml = this.mail.watchHtml;
        } else {
          watchHtml = {
            content: this.mail.watchHtml
          };
        }
        watchHtml.contentType = "text/watch-html; charset=utf-8";
      }
      if (this.mail.amp) {
        if (typeof this.mail.amp === "object" && (this.mail.amp.content || this.mail.amp.path || this.mail.amp.href || this.mail.amp.raw)) {
          amp = this.mail.amp;
        } else {
          amp = {
            content: this.mail.amp
          };
        }
        amp.contentType = "text/x-amp-html; charset=utf-8";
      }
      if (this.mail.icalEvent) {
        if (typeof this.mail.icalEvent === "object" && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {
          icalEvent = this.mail.icalEvent;
        } else {
          icalEvent = {
            content: this.mail.icalEvent
          };
        }
        eventObject = {};
        Object.keys(icalEvent).forEach((key) => {
          eventObject[key] = icalEvent[key];
        });
        if (eventObject.content && typeof eventObject.content === "object") {
          eventObject.content._resolve = true;
        }
        eventObject.filename = false;
        eventObject.contentType = "text/calendar; charset=utf-8; method=" + (eventObject.method || "PUBLISH").toString().trim().toUpperCase();
        if (!eventObject.headers) {
          eventObject.headers = {};
        }
      }
      if (this.mail.html) {
        if (typeof this.mail.html === "object" && (this.mail.html.content || this.mail.html.path || this.mail.html.href || this.mail.html.raw)) {
          html = this.mail.html;
        } else {
          html = {
            content: this.mail.html
          };
        }
        html.contentType = "text/html; charset=utf-8";
      }
      [].concat(text2 || []).concat(watchHtml || []).concat(amp || []).concat(html || []).concat(eventObject || []).concat(this.mail.alternatives || []).forEach((alternative) => {
        let data;
        if (/^data:/i.test(alternative.path || alternative.href)) {
          alternative = this._processDataUrl(alternative);
        }
        data = {
          contentType: alternative.contentType || mimeFuncs.detectMimeType(alternative.filename || alternative.path || alternative.href || "txt"),
          contentTransferEncoding: alternative.contentTransferEncoding
        };
        if (alternative.filename) {
          data.filename = alternative.filename;
        }
        if (/^https?:\/\//i.test(alternative.path)) {
          alternative.href = alternative.path;
          alternative.path = undefined;
        }
        if (alternative.raw) {
          data.raw = alternative.raw;
        } else if (alternative.path) {
          data.content = {
            path: alternative.path
          };
        } else if (alternative.href) {
          data.content = {
            href: alternative.href
          };
        } else {
          data.content = alternative.content || "";
        }
        if (alternative.encoding) {
          data.encoding = alternative.encoding;
        }
        if (alternative.headers) {
          data.headers = alternative.headers;
        }
        alternatives.push(data);
      });
      return alternatives;
    }
    _createMixed(parentNode) {
      let node;
      if (!parentNode) {
        node = new MimeNode("multipart/mixed", {
          baseBoundary: this.mail.baseBoundary,
          textEncoding: this.mail.textEncoding,
          boundaryPrefix: this.mail.boundaryPrefix,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      } else {
        node = parentNode.createChild("multipart/mixed", {
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      }
      if (this._useAlternative) {
        this._createAlternative(node);
      } else if (this._useRelated) {
        this._createRelated(node);
      }
      [].concat(!this._useAlternative && this._alternatives || []).concat(this._attachments.attached || []).forEach((element) => {
        if (!this._useRelated || element !== this._htmlNode) {
          this._createContentNode(node, element);
        }
      });
      return node;
    }
    _createAlternative(parentNode) {
      let node;
      if (!parentNode) {
        node = new MimeNode("multipart/alternative", {
          baseBoundary: this.mail.baseBoundary,
          textEncoding: this.mail.textEncoding,
          boundaryPrefix: this.mail.boundaryPrefix,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      } else {
        node = parentNode.createChild("multipart/alternative", {
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      }
      this._alternatives.forEach((alternative) => {
        if (this._useRelated && this._htmlNode === alternative) {
          this._createRelated(node);
        } else {
          this._createContentNode(node, alternative);
        }
      });
      return node;
    }
    _createRelated(parentNode) {
      let node;
      if (!parentNode) {
        node = new MimeNode('multipart/related; type="text/html"', {
          baseBoundary: this.mail.baseBoundary,
          textEncoding: this.mail.textEncoding,
          boundaryPrefix: this.mail.boundaryPrefix,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      } else {
        node = parentNode.createChild('multipart/related; type="text/html"', {
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      }
      this._createContentNode(node, this._htmlNode);
      this._attachments.related.forEach((alternative) => this._createContentNode(node, alternative));
      return node;
    }
    _createContentNode(parentNode, element) {
      element = element || {};
      element.content = element.content || "";
      let node;
      let encoding = (element.encoding || "utf8").toString().toLowerCase().replace(/[-_\s]/g, "");
      if (!parentNode) {
        node = new MimeNode(element.contentType, {
          filename: element.filename,
          baseBoundary: this.mail.baseBoundary,
          textEncoding: this.mail.textEncoding,
          boundaryPrefix: this.mail.boundaryPrefix,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      } else {
        node = parentNode.createChild(element.contentType, {
          filename: element.filename,
          textEncoding: this.mail.textEncoding,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      }
      if (element.headers) {
        node.addHeader(element.headers);
      }
      if (element.cid) {
        node.setHeader("Content-Id", "<" + element.cid.replace(/[<>]/g, "") + ">");
      }
      if (element.contentTransferEncoding) {
        node.setHeader("Content-Transfer-Encoding", element.contentTransferEncoding);
      } else if (this.mail.encoding && /^text\//i.test(element.contentType)) {
        node.setHeader("Content-Transfer-Encoding", this.mail.encoding);
      }
      if (!/^text\//i.test(element.contentType) || element.contentDisposition) {
        node.setHeader("Content-Disposition", element.contentDisposition || (element.cid && /^image\//i.test(element.contentType) ? "inline" : "attachment"));
      }
      if (typeof element.content === "string" && !["utf8", "usascii", "ascii"].includes(encoding)) {
        element.content = Buffer.from(element.content, encoding);
      }
      if (element.raw) {
        node.setRaw(element.raw);
      } else {
        node.setContent(element.content);
      }
      return node;
    }
    _processDataUrl(element) {
      let parsedDataUri;
      if ((element.path || element.href).match(/^data:/)) {
        parsedDataUri = parseDataURI(element.path || element.href);
      }
      if (!parsedDataUri) {
        return element;
      }
      element.content = parsedDataUri.data;
      element.contentType = element.contentType || parsedDataUri.contentType;
      if ("path" in element) {
        element.path = false;
      }
      if ("href" in element) {
        element.href = false;
      }
      return element;
    }
  }
  module.exports = MailComposer;
});

// node_modules/nodemailer/lib/dkim/message-parser.js
var require_message_parser = __commonJS((exports, module) => {
  var Transform = __require("stream").Transform;

  class MessageParser extends Transform {
    constructor(options) {
      super(options);
      this.lastBytes = Buffer.alloc(4);
      this.headersParsed = false;
      this.headerBytes = 0;
      this.headerChunks = [];
      this.rawHeaders = false;
      this.bodySize = 0;
    }
    updateLastBytes(data) {
      let lblen = this.lastBytes.length;
      let nblen = Math.min(data.length, lblen);
      for (let i = 0, len = lblen - nblen;i < len; i++) {
        this.lastBytes[i] = this.lastBytes[i + nblen];
      }
      for (let i = 1;i <= nblen; i++) {
        this.lastBytes[lblen - i] = data[data.length - i];
      }
    }
    checkHeaders(data) {
      if (this.headersParsed) {
        return true;
      }
      let lblen = this.lastBytes.length;
      let headerPos = 0;
      this.curLinePos = 0;
      for (let i = 0, len = this.lastBytes.length + data.length;i < len; i++) {
        let chr;
        if (i < lblen) {
          chr = this.lastBytes[i];
        } else {
          chr = data[i - lblen];
        }
        if (chr === 10 && i) {
          let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];
          let pr2 = i > 1 ? i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen] : false;
          if (pr1 === 10) {
            this.headersParsed = true;
            headerPos = i - lblen + 1;
            this.headerBytes += headerPos;
            break;
          } else if (pr1 === 13 && pr2 === 10) {
            this.headersParsed = true;
            headerPos = i - lblen + 1;
            this.headerBytes += headerPos;
            break;
          }
        }
      }
      if (this.headersParsed) {
        this.headerChunks.push(data.slice(0, headerPos));
        this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);
        this.headerChunks = null;
        this.emit("headers", this.parseHeaders());
        if (data.length - 1 > headerPos) {
          let chunk = data.slice(headerPos);
          this.bodySize += chunk.length;
          setImmediate(() => this.push(chunk));
        }
        return false;
      } else {
        this.headerBytes += data.length;
        this.headerChunks.push(data);
      }
      this.updateLastBytes(data);
      return false;
    }
    _transform(chunk, encoding, callback) {
      if (!chunk || !chunk.length) {
        return callback();
      }
      if (typeof chunk === "string") {
        chunk = Buffer.from(chunk, encoding);
      }
      let headersFound;
      try {
        headersFound = this.checkHeaders(chunk);
      } catch (E) {
        return callback(E);
      }
      if (headersFound) {
        this.bodySize += chunk.length;
        this.push(chunk);
      }
      setImmediate(callback);
    }
    _flush(callback) {
      if (this.headerChunks) {
        let chunk = Buffer.concat(this.headerChunks, this.headerBytes);
        this.bodySize += chunk.length;
        this.push(chunk);
        this.headerChunks = null;
      }
      callback();
    }
    parseHeaders() {
      let lines = (this.rawHeaders || "").toString().split(/\r?\n/);
      for (let i = lines.length - 1;i > 0; i--) {
        if (/^\s/.test(lines[i])) {
          lines[i - 1] += "\n" + lines[i];
          lines.splice(i, 1);
        }
      }
      return lines.filter((line) => line.trim()).map((line) => ({
        key: line.substr(0, line.indexOf(":")).trim().toLowerCase(),
        line
      }));
    }
  }
  module.exports = MessageParser;
});

// node_modules/nodemailer/lib/dkim/relaxed-body.js
var require_relaxed_body = __commonJS((exports, module) => {
  var Transform = __require("stream").Transform;
  var crypto3 = __require("crypto");

  class RelaxedBody extends Transform {
    constructor(options) {
      super();
      options = options || {};
      this.chunkBuffer = [];
      this.chunkBufferLen = 0;
      this.bodyHash = crypto3.createHash(options.hashAlgo || "sha1");
      this.remainder = "";
      this.byteLength = 0;
      this.debug = options.debug;
      this._debugBody = options.debug ? [] : false;
    }
    updateHash(chunk) {
      let bodyStr;
      let nextRemainder = "";
      let state = "file";
      for (let i = chunk.length - 1;i >= 0; i--) {
        let c = chunk[i];
        if (state === "file" && (c === 10 || c === 13)) {
        } else if (state === "file" && (c === 9 || c === 32)) {
          state = "line";
        } else if (state === "line" && (c === 9 || c === 32)) {
        } else if (state === "file" || state === "line") {
          state = "body";
          if (i === chunk.length - 1) {
            break;
          }
        }
        if (i === 0) {
          if (state === "file" && (!this.remainder || /[\r\n]$/.test(this.remainder)) || state === "line" && (!this.remainder || /[ \t]$/.test(this.remainder))) {
            this.remainder += chunk.toString("binary");
            return;
          } else if (state === "line" || state === "file") {
            nextRemainder = chunk.toString("binary");
            chunk = false;
            break;
          }
        }
        if (state !== "body") {
          continue;
        }
        nextRemainder = chunk.slice(i + 1).toString("binary");
        chunk = chunk.slice(0, i + 1);
        break;
      }
      let needsFixing = !!this.remainder;
      if (chunk && !needsFixing) {
        for (let i = 0, len = chunk.length;i < len; i++) {
          if (i && chunk[i] === 10 && chunk[i - 1] !== 13) {
            needsFixing = true;
            break;
          } else if (i && chunk[i] === 13 && chunk[i - 1] === 32) {
            needsFixing = true;
            break;
          } else if (i && chunk[i] === 32 && chunk[i - 1] === 32) {
            needsFixing = true;
            break;
          } else if (chunk[i] === 9) {
            needsFixing = true;
            break;
          }
        }
      }
      if (needsFixing) {
        bodyStr = this.remainder + (chunk ? chunk.toString("binary") : "");
        this.remainder = nextRemainder;
        bodyStr = bodyStr.replace(/\r?\n/g, "\n").replace(/[ \t]*$/gm, "").replace(/[ \t]+/gm, " ").replace(/\n/g, "\r\n");
        chunk = Buffer.from(bodyStr, "binary");
      } else if (nextRemainder) {
        this.remainder = nextRemainder;
      }
      if (this.debug) {
        this._debugBody.push(chunk);
      }
      this.bodyHash.update(chunk);
    }
    _transform(chunk, encoding, callback) {
      if (!chunk || !chunk.length) {
        return callback();
      }
      if (typeof chunk === "string") {
        chunk = Buffer.from(chunk, encoding);
      }
      this.updateHash(chunk);
      this.byteLength += chunk.length;
      this.push(chunk);
      callback();
    }
    _flush(callback) {
      if (/[\r\n]$/.test(this.remainder) && this.byteLength > 2) {
        this.bodyHash.update(Buffer.from("\r\n"));
      }
      if (!this.byteLength) {
        this.push(Buffer.from("\r\n"));
      }
      this.emit("hash", this.bodyHash.digest("base64"), this.debug ? Buffer.concat(this._debugBody) : false);
      callback();
    }
  }
  module.exports = RelaxedBody;
});

// node_modules/nodemailer/lib/dkim/sign.js
var require_sign = __commonJS((exports, module) => {
  function generateDKIMHeader(domainName, keySelector, fieldNames, hashAlgo, bodyHash) {
    let dkim = [
      "v=1",
      "a=rsa-" + hashAlgo,
      "c=relaxed/relaxed",
      "d=" + punycode.toASCII(domainName),
      "q=dns/txt",
      "s=" + keySelector,
      "bh=" + bodyHash,
      "h=" + fieldNames
    ].join("; ");
    return mimeFuncs.foldLines("DKIM-Signature: " + dkim, 76) + ";\r\n b=";
  }
  function relaxedHeaders(headers, fieldNames, skipFields) {
    let includedFields = new Set;
    let skip = new Set;
    let headerFields = new Map;
    (skipFields || "").toLowerCase().split(":").forEach((field) => {
      skip.add(field.trim());
    });
    (fieldNames || "").toLowerCase().split(":").filter((field) => !skip.has(field.trim())).forEach((field) => {
      includedFields.add(field.trim());
    });
    for (let i = headers.length - 1;i >= 0; i--) {
      let line = headers[i];
      if (includedFields.has(line.key) && !headerFields.has(line.key)) {
        headerFields.set(line.key, relaxedHeaderLine(line.line));
      }
    }
    let headersList = [];
    let fields = [];
    includedFields.forEach((field) => {
      if (headerFields.has(field)) {
        fields.push(field);
        headersList.push(field + ":" + headerFields.get(field));
      }
    });
    return {
      headers: headersList.join("\r\n") + "\r\n",
      fieldNames: fields.join(":")
    };
  }
  function relaxedHeaderLine(line) {
    return line.substr(line.indexOf(":") + 1).replace(/\r?\n/g, "").replace(/\s+/g, " ").trim();
  }
  var punycode = require_punycode();
  var mimeFuncs = require_mime_funcs();
  var crypto3 = __require("crypto");
  module.exports = (headers, hashAlgo, bodyHash, options) => {
    options = options || {};
    let defaultFieldNames = "From:Sender:Reply-To:Subject:Date:Message-ID:To:" + "Cc:MIME-Version:Content-Type:Content-Transfer-Encoding:Content-ID:" + "Content-Description:Resent-Date:Resent-From:Resent-Sender:" + "Resent-To:Resent-Cc:Resent-Message-ID:In-Reply-To:References:" + "List-Id:List-Help:List-Unsubscribe:List-Subscribe:List-Post:" + "List-Owner:List-Archive";
    let fieldNames = options.headerFieldNames || defaultFieldNames;
    let canonicalizedHeaderData = relaxedHeaders(headers, fieldNames, options.skipFields);
    let dkimHeader = generateDKIMHeader(options.domainName, options.keySelector, canonicalizedHeaderData.fieldNames, hashAlgo, bodyHash);
    let signer, signature;
    canonicalizedHeaderData.headers += "dkim-signature:" + relaxedHeaderLine(dkimHeader);
    signer = crypto3.createSign(("rsa-" + hashAlgo).toUpperCase());
    signer.update(canonicalizedHeaderData.headers);
    try {
      signature = signer.sign(options.privateKey, "base64");
    } catch (E) {
      return false;
    }
    return dkimHeader + signature.replace(/(^.{73}|.{75}(?!\r?\n|\r))/g, "$&\r\n ").trim();
  };
  module.exports.relaxedHeaders = relaxedHeaders;
});

// node_modules/nodemailer/lib/dkim/index.js
var require_dkim = __commonJS((exports, module) => {
  var MessageParser = require_message_parser();
  var RelaxedBody = require_relaxed_body();
  var sign = require_sign();
  var PassThrough = __require("stream").PassThrough;
  var fs2 = __require("fs");
  var path = __require("path");
  var crypto3 = __require("crypto");
  var DKIM_ALGO = "sha256";
  var MAX_MESSAGE_SIZE = 2 * 1024 * 1024;

  class DKIMSigner {
    constructor(options, keys, input, output) {
      this.options = options || {};
      this.keys = keys;
      this.cacheTreshold = Number(this.options.cacheTreshold) || MAX_MESSAGE_SIZE;
      this.hashAlgo = this.options.hashAlgo || DKIM_ALGO;
      this.cacheDir = this.options.cacheDir || false;
      this.chunks = [];
      this.chunklen = 0;
      this.readPos = 0;
      this.cachePath = this.cacheDir ? path.join(this.cacheDir, "message." + Date.now() + "-" + crypto3.randomBytes(14).toString("hex")) : false;
      this.cache = false;
      this.headers = false;
      this.bodyHash = false;
      this.parser = false;
      this.relaxedBody = false;
      this.input = input;
      this.output = output;
      this.output.usingCache = false;
      this.hasErrored = false;
      this.input.on("error", (err) => {
        this.hasErrored = true;
        this.cleanup();
        output.emit("error", err);
      });
    }
    cleanup() {
      if (!this.cache || !this.cachePath) {
        return;
      }
      fs2.unlink(this.cachePath, () => false);
    }
    createReadCache() {
      this.cache = fs2.createReadStream(this.cachePath);
      this.cache.once("error", (err) => {
        this.cleanup();
        this.output.emit("error", err);
      });
      this.cache.once("close", () => {
        this.cleanup();
      });
      this.cache.pipe(this.output);
    }
    sendNextChunk() {
      if (this.hasErrored) {
        return;
      }
      if (this.readPos >= this.chunks.length) {
        if (!this.cache) {
          return this.output.end();
        }
        return this.createReadCache();
      }
      let chunk = this.chunks[this.readPos++];
      if (this.output.write(chunk) === false) {
        return this.output.once("drain", () => {
          this.sendNextChunk();
        });
      }
      setImmediate(() => this.sendNextChunk());
    }
    sendSignedOutput() {
      let keyPos = 0;
      let signNextKey = () => {
        if (keyPos >= this.keys.length) {
          this.output.write(this.parser.rawHeaders);
          return setImmediate(() => this.sendNextChunk());
        }
        let key = this.keys[keyPos++];
        let dkimField = sign(this.headers, this.hashAlgo, this.bodyHash, {
          domainName: key.domainName,
          keySelector: key.keySelector,
          privateKey: key.privateKey,
          headerFieldNames: this.options.headerFieldNames,
          skipFields: this.options.skipFields
        });
        if (dkimField) {
          this.output.write(Buffer.from(dkimField + "\r\n"));
        }
        return setImmediate(signNextKey);
      };
      if (this.bodyHash && this.headers) {
        return signNextKey();
      }
      this.output.write(this.parser.rawHeaders);
      this.sendNextChunk();
    }
    createWriteCache() {
      this.output.usingCache = true;
      this.cache = fs2.createWriteStream(this.cachePath);
      this.cache.once("error", (err) => {
        this.cleanup();
        this.relaxedBody.unpipe(this.cache);
        this.relaxedBody.on("readable", () => {
          while (this.relaxedBody.read() !== null) {
          }
        });
        this.hasErrored = true;
        this.output.emit("error", err);
      });
      this.cache.once("close", () => {
        this.sendSignedOutput();
      });
      this.relaxedBody.removeAllListeners("readable");
      this.relaxedBody.pipe(this.cache);
    }
    signStream() {
      this.parser = new MessageParser;
      this.relaxedBody = new RelaxedBody({
        hashAlgo: this.hashAlgo
      });
      this.parser.on("headers", (value) => {
        this.headers = value;
      });
      this.relaxedBody.on("hash", (value) => {
        this.bodyHash = value;
      });
      this.relaxedBody.on("readable", () => {
        let chunk;
        if (this.cache) {
          return;
        }
        while ((chunk = this.relaxedBody.read()) !== null) {
          this.chunks.push(chunk);
          this.chunklen += chunk.length;
          if (this.chunklen >= this.cacheTreshold && this.cachePath) {
            return this.createWriteCache();
          }
        }
      });
      this.relaxedBody.on("end", () => {
        if (this.cache) {
          return;
        }
        this.sendSignedOutput();
      });
      this.parser.pipe(this.relaxedBody);
      setImmediate(() => this.input.pipe(this.parser));
    }
  }

  class DKIM {
    constructor(options) {
      this.options = options || {};
      this.keys = [].concat(this.options.keys || {
        domainName: options.domainName,
        keySelector: options.keySelector,
        privateKey: options.privateKey
      });
    }
    sign(input, extraOptions) {
      let output = new PassThrough;
      let inputStream = input;
      let writeValue = false;
      if (Buffer.isBuffer(input)) {
        writeValue = input;
        inputStream = new PassThrough;
      } else if (typeof input === "string") {
        writeValue = Buffer.from(input);
        inputStream = new PassThrough;
      }
      let options = this.options;
      if (extraOptions && Object.keys(extraOptions).length) {
        options = {};
        Object.keys(this.options || {}).forEach((key) => {
          options[key] = this.options[key];
        });
        Object.keys(extraOptions || {}).forEach((key) => {
          if (!(key in options)) {
            options[key] = extraOptions[key];
          }
        });
      }
      let signer = new DKIMSigner(options, this.keys, inputStream, output);
      setImmediate(() => {
        signer.signStream();
        if (writeValue) {
          setImmediate(() => {
            inputStream.end(writeValue);
          });
        }
      });
      return output;
    }
  }
  module.exports = DKIM;
});

// node_modules/nodemailer/lib/smtp-connection/http-proxy-client.js
var require_http_proxy_client = __commonJS((exports, module) => {
  function httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {
    let proxy = urllib.parse(proxyUrl);
    let options;
    let connect;
    let socket;
    options = {
      host: proxy.hostname,
      port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === "https:" ? 443 : 80
    };
    if (proxy.protocol === "https:") {
      options.rejectUnauthorized = false;
      connect = tls2.connect.bind(tls2);
    } else {
      connect = net2.connect.bind(net2);
    }
    let finished = false;
    let tempSocketErr = (err) => {
      if (finished) {
        return;
      }
      finished = true;
      try {
        socket.destroy();
      } catch (E) {
      }
      callback(err);
    };
    let timeoutErr = () => {
      let err = new Error("Proxy socket timed out");
      err.code = "ETIMEDOUT";
      tempSocketErr(err);
    };
    socket = connect(options, () => {
      if (finished) {
        return;
      }
      let reqHeaders = {
        Host: destinationHost + ":" + destinationPort,
        Connection: "close"
      };
      if (proxy.auth) {
        reqHeaders["Proxy-Authorization"] = "Basic " + Buffer.from(proxy.auth).toString("base64");
      }
      socket.write("CONNECT " + destinationHost + ":" + destinationPort + " HTTP/1.1\r\n" + Object.keys(reqHeaders).map((key) => key + ": " + reqHeaders[key]).join("\r\n") + "\r\n\r\n");
      let headers = "";
      let onSocketData = (chunk) => {
        let match;
        let remainder;
        if (finished) {
          return;
        }
        headers += chunk.toString("binary");
        if (match = headers.match(/\r\n\r\n/)) {
          socket.removeListener("data", onSocketData);
          remainder = headers.substr(match.index + match[0].length);
          headers = headers.substr(0, match.index);
          if (remainder) {
            socket.unshift(Buffer.from(remainder, "binary"));
          }
          finished = true;
          match = headers.match(/^HTTP\/\d+\.\d+ (\d+)/i);
          if (!match || (match[1] || "").charAt(0) !== "2") {
            try {
              socket.destroy();
            } catch (E) {
            }
            return callback(new Error("Invalid response from proxy" + (match && ": " + match[1] || "")));
          }
          socket.removeListener("error", tempSocketErr);
          socket.removeListener("timeout", timeoutErr);
          socket.setTimeout(0);
          return callback(null, socket);
        }
      };
      socket.on("data", onSocketData);
    });
    socket.setTimeout(httpProxyClient.timeout || 30 * 1000);
    socket.on("timeout", timeoutErr);
    socket.once("error", tempSocketErr);
  }
  var net2 = __require("net");
  var tls2 = __require("tls");
  var urllib = __require("url");
  module.exports = httpProxyClient;
});

// node_modules/nodemailer/lib/mailer/mail-message.js
var require_mail_message = __commonJS((exports, module) => {
  var shared = require_shared();
  var MimeNode = require_mime_node();
  var mimeFuncs = require_mime_funcs();

  class MailMessage {
    constructor(mailer, data) {
      this.mailer = mailer;
      this.data = {};
      this.message = null;
      data = data || {};
      let options = mailer.options || {};
      let defaults = mailer._defaults || {};
      Object.keys(data).forEach((key) => {
        this.data[key] = data[key];
      });
      this.data.headers = this.data.headers || {};
      Object.keys(defaults).forEach((key) => {
        if (!(key in this.data)) {
          this.data[key] = defaults[key];
        } else if (key === "headers") {
          Object.keys(defaults.headers).forEach((key2) => {
            if (!(key2 in this.data.headers)) {
              this.data.headers[key2] = defaults.headers[key2];
            }
          });
        }
      });
      ["disableFileAccess", "disableUrlAccess", "normalizeHeaderKey"].forEach((key) => {
        if (key in options) {
          this.data[key] = options[key];
        }
      });
    }
    resolveContent(...args) {
      return shared.resolveContent(...args);
    }
    resolveAll(callback) {
      let keys = [
        [this.data, "html"],
        [this.data, "text"],
        [this.data, "watchHtml"],
        [this.data, "amp"],
        [this.data, "icalEvent"]
      ];
      if (this.data.alternatives && this.data.alternatives.length) {
        this.data.alternatives.forEach((alternative, i) => {
          keys.push([this.data.alternatives, i]);
        });
      }
      if (this.data.attachments && this.data.attachments.length) {
        this.data.attachments.forEach((attachment, i) => {
          if (!attachment.filename) {
            attachment.filename = (attachment.path || attachment.href || "").split("/").pop().split("?").shift() || "attachment-" + (i + 1);
            if (attachment.filename.indexOf(".") < 0) {
              attachment.filename += "." + mimeFuncs.detectExtension(attachment.contentType);
            }
          }
          if (!attachment.contentType) {
            attachment.contentType = mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || "bin");
          }
          keys.push([this.data.attachments, i]);
        });
      }
      let mimeNode = new MimeNode;
      let addressKeys = ["from", "to", "cc", "bcc", "sender", "replyTo"];
      addressKeys.forEach((address) => {
        let value;
        if (this.message) {
          value = [].concat(mimeNode._parseAddresses(this.message.getHeader(address === "replyTo" ? "reply-to" : address)) || []);
        } else if (this.data[address]) {
          value = [].concat(mimeNode._parseAddresses(this.data[address]) || []);
        }
        if (value && value.length) {
          this.data[address] = value;
        } else if (address in this.data) {
          this.data[address] = null;
        }
      });
      let singleKeys = ["from", "sender"];
      singleKeys.forEach((address) => {
        if (this.data[address]) {
          this.data[address] = this.data[address].shift();
        }
      });
      let pos = 0;
      let resolveNext = () => {
        if (pos >= keys.length) {
          return callback(null, this.data);
        }
        let args = keys[pos++];
        if (!args[0] || !args[0][args[1]]) {
          return resolveNext();
        }
        shared.resolveContent(...args, (err, value) => {
          if (err) {
            return callback(err);
          }
          let node = {
            content: value
          };
          if (args[0][args[1]] && typeof args[0][args[1]] === "object" && !Buffer.isBuffer(args[0][args[1]])) {
            Object.keys(args[0][args[1]]).forEach((key) => {
              if (!(key in node) && !["content", "path", "href", "raw"].includes(key)) {
                node[key] = args[0][args[1]][key];
              }
            });
          }
          args[0][args[1]] = node;
          resolveNext();
        });
      };
      setImmediate(() => resolveNext());
    }
    normalize(callback) {
      let envelope = this.data.envelope || this.message.getEnvelope();
      let messageId = this.message.messageId();
      this.resolveAll((err, data) => {
        if (err) {
          return callback(err);
        }
        data.envelope = envelope;
        data.messageId = messageId;
        ["html", "text", "watchHtml", "amp"].forEach((key) => {
          if (data[key] && data[key].content) {
            if (typeof data[key].content === "string") {
              data[key] = data[key].content;
            } else if (Buffer.isBuffer(data[key].content)) {
              data[key] = data[key].content.toString();
            }
          }
        });
        if (data.icalEvent && Buffer.isBuffer(data.icalEvent.content)) {
          data.icalEvent.content = data.icalEvent.content.toString("base64");
          data.icalEvent.encoding = "base64";
        }
        if (data.alternatives && data.alternatives.length) {
          data.alternatives.forEach((alternative) => {
            if (alternative && alternative.content && Buffer.isBuffer(alternative.content)) {
              alternative.content = alternative.content.toString("base64");
              alternative.encoding = "base64";
            }
          });
        }
        if (data.attachments && data.attachments.length) {
          data.attachments.forEach((attachment) => {
            if (attachment && attachment.content && Buffer.isBuffer(attachment.content)) {
              attachment.content = attachment.content.toString("base64");
              attachment.encoding = "base64";
            }
          });
        }
        data.normalizedHeaders = {};
        Object.keys(data.headers || {}).forEach((key) => {
          let value = [].concat(data.headers[key] || []).shift();
          value = value && value.value || value;
          if (value) {
            if (["references", "in-reply-to", "message-id", "content-id"].includes(key)) {
              value = this.message._encodeHeaderValue(key, value);
            }
            data.normalizedHeaders[key] = value;
          }
        });
        if (data.list && typeof data.list === "object") {
          let listHeaders = this._getListHeaders(data.list);
          listHeaders.forEach((entry) => {
            data.normalizedHeaders[entry.key] = entry.value.map((val) => val && val.value || val).join(", ");
          });
        }
        if (data.references) {
          data.normalizedHeaders.references = this.message._encodeHeaderValue("references", data.references);
        }
        if (data.inReplyTo) {
          data.normalizedHeaders["in-reply-to"] = this.message._encodeHeaderValue("in-reply-to", data.inReplyTo);
        }
        return callback(null, data);
      });
    }
    setMailerHeader() {
      if (!this.message || !this.data.xMailer) {
        return;
      }
      this.message.setHeader("X-Mailer", this.data.xMailer);
    }
    setPriorityHeaders() {
      if (!this.message || !this.data.priority) {
        return;
      }
      switch ((this.data.priority || "").toString().toLowerCase()) {
        case "high":
          this.message.setHeader("X-Priority", "1 (Highest)");
          this.message.setHeader("X-MSMail-Priority", "High");
          this.message.setHeader("Importance", "High");
          break;
        case "low":
          this.message.setHeader("X-Priority", "5 (Lowest)");
          this.message.setHeader("X-MSMail-Priority", "Low");
          this.message.setHeader("Importance", "Low");
          break;
        default:
      }
    }
    setListHeaders() {
      if (!this.message || !this.data.list || typeof this.data.list !== "object") {
        return;
      }
      if (this.data.list && typeof this.data.list === "object") {
        this._getListHeaders(this.data.list).forEach((listHeader) => {
          listHeader.value.forEach((value) => {
            this.message.addHeader(listHeader.key, value);
          });
        });
      }
    }
    _getListHeaders(listData) {
      return Object.keys(listData).map((key) => ({
        key: "list-" + key.toLowerCase().trim(),
        value: [].concat(listData[key] || []).map((value) => ({
          prepared: true,
          foldLines: true,
          value: [].concat(value || []).map((value2) => {
            if (typeof value2 === "string") {
              value2 = {
                url: value2
              };
            }
            if (value2 && value2.url) {
              if (key.toLowerCase().trim() === "id") {
                let comment2 = value2.comment || "";
                if (mimeFuncs.isPlainText(comment2)) {
                  comment2 = '"' + comment2 + '"';
                } else {
                  comment2 = mimeFuncs.encodeWord(comment2);
                }
                return (value2.comment ? comment2 + " " : "") + this._formatListUrl(value2.url).replace(/^<[^:]+\/{,2}/, "");
              }
              let comment = value2.comment || "";
              if (!mimeFuncs.isPlainText(comment)) {
                comment = mimeFuncs.encodeWord(comment);
              }
              return this._formatListUrl(value2.url) + (value2.comment ? " (" + comment + ")" : "");
            }
            return "";
          }).filter((value2) => value2).join(", ")
        }))
      }));
    }
    _formatListUrl(url) {
      url = url.replace(/[\s<]+|[\s>]+/g, "");
      if (/^(https?|mailto|ftp):/.test(url)) {
        return "<" + url + ">";
      }
      if (/^[^@]+@[^@]+$/.test(url)) {
        return "<mailto:" + url + ">";
      }
      return "<http://" + url + ">";
    }
  }
  module.exports = MailMessage;
});

// node_modules/nodemailer/lib/mailer/index.js
var require_mailer = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var shared = require_shared();
  var mimeTypes = require_mime_types();
  var MailComposer = require_mail_composer();
  var DKIM = require_dkim();
  var httpProxyClient = require_http_proxy_client();
  var util2 = __require("util");
  var urllib = __require("url");
  var packageData = require_package();
  var MailMessage = require_mail_message();
  var net2 = __require("net");
  var dns = __require("dns");
  var crypto3 = __require("crypto");

  class Mail extends EventEmitter {
    constructor(transporter, options, defaults) {
      super();
      this.options = options || {};
      this._defaults = defaults || {};
      this._defaultPlugins = {
        compile: [(...args) => this._convertDataImages(...args)],
        stream: []
      };
      this._userPlugins = {
        compile: [],
        stream: []
      };
      this.meta = new Map;
      this.dkim = this.options.dkim ? new DKIM(this.options.dkim) : false;
      this.transporter = transporter;
      this.transporter.mailer = this;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "mail"
      });
      this.logger.debug({
        tnx: "create"
      }, "Creating transport: %s", this.getVersionString());
      if (typeof this.transporter.on === "function") {
        this.transporter.on("log", (log) => {
          this.logger.debug({
            tnx: "transport"
          }, "%s: %s", log.type, log.message);
        });
        this.transporter.on("error", (err) => {
          this.logger.error({
            err,
            tnx: "transport"
          }, "Transport Error: %s", err.message);
          this.emit("error", err);
        });
        this.transporter.on("idle", (...args) => {
          this.emit("idle", ...args);
        });
        this.transporter.on("clear", (...args) => {
          this.emit("clear", ...args);
        });
      }
      ["close", "isIdle", "verify"].forEach((method) => {
        this[method] = (...args) => {
          if (typeof this.transporter[method] === "function") {
            if (method === "verify" && typeof this.getSocket === "function") {
              this.transporter.getSocket = this.getSocket;
              this.getSocket = false;
            }
            return this.transporter[method](...args);
          } else {
            this.logger.warn({
              tnx: "transport",
              methodName: method
            }, "Non existing method %s called for transport", method);
            return false;
          }
        };
      });
      if (this.options.proxy && typeof this.options.proxy === "string") {
        this.setupProxy(this.options.proxy);
      }
    }
    use(step, plugin) {
      step = (step || "").toString();
      if (!this._userPlugins.hasOwnProperty(step)) {
        this._userPlugins[step] = [plugin];
      } else {
        this._userPlugins[step].push(plugin);
      }
      return this;
    }
    sendMail(data, callback = null) {
      let promise;
      if (!callback) {
        promise = new Promise((resolve, reject) => {
          callback = shared.callbackPromise(resolve, reject);
        });
      }
      if (typeof this.getSocket === "function") {
        this.transporter.getSocket = this.getSocket;
        this.getSocket = false;
      }
      let mail = new MailMessage(this, data);
      this.logger.debug({
        tnx: "transport",
        name: this.transporter.name,
        version: this.transporter.version,
        action: "send"
      }, "Sending mail using %s/%s", this.transporter.name, this.transporter.version);
      this._processPlugins("compile", mail, (err) => {
        if (err) {
          this.logger.error({
            err,
            tnx: "plugin",
            action: "compile"
          }, "PluginCompile Error: %s", err.message);
          return callback(err);
        }
        mail.message = new MailComposer(mail.data).compile();
        mail.setMailerHeader();
        mail.setPriorityHeaders();
        mail.setListHeaders();
        this._processPlugins("stream", mail, (err2) => {
          if (err2) {
            this.logger.error({
              err: err2,
              tnx: "plugin",
              action: "stream"
            }, "PluginStream Error: %s", err2.message);
            return callback(err2);
          }
          if (mail.data.dkim || this.dkim) {
            mail.message.processFunc((input) => {
              let dkim = mail.data.dkim ? new DKIM(mail.data.dkim) : this.dkim;
              this.logger.debug({
                tnx: "DKIM",
                messageId: mail.message.messageId(),
                dkimDomains: dkim.keys.map((key) => key.keySelector + "." + key.domainName).join(", ")
              }, "Signing outgoing message with %s keys", dkim.keys.length);
              return dkim.sign(input, mail.data._dkim);
            });
          }
          this.transporter.send(mail, (...args) => {
            if (args[0]) {
              this.logger.error({
                err: args[0],
                tnx: "transport",
                action: "send"
              }, "Send Error: %s", args[0].message);
            }
            callback(...args);
          });
        });
      });
      return promise;
    }
    getVersionString() {
      return util2.format("%s (%s; +%s; %s/%s)", packageData.name, packageData.version, packageData.homepage, this.transporter.name, this.transporter.version);
    }
    _processPlugins(step, mail, callback) {
      step = (step || "").toString();
      if (!this._userPlugins.hasOwnProperty(step)) {
        return callback();
      }
      let userPlugins = this._userPlugins[step] || [];
      let defaultPlugins = this._defaultPlugins[step] || [];
      if (userPlugins.length) {
        this.logger.debug({
          tnx: "transaction",
          pluginCount: userPlugins.length,
          step
        }, "Using %s plugins for %s", userPlugins.length, step);
      }
      if (userPlugins.length + defaultPlugins.length === 0) {
        return callback();
      }
      let pos = 0;
      let block = "default";
      let processPlugins = () => {
        let curplugins = block === "default" ? defaultPlugins : userPlugins;
        if (pos >= curplugins.length) {
          if (block === "default" && userPlugins.length) {
            block = "user";
            pos = 0;
            curplugins = userPlugins;
          } else {
            return callback();
          }
        }
        let plugin = curplugins[pos++];
        plugin(mail, (err) => {
          if (err) {
            return callback(err);
          }
          processPlugins();
        });
      };
      processPlugins();
    }
    setupProxy(proxyUrl) {
      let proxy = urllib.parse(proxyUrl);
      this.getSocket = (options, callback) => {
        let protocol = proxy.protocol.replace(/:$/, "").toLowerCase();
        if (this.meta.has("proxy_handler_" + protocol)) {
          return this.meta.get("proxy_handler_" + protocol)(proxy, options, callback);
        }
        switch (protocol) {
          case "http":
          case "https":
            httpProxyClient(proxy.href, options.port, options.host, (err, socket) => {
              if (err) {
                return callback(err);
              }
              return callback(null, {
                connection: socket
              });
            });
            return;
          case "socks":
          case "socks5":
          case "socks4":
          case "socks4a": {
            if (!this.meta.has("proxy_socks_module")) {
              return callback(new Error("Socks module not loaded"));
            }
            let connect = (ipaddress) => {
              let proxyV2 = !!this.meta.get("proxy_socks_module").SocksClient;
              let socksClient = proxyV2 ? this.meta.get("proxy_socks_module").SocksClient : this.meta.get("proxy_socks_module");
              let proxyType = Number(proxy.protocol.replace(/\D/g, "")) || 5;
              let connectionOpts = {
                proxy: {
                  ipaddress,
                  port: Number(proxy.port),
                  type: proxyType
                },
                [proxyV2 ? "destination" : "target"]: {
                  host: options.host,
                  port: options.port
                },
                command: "connect"
              };
              if (proxy.auth) {
                let username = decodeURIComponent(proxy.auth.split(":").shift());
                let password = decodeURIComponent(proxy.auth.split(":").pop());
                if (proxyV2) {
                  connectionOpts.proxy.userId = username;
                  connectionOpts.proxy.password = password;
                } else if (proxyType === 4) {
                  connectionOpts.userid = username;
                } else {
                  connectionOpts.authentication = {
                    username,
                    password
                  };
                }
              }
              socksClient.createConnection(connectionOpts, (err, info) => {
                if (err) {
                  return callback(err);
                }
                return callback(null, {
                  connection: info.socket || info
                });
              });
            };
            if (net2.isIP(proxy.hostname)) {
              return connect(proxy.hostname);
            }
            return dns.resolve(proxy.hostname, (err, address) => {
              if (err) {
                return callback(err);
              }
              connect(Array.isArray(address) ? address[0] : address);
            });
          }
        }
        callback(new Error("Unknown proxy configuration"));
      };
    }
    _convertDataImages(mail, callback) {
      if (!this.options.attachDataUrls && !mail.data.attachDataUrls || !mail.data.html) {
        return callback();
      }
      mail.resolveContent(mail.data, "html", (err, html) => {
        if (err) {
          return callback(err);
        }
        let cidCounter = 0;
        html = (html || "").toString().replace(/(<img\b[^<>]{0,1024} src\s{0,20}=[\s"']{0,20})(data:([^;]+);[^"'>\s]+)/gi, (match, prefix, dataUri, mimeType) => {
          let cid = crypto3.randomBytes(10).toString("hex") + "@localhost";
          if (!mail.data.attachments) {
            mail.data.attachments = [];
          }
          if (!Array.isArray(mail.data.attachments)) {
            mail.data.attachments = [].concat(mail.data.attachments || []);
          }
          mail.data.attachments.push({
            path: dataUri,
            cid,
            filename: "image-" + ++cidCounter + "." + mimeTypes.detectExtension(mimeType)
          });
          return prefix + "cid:" + cid;
        });
        mail.data.html = html;
        callback();
      });
    }
    set(key, value) {
      return this.meta.set(key, value);
    }
    get(key) {
      return this.meta.get(key);
    }
  }
  module.exports = Mail;
});

// node_modules/nodemailer/lib/smtp-connection/data-stream.js
var require_data_stream = __commonJS((exports, module) => {
  var stream = __require("stream");
  var Transform = stream.Transform;

  class DataStream extends Transform {
    constructor(options) {
      super(options);
      this.options = options || {};
      this._curLine = "";
      this.inByteCount = 0;
      this.outByteCount = 0;
      this.lastByte = false;
    }
    _transform(chunk, encoding, done) {
      let chunks = [];
      let chunklen = 0;
      let i, len, lastPos = 0;
      let buf;
      if (!chunk || !chunk.length) {
        return done();
      }
      if (typeof chunk === "string") {
        chunk = Buffer.from(chunk);
      }
      this.inByteCount += chunk.length;
      for (i = 0, len = chunk.length;i < len; i++) {
        if (chunk[i] === 46) {
          if (i && chunk[i - 1] === 10 || !i && (!this.lastByte || this.lastByte === 10)) {
            buf = chunk.slice(lastPos, i + 1);
            chunks.push(buf);
            chunks.push(Buffer.from("."));
            chunklen += buf.length + 1;
            lastPos = i + 1;
          }
        } else if (chunk[i] === 10) {
          if (i && chunk[i - 1] !== 13 || !i && this.lastByte !== 13) {
            if (i > lastPos) {
              buf = chunk.slice(lastPos, i);
              chunks.push(buf);
              chunklen += buf.length + 2;
            } else {
              chunklen += 2;
            }
            chunks.push(Buffer.from("\r\n"));
            lastPos = i + 1;
          }
        }
      }
      if (chunklen) {
        if (lastPos < chunk.length) {
          buf = chunk.slice(lastPos);
          chunks.push(buf);
          chunklen += buf.length;
        }
        this.outByteCount += chunklen;
        this.push(Buffer.concat(chunks, chunklen));
      } else {
        this.outByteCount += chunk.length;
        this.push(chunk);
      }
      this.lastByte = chunk[chunk.length - 1];
      done();
    }
    _flush(done) {
      let buf;
      if (this.lastByte === 10) {
        buf = Buffer.from(".\r\n");
      } else if (this.lastByte === 13) {
        buf = Buffer.from("\n.\r\n");
      } else {
        buf = Buffer.from("\r\n.\r\n");
      }
      this.outByteCount += buf.length;
      this.push(buf);
      done();
    }
  }
  module.exports = DataStream;
});

// node_modules/nodemailer/lib/smtp-connection/index.js
var require_smtp_connection = __commonJS((exports, module) => {
  var packageInfo = require_package();
  var EventEmitter = __require("events").EventEmitter;
  var net2 = __require("net");
  var tls2 = __require("tls");
  var os2 = __require("os");
  var crypto3 = __require("crypto");
  var DataStream = require_data_stream();
  var PassThrough = __require("stream").PassThrough;
  var shared = require_shared();
  var CONNECTION_TIMEOUT = 2 * 60 * 1000;
  var SOCKET_TIMEOUT = 10 * 60 * 1000;
  var GREETING_TIMEOUT = 30 * 1000;
  var DNS_TIMEOUT = 30 * 1000;

  class SMTPConnection extends EventEmitter {
    constructor(options) {
      super(options);
      this.id = crypto3.randomBytes(8).toString("base64").replace(/\W/g, "");
      this.stage = "init";
      this.options = options || {};
      this.secureConnection = !!this.options.secure;
      this.alreadySecured = !!this.options.secured;
      this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);
      this.host = this.options.host || "localhost";
      this.servername = this.options.servername ? this.options.servername : !net2.isIP(this.host) ? this.host : false;
      this.allowInternalNetworkInterfaces = this.options.allowInternalNetworkInterfaces || false;
      if (typeof this.options.secure === "undefined" && this.port === 465) {
        this.secureConnection = true;
      }
      this.name = this.options.name || this._getHostname();
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "smtp-connection",
        sid: this.id
      });
      this.customAuth = new Map;
      Object.keys(this.options.customAuth || {}).forEach((key) => {
        let mapKey = (key || "").toString().trim().toUpperCase();
        if (!mapKey) {
          return;
        }
        this.customAuth.set(mapKey, this.options.customAuth[key]);
      });
      this.version = packageInfo.version;
      this.authenticated = false;
      this.destroyed = false;
      this.secure = !!this.secureConnection;
      this._remainder = "";
      this._responseQueue = [];
      this.lastServerResponse = false;
      this._socket = false;
      this._supportedAuth = [];
      this.allowsAuth = false;
      this._envelope = false;
      this._supportedExtensions = [];
      this._maxAllowedSize = 0;
      this._responseActions = [];
      this._recipientQueue = [];
      this._greetingTimeout = false;
      this._connectionTimeout = false;
      this._destroyed = false;
      this._closing = false;
      this._onSocketData = (chunk) => this._onData(chunk);
      this._onSocketError = (error) => this._onError(error, "ESOCKET", false, "CONN");
      this._onSocketClose = () => this._onClose();
      this._onSocketEnd = () => this._onEnd();
      this._onSocketTimeout = () => this._onTimeout();
    }
    connect(connectCallback) {
      if (typeof connectCallback === "function") {
        this.once("connect", () => {
          this.logger.debug({
            tnx: "smtp"
          }, "SMTP handshake finished");
          connectCallback();
        });
        const isDestroyedMessage = this._isDestroyedMessage("connect");
        if (isDestroyedMessage) {
          return connectCallback(this._formatError(isDestroyedMessage, "ECONNECTION", false, "CONN"));
        }
      }
      let opts = {
        port: this.port,
        host: this.host,
        allowInternalNetworkInterfaces: this.allowInternalNetworkInterfaces,
        timeout: this.options.dnsTimeout || DNS_TIMEOUT
      };
      if (this.options.localAddress) {
        opts.localAddress = this.options.localAddress;
      }
      let setupConnectionHandlers = () => {
        this._connectionTimeout = setTimeout(() => {
          this._onError("Connection timeout", "ETIMEDOUT", false, "CONN");
        }, this.options.connectionTimeout || CONNECTION_TIMEOUT);
        this._socket.on("error", this._onSocketError);
      };
      if (this.options.connection) {
        this._socket = this.options.connection;
        setupConnectionHandlers();
        if (this.secureConnection && !this.alreadySecured) {
          setImmediate(() => this._upgradeConnection((err) => {
            if (err) {
              this._onError(new Error("Error initiating TLS - " + (err.message || err)), "ETLS", false, "CONN");
              return;
            }
            this._onConnect();
          }));
        } else {
          setImmediate(() => this._onConnect());
        }
        return;
      } else if (this.options.socket) {
        this._socket = this.options.socket;
        return shared.resolveHostname(opts, (err, resolved) => {
          if (err) {
            return setImmediate(() => this._onError(err, "EDNS", false, "CONN"));
          }
          this.logger.debug({
            tnx: "dns",
            source: opts.host,
            resolved: resolved.host,
            cached: !!resolved.cached
          }, "Resolved %s as %s [cache %s]", opts.host, resolved.host, resolved.cached ? "hit" : "miss");
          Object.keys(resolved).forEach((key) => {
            if (key.charAt(0) !== "_" && resolved[key]) {
              opts[key] = resolved[key];
            }
          });
          try {
            this._socket.connect(this.port, this.host, () => {
              this._socket.setKeepAlive(true);
              this._onConnect();
            });
            setupConnectionHandlers();
          } catch (E) {
            return setImmediate(() => this._onError(E, "ECONNECTION", false, "CONN"));
          }
        });
      } else if (this.secureConnection) {
        if (this.options.tls) {
          Object.keys(this.options.tls).forEach((key) => {
            opts[key] = this.options.tls[key];
          });
        }
        if (this.servername && !opts.servername) {
          opts.servername = this.servername;
        }
        return shared.resolveHostname(opts, (err, resolved) => {
          if (err) {
            return setImmediate(() => this._onError(err, "EDNS", false, "CONN"));
          }
          this.logger.debug({
            tnx: "dns",
            source: opts.host,
            resolved: resolved.host,
            cached: !!resolved.cached
          }, "Resolved %s as %s [cache %s]", opts.host, resolved.host, resolved.cached ? "hit" : "miss");
          Object.keys(resolved).forEach((key) => {
            if (key.charAt(0) !== "_" && resolved[key]) {
              opts[key] = resolved[key];
            }
          });
          try {
            this._socket = tls2.connect(opts, () => {
              this._socket.setKeepAlive(true);
              this._onConnect();
            });
            setupConnectionHandlers();
          } catch (E) {
            return setImmediate(() => this._onError(E, "ECONNECTION", false, "CONN"));
          }
        });
      } else {
        return shared.resolveHostname(opts, (err, resolved) => {
          if (err) {
            return setImmediate(() => this._onError(err, "EDNS", false, "CONN"));
          }
          this.logger.debug({
            tnx: "dns",
            source: opts.host,
            resolved: resolved.host,
            cached: !!resolved.cached
          }, "Resolved %s as %s [cache %s]", opts.host, resolved.host, resolved.cached ? "hit" : "miss");
          Object.keys(resolved).forEach((key) => {
            if (key.charAt(0) !== "_" && resolved[key]) {
              opts[key] = resolved[key];
            }
          });
          try {
            this._socket = net2.connect(opts, () => {
              this._socket.setKeepAlive(true);
              this._onConnect();
            });
            setupConnectionHandlers();
          } catch (E) {
            return setImmediate(() => this._onError(E, "ECONNECTION", false, "CONN"));
          }
        });
      }
    }
    quit() {
      this._sendCommand("QUIT");
      this._responseActions.push(this.close);
    }
    close() {
      clearTimeout(this._connectionTimeout);
      clearTimeout(this._greetingTimeout);
      this._responseActions = [];
      if (this._closing) {
        return;
      }
      this._closing = true;
      let closeMethod = "end";
      if (this.stage === "init") {
        closeMethod = "destroy";
      }
      this.logger.debug({
        tnx: "smtp"
      }, 'Closing connection to the server using "%s"', closeMethod);
      let socket = this._socket && this._socket.socket || this._socket;
      if (socket && !socket.destroyed) {
        try {
          socket[closeMethod]();
        } catch (E) {
        }
      }
      this._destroy();
    }
    login(authData, callback) {
      const isDestroyedMessage = this._isDestroyedMessage("login");
      if (isDestroyedMessage) {
        return callback(this._formatError(isDestroyedMessage, "ECONNECTION", false, "API"));
      }
      this._auth = authData || {};
      this._authMethod = (this._auth.method || "").toString().trim().toUpperCase() || false;
      if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {
        this._authMethod = "XOAUTH2";
      } else if (!this._authMethod || this._authMethod === "XOAUTH2" && !this._auth.oauth2) {
        this._authMethod = (this._supportedAuth[0] || "PLAIN").toUpperCase().trim();
      }
      if (this._authMethod !== "XOAUTH2" && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {
        if (this._auth.user && this._auth.pass || this.customAuth.has(this._authMethod)) {
          this._auth.credentials = {
            user: this._auth.user,
            pass: this._auth.pass,
            options: this._auth.options
          };
        } else {
          return callback(this._formatError('Missing credentials for "' + this._authMethod + '"', "EAUTH", false, "API"));
        }
      }
      if (this.customAuth.has(this._authMethod)) {
        let handler = this.customAuth.get(this._authMethod);
        let lastResponse;
        let returned = false;
        let resolve = () => {
          if (returned) {
            return;
          }
          returned = true;
          this.logger.info({
            tnx: "smtp",
            username: this._auth.user,
            action: "authenticated",
            method: this._authMethod
          }, "User %s authenticated", JSON.stringify(this._auth.user));
          this.authenticated = true;
          callback(null, true);
        };
        let reject = (err) => {
          if (returned) {
            return;
          }
          returned = true;
          callback(this._formatError(err, "EAUTH", lastResponse, "AUTH " + this._authMethod));
        };
        let handlerResponse = handler({
          auth: this._auth,
          method: this._authMethod,
          extensions: [].concat(this._supportedExtensions),
          authMethods: [].concat(this._supportedAuth),
          maxAllowedSize: this._maxAllowedSize || false,
          sendCommand: (cmd, done) => {
            let promise;
            if (!done) {
              promise = new Promise((resolve2, reject2) => {
                done = shared.callbackPromise(resolve2, reject2);
              });
            }
            this._responseActions.push((str) => {
              lastResponse = str;
              let codes = str.match(/^(\d+)(?:\s(\d+\.\d+\.\d+))?\s/);
              let data = {
                command: cmd,
                response: str
              };
              if (codes) {
                data.status = Number(codes[1]) || 0;
                if (codes[2]) {
                  data.code = codes[2];
                }
                data.text = str.substr(codes[0].length);
              } else {
                data.text = str;
                data.status = 0;
              }
              done(null, data);
            });
            setImmediate(() => this._sendCommand(cmd));
            return promise;
          },
          resolve,
          reject
        });
        if (handlerResponse && typeof handlerResponse.catch === "function") {
          handlerResponse.then(resolve).catch(reject);
        }
        return;
      }
      switch (this._authMethod) {
        case "XOAUTH2":
          this._handleXOauth2Token(false, callback);
          return;
        case "LOGIN":
          this._responseActions.push((str) => {
            this._actionAUTH_LOGIN_USER(str, callback);
          });
          this._sendCommand("AUTH LOGIN");
          return;
        case "PLAIN":
          this._responseActions.push((str) => {
            this._actionAUTHComplete(str, callback);
          });
          this._sendCommand("AUTH PLAIN " + Buffer.from("\0" + this._auth.credentials.user + "\0" + this._auth.credentials.pass, "utf-8").toString("base64"), "AUTH PLAIN " + Buffer.from("\0" + this._auth.credentials.user + "\0" + "/* secret */", "utf-8").toString("base64"));
          return;
        case "CRAM-MD5":
          this._responseActions.push((str) => {
            this._actionAUTH_CRAM_MD5(str, callback);
          });
          this._sendCommand("AUTH CRAM-MD5");
          return;
      }
      return callback(this._formatError('Unknown authentication method "' + this._authMethod + '"', "EAUTH", false, "API"));
    }
    send(envelope, message, done) {
      if (!message) {
        return done(this._formatError("Empty message", "EMESSAGE", false, "API"));
      }
      const isDestroyedMessage = this._isDestroyedMessage("send message");
      if (isDestroyedMessage) {
        return done(this._formatError(isDestroyedMessage, "ECONNECTION", false, "API"));
      }
      if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {
        return setImmediate(() => {
          done(this._formatError("Message size larger than allowed " + this._maxAllowedSize, "EMESSAGE", false, "MAIL FROM"));
        });
      }
      let returned = false;
      let callback = function() {
        if (returned) {
          return;
        }
        returned = true;
        done(...arguments);
      };
      if (typeof message.on === "function") {
        message.on("error", (err) => callback(this._formatError(err, "ESTREAM", false, "API")));
      }
      let startTime = Date.now();
      this._setEnvelope(envelope, (err, info) => {
        if (err) {
          let stream2 = new PassThrough;
          if (typeof message.pipe === "function") {
            message.pipe(stream2);
          } else {
            stream2.write(message);
            stream2.end();
          }
          return callback(err);
        }
        let envelopeTime = Date.now();
        let stream = this._createSendStream((err2, str) => {
          if (err2) {
            return callback(err2);
          }
          info.envelopeTime = envelopeTime - startTime;
          info.messageTime = Date.now() - envelopeTime;
          info.messageSize = stream.outByteCount;
          info.response = str;
          return callback(null, info);
        });
        if (typeof message.pipe === "function") {
          message.pipe(stream);
        } else {
          stream.write(message);
          stream.end();
        }
      });
    }
    reset(callback) {
      this._sendCommand("RSET");
      this._responseActions.push((str) => {
        if (str.charAt(0) !== "2") {
          return callback(this._formatError("Could not reset session state. response=" + str, "EPROTOCOL", str, "RSET"));
        }
        this._envelope = false;
        return callback(null, true);
      });
    }
    _onConnect() {
      clearTimeout(this._connectionTimeout);
      this.logger.info({
        tnx: "network",
        localAddress: this._socket.localAddress,
        localPort: this._socket.localPort,
        remoteAddress: this._socket.remoteAddress,
        remotePort: this._socket.remotePort
      }, "%s established to %s:%s", this.secure ? "Secure connection" : "Connection", this._socket.remoteAddress, this._socket.remotePort);
      if (this._destroyed) {
        this.close();
        return;
      }
      this.stage = "connected";
      this._socket.removeListener("data", this._onSocketData);
      this._socket.removeListener("timeout", this._onSocketTimeout);
      this._socket.removeListener("close", this._onSocketClose);
      this._socket.removeListener("end", this._onSocketEnd);
      this._socket.on("data", this._onSocketData);
      this._socket.once("close", this._onSocketClose);
      this._socket.once("end", this._onSocketEnd);
      this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);
      this._socket.on("timeout", this._onSocketTimeout);
      this._greetingTimeout = setTimeout(() => {
        if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {
          this._onError("Greeting never received", "ETIMEDOUT", false, "CONN");
        }
      }, this.options.greetingTimeout || GREETING_TIMEOUT);
      this._responseActions.push(this._actionGreeting);
      this._socket.resume();
    }
    _onData(chunk) {
      if (this._destroyed || !chunk || !chunk.length) {
        return;
      }
      let data = (chunk || "").toString("binary");
      let lines = (this._remainder + data).split(/\r?\n/);
      let lastline;
      this._remainder = lines.pop();
      for (let i = 0, len = lines.length;i < len; i++) {
        if (this._responseQueue.length) {
          lastline = this._responseQueue[this._responseQueue.length - 1];
          if (/^\d+-/.test(lastline.split("\n").pop())) {
            this._responseQueue[this._responseQueue.length - 1] += "\n" + lines[i];
            continue;
          }
        }
        this._responseQueue.push(lines[i]);
      }
      if (this._responseQueue.length) {
        lastline = this._responseQueue[this._responseQueue.length - 1];
        if (/^\d+-/.test(lastline.split("\n").pop())) {
          return;
        }
      }
      this._processResponse();
    }
    _onError(err, type, data, command) {
      clearTimeout(this._connectionTimeout);
      clearTimeout(this._greetingTimeout);
      if (this._destroyed) {
        return;
      }
      err = this._formatError(err, type, data, command);
      this.logger.error(data, err.message);
      this.emit("error", err);
      this.close();
    }
    _formatError(message, type, response, command) {
      let err;
      if (/Error\]$/i.test(Object.prototype.toString.call(message))) {
        err = message;
      } else {
        err = new Error(message);
      }
      if (type && type !== "Error") {
        err.code = type;
      }
      if (response) {
        err.response = response;
        err.message += ": " + response;
      }
      let responseCode = typeof response === "string" && Number((response.match(/^\d+/) || [])[0]) || false;
      if (responseCode) {
        err.responseCode = responseCode;
      }
      if (command) {
        err.command = command;
      }
      return err;
    }
    _onClose() {
      let serverResponse = false;
      if (this._remainder && this._remainder.trim()) {
        if (this.options.debug || this.options.transactionLog) {
          this.logger.debug({
            tnx: "server"
          }, this._remainder.replace(/\r?\n$/, ""));
        }
        this.lastServerResponse = serverResponse = this._remainder.trim();
      }
      this.logger.info({
        tnx: "network"
      }, "Connection closed");
      if (this.upgrading && !this._destroyed) {
        return this._onError(new Error("Connection closed unexpectedly"), "ETLS", serverResponse, "CONN");
      } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {
        return this._onError(new Error("Connection closed unexpectedly"), "ECONNECTION", serverResponse, "CONN");
      } else if (/^[45]\d{2}\b/.test(serverResponse)) {
        return this._onError(new Error("Connection closed unexpectedly"), "ECONNECTION", serverResponse, "CONN");
      }
      this._destroy();
    }
    _onEnd() {
      if (this._socket && !this._socket.destroyed) {
        this._socket.destroy();
      }
    }
    _onTimeout() {
      return this._onError(new Error("Timeout"), "ETIMEDOUT", false, "CONN");
    }
    _destroy() {
      if (this._destroyed) {
        return;
      }
      this._destroyed = true;
      this.emit("end");
    }
    _upgradeConnection(callback) {
      this._socket.removeListener("data", this._onSocketData);
      this._socket.removeListener("timeout", this._onSocketTimeout);
      let socketPlain = this._socket;
      let opts = {
        socket: this._socket,
        host: this.host
      };
      Object.keys(this.options.tls || {}).forEach((key) => {
        opts[key] = this.options.tls[key];
      });
      if (this.servername && !opts.servername) {
        opts.servername = this.servername;
      }
      this.upgrading = true;
      try {
        this._socket = tls2.connect(opts, () => {
          this.secure = true;
          this.upgrading = false;
          this._socket.on("data", this._onSocketData);
          socketPlain.removeListener("close", this._onSocketClose);
          socketPlain.removeListener("end", this._onSocketEnd);
          return callback(null, true);
        });
      } catch (err) {
        return callback(err);
      }
      this._socket.on("error", this._onSocketError);
      this._socket.once("close", this._onSocketClose);
      this._socket.once("end", this._onSocketEnd);
      this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);
      this._socket.on("timeout", this._onSocketTimeout);
      socketPlain.resume();
    }
    _processResponse() {
      if (!this._responseQueue.length) {
        return false;
      }
      let str = this.lastServerResponse = (this._responseQueue.shift() || "").toString();
      if (/^\d+-/.test(str.split("\n").pop())) {
        return;
      }
      if (this.options.debug || this.options.transactionLog) {
        this.logger.debug({
          tnx: "server"
        }, str.replace(/\r?\n$/, ""));
      }
      if (!str.trim()) {
        setImmediate(() => this._processResponse());
      }
      let action = this._responseActions.shift();
      if (typeof action === "function") {
        action.call(this, str);
        setImmediate(() => this._processResponse());
      } else {
        return this._onError(new Error("Unexpected Response"), "EPROTOCOL", str, "CONN");
      }
    }
    _sendCommand(str, logStr) {
      if (this._destroyed) {
        return;
      }
      if (this._socket.destroyed) {
        return this.close();
      }
      if (this.options.debug || this.options.transactionLog) {
        this.logger.debug({
          tnx: "client"
        }, (logStr || str || "").toString().replace(/\r?\n$/, ""));
      }
      this._socket.write(Buffer.from(str + "\r\n", "utf-8"));
    }
    _setEnvelope(envelope, callback) {
      let args = [];
      let useSmtpUtf8 = false;
      this._envelope = envelope || {};
      this._envelope.from = (this._envelope.from && this._envelope.from.address || this._envelope.from || "").toString().trim();
      this._envelope.to = [].concat(this._envelope.to || []).map((to) => (to && to.address || to || "").toString().trim());
      if (!this._envelope.to.length) {
        return callback(this._formatError("No recipients defined", "EENVELOPE", false, "API"));
      }
      if (this._envelope.from && /[\r\n<>]/.test(this._envelope.from)) {
        return callback(this._formatError("Invalid sender " + JSON.stringify(this._envelope.from), "EENVELOPE", false, "API"));
      }
      if (/[\x80-\uFFFF]/.test(this._envelope.from)) {
        useSmtpUtf8 = true;
      }
      for (let i = 0, len = this._envelope.to.length;i < len; i++) {
        if (!this._envelope.to[i] || /[\r\n<>]/.test(this._envelope.to[i])) {
          return callback(this._formatError("Invalid recipient " + JSON.stringify(this._envelope.to[i]), "EENVELOPE", false, "API"));
        }
        if (/[\x80-\uFFFF]/.test(this._envelope.to[i])) {
          useSmtpUtf8 = true;
        }
      }
      this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));
      this._envelope.rejected = [];
      this._envelope.rejectedErrors = [];
      this._envelope.accepted = [];
      if (this._envelope.dsn) {
        try {
          this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);
        } catch (err) {
          return callback(this._formatError("Invalid DSN " + err.message, "EENVELOPE", false, "API"));
        }
      }
      this._responseActions.push((str) => {
        this._actionMAIL(str, callback);
      });
      if (useSmtpUtf8 && this._supportedExtensions.includes("SMTPUTF8")) {
        args.push("SMTPUTF8");
        this._usingSmtpUtf8 = true;
      }
      if (this._envelope.use8BitMime && this._supportedExtensions.includes("8BITMIME")) {
        args.push("BODY=8BITMIME");
        this._using8BitMime = true;
      }
      if (this._envelope.size && this._supportedExtensions.includes("SIZE")) {
        args.push("SIZE=" + this._envelope.size);
      }
      if (this._envelope.dsn && this._supportedExtensions.includes("DSN")) {
        if (this._envelope.dsn.ret) {
          args.push("RET=" + shared.encodeXText(this._envelope.dsn.ret));
        }
        if (this._envelope.dsn.envid) {
          args.push("ENVID=" + shared.encodeXText(this._envelope.dsn.envid));
        }
      }
      this._sendCommand("MAIL FROM:<" + this._envelope.from + ">" + (args.length ? " " + args.join(" ") : ""));
    }
    _setDsnEnvelope(params) {
      let ret = (params.ret || params.return || "").toString().toUpperCase() || null;
      if (ret) {
        switch (ret) {
          case "HDRS":
          case "HEADERS":
            ret = "HDRS";
            break;
          case "FULL":
          case "BODY":
            ret = "FULL";
            break;
        }
      }
      if (ret && !["FULL", "HDRS"].includes(ret)) {
        throw new Error("ret: " + JSON.stringify(ret));
      }
      let envid = (params.envid || params.id || "").toString() || null;
      let notify = params.notify || null;
      if (notify) {
        if (typeof notify === "string") {
          notify = notify.split(",");
        }
        notify = notify.map((n) => n.trim().toUpperCase());
        let validNotify = ["NEVER", "SUCCESS", "FAILURE", "DELAY"];
        let invaliNotify = notify.filter((n) => !validNotify.includes(n));
        if (invaliNotify.length || notify.length > 1 && notify.includes("NEVER")) {
          throw new Error("notify: " + JSON.stringify(notify.join(",")));
        }
        notify = notify.join(",");
      }
      let orcpt = (params.recipient || params.orcpt || "").toString() || null;
      if (orcpt && orcpt.indexOf(";") < 0) {
        orcpt = "rfc822;" + orcpt;
      }
      return {
        ret,
        envid,
        notify,
        orcpt
      };
    }
    _getDsnRcptToArgs() {
      let args = [];
      if (this._envelope.dsn && this._supportedExtensions.includes("DSN")) {
        if (this._envelope.dsn.notify) {
          args.push("NOTIFY=" + shared.encodeXText(this._envelope.dsn.notify));
        }
        if (this._envelope.dsn.orcpt) {
          args.push("ORCPT=" + shared.encodeXText(this._envelope.dsn.orcpt));
        }
      }
      return args.length ? " " + args.join(" ") : "";
    }
    _createSendStream(callback) {
      let dataStream = new DataStream;
      let logStream;
      if (this.options.lmtp) {
        this._envelope.accepted.forEach((recipient, i) => {
          let final = i === this._envelope.accepted.length - 1;
          this._responseActions.push((str) => {
            this._actionLMTPStream(recipient, final, str, callback);
          });
        });
      } else {
        this._responseActions.push((str) => {
          this._actionSMTPStream(str, callback);
        });
      }
      dataStream.pipe(this._socket, {
        end: false
      });
      if (this.options.debug) {
        logStream = new PassThrough;
        logStream.on("readable", () => {
          let chunk;
          while (chunk = logStream.read()) {
            this.logger.debug({
              tnx: "message"
            }, chunk.toString("binary").replace(/\r?\n$/, ""));
          }
        });
        dataStream.pipe(logStream);
      }
      dataStream.once("end", () => {
        this.logger.info({
          tnx: "message",
          inByteCount: dataStream.inByteCount,
          outByteCount: dataStream.outByteCount
        }, "<%s bytes encoded mime message (source size %s bytes)>", dataStream.outByteCount, dataStream.inByteCount);
      });
      return dataStream;
    }
    _actionGreeting(str) {
      clearTimeout(this._greetingTimeout);
      if (str.substr(0, 3) !== "220") {
        this._onError(new Error("Invalid greeting. response=" + str), "EPROTOCOL", str, "CONN");
        return;
      }
      if (this.options.lmtp) {
        this._responseActions.push(this._actionLHLO);
        this._sendCommand("LHLO " + this.name);
      } else {
        this._responseActions.push(this._actionEHLO);
        this._sendCommand("EHLO " + this.name);
      }
    }
    _actionLHLO(str) {
      if (str.charAt(0) !== "2") {
        this._onError(new Error("Invalid LHLO. response=" + str), "EPROTOCOL", str, "LHLO");
        return;
      }
      this._actionEHLO(str);
    }
    _actionEHLO(str) {
      let match;
      if (str.substr(0, 3) === "421") {
        this._onError(new Error("Server terminates connection. response=" + str), "ECONNECTION", str, "EHLO");
        return;
      }
      if (str.charAt(0) !== "2") {
        if (this.options.requireTLS) {
          this._onError(new Error("EHLO failed but HELO does not support required STARTTLS. response=" + str), "ECONNECTION", str, "EHLO");
          return;
        }
        this._responseActions.push(this._actionHELO);
        this._sendCommand("HELO " + this.name);
        return;
      }
      this._ehloLines = str.split(/\r?\n/).map((line) => line.replace(/^\d+[ -]/, "").trim()).filter((line) => line).slice(1);
      if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\b/im.test(str) || this.options.requireTLS)) {
        this._sendCommand("STARTTLS");
        this._responseActions.push(this._actionSTARTTLS);
        return;
      }
      if (/[ -]SMTPUTF8\b/im.test(str)) {
        this._supportedExtensions.push("SMTPUTF8");
      }
      if (/[ -]DSN\b/im.test(str)) {
        this._supportedExtensions.push("DSN");
      }
      if (/[ -]8BITMIME\b/im.test(str)) {
        this._supportedExtensions.push("8BITMIME");
      }
      if (/[ -]PIPELINING\b/im.test(str)) {
        this._supportedExtensions.push("PIPELINING");
      }
      if (/[ -]AUTH\b/i.test(str)) {
        this.allowsAuth = true;
      }
      if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)PLAIN/i.test(str)) {
        this._supportedAuth.push("PLAIN");
      }
      if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)LOGIN/i.test(str)) {
        this._supportedAuth.push("LOGIN");
      }
      if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)CRAM-MD5/i.test(str)) {
        this._supportedAuth.push("CRAM-MD5");
      }
      if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)XOAUTH2/i.test(str)) {
        this._supportedAuth.push("XOAUTH2");
      }
      if (match = str.match(/[ -]SIZE(?:[ \t]+(\d+))?/im)) {
        this._supportedExtensions.push("SIZE");
        this._maxAllowedSize = Number(match[1]) || 0;
      }
      this.emit("connect");
    }
    _actionHELO(str) {
      if (str.charAt(0) !== "2") {
        this._onError(new Error("Invalid HELO. response=" + str), "EPROTOCOL", str, "HELO");
        return;
      }
      this.allowsAuth = true;
      this.emit("connect");
    }
    _actionSTARTTLS(str) {
      if (str.charAt(0) !== "2") {
        if (this.options.opportunisticTLS) {
          this.logger.info({
            tnx: "smtp"
          }, "Failed STARTTLS upgrade, continuing unencrypted");
          return this.emit("connect");
        }
        this._onError(new Error("Error upgrading connection with STARTTLS"), "ETLS", str, "STARTTLS");
        return;
      }
      this._upgradeConnection((err, secured) => {
        if (err) {
          this._onError(new Error("Error initiating TLS - " + (err.message || err)), "ETLS", false, "STARTTLS");
          return;
        }
        this.logger.info({
          tnx: "smtp"
        }, "Connection upgraded with STARTTLS");
        if (secured) {
          if (this.options.lmtp) {
            this._responseActions.push(this._actionLHLO);
            this._sendCommand("LHLO " + this.name);
          } else {
            this._responseActions.push(this._actionEHLO);
            this._sendCommand("EHLO " + this.name);
          }
        } else {
          this.emit("connect");
        }
      });
    }
    _actionAUTH_LOGIN_USER(str, callback) {
      if (!/^334[ -]/.test(str)) {
        callback(this._formatError('Invalid login sequence while waiting for "334 VXNlcm5hbWU6"', "EAUTH", str, "AUTH LOGIN"));
        return;
      }
      this._responseActions.push((str2) => {
        this._actionAUTH_LOGIN_PASS(str2, callback);
      });
      this._sendCommand(Buffer.from(this._auth.credentials.user + "", "utf-8").toString("base64"));
    }
    _actionAUTH_CRAM_MD5(str, callback) {
      let challengeMatch = str.match(/^334\s+(.+)$/);
      let challengeString = "";
      if (!challengeMatch) {
        return callback(this._formatError("Invalid login sequence while waiting for server challenge string", "EAUTH", str, "AUTH CRAM-MD5"));
      } else {
        challengeString = challengeMatch[1];
      }
      let base64decoded = Buffer.from(challengeString, "base64").toString("ascii"), hmacMD5 = crypto3.createHmac("md5", this._auth.credentials.pass);
      hmacMD5.update(base64decoded);
      let prepended = this._auth.credentials.user + " " + hmacMD5.digest("hex");
      this._responseActions.push((str2) => {
        this._actionAUTH_CRAM_MD5_PASS(str2, callback);
      });
      this._sendCommand(Buffer.from(prepended).toString("base64"), Buffer.from(this._auth.credentials.user + " /* secret */").toString("base64"));
    }
    _actionAUTH_CRAM_MD5_PASS(str, callback) {
      if (!str.match(/^235\s+/)) {
        return callback(this._formatError('Invalid login sequence while waiting for "235"', "EAUTH", str, "AUTH CRAM-MD5"));
      }
      this.logger.info({
        tnx: "smtp",
        username: this._auth.user,
        action: "authenticated",
        method: this._authMethod
      }, "User %s authenticated", JSON.stringify(this._auth.user));
      this.authenticated = true;
      callback(null, true);
    }
    _actionAUTH_LOGIN_PASS(str, callback) {
      if (!/^334[ -]/.test(str)) {
        return callback(this._formatError('Invalid login sequence while waiting for "334 UGFzc3dvcmQ6"', "EAUTH", str, "AUTH LOGIN"));
      }
      this._responseActions.push((str2) => {
        this._actionAUTHComplete(str2, callback);
      });
      this._sendCommand(Buffer.from((this._auth.credentials.pass || "").toString(), "utf-8").toString("base64"), Buffer.from("/* secret */", "utf-8").toString("base64"));
    }
    _actionAUTHComplete(str, isRetry, callback) {
      if (!callback && typeof isRetry === "function") {
        callback = isRetry;
        isRetry = false;
      }
      if (str.substr(0, 3) === "334") {
        this._responseActions.push((str2) => {
          if (isRetry || this._authMethod !== "XOAUTH2") {
            this._actionAUTHComplete(str2, true, callback);
          } else {
            setImmediate(() => this._handleXOauth2Token(true, callback));
          }
        });
        this._sendCommand("");
        return;
      }
      if (str.charAt(0) !== "2") {
        this.logger.info({
          tnx: "smtp",
          username: this._auth.user,
          action: "authfail",
          method: this._authMethod
        }, "User %s failed to authenticate", JSON.stringify(this._auth.user));
        return callback(this._formatError("Invalid login", "EAUTH", str, "AUTH " + this._authMethod));
      }
      this.logger.info({
        tnx: "smtp",
        username: this._auth.user,
        action: "authenticated",
        method: this._authMethod
      }, "User %s authenticated", JSON.stringify(this._auth.user));
      this.authenticated = true;
      callback(null, true);
    }
    _actionMAIL(str, callback) {
      let message, curRecipient;
      if (Number(str.charAt(0)) !== 2) {
        if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\x80-\uFFFF]/.test(this._envelope.from)) {
          message = "Internationalized mailbox name not allowed";
        } else {
          message = "Mail command failed";
        }
        return callback(this._formatError(message, "EENVELOPE", str, "MAIL FROM"));
      }
      if (!this._envelope.rcptQueue.length) {
        return callback(this._formatError("Can't send mail - no recipients defined", "EENVELOPE", false, "API"));
      } else {
        this._recipientQueue = [];
        if (this._supportedExtensions.includes("PIPELINING")) {
          while (this._envelope.rcptQueue.length) {
            curRecipient = this._envelope.rcptQueue.shift();
            this._recipientQueue.push(curRecipient);
            this._responseActions.push((str2) => {
              this._actionRCPT(str2, callback);
            });
            this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
          }
        } else {
          curRecipient = this._envelope.rcptQueue.shift();
          this._recipientQueue.push(curRecipient);
          this._responseActions.push((str2) => {
            this._actionRCPT(str2, callback);
          });
          this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
        }
      }
    }
    _actionRCPT(str, callback) {
      let message, err, curRecipient = this._recipientQueue.shift();
      if (Number(str.charAt(0)) !== 2) {
        if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\x80-\uFFFF]/.test(curRecipient)) {
          message = "Internationalized mailbox name not allowed";
        } else {
          message = "Recipient command failed";
        }
        this._envelope.rejected.push(curRecipient);
        err = this._formatError(message, "EENVELOPE", str, "RCPT TO");
        err.recipient = curRecipient;
        this._envelope.rejectedErrors.push(err);
      } else {
        this._envelope.accepted.push(curRecipient);
      }
      if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {
        if (this._envelope.rejected.length < this._envelope.to.length) {
          this._responseActions.push((str2) => {
            this._actionDATA(str2, callback);
          });
          this._sendCommand("DATA");
        } else {
          err = this._formatError("Can't send mail - all recipients were rejected", "EENVELOPE", str, "RCPT TO");
          err.rejected = this._envelope.rejected;
          err.rejectedErrors = this._envelope.rejectedErrors;
          return callback(err);
        }
      } else if (this._envelope.rcptQueue.length) {
        curRecipient = this._envelope.rcptQueue.shift();
        this._recipientQueue.push(curRecipient);
        this._responseActions.push((str2) => {
          this._actionRCPT(str2, callback);
        });
        this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
      }
    }
    _actionDATA(str, callback) {
      if (!/^[23]/.test(str)) {
        return callback(this._formatError("Data command failed", "EENVELOPE", str, "DATA"));
      }
      let response = {
        accepted: this._envelope.accepted,
        rejected: this._envelope.rejected
      };
      if (this._ehloLines && this._ehloLines.length) {
        response.ehlo = this._ehloLines;
      }
      if (this._envelope.rejectedErrors.length) {
        response.rejectedErrors = this._envelope.rejectedErrors;
      }
      callback(null, response);
    }
    _actionSMTPStream(str, callback) {
      if (Number(str.charAt(0)) !== 2) {
        return callback(this._formatError("Message failed", "EMESSAGE", str, "DATA"));
      } else {
        return callback(null, str);
      }
    }
    _actionLMTPStream(recipient, final, str, callback) {
      let err;
      if (Number(str.charAt(0)) !== 2) {
        err = this._formatError("Message failed for recipient " + recipient, "EMESSAGE", str, "DATA");
        err.recipient = recipient;
        this._envelope.rejected.push(recipient);
        this._envelope.rejectedErrors.push(err);
        for (let i = 0, len = this._envelope.accepted.length;i < len; i++) {
          if (this._envelope.accepted[i] === recipient) {
            this._envelope.accepted.splice(i, 1);
          }
        }
      }
      if (final) {
        return callback(null, str);
      }
    }
    _handleXOauth2Token(isRetry, callback) {
      this._auth.oauth2.getToken(isRetry, (err, accessToken) => {
        if (err) {
          this.logger.info({
            tnx: "smtp",
            username: this._auth.user,
            action: "authfail",
            method: this._authMethod
          }, "User %s failed to authenticate", JSON.stringify(this._auth.user));
          return callback(this._formatError(err, "EAUTH", false, "AUTH XOAUTH2"));
        }
        this._responseActions.push((str) => {
          this._actionAUTHComplete(str, isRetry, callback);
        });
        this._sendCommand("AUTH XOAUTH2 " + this._auth.oauth2.buildXOAuth2Token(accessToken), "AUTH XOAUTH2 " + this._auth.oauth2.buildXOAuth2Token("/* secret */"));
      });
    }
    _isDestroyedMessage(command) {
      if (this._destroyed) {
        return "Cannot " + command + " - smtp connection is already destroyed.";
      }
      if (this._socket) {
        if (this._socket.destroyed) {
          return "Cannot " + command + " - smtp connection socket is already destroyed.";
        }
        if (!this._socket.writable) {
          return "Cannot " + command + " - smtp connection socket is already half-closed.";
        }
      }
    }
    _getHostname() {
      let defaultHostname;
      try {
        defaultHostname = os2.hostname() || "";
      } catch (err) {
        defaultHostname = "localhost";
      }
      if (!defaultHostname || defaultHostname.indexOf(".") < 0) {
        defaultHostname = "[127.0.0.1]";
      }
      if (defaultHostname.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)) {
        defaultHostname = "[" + defaultHostname + "]";
      }
      return defaultHostname;
    }
  }
  module.exports = SMTPConnection;
});

// node_modules/nodemailer/lib/xoauth2/index.js
var require_xoauth2 = __commonJS((exports, module) => {
  var Stream3 = __require("stream").Stream;
  var nmfetch = require_fetch();
  var crypto3 = __require("crypto");
  var shared = require_shared();

  class XOAuth2 extends Stream3 {
    constructor(options, logger3) {
      super();
      this.options = options || {};
      if (options && options.serviceClient) {
        if (!options.privateKey || !options.user) {
          setImmediate(() => this.emit("error", new Error('Options "privateKey" and "user" are required for service account!')));
          return;
        }
        let serviceRequestTimeout = Math.min(Math.max(Number(this.options.serviceRequestTimeout) || 0, 0), 3600);
        this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;
      }
      this.logger = shared.getLogger({
        logger: logger3
      }, {
        component: this.options.component || "OAuth2"
      });
      this.provisionCallback = typeof this.options.provisionCallback === "function" ? this.options.provisionCallback : false;
      this.options.accessUrl = this.options.accessUrl || "https://accounts.google.com/o/oauth2/token";
      this.options.customHeaders = this.options.customHeaders || {};
      this.options.customParams = this.options.customParams || {};
      this.accessToken = this.options.accessToken || false;
      if (this.options.expires && Number(this.options.expires)) {
        this.expires = this.options.expires;
      } else {
        let timeout = Math.max(Number(this.options.timeout) || 0, 0);
        this.expires = timeout && Date.now() + timeout * 1000 || 0;
      }
    }
    getToken(renew, callback) {
      if (!renew && this.accessToken && (!this.expires || this.expires > Date.now())) {
        return callback(null, this.accessToken);
      }
      let generateCallback = (...args) => {
        if (args[0]) {
          this.logger.error({
            err: args[0],
            tnx: "OAUTH2",
            user: this.options.user,
            action: "renew"
          }, "Failed generating new Access Token for %s", this.options.user);
        } else {
          this.logger.info({
            tnx: "OAUTH2",
            user: this.options.user,
            action: "renew"
          }, "Generated new Access Token for %s", this.options.user);
        }
        callback(...args);
      };
      if (this.provisionCallback) {
        this.provisionCallback(this.options.user, !!renew, (err, accessToken, expires) => {
          if (!err && accessToken) {
            this.accessToken = accessToken;
            this.expires = expires || 0;
          }
          generateCallback(err, accessToken);
        });
      } else {
        this.generateToken(generateCallback);
      }
    }
    updateToken(accessToken, timeout) {
      this.accessToken = accessToken;
      timeout = Math.max(Number(timeout) || 0, 0);
      this.expires = timeout && Date.now() + timeout * 1000 || 0;
      this.emit("token", {
        user: this.options.user,
        accessToken: accessToken || "",
        expires: this.expires
      });
    }
    generateToken(callback) {
      let urlOptions;
      let loggedUrlOptions;
      if (this.options.serviceClient) {
        let iat = Math.floor(Date.now() / 1000);
        let tokenData = {
          iss: this.options.serviceClient,
          scope: this.options.scope || "https://mail.google.com/",
          sub: this.options.user,
          aud: this.options.accessUrl,
          iat,
          exp: iat + this.options.serviceRequestTimeout
        };
        let token;
        try {
          token = this.jwtSignRS256(tokenData);
        } catch (err) {
          return callback(new Error("Can't generate token. Check your auth options"));
        }
        urlOptions = {
          grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
          assertion: token
        };
        loggedUrlOptions = {
          grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
          assertion: tokenData
        };
      } else {
        if (!this.options.refreshToken) {
          return callback(new Error("Can't create new access token for user"));
        }
        urlOptions = {
          client_id: this.options.clientId || "",
          client_secret: this.options.clientSecret || "",
          refresh_token: this.options.refreshToken,
          grant_type: "refresh_token"
        };
        loggedUrlOptions = {
          client_id: this.options.clientId || "",
          client_secret: (this.options.clientSecret || "").substr(0, 6) + "...",
          refresh_token: (this.options.refreshToken || "").substr(0, 6) + "...",
          grant_type: "refresh_token"
        };
      }
      Object.keys(this.options.customParams).forEach((key) => {
        urlOptions[key] = this.options.customParams[key];
        loggedUrlOptions[key] = this.options.customParams[key];
      });
      this.logger.debug({
        tnx: "OAUTH2",
        user: this.options.user,
        action: "generate"
      }, "Requesting token using: %s", JSON.stringify(loggedUrlOptions));
      this.postRequest(this.options.accessUrl, urlOptions, this.options, (error, body) => {
        let data;
        if (error) {
          return callback(error);
        }
        try {
          data = JSON.parse(body.toString());
        } catch (E) {
          return callback(E);
        }
        if (!data || typeof data !== "object") {
          this.logger.debug({
            tnx: "OAUTH2",
            user: this.options.user,
            action: "post"
          }, "Response: %s", (body || "").toString());
          return callback(new Error("Invalid authentication response"));
        }
        let logData = {};
        Object.keys(data).forEach((key) => {
          if (key !== "access_token") {
            logData[key] = data[key];
          } else {
            logData[key] = (data[key] || "").toString().substr(0, 6) + "...";
          }
        });
        this.logger.debug({
          tnx: "OAUTH2",
          user: this.options.user,
          action: "post"
        }, "Response: %s", JSON.stringify(logData));
        if (data.error) {
          let errorMessage = data.error;
          if (data.error_description) {
            errorMessage += ": " + data.error_description;
          }
          if (data.error_uri) {
            errorMessage += " (" + data.error_uri + ")";
          }
          return callback(new Error(errorMessage));
        }
        if (data.access_token) {
          this.updateToken(data.access_token, data.expires_in);
          return callback(null, this.accessToken);
        }
        return callback(new Error("No access token"));
      });
    }
    buildXOAuth2Token(accessToken) {
      let authData = ["user=" + (this.options.user || ""), "auth=Bearer " + (accessToken || this.accessToken), "", ""];
      return Buffer.from(authData.join("\x01"), "utf-8").toString("base64");
    }
    postRequest(url, payload, params, callback) {
      let returned = false;
      let chunks = [];
      let chunklen = 0;
      let req = nmfetch(url, {
        method: "post",
        headers: params.customHeaders,
        body: payload,
        allowErrorResponse: true
      });
      req.on("readable", () => {
        let chunk;
        while ((chunk = req.read()) !== null) {
          chunks.push(chunk);
          chunklen += chunk.length;
        }
      });
      req.once("error", (err) => {
        if (returned) {
          return;
        }
        returned = true;
        return callback(err);
      });
      req.once("end", () => {
        if (returned) {
          return;
        }
        returned = true;
        return callback(null, Buffer.concat(chunks, chunklen));
      });
    }
    toBase64URL(data) {
      if (typeof data === "string") {
        data = Buffer.from(data);
      }
      return data.toString("base64").replace(/[=]+/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    jwtSignRS256(payload) {
      payload = ['{"alg":"RS256","typ":"JWT"}', JSON.stringify(payload)].map((val) => this.toBase64URL(val)).join(".");
      let signature = crypto3.createSign("RSA-SHA256").update(payload).sign(this.options.privateKey);
      return payload + "." + this.toBase64URL(signature);
    }
  }
  module.exports = XOAuth2;
});

// node_modules/nodemailer/lib/smtp-pool/pool-resource.js
var require_pool_resource = __commonJS((exports, module) => {
  var SMTPConnection = require_smtp_connection();
  var assign = require_shared().assign;
  var XOAuth2 = require_xoauth2();
  var EventEmitter = __require("events");

  class PoolResource extends EventEmitter {
    constructor(pool) {
      super();
      this.pool = pool;
      this.options = pool.options;
      this.logger = this.pool.logger;
      if (this.options.auth) {
        switch ((this.options.auth.type || "").toString().toUpperCase()) {
          case "OAUTH2": {
            let oauth2 = new XOAuth2(this.options.auth, this.logger);
            oauth2.provisionCallback = this.pool.mailer && this.pool.mailer.get("oauth2_provision_cb") || oauth2.provisionCallback;
            this.auth = {
              type: "OAUTH2",
              user: this.options.auth.user,
              oauth2,
              method: "XOAUTH2"
            };
            oauth2.on("token", (token) => this.pool.mailer.emit("token", token));
            oauth2.on("error", (err) => this.emit("error", err));
            break;
          }
          default:
            if (!this.options.auth.user && !this.options.auth.pass) {
              break;
            }
            this.auth = {
              type: (this.options.auth.type || "").toString().toUpperCase() || "LOGIN",
              user: this.options.auth.user,
              credentials: {
                user: this.options.auth.user || "",
                pass: this.options.auth.pass,
                options: this.options.auth.options
              },
              method: (this.options.auth.method || "").trim().toUpperCase() || this.options.authMethod || false
            };
        }
      }
      this._connection = false;
      this._connected = false;
      this.messages = 0;
      this.available = true;
    }
    connect(callback) {
      this.pool.getSocket(this.options, (err, socketOptions) => {
        if (err) {
          return callback(err);
        }
        let returned = false;
        let options = this.options;
        if (socketOptions && socketOptions.connection) {
          this.logger.info({
            tnx: "proxy",
            remoteAddress: socketOptions.connection.remoteAddress,
            remotePort: socketOptions.connection.remotePort,
            destHost: options.host || "",
            destPort: options.port || "",
            action: "connected"
          }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
          options = assign(false, options);
          Object.keys(socketOptions).forEach((key) => {
            options[key] = socketOptions[key];
          });
        }
        this.connection = new SMTPConnection(options);
        this.connection.once("error", (err2) => {
          this.emit("error", err2);
          if (returned) {
            return;
          }
          returned = true;
          return callback(err2);
        });
        this.connection.once("end", () => {
          this.close();
          if (returned) {
            return;
          }
          returned = true;
          let timer2 = setTimeout(() => {
            if (returned) {
              return;
            }
            let err2 = new Error("Unexpected socket close");
            if (this.connection && this.connection._socket && this.connection._socket.upgrading) {
              err2.code = "ETLS";
            }
            callback(err2);
          }, 1000);
          try {
            timer2.unref();
          } catch (E) {
          }
        });
        this.connection.connect(() => {
          if (returned) {
            return;
          }
          if (this.auth && (this.connection.allowsAuth || options.forceAuth)) {
            this.connection.login(this.auth, (err2) => {
              if (returned) {
                return;
              }
              returned = true;
              if (err2) {
                this.connection.close();
                this.emit("error", err2);
                return callback(err2);
              }
              this._connected = true;
              callback(null, true);
            });
          } else {
            returned = true;
            this._connected = true;
            return callback(null, true);
          }
        });
      });
    }
    send(mail, callback) {
      if (!this._connected) {
        return this.connect((err) => {
          if (err) {
            return callback(err);
          }
          return this.send(mail, callback);
        });
      }
      let envelope = mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let recipients = [].concat(envelope.to || []);
      if (recipients.length > 3) {
        recipients.push("...and " + recipients.splice(2).length + " more");
      }
      this.logger.info({
        tnx: "send",
        messageId,
        cid: this.id
      }, "Sending message %s using #%s to <%s>", messageId, this.id, recipients.join(", "));
      if (mail.data.dsn) {
        envelope.dsn = mail.data.dsn;
      }
      this.connection.send(envelope, mail.message.createReadStream(), (err, info) => {
        this.messages++;
        if (err) {
          this.connection.close();
          this.emit("error", err);
          return callback(err);
        }
        info.envelope = {
          from: envelope.from,
          to: envelope.to
        };
        info.messageId = messageId;
        setImmediate(() => {
          let err2;
          if (this.messages >= this.options.maxMessages) {
            err2 = new Error("Resource exhausted");
            err2.code = "EMAXLIMIT";
            this.connection.close();
            this.emit("error", err2);
          } else {
            this.pool._checkRateLimit(() => {
              this.available = true;
              this.emit("available");
            });
          }
        });
        callback(null, info);
      });
    }
    close() {
      this._connected = false;
      if (this.auth && this.auth.oauth2) {
        this.auth.oauth2.removeAllListeners();
      }
      if (this.connection) {
        this.connection.close();
      }
      this.emit("close");
    }
  }
  module.exports = PoolResource;
});

// node_modules/nodemailer/lib/well-known/services.json
var require_services = __commonJS((exports, module) => {
  module.exports = {
    "1und1": {
      description: "1&1 Mail (German hosting provider)",
      host: "smtp.1und1.de",
      port: 465,
      secure: true,
      authMethod: "LOGIN"
    },
    "126": {
      description: "126 Mail (NetEase)",
      host: "smtp.126.com",
      port: 465,
      secure: true
    },
    "163": {
      description: "163 Mail (NetEase)",
      host: "smtp.163.com",
      port: 465,
      secure: true
    },
    Aliyun: {
      description: "Alibaba Cloud Mail",
      domains: ["aliyun.com"],
      host: "smtp.aliyun.com",
      port: 465,
      secure: true
    },
    AliyunQiye: {
      description: "Alibaba Cloud Enterprise Mail",
      host: "smtp.qiye.aliyun.com",
      port: 465,
      secure: true
    },
    AOL: {
      description: "AOL Mail",
      domains: ["aol.com"],
      host: "smtp.aol.com",
      port: 587
    },
    Bluewin: {
      description: "Bluewin (Swiss email provider)",
      host: "smtpauths.bluewin.ch",
      domains: ["bluewin.ch"],
      port: 465
    },
    DebugMail: {
      description: "DebugMail (email testing service)",
      host: "debugmail.io",
      port: 25
    },
    DynectEmail: {
      description: "Dyn Email Delivery",
      aliases: ["Dynect"],
      host: "smtp.dynect.net",
      port: 25
    },
    ElasticEmail: {
      description: "Elastic Email",
      aliases: ["Elastic Email"],
      host: "smtp.elasticemail.com",
      port: 465,
      secure: true
    },
    Ethereal: {
      description: "Ethereal Email (email testing service)",
      aliases: ["ethereal.email"],
      host: "smtp.ethereal.email",
      port: 587
    },
    FastMail: {
      description: "FastMail",
      domains: ["fastmail.fm"],
      host: "smtp.fastmail.com",
      port: 465,
      secure: true
    },
    "Feishu Mail": {
      description: "Feishu Mail (Lark)",
      aliases: ["Feishu", "FeishuMail"],
      domains: ["www.feishu.cn"],
      host: "smtp.feishu.cn",
      port: 465,
      secure: true
    },
    "Forward Email": {
      description: "Forward Email (email forwarding service)",
      aliases: ["FE", "ForwardEmail"],
      domains: ["forwardemail.net"],
      host: "smtp.forwardemail.net",
      port: 465,
      secure: true
    },
    GandiMail: {
      description: "Gandi Mail",
      aliases: ["Gandi", "Gandi Mail"],
      host: "mail.gandi.net",
      port: 587
    },
    Gmail: {
      description: "Gmail",
      aliases: ["Google Mail"],
      domains: ["gmail.com", "googlemail.com"],
      host: "smtp.gmail.com",
      port: 465,
      secure: true
    },
    GMX: {
      description: "GMX Mail",
      domains: ["gmx.com", "gmx.net", "gmx.de"],
      host: "mail.gmx.com",
      port: 587
    },
    Godaddy: {
      description: "GoDaddy Email (US)",
      host: "smtpout.secureserver.net",
      port: 25
    },
    GodaddyAsia: {
      description: "GoDaddy Email (Asia)",
      host: "smtp.asia.secureserver.net",
      port: 25
    },
    GodaddyEurope: {
      description: "GoDaddy Email (Europe)",
      host: "smtp.europe.secureserver.net",
      port: 25
    },
    "hot.ee": {
      description: "Hot.ee (Estonian email provider)",
      host: "mail.hot.ee"
    },
    Hotmail: {
      description: "Outlook.com / Hotmail",
      aliases: ["Outlook", "Outlook.com", "Hotmail.com"],
      domains: ["hotmail.com", "outlook.com"],
      host: "smtp-mail.outlook.com",
      port: 587
    },
    iCloud: {
      description: "iCloud Mail",
      aliases: ["Me", "Mac"],
      domains: ["me.com", "mac.com"],
      host: "smtp.mail.me.com",
      port: 587
    },
    Infomaniak: {
      description: "Infomaniak Mail (Swiss hosting provider)",
      host: "mail.infomaniak.com",
      domains: ["ik.me", "ikmail.com", "etik.com"],
      port: 587
    },
    Loopia: {
      description: "Loopia (Swedish hosting provider)",
      host: "mailcluster.loopia.se",
      port: 465
    },
    Loops: {
      description: "Loops",
      host: "smtp.loops.so",
      port: 587
    },
    "mail.ee": {
      description: "Mail.ee (Estonian email provider)",
      host: "smtp.mail.ee"
    },
    "Mail.ru": {
      description: "Mail.ru",
      host: "smtp.mail.ru",
      port: 465,
      secure: true
    },
    "Mailcatch.app": {
      description: "Mailcatch (email testing service)",
      host: "sandbox-smtp.mailcatch.app",
      port: 2525
    },
    Maildev: {
      description: "MailDev (local email testing)",
      port: 1025,
      ignoreTLS: true
    },
    MailerSend: {
      description: "MailerSend",
      host: "smtp.mailersend.net",
      port: 587
    },
    Mailgun: {
      description: "Mailgun",
      host: "smtp.mailgun.org",
      port: 465,
      secure: true
    },
    Mailjet: {
      description: "Mailjet",
      host: "in.mailjet.com",
      port: 587
    },
    Mailosaur: {
      description: "Mailosaur (email testing service)",
      host: "mailosaur.io",
      port: 25
    },
    Mailtrap: {
      description: "Mailtrap",
      host: "live.smtp.mailtrap.io",
      port: 587
    },
    Mandrill: {
      description: "Mandrill (by Mailchimp)",
      host: "smtp.mandrillapp.com",
      port: 587
    },
    Naver: {
      description: "Naver Mail (Korean email provider)",
      host: "smtp.naver.com",
      port: 587
    },
    OhMySMTP: {
      description: "OhMySMTP (email delivery service)",
      host: "smtp.ohmysmtp.com",
      port: 587,
      secure: false
    },
    One: {
      description: "One.com Email",
      host: "send.one.com",
      port: 465,
      secure: true
    },
    OpenMailBox: {
      description: "OpenMailBox",
      aliases: ["OMB", "openmailbox.org"],
      host: "smtp.openmailbox.org",
      port: 465,
      secure: true
    },
    Outlook365: {
      description: "Microsoft 365 / Office 365",
      host: "smtp.office365.com",
      port: 587,
      secure: false
    },
    Postmark: {
      description: "Postmark",
      aliases: ["PostmarkApp"],
      host: "smtp.postmarkapp.com",
      port: 2525
    },
    Proton: {
      description: "Proton Mail",
      aliases: ["ProtonMail", "Proton.me", "Protonmail.com", "Protonmail.ch"],
      domains: ["proton.me", "protonmail.com", "pm.me", "protonmail.ch"],
      host: "smtp.protonmail.ch",
      port: 587,
      requireTLS: true
    },
    "qiye.aliyun": {
      description: "Alibaba Mail Enterprise Edition",
      host: "smtp.mxhichina.com",
      port: "465",
      secure: true
    },
    QQ: {
      description: "QQ Mail",
      domains: ["qq.com"],
      host: "smtp.qq.com",
      port: 465,
      secure: true
    },
    QQex: {
      description: "QQ Enterprise Mail",
      aliases: ["QQ Enterprise"],
      domains: ["exmail.qq.com"],
      host: "smtp.exmail.qq.com",
      port: 465,
      secure: true
    },
    Resend: {
      description: "Resend",
      host: "smtp.resend.com",
      port: 465,
      secure: true
    },
    SendCloud: {
      description: "SendCloud (Chinese email delivery)",
      host: "smtp.sendcloud.net",
      port: 2525
    },
    SendGrid: {
      description: "SendGrid",
      host: "smtp.sendgrid.net",
      port: 587
    },
    SendinBlue: {
      description: "Brevo (formerly Sendinblue)",
      aliases: ["Brevo"],
      host: "smtp-relay.brevo.com",
      port: 587
    },
    SendPulse: {
      description: "SendPulse",
      host: "smtp-pulse.com",
      port: 465,
      secure: true
    },
    SES: {
      description: "AWS SES US East (N. Virginia)",
      host: "email-smtp.us-east-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-NORTHEAST-1": {
      description: "AWS SES Asia Pacific (Tokyo)",
      host: "email-smtp.ap-northeast-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-NORTHEAST-2": {
      description: "AWS SES Asia Pacific (Seoul)",
      host: "email-smtp.ap-northeast-2.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-NORTHEAST-3": {
      description: "AWS SES Asia Pacific (Osaka)",
      host: "email-smtp.ap-northeast-3.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-SOUTH-1": {
      description: "AWS SES Asia Pacific (Mumbai)",
      host: "email-smtp.ap-south-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-SOUTHEAST-1": {
      description: "AWS SES Asia Pacific (Singapore)",
      host: "email-smtp.ap-southeast-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-SOUTHEAST-2": {
      description: "AWS SES Asia Pacific (Sydney)",
      host: "email-smtp.ap-southeast-2.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-CA-CENTRAL-1": {
      description: "AWS SES Canada (Central)",
      host: "email-smtp.ca-central-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-EU-CENTRAL-1": {
      description: "AWS SES Europe (Frankfurt)",
      host: "email-smtp.eu-central-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-EU-NORTH-1": {
      description: "AWS SES Europe (Stockholm)",
      host: "email-smtp.eu-north-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-EU-WEST-1": {
      description: "AWS SES Europe (Ireland)",
      host: "email-smtp.eu-west-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-EU-WEST-2": {
      description: "AWS SES Europe (London)",
      host: "email-smtp.eu-west-2.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-EU-WEST-3": {
      description: "AWS SES Europe (Paris)",
      host: "email-smtp.eu-west-3.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-SA-EAST-1": {
      description: "AWS SES South America (São Paulo)",
      host: "email-smtp.sa-east-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-US-EAST-1": {
      description: "AWS SES US East (N. Virginia)",
      host: "email-smtp.us-east-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-US-EAST-2": {
      description: "AWS SES US East (Ohio)",
      host: "email-smtp.us-east-2.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-US-GOV-EAST-1": {
      description: "AWS SES GovCloud (US-East)",
      host: "email-smtp.us-gov-east-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-US-GOV-WEST-1": {
      description: "AWS SES GovCloud (US-West)",
      host: "email-smtp.us-gov-west-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-US-WEST-1": {
      description: "AWS SES US West (N. California)",
      host: "email-smtp.us-west-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-US-WEST-2": {
      description: "AWS SES US West (Oregon)",
      host: "email-smtp.us-west-2.amazonaws.com",
      port: 465,
      secure: true
    },
    Seznam: {
      description: "Seznam Email (Czech email provider)",
      aliases: ["Seznam Email"],
      domains: ["seznam.cz", "email.cz", "post.cz", "spoluzaci.cz"],
      host: "smtp.seznam.cz",
      port: 465,
      secure: true
    },
    SMTP2GO: {
      description: "SMTP2GO",
      host: "mail.smtp2go.com",
      port: 2525
    },
    Sparkpost: {
      description: "SparkPost",
      aliases: ["SparkPost", "SparkPost Mail"],
      domains: ["sparkpost.com"],
      host: "smtp.sparkpostmail.com",
      port: 587,
      secure: false
    },
    Tipimail: {
      description: "Tipimail (email delivery service)",
      host: "smtp.tipimail.com",
      port: 587
    },
    Tutanota: {
      description: "Tutanota (Tuta Mail)",
      domains: ["tutanota.com", "tuta.com", "tutanota.de", "tuta.io"],
      host: "smtp.tutanota.com",
      port: 465,
      secure: true
    },
    Yahoo: {
      description: "Yahoo Mail",
      domains: ["yahoo.com"],
      host: "smtp.mail.yahoo.com",
      port: 465,
      secure: true
    },
    Yandex: {
      description: "Yandex Mail",
      domains: ["yandex.ru"],
      host: "smtp.yandex.ru",
      port: 465,
      secure: true
    },
    Zoho: {
      description: "Zoho Mail",
      host: "smtp.zoho.com",
      port: 465,
      secure: true,
      authMethod: "LOGIN"
    }
  };
});

// node_modules/nodemailer/lib/well-known/index.js
var require_well_known = __commonJS((exports, module) => {
  function normalizeKey(key) {
    return key.replace(/[^a-zA-Z0-9.-]/g, "").toLowerCase();
  }
  function normalizeService(service) {
    let filter = ["domains", "aliases"];
    let response = {};
    Object.keys(service).forEach((key) => {
      if (filter.indexOf(key) < 0) {
        response[key] = service[key];
      }
    });
    return response;
  }
  var services = require_services();
  var normalized = {};
  Object.keys(services).forEach((key) => {
    let service = services[key];
    normalized[normalizeKey(key)] = normalizeService(service);
    [].concat(service.aliases || []).forEach((alias3) => {
      normalized[normalizeKey(alias3)] = normalizeService(service);
    });
    [].concat(service.domains || []).forEach((domain) => {
      normalized[normalizeKey(domain)] = normalizeService(service);
    });
  });
  module.exports = function(key) {
    key = normalizeKey(key.split("@").pop());
    return normalized[key] || false;
  };
});

// node_modules/nodemailer/lib/smtp-pool/index.js
var require_smtp_pool = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var PoolResource = require_pool_resource();
  var SMTPConnection = require_smtp_connection();
  var wellKnown = require_well_known();
  var shared = require_shared();
  var packageData = require_package();

  class SMTPPool extends EventEmitter {
    constructor(options) {
      super();
      options = options || {};
      if (typeof options === "string") {
        options = {
          url: options
        };
      }
      let urlData;
      let service = options.service;
      if (typeof options.getSocket === "function") {
        this.getSocket = options.getSocket;
      }
      if (options.url) {
        urlData = shared.parseConnectionUrl(options.url);
        service = service || urlData.service;
      }
      this.options = shared.assign(false, options, urlData, service && wellKnown(service));
      this.options.maxConnections = this.options.maxConnections || 5;
      this.options.maxMessages = this.options.maxMessages || 100;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "smtp-pool"
      });
      let connection5 = new SMTPConnection(this.options);
      this.name = "SMTP (pool)";
      this.version = packageData.version + "[client:" + connection5.version + "]";
      this._rateLimit = {
        counter: 0,
        timeout: null,
        waiting: [],
        checkpoint: false,
        delta: Number(this.options.rateDelta) || 1000,
        limit: Number(this.options.rateLimit) || 0
      };
      this._closed = false;
      this._queue = [];
      this._connections = [];
      this._connectionCounter = 0;
      this.idling = true;
      setImmediate(() => {
        if (this.idling) {
          this.emit("idle");
        }
      });
    }
    getSocket(options, callback) {
      return setImmediate(() => callback(null, false));
    }
    send(mail, callback) {
      if (this._closed) {
        return false;
      }
      this._queue.push({
        mail,
        requeueAttempts: 0,
        callback
      });
      if (this.idling && this._queue.length >= this.options.maxConnections) {
        this.idling = false;
      }
      setImmediate(() => this._processMessages());
      return true;
    }
    close() {
      let connection5;
      let len = this._connections.length;
      this._closed = true;
      clearTimeout(this._rateLimit.timeout);
      if (!len && !this._queue.length) {
        return;
      }
      for (let i = len - 1;i >= 0; i--) {
        if (this._connections[i] && this._connections[i].available) {
          connection5 = this._connections[i];
          connection5.close();
          this.logger.info({
            tnx: "connection",
            cid: connection5.id,
            action: "removed"
          }, "Connection #%s removed", connection5.id);
        }
      }
      if (len && !this._connections.length) {
        this.logger.debug({
          tnx: "connection"
        }, "All connections removed");
      }
      if (!this._queue.length) {
        return;
      }
      let invokeCallbacks = () => {
        if (!this._queue.length) {
          this.logger.debug({
            tnx: "connection"
          }, "Pending queue entries cleared");
          return;
        }
        let entry = this._queue.shift();
        if (entry && typeof entry.callback === "function") {
          try {
            entry.callback(new Error("Connection pool was closed"));
          } catch (E) {
            this.logger.error({
              err: E,
              tnx: "callback",
              cid: connection5.id
            }, "Callback error for #%s: %s", connection5.id, E.message);
          }
        }
        setImmediate(invokeCallbacks);
      };
      setImmediate(invokeCallbacks);
    }
    _processMessages() {
      let connection5;
      let i, len;
      if (this._closed) {
        return;
      }
      if (!this._queue.length) {
        if (!this.idling) {
          this.idling = true;
          this.emit("idle");
        }
        return;
      }
      for (i = 0, len = this._connections.length;i < len; i++) {
        if (this._connections[i].available) {
          connection5 = this._connections[i];
          break;
        }
      }
      if (!connection5 && this._connections.length < this.options.maxConnections) {
        connection5 = this._createConnection();
      }
      if (!connection5) {
        this.idling = false;
        return;
      }
      if (!this.idling && this._queue.length < this.options.maxConnections) {
        this.idling = true;
        this.emit("idle");
      }
      let entry = connection5.queueEntry = this._queue.shift();
      entry.messageId = (connection5.queueEntry.mail.message.getHeader("message-id") || "").replace(/[<>\s]/g, "");
      connection5.available = false;
      this.logger.debug({
        tnx: "pool",
        cid: connection5.id,
        messageId: entry.messageId,
        action: "assign"
      }, "Assigned message <%s> to #%s (%s)", entry.messageId, connection5.id, connection5.messages + 1);
      if (this._rateLimit.limit) {
        this._rateLimit.counter++;
        if (!this._rateLimit.checkpoint) {
          this._rateLimit.checkpoint = Date.now();
        }
      }
      connection5.send(entry.mail, (err, info) => {
        if (entry === connection5.queueEntry) {
          try {
            entry.callback(err, info);
          } catch (E) {
            this.logger.error({
              err: E,
              tnx: "callback",
              cid: connection5.id
            }, "Callback error for #%s: %s", connection5.id, E.message);
          }
          connection5.queueEntry = false;
        }
      });
    }
    _createConnection() {
      let connection5 = new PoolResource(this);
      connection5.id = ++this._connectionCounter;
      this.logger.info({
        tnx: "pool",
        cid: connection5.id,
        action: "conection"
      }, "Created new pool resource #%s", connection5.id);
      connection5.on("available", () => {
        this.logger.debug({
          tnx: "connection",
          cid: connection5.id,
          action: "available"
        }, "Connection #%s became available", connection5.id);
        if (this._closed) {
          this.close();
        } else {
          this._processMessages();
        }
      });
      connection5.once("error", (err) => {
        if (err.code !== "EMAXLIMIT") {
          this.logger.error({
            err,
            tnx: "pool",
            cid: connection5.id
          }, "Pool Error for #%s: %s", connection5.id, err.message);
        } else {
          this.logger.debug({
            tnx: "pool",
            cid: connection5.id,
            action: "maxlimit"
          }, "Max messages limit exchausted for #%s", connection5.id);
        }
        if (connection5.queueEntry) {
          try {
            connection5.queueEntry.callback(err);
          } catch (E) {
            this.logger.error({
              err: E,
              tnx: "callback",
              cid: connection5.id
            }, "Callback error for #%s: %s", connection5.id, E.message);
          }
          connection5.queueEntry = false;
        }
        this._removeConnection(connection5);
        this._continueProcessing();
      });
      connection5.once("close", () => {
        this.logger.info({
          tnx: "connection",
          cid: connection5.id,
          action: "closed"
        }, "Connection #%s was closed", connection5.id);
        this._removeConnection(connection5);
        if (connection5.queueEntry) {
          setTimeout(() => {
            if (connection5.queueEntry) {
              if (this._shouldRequeuOnConnectionClose(connection5.queueEntry)) {
                this._requeueEntryOnConnectionClose(connection5);
              } else {
                this._failDeliveryOnConnectionClose(connection5);
              }
            }
            this._continueProcessing();
          }, 50);
        } else {
          if (!this._closed && this.idling && !this._connections.length) {
            this.emit("clear");
          }
          this._continueProcessing();
        }
      });
      this._connections.push(connection5);
      return connection5;
    }
    _shouldRequeuOnConnectionClose(queueEntry) {
      if (this.options.maxRequeues === undefined || this.options.maxRequeues < 0) {
        return true;
      }
      return queueEntry.requeueAttempts < this.options.maxRequeues;
    }
    _failDeliveryOnConnectionClose(connection5) {
      if (connection5.queueEntry && connection5.queueEntry.callback) {
        try {
          connection5.queueEntry.callback(new Error("Reached maximum number of retries after connection was closed"));
        } catch (E) {
          this.logger.error({
            err: E,
            tnx: "callback",
            messageId: connection5.queueEntry.messageId,
            cid: connection5.id
          }, "Callback error for #%s: %s", connection5.id, E.message);
        }
        connection5.queueEntry = false;
      }
    }
    _requeueEntryOnConnectionClose(connection5) {
      connection5.queueEntry.requeueAttempts = connection5.queueEntry.requeueAttempts + 1;
      this.logger.debug({
        tnx: "pool",
        cid: connection5.id,
        messageId: connection5.queueEntry.messageId,
        action: "requeue"
      }, "Re-queued message <%s> for #%s. Attempt: #%s", connection5.queueEntry.messageId, connection5.id, connection5.queueEntry.requeueAttempts);
      this._queue.unshift(connection5.queueEntry);
      connection5.queueEntry = false;
    }
    _continueProcessing() {
      if (this._closed) {
        this.close();
      } else {
        setTimeout(() => this._processMessages(), 100);
      }
    }
    _removeConnection(connection5) {
      let index2 = this._connections.indexOf(connection5);
      if (index2 !== -1) {
        this._connections.splice(index2, 1);
      }
    }
    _checkRateLimit(callback) {
      if (!this._rateLimit.limit) {
        return callback();
      }
      let now = Date.now();
      if (this._rateLimit.counter < this._rateLimit.limit) {
        return callback();
      }
      this._rateLimit.waiting.push(callback);
      if (this._rateLimit.checkpoint <= now - this._rateLimit.delta) {
        return this._clearRateLimit();
      } else if (!this._rateLimit.timeout) {
        this._rateLimit.timeout = setTimeout(() => this._clearRateLimit(), this._rateLimit.delta - (now - this._rateLimit.checkpoint));
        this._rateLimit.checkpoint = now;
      }
    }
    _clearRateLimit() {
      clearTimeout(this._rateLimit.timeout);
      this._rateLimit.timeout = null;
      this._rateLimit.counter = 0;
      this._rateLimit.checkpoint = false;
      while (this._rateLimit.waiting.length) {
        let cb = this._rateLimit.waiting.shift();
        setImmediate(cb);
      }
    }
    isIdle() {
      return this.idling;
    }
    verify(callback) {
      let promise;
      if (!callback) {
        promise = new Promise((resolve, reject) => {
          callback = shared.callbackPromise(resolve, reject);
        });
      }
      let auth = new PoolResource(this).auth;
      this.getSocket(this.options, (err, socketOptions) => {
        if (err) {
          return callback(err);
        }
        let options = this.options;
        if (socketOptions && socketOptions.connection) {
          this.logger.info({
            tnx: "proxy",
            remoteAddress: socketOptions.connection.remoteAddress,
            remotePort: socketOptions.connection.remotePort,
            destHost: options.host || "",
            destPort: options.port || "",
            action: "connected"
          }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
          options = shared.assign(false, options);
          Object.keys(socketOptions).forEach((key) => {
            options[key] = socketOptions[key];
          });
        }
        let connection5 = new SMTPConnection(options);
        let returned = false;
        connection5.once("error", (err2) => {
          if (returned) {
            return;
          }
          returned = true;
          connection5.close();
          return callback(err2);
        });
        connection5.once("end", () => {
          if (returned) {
            return;
          }
          returned = true;
          return callback(new Error("Connection closed"));
        });
        let finalize = () => {
          if (returned) {
            return;
          }
          returned = true;
          connection5.quit();
          return callback(null, true);
        };
        connection5.connect(() => {
          if (returned) {
            return;
          }
          if (auth && (connection5.allowsAuth || options.forceAuth)) {
            connection5.login(auth, (err2) => {
              if (returned) {
                return;
              }
              if (err2) {
                returned = true;
                connection5.close();
                return callback(err2);
              }
              finalize();
            });
          } else if (!auth && connection5.allowsAuth && options.forceAuth) {
            let err2 = new Error("Authentication info was not provided");
            err2.code = "NoAuth";
            returned = true;
            connection5.close();
            return callback(err2);
          } else {
            finalize();
          }
        });
      });
      return promise;
    }
  }
  module.exports = SMTPPool;
});

// node_modules/nodemailer/lib/smtp-transport/index.js
var require_smtp_transport = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var SMTPConnection = require_smtp_connection();
  var wellKnown = require_well_known();
  var shared = require_shared();
  var XOAuth2 = require_xoauth2();
  var packageData = require_package();

  class SMTPTransport extends EventEmitter {
    constructor(options) {
      super();
      options = options || {};
      if (typeof options === "string") {
        options = {
          url: options
        };
      }
      let urlData;
      let service = options.service;
      if (typeof options.getSocket === "function") {
        this.getSocket = options.getSocket;
      }
      if (options.url) {
        urlData = shared.parseConnectionUrl(options.url);
        service = service || urlData.service;
      }
      this.options = shared.assign(false, options, urlData, service && wellKnown(service));
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "smtp-transport"
      });
      let connection5 = new SMTPConnection(this.options);
      this.name = "SMTP";
      this.version = packageData.version + "[client:" + connection5.version + "]";
      if (this.options.auth) {
        this.auth = this.getAuth({});
      }
    }
    getSocket(options, callback) {
      return setImmediate(() => callback(null, false));
    }
    getAuth(authOpts) {
      if (!authOpts) {
        return this.auth;
      }
      let hasAuth = false;
      let authData = {};
      if (this.options.auth && typeof this.options.auth === "object") {
        Object.keys(this.options.auth).forEach((key) => {
          hasAuth = true;
          authData[key] = this.options.auth[key];
        });
      }
      if (authOpts && typeof authOpts === "object") {
        Object.keys(authOpts).forEach((key) => {
          hasAuth = true;
          authData[key] = authOpts[key];
        });
      }
      if (!hasAuth) {
        return false;
      }
      switch ((authData.type || "").toString().toUpperCase()) {
        case "OAUTH2": {
          if (!authData.service && !authData.user) {
            return false;
          }
          let oauth2 = new XOAuth2(authData, this.logger);
          oauth2.provisionCallback = this.mailer && this.mailer.get("oauth2_provision_cb") || oauth2.provisionCallback;
          oauth2.on("token", (token) => this.mailer.emit("token", token));
          oauth2.on("error", (err) => this.emit("error", err));
          return {
            type: "OAUTH2",
            user: authData.user,
            oauth2,
            method: "XOAUTH2"
          };
        }
        default:
          return {
            type: (authData.type || "").toString().toUpperCase() || "LOGIN",
            user: authData.user,
            credentials: {
              user: authData.user || "",
              pass: authData.pass,
              options: authData.options
            },
            method: (authData.method || "").trim().toUpperCase() || this.options.authMethod || false
          };
      }
    }
    send(mail, callback) {
      this.getSocket(this.options, (err, socketOptions) => {
        if (err) {
          return callback(err);
        }
        let returned = false;
        let options = this.options;
        if (socketOptions && socketOptions.connection) {
          this.logger.info({
            tnx: "proxy",
            remoteAddress: socketOptions.connection.remoteAddress,
            remotePort: socketOptions.connection.remotePort,
            destHost: options.host || "",
            destPort: options.port || "",
            action: "connected"
          }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
          options = shared.assign(false, options);
          Object.keys(socketOptions).forEach((key) => {
            options[key] = socketOptions[key];
          });
        }
        let connection5 = new SMTPConnection(options);
        connection5.once("error", (err2) => {
          if (returned) {
            return;
          }
          returned = true;
          connection5.close();
          return callback(err2);
        });
        connection5.once("end", () => {
          if (returned) {
            return;
          }
          let timer2 = setTimeout(() => {
            if (returned) {
              return;
            }
            returned = true;
            let err2 = new Error("Unexpected socket close");
            if (connection5 && connection5._socket && connection5._socket.upgrading) {
              err2.code = "ETLS";
            }
            callback(err2);
          }, 1000);
          try {
            timer2.unref();
          } catch (E) {
          }
        });
        let sendMessage = () => {
          let envelope = mail.message.getEnvelope();
          let messageId = mail.message.messageId();
          let recipients = [].concat(envelope.to || []);
          if (recipients.length > 3) {
            recipients.push("...and " + recipients.splice(2).length + " more");
          }
          if (mail.data.dsn) {
            envelope.dsn = mail.data.dsn;
          }
          this.logger.info({
            tnx: "send",
            messageId
          }, "Sending message %s to <%s>", messageId, recipients.join(", "));
          connection5.send(envelope, mail.message.createReadStream(), (err2, info) => {
            returned = true;
            connection5.close();
            if (err2) {
              this.logger.error({
                err: err2,
                tnx: "send"
              }, "Send error for %s: %s", messageId, err2.message);
              return callback(err2);
            }
            info.envelope = {
              from: envelope.from,
              to: envelope.to
            };
            info.messageId = messageId;
            try {
              return callback(null, info);
            } catch (E) {
              this.logger.error({
                err: E,
                tnx: "callback"
              }, "Callback error for %s: %s", messageId, E.message);
            }
          });
        };
        connection5.connect(() => {
          if (returned) {
            return;
          }
          let auth = this.getAuth(mail.data.auth);
          if (auth && (connection5.allowsAuth || options.forceAuth)) {
            connection5.login(auth, (err2) => {
              if (auth && auth !== this.auth && auth.oauth2) {
                auth.oauth2.removeAllListeners();
              }
              if (returned) {
                return;
              }
              if (err2) {
                returned = true;
                connection5.close();
                return callback(err2);
              }
              sendMessage();
            });
          } else {
            sendMessage();
          }
        });
      });
    }
    verify(callback) {
      let promise;
      if (!callback) {
        promise = new Promise((resolve, reject) => {
          callback = shared.callbackPromise(resolve, reject);
        });
      }
      this.getSocket(this.options, (err, socketOptions) => {
        if (err) {
          return callback(err);
        }
        let options = this.options;
        if (socketOptions && socketOptions.connection) {
          this.logger.info({
            tnx: "proxy",
            remoteAddress: socketOptions.connection.remoteAddress,
            remotePort: socketOptions.connection.remotePort,
            destHost: options.host || "",
            destPort: options.port || "",
            action: "connected"
          }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
          options = shared.assign(false, options);
          Object.keys(socketOptions).forEach((key) => {
            options[key] = socketOptions[key];
          });
        }
        let connection5 = new SMTPConnection(options);
        let returned = false;
        connection5.once("error", (err2) => {
          if (returned) {
            return;
          }
          returned = true;
          connection5.close();
          return callback(err2);
        });
        connection5.once("end", () => {
          if (returned) {
            return;
          }
          returned = true;
          return callback(new Error("Connection closed"));
        });
        let finalize = () => {
          if (returned) {
            return;
          }
          returned = true;
          connection5.quit();
          return callback(null, true);
        };
        connection5.connect(() => {
          if (returned) {
            return;
          }
          let authData = this.getAuth({});
          if (authData && (connection5.allowsAuth || options.forceAuth)) {
            connection5.login(authData, (err2) => {
              if (returned) {
                return;
              }
              if (err2) {
                returned = true;
                connection5.close();
                return callback(err2);
              }
              finalize();
            });
          } else if (!authData && connection5.allowsAuth && options.forceAuth) {
            let err2 = new Error("Authentication info was not provided");
            err2.code = "NoAuth";
            returned = true;
            connection5.close();
            return callback(err2);
          } else {
            finalize();
          }
        });
      });
      return promise;
    }
    close() {
      if (this.auth && this.auth.oauth2) {
        this.auth.oauth2.removeAllListeners();
      }
      this.emit("close");
    }
  }
  module.exports = SMTPTransport;
});

// node_modules/nodemailer/lib/sendmail-transport/index.js
var require_sendmail_transport = __commonJS((exports, module) => {
  var spawn = __require("child_process").spawn;
  var packageData = require_package();
  var shared = require_shared();

  class SendmailTransport {
    constructor(options) {
      options = options || {};
      this._spawn = spawn;
      this.options = options || {};
      this.name = "Sendmail";
      this.version = packageData.version;
      this.path = "sendmail";
      this.args = false;
      this.winbreak = false;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "sendmail"
      });
      if (options) {
        if (typeof options === "string") {
          this.path = options;
        } else if (typeof options === "object") {
          if (options.path) {
            this.path = options.path;
          }
          if (Array.isArray(options.args)) {
            this.args = options.args;
          }
          this.winbreak = ["win", "windows", "dos", "\r\n"].includes((options.newline || "").toString().toLowerCase());
        }
      }
    }
    send(mail, done) {
      mail.message.keepBcc = true;
      let envelope = mail.data.envelope || mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let args;
      let sendmail;
      let returned;
      const hasInvalidAddresses = [].concat(envelope.from || []).concat(envelope.to || []).some((addr) => /^-/.test(addr));
      if (hasInvalidAddresses) {
        return done(new Error("Can not send mail. Invalid envelope addresses."));
      }
      if (this.args) {
        args = ["-i"].concat(this.args).concat(envelope.to);
      } else {
        args = ["-i"].concat(envelope.from ? ["-f", envelope.from] : []).concat(envelope.to);
      }
      let callback = (err) => {
        if (returned) {
          return;
        }
        returned = true;
        if (typeof done === "function") {
          if (err) {
            return done(err);
          } else {
            return done(null, {
              envelope: mail.data.envelope || mail.message.getEnvelope(),
              messageId,
              response: "Messages queued for delivery"
            });
          }
        }
      };
      try {
        sendmail = this._spawn(this.path, args);
      } catch (E) {
        this.logger.error({
          err: E,
          tnx: "spawn",
          messageId
        }, "Error occurred while spawning sendmail. %s", E.message);
        return callback(E);
      }
      if (sendmail) {
        sendmail.on("error", (err) => {
          this.logger.error({
            err,
            tnx: "spawn",
            messageId
          }, "Error occurred when sending message %s. %s", messageId, err.message);
          callback(err);
        });
        sendmail.once("exit", (code) => {
          if (!code) {
            return callback();
          }
          let err;
          if (code === 127) {
            err = new Error("Sendmail command not found, process exited with code " + code);
          } else {
            err = new Error("Sendmail exited with code " + code);
          }
          this.logger.error({
            err,
            tnx: "stdin",
            messageId
          }, "Error sending message %s to sendmail. %s", messageId, err.message);
          callback(err);
        });
        sendmail.once("close", callback);
        sendmail.stdin.on("error", (err) => {
          this.logger.error({
            err,
            tnx: "stdin",
            messageId
          }, "Error occurred when piping message %s to sendmail. %s", messageId, err.message);
          callback(err);
        });
        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
          recipients.push("...and " + recipients.splice(2).length + " more");
        }
        this.logger.info({
          tnx: "send",
          messageId
        }, "Sending message %s to <%s>", messageId, recipients.join(", "));
        let sourceStream = mail.message.createReadStream();
        sourceStream.once("error", (err) => {
          this.logger.error({
            err,
            tnx: "stdin",
            messageId
          }, "Error occurred when generating message %s. %s", messageId, err.message);
          sendmail.kill("SIGINT");
          callback(err);
        });
        sourceStream.pipe(sendmail.stdin);
      } else {
        return callback(new Error("sendmail was not found"));
      }
    }
  }
  module.exports = SendmailTransport;
});

// node_modules/nodemailer/lib/stream-transport/index.js
var require_stream_transport = __commonJS((exports, module) => {
  var packageData = require_package();
  var shared = require_shared();

  class StreamTransport {
    constructor(options) {
      options = options || {};
      this.options = options || {};
      this.name = "StreamTransport";
      this.version = packageData.version;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "stream-transport"
      });
      this.winbreak = ["win", "windows", "dos", "\r\n"].includes((options.newline || "").toString().toLowerCase());
    }
    send(mail, done) {
      mail.message.keepBcc = true;
      let envelope = mail.data.envelope || mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let recipients = [].concat(envelope.to || []);
      if (recipients.length > 3) {
        recipients.push("...and " + recipients.splice(2).length + " more");
      }
      this.logger.info({
        tnx: "send",
        messageId
      }, "Sending message %s to <%s> using %s line breaks", messageId, recipients.join(", "), this.winbreak ? "<CR><LF>" : "<LF>");
      setImmediate(() => {
        let stream;
        try {
          stream = mail.message.createReadStream();
        } catch (E) {
          this.logger.error({
            err: E,
            tnx: "send",
            messageId
          }, "Creating send stream failed for %s. %s", messageId, E.message);
          return done(E);
        }
        if (!this.options.buffer) {
          stream.once("error", (err) => {
            this.logger.error({
              err,
              tnx: "send",
              messageId
            }, "Failed creating message for %s. %s", messageId, err.message);
          });
          return done(null, {
            envelope: mail.data.envelope || mail.message.getEnvelope(),
            messageId,
            message: stream
          });
        }
        let chunks = [];
        let chunklen = 0;
        stream.on("readable", () => {
          let chunk;
          while ((chunk = stream.read()) !== null) {
            chunks.push(chunk);
            chunklen += chunk.length;
          }
        });
        stream.once("error", (err) => {
          this.logger.error({
            err,
            tnx: "send",
            messageId
          }, "Failed creating message for %s. %s", messageId, err.message);
          return done(err);
        });
        stream.on("end", () => done(null, {
          envelope: mail.data.envelope || mail.message.getEnvelope(),
          messageId,
          message: Buffer.concat(chunks, chunklen)
        }));
      });
    }
  }
  module.exports = StreamTransport;
});

// node_modules/nodemailer/lib/json-transport/index.js
var require_json_transport = __commonJS((exports, module) => {
  var packageData = require_package();
  var shared = require_shared();

  class JSONTransport {
    constructor(options) {
      options = options || {};
      this.options = options || {};
      this.name = "JSONTransport";
      this.version = packageData.version;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "json-transport"
      });
    }
    send(mail, done) {
      mail.message.keepBcc = true;
      let envelope = mail.data.envelope || mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let recipients = [].concat(envelope.to || []);
      if (recipients.length > 3) {
        recipients.push("...and " + recipients.splice(2).length + " more");
      }
      this.logger.info({
        tnx: "send",
        messageId
      }, "Composing JSON structure of %s to <%s>", messageId, recipients.join(", "));
      setImmediate(() => {
        mail.normalize((err, data) => {
          if (err) {
            this.logger.error({
              err,
              tnx: "send",
              messageId
            }, "Failed building JSON structure for %s. %s", messageId, err.message);
            return done(err);
          }
          delete data.envelope;
          delete data.normalizedHeaders;
          return done(null, {
            envelope,
            messageId,
            message: this.options.skipEncoding ? data : JSON.stringify(data)
          });
        });
      });
    }
  }
  module.exports = JSONTransport;
});

// node_modules/nodemailer/lib/ses-transport/index.js
var require_ses_transport = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var packageData = require_package();
  var shared = require_shared();
  var LeWindows = require_le_windows();
  var MimeNode = require_mime_node();

  class SESTransport extends EventEmitter {
    constructor(options) {
      super();
      options = options || {};
      this.options = options || {};
      this.ses = this.options.SES;
      this.name = "SESTransport";
      this.version = packageData.version;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "ses-transport"
      });
    }
    getRegion(cb) {
      if (this.ses.sesClient.config && typeof this.ses.sesClient.config.region === "function") {
        return this.ses.sesClient.config.region().then((region) => cb(null, region)).catch((err) => cb(err));
      }
      return cb(null, false);
    }
    send(mail, callback) {
      let statObject = {
        ts: Date.now(),
        pending: true
      };
      let fromHeader = mail.message._headers.find((header) => /^from$/i.test(header.key));
      if (fromHeader) {
        let mimeNode = new MimeNode("text/plain");
        fromHeader = mimeNode._convertAddresses(mimeNode._parseAddresses(fromHeader.value));
      }
      let envelope = mail.data.envelope || mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let recipients = [].concat(envelope.to || []);
      if (recipients.length > 3) {
        recipients.push("...and " + recipients.splice(2).length + " more");
      }
      this.logger.info({
        tnx: "send",
        messageId
      }, "Sending message %s to <%s>", messageId, recipients.join(", "));
      let getRawMessage = (next) => {
        if (!mail.data._dkim) {
          mail.data._dkim = {};
        }
        if (mail.data._dkim.skipFields && typeof mail.data._dkim.skipFields === "string") {
          mail.data._dkim.skipFields += ":date:message-id";
        } else {
          mail.data._dkim.skipFields = "date:message-id";
        }
        let sourceStream = mail.message.createReadStream();
        let stream = sourceStream.pipe(new LeWindows);
        let chunks = [];
        let chunklen = 0;
        stream.on("readable", () => {
          let chunk;
          while ((chunk = stream.read()) !== null) {
            chunks.push(chunk);
            chunklen += chunk.length;
          }
        });
        sourceStream.once("error", (err) => stream.emit("error", err));
        stream.once("error", (err) => {
          next(err);
        });
        stream.once("end", () => next(null, Buffer.concat(chunks, chunklen)));
      };
      setImmediate(() => getRawMessage((err, raw) => {
        if (err) {
          this.logger.error({
            err,
            tnx: "send",
            messageId
          }, "Failed creating message for %s. %s", messageId, err.message);
          statObject.pending = false;
          return callback(err);
        }
        let sesMessage = {
          Content: {
            Raw: {
              Data: raw
            }
          },
          FromEmailAddress: fromHeader ? fromHeader : envelope.from,
          Destination: {
            ToAddresses: envelope.to
          }
        };
        Object.keys(mail.data.ses || {}).forEach((key) => {
          sesMessage[key] = mail.data.ses[key];
        });
        this.getRegion((err2, region) => {
          if (err2 || !region) {
            region = "us-east-1";
          }
          const command = new this.ses.SendEmailCommand(sesMessage);
          const sendPromise = this.ses.sesClient.send(command);
          sendPromise.then((data) => {
            if (region === "us-east-1") {
              region = "email";
            }
            statObject.pending = true;
            callback(null, {
              envelope: {
                from: envelope.from,
                to: envelope.to
              },
              messageId: "<" + data.MessageId + (!/@/.test(data.MessageId) ? "@" + region + ".amazonses.com" : "") + ">",
              response: data.MessageId,
              raw
            });
          }).catch((err3) => {
            this.logger.error({
              err: err3,
              tnx: "send"
            }, "Send error for %s: %s", messageId, err3.message);
            statObject.pending = false;
            callback(err3);
          });
        });
      }));
    }
    verify(callback) {
      let promise;
      if (!callback) {
        promise = new Promise((resolve, reject) => {
          callback = shared.callbackPromise(resolve, reject);
        });
      }
      const cb = (err) => {
        if (err && !["InvalidParameterValue", "MessageRejected"].includes(err.code || err.Code || err.name)) {
          return callback(err);
        }
        return callback(null, true);
      };
      const sesMessage = {
        Content: {
          Raw: {
            Data: Buffer.from("From: <invalid@invalid>\r\nTo: <invalid@invalid>\r\n Subject: Invalid\r\n\r\nInvalid")
          }
        },
        FromEmailAddress: "invalid@invalid",
        Destination: {
          ToAddresses: ["invalid@invalid"]
        }
      };
      this.getRegion((err, region) => {
        if (err || !region) {
          region = "us-east-1";
        }
        const command = new this.ses.SendEmailCommand(sesMessage);
        const sendPromise = this.ses.sesClient.send(command);
        sendPromise.then((data) => cb(null, data)).catch((err2) => cb(err2));
      });
      return promise;
    }
  }
  module.exports = SESTransport;
});

// node_modules/nodemailer/lib/nodemailer.js
var require_nodemailer = __commonJS((exports, module) => {
  var Mailer = require_mailer();
  var shared = require_shared();
  var SMTPPool = require_smtp_pool();
  var SMTPTransport = require_smtp_transport();
  var SendmailTransport = require_sendmail_transport();
  var StreamTransport = require_stream_transport();
  var JSONTransport = require_json_transport();
  var SESTransport = require_ses_transport();
  var nmfetch = require_fetch();
  var packageData = require_package();
  var ETHEREAL_API = (process.env.ETHEREAL_API || "https://api.nodemailer.com").replace(/\/+$/, "");
  var ETHEREAL_WEB = (process.env.ETHEREAL_WEB || "https://ethereal.email").replace(/\/+$/, "");
  var ETHEREAL_API_KEY = (process.env.ETHEREAL_API_KEY || "").replace(/\s*/g, "") || null;
  var ETHEREAL_CACHE = ["true", "yes", "y", "1"].includes((process.env.ETHEREAL_CACHE || "yes").toString().trim().toLowerCase());
  var testAccount = false;
  exports.createTransport = function(transporter, defaults) {
    let urlConfig;
    let options;
    let mailer;
    if (typeof transporter === "object" && typeof transporter.send !== "function" || typeof transporter === "string" && /^(smtps?|direct):/i.test(transporter)) {
      if (urlConfig = typeof transporter === "string" ? transporter : transporter.url) {
        options = shared.parseConnectionUrl(urlConfig);
      } else {
        options = transporter;
      }
      if (options.pool) {
        transporter = new SMTPPool(options);
      } else if (options.sendmail) {
        transporter = new SendmailTransport(options);
      } else if (options.streamTransport) {
        transporter = new StreamTransport(options);
      } else if (options.jsonTransport) {
        transporter = new JSONTransport(options);
      } else if (options.SES) {
        if (options.SES.ses && options.SES.aws) {
          let error = new Error("Using legacy SES configuration, expecting @aws-sdk/client-sesv2, see https://nodemailer.com/transports/ses/");
          error.code = "LegacyConfig";
          throw error;
        }
        transporter = new SESTransport(options);
      } else {
        transporter = new SMTPTransport(options);
      }
    }
    mailer = new Mailer(transporter, options, defaults);
    return mailer;
  };
  exports.createTestAccount = function(apiUrl, callback) {
    let promise;
    if (!callback && typeof apiUrl === "function") {
      callback = apiUrl;
      apiUrl = false;
    }
    if (!callback) {
      promise = new Promise((resolve, reject) => {
        callback = shared.callbackPromise(resolve, reject);
      });
    }
    if (ETHEREAL_CACHE && testAccount) {
      setImmediate(() => callback(null, testAccount));
      return promise;
    }
    apiUrl = apiUrl || ETHEREAL_API;
    let chunks = [];
    let chunklen = 0;
    let requestHeaders = {};
    let requestBody = {
      requestor: packageData.name,
      version: packageData.version
    };
    if (ETHEREAL_API_KEY) {
      requestHeaders.Authorization = "Bearer " + ETHEREAL_API_KEY;
    }
    let req = nmfetch(apiUrl + "/user", {
      contentType: "application/json",
      method: "POST",
      headers: requestHeaders,
      body: Buffer.from(JSON.stringify(requestBody))
    });
    req.on("readable", () => {
      let chunk;
      while ((chunk = req.read()) !== null) {
        chunks.push(chunk);
        chunklen += chunk.length;
      }
    });
    req.once("error", (err) => callback(err));
    req.once("end", () => {
      let res = Buffer.concat(chunks, chunklen);
      let data;
      let err;
      try {
        data = JSON.parse(res.toString());
      } catch (E) {
        err = E;
      }
      if (err) {
        return callback(err);
      }
      if (data.status !== "success" || data.error) {
        return callback(new Error(data.error || "Request failed"));
      }
      delete data.status;
      testAccount = data;
      callback(null, testAccount);
    });
    return promise;
  };
  exports.getTestMessageUrl = function(info) {
    if (!info || !info.response) {
      return false;
    }
    let infoProps = new Map;
    info.response.replace(/\[([^\]]+)\]$/, (m, props) => {
      props.replace(/\b([A-Z0-9]+)=([^\s]+)/g, (m2, key, value) => {
        infoProps.set(key, value);
      });
    });
    if (infoProps.has("STATUS") && infoProps.has("MSGID")) {
      return (testAccount.web || ETHEREAL_WEB) + "/message/" + infoProps.get("MSGID");
    }
    return false;
  };
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS((exports, module) => {
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);
      }
      var ReactVersion = "18.2.0";
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactCurrentDispatcher = {
        current: null
      };
      var ReactCurrentBatchConfig = {
        transition: null
      };
      var ReactCurrentActQueue = {
        current: null,
        isBatchingLegacy: false,
        didScheduleLegacyUpdate: false
      };
      var ReactCurrentOwner = {
        current: null
      };
      var ReactDebugCurrentFrame = {};
      var currentExtraStackFrame = null;
      function setExtraStackFrame(stack) {
        {
          currentExtraStackFrame = stack;
        }
      }
      {
        ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
          {
            currentExtraStackFrame = stack;
          }
        };
        ReactDebugCurrentFrame.getCurrentStack = null;
        ReactDebugCurrentFrame.getStackAddendum = function() {
          var stack = "";
          if (currentExtraStackFrame) {
            stack += currentExtraStackFrame;
          }
          var impl = ReactDebugCurrentFrame.getCurrentStack;
          if (impl) {
            stack += impl() || "";
          }
          return stack;
        };
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var ReactSharedInternals = {
        ReactCurrentDispatcher,
        ReactCurrentBatchConfig,
        ReactCurrentOwner
      };
      {
        ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
        ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
      }
      function warn(format) {
        {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
      }
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var didWarnStateUpdateForUnmountedComponent = {};
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor;
          var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
          var warningKey = componentName + "." + callerName;
          if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
            return;
          }
          error("Can't call %s on a component that is not yet mounted. " + "This is a no-op, but it might indicate a bug in your application. " + "Instead, assign to `this.state` directly or define a `state = {};` " + "class property with the desired state in the %s component.", callerName, componentName);
          didWarnStateUpdateForUnmountedComponent[warningKey] = true;
        }
      }
      var ReactNoopUpdateQueue = {
        isMounted: function(publicInstance) {
          return false;
        },
        enqueueForceUpdate: function(publicInstance, callback, callerName) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance, partialState, callback, callerName) {
          warnNoop(publicInstance, "setState");
        }
      };
      var assign = Object.assign;
      var emptyObject = {};
      {
        Object.freeze(emptyObject);
      }
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
          throw new Error("setState(...): takes an object of state variables to update or a " + "function which returns an object of state variables.");
        }
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      {
        var deprecatedAPIs = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in " + "componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see " + "https://github.com/facebook/react/issues/3236)."]
        };
        var defineDeprecationWarning = function(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function() {
              warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
              return;
            }
          });
        };
        for (var fnName in deprecatedAPIs) {
          if (deprecatedAPIs.hasOwnProperty(fnName)) {
            defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
          }
        }
      }
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy;
      pureComponentPrototype.constructor = PureComponent;
      assign(pureComponentPrototype, Component.prototype);
      pureComponentPrototype.isPureReactComponent = true;
      function createRef() {
        var refObject = {
          current: null
        };
        {
          Object.seal(refObject);
        }
        return refObject;
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s." + " This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). " + "This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return getComponentNameFromType(init2(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
      {
        didWarnAboutStringRefs = {};
      }
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== undefined;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== undefined;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function() {
          {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result " + "in `undefined` being returned. If you need to access the same " + "value within the child component, you should pass it as a different " + "prop. (https://reactjs.org/link/special-props)", displayName);
            }
          }
        };
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function() {
          {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result " + "in `undefined` being returned. If you need to access the same " + "value within the child component, you should pass it as a different " + "prop. (https://reactjs.org/link/special-props)", displayName);
            }
          }
        };
        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, "ref", {
          get: warnAboutAccessingRef,
          configurable: true
        });
      }
      function warnIfStringRefCannotBeAutoConverted(config) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
              error('Component "%s" contains the string ref "%s". ' + "Support for string refs will be removed in a future major release. " + "This case cannot be automatically converted to an arrow function. " + "We ask you to manually fix this case by using useRef() or createRef() instead. " + "Learn more about using refs safely here: " + "https://reactjs.org/link/strict-mode-string-ref", componentName, config.ref);
              didWarnAboutStringRefs[componentName] = true;
            }
          }
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref,
          props,
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function createElement(type, config, children) {
        var propName;
        var props = {};
        var key = null;
        var ref = null;
        var self2 = null;
        var source = null;
        if (config != null) {
          if (hasValidRef(config)) {
            ref = config.ref;
            {
              warnIfStringRefCannotBeAutoConverted(config);
            }
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          self2 = config.__self === undefined ? null : config.__self;
          source = config.__source === undefined ? null : config.__source;
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);
          for (var i = 0;i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }
          {
            if (Object.freeze) {
              Object.freeze(childArray);
            }
          }
          props.children = childArray;
        }
        if (type && type.defaultProps) {
          var defaultProps = type.defaultProps;
          for (propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
        }
        {
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
        return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
        return newElement;
      }
      function cloneElement(element, config, children) {
        if (element === null || element === undefined) {
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
        }
        var propName;
        var props = assign({}, element.props);
        var key = element.key;
        var ref = element.ref;
        var self2 = element._self;
        var source = element._source;
        var owner = element._owner;
        if (config != null) {
          if (hasValidRef(config)) {
            ref = config.ref;
            owner = ReactCurrentOwner.current;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          var defaultProps;
          if (element.type && element.type.defaultProps) {
            defaultProps = element.type.defaultProps;
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              if (config[propName] === undefined && defaultProps !== undefined) {
                props[propName] = defaultProps[propName];
              } else {
                props[propName] = config[propName];
              }
            }
          }
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);
          for (var i = 0;i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }
          props.children = childArray;
        }
        return ReactElement(element.type, key, ref, self2, source, owner, props);
      }
      function isValidElement(object) {
        return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      var SEPARATOR = ".";
      var SUBSEPARATOR = ":";
      function escape2(key) {
        var escapeRegex = /[=:]/g;
        var escaperLookup = {
          "=": "=0",
          ":": "=2"
        };
        var escapedString = key.replace(escapeRegex, function(match) {
          return escaperLookup[match];
        });
        return "$" + escapedString;
      }
      var didWarnAboutMaps = false;
      var userProvidedKeyEscapeRegex = /\/+/g;
      function escapeUserProvidedKey(text2) {
        return text2.replace(userProvidedKeyEscapeRegex, "$&/");
      }
      function getElementKey(element, index2) {
        if (typeof element === "object" && element !== null && element.key != null) {
          {
            checkKeyStringCoercion(element.key);
          }
          return escape2("" + element.key);
        }
        return index2.toString(36);
      }
      function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if (type === "undefined" || type === "boolean") {
          children = null;
        }
        var invokeCallback = false;
        if (children === null) {
          invokeCallback = true;
        } else {
          switch (type) {
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
              }
          }
        }
        if (invokeCallback) {
          var _child = children;
          var mappedChild = callback(_child);
          var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
          if (isArray(mappedChild)) {
            var escapedChildKey = "";
            if (childKey != null) {
              escapedChildKey = escapeUserProvidedKey(childKey) + "/";
            }
            mapIntoArray(mappedChild, array2, escapedChildKey, "", function(c) {
              return c;
            });
          } else if (mappedChild != null) {
            if (isValidElement(mappedChild)) {
              {
                if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                  checkKeyStringCoercion(mappedChild.key);
                }
              }
              mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
            }
            array2.push(mappedChild);
          }
          return 1;
        }
        var child;
        var nextName;
        var subtreeCount = 0;
        var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
        if (isArray(children)) {
          for (var i = 0;i < children.length; i++) {
            child = children[i];
            nextName = nextNamePrefix + getElementKey(child, i);
            subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
          }
        } else {
          var iteratorFn = getIteratorFn(children);
          if (typeof iteratorFn === "function") {
            var iterableChildren = children;
            {
              if (iteratorFn === iterableChildren.entries) {
                if (!didWarnAboutMaps) {
                  warn("Using Maps as children is not supported. " + "Use an array of keyed ReactElements instead.");
                }
                didWarnAboutMaps = true;
              }
            }
            var iterator = iteratorFn.call(iterableChildren);
            var step;
            var ii = 0;
            while (!(step = iterator.next()).done) {
              child = step.value;
              nextName = nextNamePrefix + getElementKey(child, ii++);
              subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
            }
          } else if (type === "object") {
            var childrenString = String(children);
            throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). " + "If you meant to render a collection of children, use an array " + "instead.");
          }
        }
        return subtreeCount;
      }
      function mapChildren(children, func, context) {
        if (children == null) {
          return children;
        }
        var result2 = [];
        var count2 = 0;
        mapIntoArray(children, result2, "", "", function(child) {
          return func.call(context, child, count2++);
        });
        return result2;
      }
      function countChildren(children) {
        var n = 0;
        mapChildren(children, function() {
          n++;
        });
        return n;
      }
      function forEachChildren(children, forEachFunc, forEachContext) {
        mapChildren(children, function() {
          forEachFunc.apply(this, arguments);
        }, forEachContext);
      }
      function toArray(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      }
      function onlyChild(children) {
        if (!isValidElement(children)) {
          throw new Error("React.Children.only expected to receive a single React element child.");
        }
        return children;
      }
      function createContext(defaultValue) {
        var context = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
          _defaultValue: null,
          _globalName: null
        };
        context.Provider = {
          $$typeof: REACT_PROVIDER_TYPE,
          _context: context
        };
        var hasWarnedAboutUsingNestedContextConsumers = false;
        var hasWarnedAboutUsingConsumerProvider = false;
        var hasWarnedAboutDisplayNameOnConsumer = false;
        {
          var Consumer = {
            $$typeof: REACT_CONTEXT_TYPE,
            _context: context
          };
          Object.defineProperties(Consumer, {
            Provider: {
              get: function() {
                if (!hasWarnedAboutUsingConsumerProvider) {
                  hasWarnedAboutUsingConsumerProvider = true;
                  error("Rendering <Context.Consumer.Provider> is not supported and will be removed in " + "a future major release. Did you mean to render <Context.Provider> instead?");
                }
                return context.Provider;
              },
              set: function(_Provider) {
                context.Provider = _Provider;
              }
            },
            _currentValue: {
              get: function() {
                return context._currentValue;
              },
              set: function(_currentValue) {
                context._currentValue = _currentValue;
              }
            },
            _currentValue2: {
              get: function() {
                return context._currentValue2;
              },
              set: function(_currentValue2) {
                context._currentValue2 = _currentValue2;
              }
            },
            _threadCount: {
              get: function() {
                return context._threadCount;
              },
              set: function(_threadCount) {
                context._threadCount = _threadCount;
              }
            },
            Consumer: {
              get: function() {
                if (!hasWarnedAboutUsingNestedContextConsumers) {
                  hasWarnedAboutUsingNestedContextConsumers = true;
                  error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in " + "a future major release. Did you mean to render <Context.Consumer> instead?");
                }
                return context.Consumer;
              }
            },
            displayName: {
              get: function() {
                return context.displayName;
              },
              set: function(displayName) {
                if (!hasWarnedAboutDisplayNameOnConsumer) {
                  warn("Setting `displayName` on Context.Consumer has no effect. " + "You should set it directly on the context with Context.displayName = '%s'.", displayName);
                  hasWarnedAboutDisplayNameOnConsumer = true;
                }
              }
            }
          });
          context.Consumer = Consumer;
        }
        {
          context._currentRenderer = null;
          context._currentRenderer2 = null;
        }
        return context;
      }
      var Uninitialized = -1;
      var Pending = 0;
      var Resolved = 1;
      var Rejected = 2;
      function lazyInitializer(payload) {
        if (payload._status === Uninitialized) {
          var ctor = payload._result;
          var thenable = ctor();
          thenable.then(function(moduleObject2) {
            if (payload._status === Pending || payload._status === Uninitialized) {
              var resolved = payload;
              resolved._status = Resolved;
              resolved._result = moduleObject2;
            }
          }, function(error2) {
            if (payload._status === Pending || payload._status === Uninitialized) {
              var rejected = payload;
              rejected._status = Rejected;
              rejected._result = error2;
            }
          });
          if (payload._status === Uninitialized) {
            var pending = payload;
            pending._status = Pending;
            pending._result = thenable;
          }
        }
        if (payload._status === Resolved) {
          var moduleObject = payload._result;
          {
            if (moduleObject === undefined) {
              error("lazy: Expected the result of a dynamic imp" + "ort() call. " + "Instead received: %s\n\nYour code should look like: \n  " + "const MyComponent = lazy(() => imp" + "ort('./MyComponent'))\n\n" + "Did you accidentally put curly braces around the import?", moduleObject);
            }
          }
          {
            if (!("default" in moduleObject)) {
              error("lazy: Expected the result of a dynamic imp" + "ort() call. " + "Instead received: %s\n\nYour code should look like: \n  " + "const MyComponent = lazy(() => imp" + "ort('./MyComponent'))", moduleObject);
            }
          }
          return moduleObject.default;
        } else {
          throw payload._result;
        }
      }
      function lazy(ctor) {
        var payload = {
          _status: Uninitialized,
          _result: ctor
        };
        var lazyType2 = {
          $$typeof: REACT_LAZY_TYPE,
          _payload: payload,
          _init: lazyInitializer
        };
        {
          var defaultProps;
          var propTypes;
          Object.defineProperties(lazyType2, {
            defaultProps: {
              configurable: true,
              get: function() {
                return defaultProps;
              },
              set: function(newDefaultProps) {
                error("React.lazy(...): It is not supported to assign `defaultProps` to " + "a lazy component import. Either specify them where the component " + "is defined, or create a wrapping component around it.");
                defaultProps = newDefaultProps;
                Object.defineProperty(lazyType2, "defaultProps", {
                  enumerable: true
                });
              }
            },
            propTypes: {
              configurable: true,
              get: function() {
                return propTypes;
              },
              set: function(newPropTypes) {
                error("React.lazy(...): It is not supported to assign `propTypes` to " + "a lazy component import. Either specify them where the component " + "is defined, or create a wrapping component around it.");
                propTypes = newPropTypes;
                Object.defineProperty(lazyType2, "propTypes", {
                  enumerable: true
                });
              }
            }
          });
        }
        return lazyType2;
      }
      function forwardRef(render) {
        {
          if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
            error("forwardRef requires a render function but received a `memo` " + "component. Instead of forwardRef(memo(...)), use " + "memo(forwardRef(...)).");
          } else if (typeof render !== "function") {
            error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
          } else {
            if (render.length !== 0 && render.length !== 2) {
              error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
            }
          }
          if (render != null) {
            if (render.defaultProps != null || render.propTypes != null) {
              error("forwardRef render functions do not support propTypes or defaultProps. " + "Did you accidentally pass a React component?");
            }
          }
        }
        var elementType = {
          $$typeof: REACT_FORWARD_REF_TYPE,
          render
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              if (!render.name && !render.displayName) {
                render.displayName = name;
              }
            }
          });
        }
        return elementType;
      }
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
            return true;
          }
        }
        return false;
      }
      function memo(type, compare) {
        {
          if (!isValidElementType(type)) {
            error("memo: The first argument must be a component. Instead " + "received: %s", type === null ? "null" : typeof type);
          }
        }
        var elementType = {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: compare === undefined ? null : compare
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              if (!type.name && !type.displayName) {
                type.displayName = name;
              }
            }
          });
        }
        return elementType;
      }
      function resolveDispatcher() {
        var dispatcher = ReactCurrentDispatcher.current;
        {
          if (dispatcher === null) {
            error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for" + " one of the following reasons:\n" + "1. You might have mismatching versions of React and the renderer (such as React DOM)\n" + "2. You might be breaking the Rules of Hooks\n" + "3. You might have more than one copy of React in the same app\n" + "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
        }
        return dispatcher;
      }
      function useContext(Context) {
        var dispatcher = resolveDispatcher();
        {
          if (Context._context !== undefined) {
            var realContext = Context._context;
            if (realContext.Consumer === Context) {
              error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be " + "removed in a future major release. Did you mean to call useContext(Context) instead?");
            } else if (realContext.Provider === Context) {
              error("Calling useContext(Context.Provider) is not supported. " + "Did you mean to call useContext(Context) instead?");
            }
          }
        }
        return dispatcher.useContext(Context);
      }
      function useState(initialState) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useState(initialState);
      }
      function useReducer(reducer, initialArg, init2) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useReducer(reducer, initialArg, init2);
      }
      function useRef(initialValue) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useRef(initialValue);
      }
      function useEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useEffect(create, deps);
      }
      function useInsertionEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useInsertionEffect(create, deps);
      }
      function useLayoutEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useLayoutEffect(create, deps);
      }
      function useCallback(callback, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useCallback(callback, deps);
      }
      function useMemo(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useMemo(create, deps);
      }
      function useImperativeHandle(ref, create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useImperativeHandle(ref, create, deps);
      }
      function useDebugValue(value, formatterFn) {
        {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDebugValue(value, formatterFn);
        }
      }
      function useTransition() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useTransition();
      }
      function useDeferredValue(value) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useDeferredValue(value);
      }
      function useId() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useId();
      }
      function useSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot);
      }
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. " + "This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--;
            }
            for (;s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--;
                    c--;
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher$1.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component2) {
        var prototype = Component2.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values2, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; " + "it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`." + "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s" + " `%s` is invalid; the type checker " + "function must return `null` or an `Error` but returned a %s. " + "You may have forgotten to pass an argument to the type checker " + "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " + "shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            setExtraStackFrame(stack);
          } else {
            setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
          var name = getComponentNameFromType(ReactCurrentOwner.current.type);
          if (name) {
            return "\n\nCheck the render method of `" + name + "`.";
          }
        }
        return "";
      }
      function getSourceInfoErrorAddendum(source) {
        if (source !== undefined) {
          var fileName = source.fileName.replace(/^.*[\\\/]/, "");
          var lineNumber = source.lineNumber;
          return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
        }
        return "";
      }
      function getSourceInfoErrorAddendumForProps(elementProps) {
        if (elementProps !== null && elementProps !== undefined) {
          return getSourceInfoErrorAddendum(elementProps.__source);
        }
        return "";
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();
        if (!info) {
          var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
          if (parentName) {
            info = "\n\nCheck the top-level render call using <" + parentName + ">.";
          }
        }
        return info;
      }
      function validateExplicitKey(element, parentType) {
        if (!element._store || element._store.validated || element.key != null) {
          return;
        }
        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          return;
        }
        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
        var childOwner = "";
        if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
          childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
        }
        {
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.' + "%s%s See https://reactjs.org/link/warning-keys for more information.", currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        if (typeof node !== "object") {
          return;
        }
        if (isArray(node)) {
          for (var i = 0;i < node.length; i++) {
            var child = node[i];
            if (isValidElement(child)) {
              validateExplicitKey(child, parentType);
            }
          }
        } else if (isValidElement(node)) {
          if (node._store) {
            node._store.validated = true;
          }
        } else if (node) {
          var iteratorFn = getIteratorFn(node);
          if (typeof iteratorFn === "function") {
            if (iteratorFn !== node.entries) {
              var iterator = iteratorFn.call(node);
              var step;
              while (!(step = iterator.next()).done) {
                if (isValidElement(step.value)) {
                  validateExplicitKey(step.value, parentType);
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === undefined || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass " + "definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment2) {
        {
          var keys = Object.keys(fragment2.props);
          for (var i = 0;i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment2);
              error("Invalid prop `%s` supplied to `React.Fragment`. " + "React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment2.ref !== null) {
            setCurrentlyValidatingElement$1(fragment2);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      function createElementWithValidation(type, props, children) {
        var validType = isValidElementType(type);
        if (!validType) {
          var info = "";
          if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
            info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and named imports.";
          }
          var sourceInfo = getSourceInfoErrorAddendumForProps(props);
          if (sourceInfo) {
            info += sourceInfo;
          } else {
            info += getDeclarationErrorAddendum();
          }
          var typeString;
          if (type === null) {
            typeString = "null";
          } else if (isArray(type)) {
            typeString = "array";
          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
            typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
            info = " Did you accidentally export a JSX literal instead of a component?";
          } else {
            typeString = typeof type;
          }
          {
            error("React.createElement: type is invalid -- expected a string (for " + "built-in components) or a class/function (for composite " + "components) but got: %s.%s", typeString, info);
          }
        }
        var element = createElement.apply(this, arguments);
        if (element == null) {
          return element;
        }
        if (validType) {
          for (var i = 2;i < arguments.length; i++) {
            validateChildKeys(arguments[i], type);
          }
        }
        if (type === REACT_FRAGMENT_TYPE) {
          validateFragmentProps(element);
        } else {
          validatePropTypes(element);
        }
        return element;
      }
      var didWarnAboutDeprecatedCreateFactory = false;
      function createFactoryWithValidation(type) {
        var validatedFactory = createElementWithValidation.bind(null, type);
        validatedFactory.type = type;
        {
          if (!didWarnAboutDeprecatedCreateFactory) {
            didWarnAboutDeprecatedCreateFactory = true;
            warn("React.createFactory() is deprecated and will be removed in " + "a future major release. Consider using JSX " + "or use React.createElement() directly instead.");
          }
          Object.defineProperty(validatedFactory, "type", {
            enumerable: false,
            get: function() {
              warn("Factory.type is deprecated. Access the class directly " + "before passing it to createFactory.");
              Object.defineProperty(this, "type", {
                value: type
              });
              return type;
            }
          });
        }
        return validatedFactory;
      }
      function cloneElementWithValidation(element, props, children) {
        var newElement = cloneElement.apply(this, arguments);
        for (var i = 2;i < arguments.length; i++) {
          validateChildKeys(arguments[i], newElement.type);
        }
        validatePropTypes(newElement);
        return newElement;
      }
      function startTransition(scope, options) {
        var prevTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition = {};
        var currentTransition = ReactCurrentBatchConfig.transition;
        {
          ReactCurrentBatchConfig.transition._updatedFibers = new Set;
        }
        try {
          scope();
        } finally {
          ReactCurrentBatchConfig.transition = prevTransition;
          {
            if (prevTransition === null && currentTransition._updatedFibers) {
              var updatedFibersCount = currentTransition._updatedFibers.size;
              if (updatedFibersCount > 10) {
                warn("Detected a large number of updates inside startTransition. " + "If this is due to a subscription please re-write it to use React provided hooks. " + "Otherwise concurrent mode guarantees are off the table.");
              }
              currentTransition._updatedFibers.clear();
            }
          }
        }
      }
      var didWarnAboutMessageChannel = false;
      var enqueueTaskImpl = null;
      function enqueueTask(task) {
        if (enqueueTaskImpl === null) {
          try {
            var requireString = ("require" + Math.random()).slice(0, 7);
            var nodeRequire = module && module[requireString];
            enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
          } catch (_err) {
            enqueueTaskImpl = function(callback) {
              {
                if (didWarnAboutMessageChannel === false) {
                  didWarnAboutMessageChannel = true;
                  if (typeof MessageChannel === "undefined") {
                    error("This browser does not have a MessageChannel implementation, " + "so enqueuing tasks via await act(async () => ...) will fail. " + "Please file an issue at https://github.com/facebook/react/issues " + "if you encounter this warning.");
                  }
                }
              }
              var channel = new MessageChannel;
              channel.port1.onmessage = callback;
              channel.port2.postMessage(undefined);
            };
          }
        }
        return enqueueTaskImpl(task);
      }
      var actScopeDepth = 0;
      var didWarnNoAwaitAct = false;
      function act(callback) {
        {
          var prevActScopeDepth = actScopeDepth;
          actScopeDepth++;
          if (ReactCurrentActQueue.current === null) {
            ReactCurrentActQueue.current = [];
          }
          var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
          var result2;
          try {
            ReactCurrentActQueue.isBatchingLegacy = true;
            result2 = callback();
            if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
              var queue3 = ReactCurrentActQueue.current;
              if (queue3 !== null) {
                ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                flushActQueue(queue3);
              }
            }
          } catch (error2) {
            popActScope(prevActScopeDepth);
            throw error2;
          } finally {
            ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
          }
          if (result2 !== null && typeof result2 === "object" && typeof result2.then === "function") {
            var thenableResult = result2;
            var wasAwaited = false;
            var thenable = {
              then: function(resolve, reject) {
                wasAwaited = true;
                thenableResult.then(function(returnValue2) {
                  popActScope(prevActScopeDepth);
                  if (actScopeDepth === 0) {
                    recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                  } else {
                    resolve(returnValue2);
                  }
                }, function(error2) {
                  popActScope(prevActScopeDepth);
                  reject(error2);
                });
              }
            };
            {
              if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                Promise.resolve().then(function() {
                }).then(function() {
                  if (!wasAwaited) {
                    didWarnNoAwaitAct = true;
                    error("You called act(async () => ...) without await. " + "This could lead to unexpected testing behaviour, " + "interleaving multiple act calls and mixing their " + "scopes. " + "You should - await act(async () => ...);");
                  }
                });
              }
            }
            return thenable;
          } else {
            var returnValue = result2;
            popActScope(prevActScopeDepth);
            if (actScopeDepth === 0) {
              var _queue = ReactCurrentActQueue.current;
              if (_queue !== null) {
                flushActQueue(_queue);
                ReactCurrentActQueue.current = null;
              }
              var _thenable = {
                then: function(resolve, reject) {
                  if (ReactCurrentActQueue.current === null) {
                    ReactCurrentActQueue.current = [];
                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  } else {
                    resolve(returnValue);
                  }
                }
              };
              return _thenable;
            } else {
              var _thenable2 = {
                then: function(resolve, reject) {
                  resolve(returnValue);
                }
              };
              return _thenable2;
            }
          }
        }
      }
      function popActScope(prevActScopeDepth) {
        {
          if (prevActScopeDepth !== actScopeDepth - 1) {
            error("You seem to have overlapping act() calls, this is not supported. " + "Be sure to await previous act() calls before making a new one. ");
          }
          actScopeDepth = prevActScopeDepth;
        }
      }
      function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        {
          var queue3 = ReactCurrentActQueue.current;
          if (queue3 !== null) {
            try {
              flushActQueue(queue3);
              enqueueTask(function() {
                if (queue3.length === 0) {
                  ReactCurrentActQueue.current = null;
                  resolve(returnValue);
                } else {
                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                }
              });
            } catch (error2) {
              reject(error2);
            }
          } else {
            resolve(returnValue);
          }
        }
      }
      var isFlushing = false;
      function flushActQueue(queue3) {
        {
          if (!isFlushing) {
            isFlushing = true;
            var i = 0;
            try {
              for (;i < queue3.length; i++) {
                var callback = queue3[i];
                do {
                  callback = callback(true);
                } while (callback !== null);
              }
              queue3.length = 0;
            } catch (error2) {
              queue3 = queue3.slice(i + 1);
              throw error2;
            } finally {
              isFlushing = false;
            }
          }
        }
      }
      var createElement$1 = createElementWithValidation;
      var cloneElement$1 = cloneElementWithValidation;
      var createFactory = createFactoryWithValidation;
      var Children = {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray,
        only: onlyChild
      };
      exports.Children = Children;
      exports.Component = Component;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
      exports.cloneElement = cloneElement$1;
      exports.createContext = createContext;
      exports.createElement = createElement$1;
      exports.createFactory = createFactory;
      exports.createRef = createRef;
      exports.forwardRef = forwardRef;
      exports.isValidElement = isValidElement;
      exports.lazy = lazy;
      exports.memo = memo;
      exports.startTransition = startTransition;
      exports.unstable_act = act;
      exports.useCallback = useCallback;
      exports.useContext = useContext;
      exports.useDebugValue = useDebugValue;
      exports.useDeferredValue = useDeferredValue;
      exports.useEffect = useEffect;
      exports.useId = useId;
      exports.useImperativeHandle = useImperativeHandle;
      exports.useInsertionEffect = useInsertionEffect;
      exports.useLayoutEffect = useLayoutEffect;
      exports.useMemo = useMemo;
      exports.useReducer = useReducer;
      exports.useRef = useRef;
      exports.useState = useState;
      exports.useSyncExternalStore = useSyncExternalStore;
      exports.useTransition = useTransition;
      exports.version = ReactVersion;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error);
      }
    })();
  }
});

// node_modules/react/index.js
var require_react = __commonJS((exports, module) => {
  var react_development = __toESM(require_react_development(), 1);
  if (false) {
  } else {
    module.exports = react_development;
  }
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs4 = __commonJS((exports, module) => {
  function isNonNullObject(value) {
    return !!value && typeof value === "object";
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
  }
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
      return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_3) {
      return false;
    }
  }
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function(key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
  deepmerge.all = function deepmergeAll(array2, options) {
    if (!Array.isArray(array2)) {
      throw new Error("first argument should be an array");
    }
    return array2.reduce(function(prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  module.exports = deepmerge_1;
});

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS((exports) => {
  var React = __toESM(require_react(), 1);
  if (true) {
    (function() {
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). " + "This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return getComponentNameFromType(init2(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. " + "This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name2, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name2;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn3, construct) {
        if (!fn3 || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn3);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn3, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn3.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn3();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s2 = sampleLines.length - 1;
            var c2 = controlLines.length - 1;
            while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {
              c2--;
            }
            for (;s2 >= 1 && c2 >= 0; s2--, c2--) {
              if (sampleLines[s2] !== controlLines[c2]) {
                if (s2 !== 1 || c2 !== 1) {
                  do {
                    s2--;
                    c2--;
                    if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {
                      var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                      if (fn3.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn3.displayName);
                      }
                      {
                        if (typeof fn3 === "function") {
                          componentFrameCache.set(fn3, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s2 >= 1 && c2 >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name2 = fn3 ? fn3.displayName || fn3.name : "";
        var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
        {
          if (typeof fn3 === "function") {
            componentFrameCache.set(fn3, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn3, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn3, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values2, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; " + "it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`." + "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s" + " `%s` is invalid; the type checker " + "function must return `null` or an `Error` but returned a %s. " + "You may have forgotten to pass an argument to the type checker " + "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " + "shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e2) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s." + " This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      var didWarnAboutStringRefs;
      {
        didWarnAboutStringRefs = {};
      }
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== undefined;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== undefined;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self2) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
              error('Component "%s" contains the string ref "%s". ' + "Support for string refs will be removed in a future major release. " + "This case cannot be automatically converted to an arrow function. " + "We ask you to manually fix this case by using useRef() or createRef() instead. " + "Learn more about using refs safely here: " + "https://reactjs.org/link/strict-mode-string-ref", getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
              didWarnAboutStringRefs[componentName] = true;
            }
          }
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result " + "in `undefined` being returned. If you need to access the same " + "value within the child component, you should pass it as a different " + "prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result " + "in `undefined` being returned. If you need to access the same " + "value within the child component, you should pass it as a different " + "prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref,
          props,
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function jsxDEV(type, config, maybeKey, source, self2) {
        {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          if (maybeKey !== undefined) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key = "" + maybeKey;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          if (hasValidRef(config)) {
            ref = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self2);
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === undefined) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement(object) {
        {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name2 = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name2) {
              return "\n\nCheck the render method of `" + name2 + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          if (source !== undefined) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.' + "%s%s See https://reactjs.org/link/warning-keys for more information.", currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node3, parentType) {
        {
          if (typeof node3 !== "object") {
            return;
          }
          if (isArray(node3)) {
            for (var i = 0;i < node3.length; i++) {
              var child = node3[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node3)) {
            if (node3._store) {
              node3._store.validated = true;
            }
          } else if (node3) {
            var iteratorFn = getIteratorFn(node3);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node3.entries) {
                var iterator = iteratorFn.call(node3);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === undefined || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name2 = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name2, element);
          } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass " + "definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment2) {
        {
          var keys = Object.keys(fragment2.props);
          for (var i = 0;i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment2);
              error("Invalid prop `%s` supplied to `React.Fragment`. " + "React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment2.ref !== null) {
            setCurrentlyValidatingElement$1(fragment2);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
        {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum(source);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            error("React.jsx: type is invalid -- expected a string (for " + "built-in components) or a class/function (for composite " + "components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV(type, props, key, source, self2);
          if (element == null) {
            return element;
          }
          if (validType) {
            var children = props.children;
            if (children !== undefined) {
              if (isStaticChildren) {
                if (isArray(children)) {
                  for (var i = 0;i < children.length; i++) {
                    validateChildKeys(children[i], type);
                  }
                  if (Object.freeze) {
                    Object.freeze(children);
                  }
                } else {
                  error("React.jsx: Static children should always be an array. " + "You are likely explicitly calling React.jsxs or React.jsxDEV. " + "Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children, type);
              }
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
      }
      function jsxWithValidationStatic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, true);
        }
      }
      function jsxWithValidationDynamic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, false);
        }
      }
      var jsx = jsxWithValidationDynamic;
      var jsxs = jsxWithValidationStatic;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsx = jsx;
      exports.jsxs = jsxs;
    })();
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS((exports, module) => {
  var react_jsx_runtime_development = __toESM(require_react_jsx_runtime_development(), 1);
  if (false) {
  } else {
    module.exports = react_jsx_runtime_development;
  }
});

// node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js
import * as stream from "stream";
var require_react_dom_server_legacy_node_development = __commonJS((exports) => {
  var React = __toESM(require_react(), 1);
  if (true) {
    (function() {
      var ReactVersion = "18.2.0";
      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function warn(format) {
        {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
      }
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function scheduleWork(callback) {
        callback();
      }
      function beginWriting(destination) {
      }
      function writeChunk(destination, chunk) {
        writeChunkAndReturn(destination, chunk);
      }
      function writeChunkAndReturn(destination, chunk) {
        return destination.push(chunk);
      }
      function completeWriting(destination) {
      }
      function close(destination) {
        destination.push(null);
      }
      function stringToChunk(content) {
        return content;
      }
      function stringToPrecomputedChunk(content) {
        return content;
      }
      function closeWithError(destination, error2) {
        destination.destroy(error2);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e2) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkAttributeStringCoercion(value, attributeName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` attribute is an unsupported type %s." + " This value must be coerced to a string before before using it here.", attributeName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkCSSPropertyStringCoercion(value, propName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` CSS property is an unsupported type %s." + " This value must be coerced to a string before before using it here.", propName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkHtmlStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided HTML markup uses a value of unsupported type %s." + " This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var RESERVED = 0;
      var STRING = 1;
      var BOOLEANISH_STRING = 2;
      var BOOLEAN = 3;
      var OVERLOADED_BOOLEAN = 4;
      var NUMERIC = 5;
      var POSITIVE_NUMERIC = 6;
      var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
          return true;
        }
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
          return false;
        }
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
          validatedAttributeNameCache[attributeName] = true;
          return true;
        }
        illegalAttributeNameCache[attributeName] = true;
        {
          error("Invalid attribute name: `%s`", attributeName);
        }
        return false;
      }
      function shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) {
          return false;
        }
        switch (typeof value) {
          case "function":
          case "symbol":
            return true;
          case "boolean": {
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              return !propertyInfo.acceptsBooleans;
            } else {
              var prefix2 = name2.toLowerCase().slice(0, 5);
              return prefix2 !== "data-" && prefix2 !== "aria-";
            }
          }
          default:
            return false;
        }
      }
      function getPropertyInfo(name2) {
        return properties.hasOwnProperty(name2) ? properties[name2] : null;
      }
      function PropertyInfoRecord(name2, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
        this.attributeName = attributeName;
        this.attributeNamespace = attributeNamespace;
        this.mustUseProperty = mustUseProperty;
        this.propertyName = name2;
        this.type = type;
        this.sanitizeURL = sanitizeURL2;
        this.removeEmptyString = removeEmptyString;
      }
      var properties = {};
      var reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(name2, RESERVED, false, name2, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name2 = _ref[0], attributeName = _ref[1];
        properties[name2] = new PropertyInfoRecord(name2, STRING, false, attributeName, null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(name2, BOOLEANISH_STRING, false, name2.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(name2, BOOLEANISH_STRING, false, name2, null, false, false);
      });
      [
        "allowFullScreen",
        "async",
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        "itemScope"
      ].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(name2, BOOLEAN, false, name2.toLowerCase(), null, false, false);
      });
      [
        "checked",
        "multiple",
        "muted",
        "selected"
      ].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(name2, BOOLEAN, true, name2, null, false, false);
      });
      [
        "capture",
        "download"
      ].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(name2, OVERLOADED_BOOLEAN, false, name2, null, false, false);
      });
      [
        "cols",
        "rows",
        "size",
        "span"
      ].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(name2, POSITIVE_NUMERIC, false, name2, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(name2, NUMERIC, false, name2.toLowerCase(), null, false, false);
      });
      var CAMELIZE = /[\-\:]([a-z])/g;
      var capitalize = function(token2) {
        return token2[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
      ].forEach(function(attributeName) {
        var name2 = attributeName.replace(CAMELIZE, capitalize);
        properties[name2] = new PropertyInfoRecord(name2, STRING, false, attributeName, null, false, false);
      });
      [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
      ].forEach(function(attributeName) {
        var name2 = attributeName.replace(CAMELIZE, capitalize);
        properties[name2] = new PropertyInfoRecord(name2, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
      });
      [
        "xml:base",
        "xml:lang",
        "xml:space"
      ].forEach(function(attributeName) {
        var name2 = attributeName.replace(CAMELIZE, capitalize);
        properties[name2] = new PropertyInfoRecord(name2, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
      });
      var xlinkHref = "xlinkHref";
      properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
      });
      var isUnitlessNumber = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      function prefixKey(prefix2, key) {
        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      };
      function checkControlledValueProps(tagName, props) {
        {
          if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
            error("You provided a `value` prop to a form field without an " + "`onChange` handler. This will render a read-only field. If " + "the field should be mutable use `defaultValue`. Otherwise, " + "set either `onChange` or `readOnly`.");
          }
          if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
            error("You provided a `checked` prop to a form field without an " + "`onChange` handler. This will render a read-only field. If " + "the field should be mutable use `defaultChecked`. Otherwise, " + "set either `onChange` or `readOnly`.");
          }
        }
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1) {
          return typeof props.is === "string";
        }
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      };
      var warnedProperties = {};
      var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
      var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
      function validateProperty(tagName, name2) {
        {
          if (hasOwnProperty.call(warnedProperties, name2) && warnedProperties[name2]) {
            return true;
          }
          if (rARIACamel.test(name2)) {
            var ariaName = "aria-" + name2.slice(4).toLowerCase();
            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null) {
              error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name2);
              warnedProperties[name2] = true;
              return true;
            }
            if (name2 !== correctName) {
              error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name2, correctName);
              warnedProperties[name2] = true;
              return true;
            }
          }
          if (rARIA.test(name2)) {
            var lowerCasedName = name2.toLowerCase();
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null) {
              warnedProperties[name2] = true;
              return false;
            }
            if (name2 !== standardName) {
              error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name2, standardName);
              warnedProperties[name2] = true;
              return true;
            }
          }
        }
        return true;
      }
      function warnInvalidARIAProps(type, props) {
        {
          var invalidProps = [];
          for (var key in props) {
            var isValid2 = validateProperty(type, key);
            if (!isValid2) {
              invalidProps.push(key);
            }
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (invalidProps.length === 1) {
            error("Invalid aria prop %s on <%s> tag. " + "For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          } else if (invalidProps.length > 1) {
            error("Invalid aria props %s on <%s> tag. " + "For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          }
        }
      }
      function validateProperties(type, props) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnInvalidARIAProps(type, props);
      }
      var didWarnValueNull = false;
      function validateProperties$1(type, props) {
        {
          if (type !== "input" && type !== "textarea" && type !== "select") {
            return;
          }
          if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true;
            if (type === "select" && props.multiple) {
              error("`value` prop on `%s` should not be null. " + "Consider using an empty array when `multiple` is set to `true` " + "to clear the component or `undefined` for uncontrolled components.", type);
            } else {
              error("`value` prop on `%s` should not be null. " + "Consider using an empty string to clear the component or `undefined` " + "for uncontrolled components.", type);
            }
          }
        }
      }
      var possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      };
      var validateProperty$1 = function() {
      };
      {
        var warnedProperties$1 = {};
        var EVENT_NAME_REGEX = /^on./;
        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
        var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name2, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties$1, name2) && warnedProperties$1[name2]) {
            return true;
          }
          var lowerCasedName = name2.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
            error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. " + "All React events are normalized to bubble, so onFocusIn and onFocusOut " + "are not needed/supported by React.");
            warnedProperties$1[name2] = true;
            return true;
          }
          if (eventRegistry != null) {
            var { registrationNameDependencies, possibleRegistrationNames } = eventRegistry;
            if (registrationNameDependencies.hasOwnProperty(name2)) {
              return true;
            }
            var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
            if (registrationName != null) {
              error("Invalid event handler property `%s`. Did you mean `%s`?", name2, registrationName);
              warnedProperties$1[name2] = true;
              return true;
            }
            if (EVENT_NAME_REGEX.test(name2)) {
              error("Unknown event handler property `%s`. It will be ignored.", name2);
              warnedProperties$1[name2] = true;
              return true;
            }
          } else if (EVENT_NAME_REGEX.test(name2)) {
            if (INVALID_EVENT_NAME_REGEX.test(name2)) {
              error("Invalid event handler property `%s`. " + "React events use the camelCase naming convention, for example `onClick`.", name2);
            }
            warnedProperties$1[name2] = true;
            return true;
          }
          if (rARIA$1.test(name2) || rARIACamel$1.test(name2)) {
            return true;
          }
          if (lowerCasedName === "innerhtml") {
            error("Directly setting property `innerHTML` is not permitted. " + "For more information, lookup documentation on `dangerouslySetInnerHTML`.");
            warnedProperties$1[name2] = true;
            return true;
          }
          if (lowerCasedName === "aria") {
            error("The `aria` attribute is reserved for future use in React. " + "Pass individual `aria-` attributes instead.");
            warnedProperties$1[name2] = true;
            return true;
          }
          if (lowerCasedName === "is" && value !== null && value !== undefined && typeof value !== "string") {
            error("Received a `%s` for a string attribute `is`. If this is expected, cast " + "the value to a string.", typeof value);
            warnedProperties$1[name2] = true;
            return true;
          }
          if (typeof value === "number" && isNaN(value)) {
            error("Received NaN for the `%s` attribute. If this is expected, cast " + "the value to a string.", name2);
            warnedProperties$1[name2] = true;
            return true;
          }
          var propertyInfo = getPropertyInfo(name2);
          var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name2) {
              error("Invalid DOM property `%s`. Did you mean `%s`?", name2, standardName);
              warnedProperties$1[name2] = true;
              return true;
            }
          } else if (!isReserved && name2 !== lowerCasedName) {
            error("React does not recognize the `%s` prop on a DOM element. If you " + "intentionally want it to appear in the DOM as a custom " + "attribute, spell it as lowercase `%s` instead. " + "If you accidentally passed it from a parent component, remove " + "it from the DOM element.", name2, lowerCasedName);
            warnedProperties$1[name2] = true;
            return true;
          }
          if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
            if (value) {
              error("Received `%s` for a non-boolean attribute `%s`.\n\n" + "If you want to write it to the DOM, pass a string instead: " + '%s="%s" or %s={value.toString()}.', value, name2, name2, value, name2);
            } else {
              error("Received `%s` for a non-boolean attribute `%s`.\n\n" + "If you want to write it to the DOM, pass a string instead: " + '%s="%s" or %s={value.toString()}.\n\n' + "If you used to conditionally omit it with %s={condition && value}, " + "pass %s={condition ? value : undefined} instead.", value, name2, name2, value, name2, name2, name2);
            }
            warnedProperties$1[name2] = true;
            return true;
          }
          if (isReserved) {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
            warnedProperties$1[name2] = true;
            return false;
          }
          if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
            error("Received the string `%s` for the boolean attribute `%s`. " + "%s " + "Did you mean %s={%s}?", value, name2, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name2, value);
            warnedProperties$1[name2] = true;
            return true;
          }
          return true;
        };
      }
      var warnUnknownProperties = function(type, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key in props) {
            var isValid2 = validateProperty$1(type, key, props[key], eventRegistry);
            if (!isValid2) {
              unknownProps.push(key);
            }
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (unknownProps.length === 1) {
            error("Invalid value for prop %s on <%s> tag. Either remove it from the element, " + "or pass a string or number value to keep it in the DOM. " + "For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          } else if (unknownProps.length > 1) {
            error("Invalid values for props %s on <%s> tag. Either remove them from the element, " + "or pass a string or number value to keep them in the DOM. " + "For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          }
        }
      };
      function validateProperties$2(type, props, eventRegistry) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnUnknownProperties(type, props, eventRegistry);
      }
      var warnValidStyle = function() {
      };
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
        var msPattern = /^-ms-/;
        var hyphenPattern = /-(.)/g;
        var badStyleValueWithSemicolonPattern = /;\s*$/;
        var warnedStyleNames = {};
        var warnedStyleValues = {};
        var warnedForNaNValue = false;
        var warnedForInfinityValue = false;
        var camelize = function(string) {
          return string.replace(hyphenPattern, function(_3, character) {
            return character.toUpperCase();
          });
        };
        var warnHyphenatedStyleName = function(name2) {
          if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
            return;
          }
          warnedStyleNames[name2] = true;
          error("Unsupported style property %s. Did you mean %s?", name2, camelize(name2.replace(msPattern, "ms-")));
        };
        var warnBadVendoredStyleName = function(name2) {
          if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
            return;
          }
          warnedStyleNames[name2] = true;
          error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name2, name2.charAt(0).toUpperCase() + name2.slice(1));
        };
        var warnStyleValueWithSemicolon = function(name2, value) {
          if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
            return;
          }
          warnedStyleValues[value] = true;
          error("Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.', name2, value.replace(badStyleValueWithSemicolonPattern, ""));
        };
        var warnStyleValueIsNaN = function(name2, value) {
          if (warnedForNaNValue) {
            return;
          }
          warnedForNaNValue = true;
          error("`NaN` is an invalid value for the `%s` css style property.", name2);
        };
        var warnStyleValueIsInfinity = function(name2, value) {
          if (warnedForInfinityValue) {
            return;
          }
          warnedForInfinityValue = true;
          error("`Infinity` is an invalid value for the `%s` css style property.", name2);
        };
        warnValidStyle = function(name2, value) {
          if (name2.indexOf("-") > -1) {
            warnHyphenatedStyleName(name2);
          } else if (badVendoredStyleNamePattern.test(name2)) {
            warnBadVendoredStyleName(name2);
          } else if (badStyleValueWithSemicolonPattern.test(value)) {
            warnStyleValueWithSemicolon(name2, value);
          }
          if (typeof value === "number") {
            if (isNaN(value)) {
              warnStyleValueIsNaN(name2, value);
            } else if (!isFinite(value)) {
              warnStyleValueIsInfinity(name2, value);
            }
          }
        };
      }
      var warnValidStyle$1 = warnValidStyle;
      var matchHtmlRegExp = /["'&<>]/;
      function escapeHtml(string) {
        {
          checkHtmlStringCoercion(string);
        }
        var str = "" + string;
        var match = matchHtmlRegExp.exec(str);
        if (!match) {
          return str;
        }
        var escape4;
        var html = "";
        var index2;
        var lastIndex = 0;
        for (index2 = match.index;index2 < str.length; index2++) {
          switch (str.charCodeAt(index2)) {
            case 34:
              escape4 = "&quot;";
              break;
            case 38:
              escape4 = "&amp;";
              break;
            case 39:
              escape4 = "&#x27;";
              break;
            case 60:
              escape4 = "&lt;";
              break;
            case 62:
              escape4 = "&gt;";
              break;
            default:
              continue;
          }
          if (lastIndex !== index2) {
            html += str.substring(lastIndex, index2);
          }
          lastIndex = index2 + 1;
          html += escape4;
        }
        return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
      }
      function escapeTextForBrowser(text2) {
        if (typeof text2 === "boolean" || typeof text2 === "number") {
          return "" + text2;
        }
        return escapeHtml(text2);
      }
      var uppercasePattern = /([A-Z])/g;
      var msPattern$1 = /^ms-/;
      function hyphenateStyleName(name2) {
        return name2.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
      }
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
      var didWarn = false;
      function sanitizeURL(url) {
        {
          if (!didWarn && isJavaScriptProtocol.test(url)) {
            didWarn = true;
            error("A future version of React will block javascript: URLs as a security precaution. " + "Use event handlers instead if you can. If you need to generate unsafe HTML try " + "using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      var startInlineScript = stringToPrecomputedChunk("<script>");
      var endInlineScript = stringToPrecomputedChunk("</script>");
      var startScriptSrc = stringToPrecomputedChunk('<script src="');
      var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
      var endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
      function escapeBootstrapScriptContent(scriptText) {
        {
          checkHtmlStringCoercion(scriptText);
        }
        return ("" + scriptText).replace(scriptRegex, scriptReplacer);
      }
      var scriptRegex = /(<\/|<)(s)(cript)/gi;
      var scriptReplacer = function(match, prefix2, s2, suffix) {
        return "" + prefix2 + (s2 === "s" ? "\\u0073" : "\\u0053") + suffix;
      };
      function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        var idPrefix = identifierPrefix === undefined ? "" : identifierPrefix;
        var inlineScriptWithNonce = nonce === undefined ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
        var bootstrapChunks = [];
        if (bootstrapScriptContent !== undefined) {
          bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
        }
        if (bootstrapScripts !== undefined) {
          for (var i = 0;i < bootstrapScripts.length; i++) {
            bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);
          }
        }
        if (bootstrapModules !== undefined) {
          for (var _i2 = 0;_i2 < bootstrapModules.length; _i2++) {
            bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i2])), endAsyncScript);
          }
        }
        return {
          bootstrapChunks,
          startInlineScript: inlineScriptWithNonce,
          placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
          segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
          boundaryPrefix: idPrefix + "B:",
          idPrefix,
          nextSuspenseID: 0,
          sentCompleteSegmentFunction: false,
          sentCompleteBoundaryFunction: false,
          sentClientRenderFunction: false
        };
      }
      var ROOT_HTML_MODE = 0;
      var HTML_MODE = 1;
      var SVG_MODE = 2;
      var MATHML_MODE = 3;
      var HTML_TABLE_MODE = 4;
      var HTML_TABLE_BODY_MODE = 5;
      var HTML_TABLE_ROW_MODE = 6;
      var HTML_COLGROUP_MODE = 7;
      function createFormatContext(insertionMode, selectedValue) {
        return {
          insertionMode,
          selectedValue
        };
      }
      function getChildFormatContext(parentContext, type, props) {
        switch (type) {
          case "select":
            return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
          case "svg":
            return createFormatContext(SVG_MODE, null);
          case "math":
            return createFormatContext(MATHML_MODE, null);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null);
          case "table":
            return createFormatContext(HTML_TABLE_MODE, null);
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(HTML_TABLE_BODY_MODE, null);
          case "colgroup":
            return createFormatContext(HTML_COLGROUP_MODE, null);
          case "tr":
            return createFormatContext(HTML_TABLE_ROW_MODE, null);
        }
        if (parentContext.insertionMode >= HTML_TABLE_MODE) {
          return createFormatContext(HTML_MODE, null);
        }
        if (parentContext.insertionMode === ROOT_HTML_MODE) {
          return createFormatContext(HTML_MODE, null);
        }
        return parentContext;
      }
      var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
      function assignSuspenseBoundaryID(responseState) {
        var generatedID = responseState.nextSuspenseID++;
        return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
      }
      function makeId(responseState, treeId, localId) {
        var idPrefix = responseState.idPrefix;
        var id = ":" + idPrefix + "R" + treeId;
        if (localId > 0) {
          id += "H" + localId.toString(32);
        }
        return id + ":";
      }
      function encodeHTMLTextNode(text2) {
        return escapeTextForBrowser(text2);
      }
      var textSeparator = stringToPrecomputedChunk("<!-- -->");
      function pushTextInstance(target, text2, responseState, textEmbedded) {
        if (text2 === "") {
          return textEmbedded;
        }
        if (textEmbedded) {
          target.push(textSeparator);
        }
        target.push(stringToChunk(encodeHTMLTextNode(text2)));
        return true;
      }
      function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
        if (lastPushedText && textEmbedded) {
          target.push(textSeparator);
        }
      }
      var styleNameCache = new Map;
      function processStyleName(styleName) {
        var chunk = styleNameCache.get(styleName);
        if (chunk !== undefined) {
          return chunk;
        }
        var result2 = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
        styleNameCache.set(styleName, result2);
        return result2;
      }
      var styleAttributeStart = stringToPrecomputedChunk(' style="');
      var styleAssign = stringToPrecomputedChunk(":");
      var styleSeparator = stringToPrecomputedChunk(";");
      function pushStyle(target, responseState, style) {
        if (typeof style !== "object") {
          throw new Error("The `style` prop expects a mapping from style properties to values, " + "not a string. For example, style={{marginRight: spacing + 'em'}} when " + "using JSX.");
        }
        var isFirst = true;
        for (var styleName in style) {
          if (!hasOwnProperty.call(style, styleName)) {
            continue;
          }
          var styleValue = style[styleName];
          if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
            continue;
          }
          var nameChunk = undefined;
          var valueChunk = undefined;
          var isCustomProperty = styleName.indexOf("--") === 0;
          if (isCustomProperty) {
            nameChunk = stringToChunk(escapeTextForBrowser(styleName));
            {
              checkCSSPropertyStringCoercion(styleValue, styleName);
            }
            valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
          } else {
            {
              warnValidStyle$1(styleName, styleValue);
            }
            nameChunk = processStyleName(styleName);
            if (typeof styleValue === "number") {
              if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                valueChunk = stringToChunk(styleValue + "px");
              } else {
                valueChunk = stringToChunk("" + styleValue);
              }
            } else {
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            }
          }
          if (isFirst) {
            isFirst = false;
            target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
          } else {
            target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
          }
        }
        if (!isFirst) {
          target.push(attributeEnd);
        }
      }
      var attributeSeparator = stringToPrecomputedChunk(" ");
      var attributeAssign = stringToPrecomputedChunk('="');
      var attributeEnd = stringToPrecomputedChunk('"');
      var attributeEmptyString = stringToPrecomputedChunk('=""');
      function pushAttribute(target, responseState, name2, value) {
        switch (name2) {
          case "style": {
            pushStyle(target, responseState, value);
            return;
          }
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            return;
        }
        if (name2.length > 2 && (name2[0] === "o" || name2[0] === "O") && (name2[1] === "n" || name2[1] === "N")) {
          return;
        }
        var propertyInfo = getPropertyInfo(name2);
        if (propertyInfo !== null) {
          switch (typeof value) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              if (!propertyInfo.acceptsBooleans) {
                return;
              }
            }
          }
          var attributeName = propertyInfo.attributeName;
          var attributeNameChunk = stringToChunk(attributeName);
          switch (propertyInfo.type) {
            case BOOLEAN:
              if (value) {
                target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
              }
              return;
            case OVERLOADED_BOOLEAN:
              if (value === true) {
                target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
              } else if (value === false)
                ;
              else {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              return;
            case NUMERIC:
              if (!isNaN(value)) {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              break;
            case POSITIVE_NUMERIC:
              if (!isNaN(value) && value >= 1) {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              break;
            default:
              if (propertyInfo.sanitizeURL) {
                {
                  checkAttributeStringCoercion(value, attributeName);
                }
                value = "" + value;
                sanitizeURL(value);
              }
              target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
          }
        } else if (isAttributeNameSafe(name2)) {
          switch (typeof value) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var prefix2 = name2.toLowerCase().slice(0, 5);
              if (prefix2 !== "data-" && prefix2 !== "aria-") {
                return;
              }
            }
          }
          target.push(attributeSeparator, stringToChunk(name2), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
        }
      }
      var endOfStartTag = stringToPrecomputedChunk(">");
      var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
      function pushInnerHTML(target, innerHTML, children) {
        if (innerHTML != null) {
          if (children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. " + "Please visit https://reactjs.org/link/dangerously-set-inner-html " + "for more information.");
          }
          var html = innerHTML.__html;
          if (html !== null && html !== undefined) {
            {
              checkHtmlStringCoercion(html);
            }
            target.push(stringToChunk("" + html));
          }
        }
      }
      var didWarnDefaultInputValue = false;
      var didWarnDefaultChecked = false;
      var didWarnDefaultSelectValue = false;
      var didWarnDefaultTextareaValue = false;
      var didWarnInvalidOptionChildren = false;
      var didWarnInvalidOptionInnerHTML = false;
      var didWarnSelectedSetOnOption = false;
      function checkSelectProp(props, propName) {
        {
          var value = props[propName];
          if (value != null) {
            var array2 = isArray(value);
            if (props.multiple && !array2) {
              error("The `%s` prop supplied to <select> must be an array if " + "`multiple` is true.", propName);
            } else if (!props.multiple && array2) {
              error("The `%s` prop supplied to <select> must be a scalar " + "value if `multiple` is false.", propName);
            }
          }
        }
      }
      function pushStartSelect(target, props, responseState) {
        {
          checkControlledValueProps("select", props);
          checkSelectProp(props, "value");
          checkSelectProp(props, "defaultValue");
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {
            error("Select elements must be either controlled or uncontrolled " + "(specify either the value prop, or the defaultValue prop, but not " + "both). Decide between using a controlled or uncontrolled select " + "element and remove one of these props. More info: " + "https://reactjs.org/link/controlled-components");
            didWarnDefaultSelectValue = true;
          }
        }
        target.push(startChunkForTag("select"));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      function flattenOptionChildren(children) {
        var content = "";
        React.Children.forEach(children, function(child) {
          if (child == null) {
            return;
          }
          content += child;
          {
            if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
              didWarnInvalidOptionChildren = true;
              error("Cannot infer the option value of complex children. " + "Pass a `value` prop or use a plain string as children to <option>.");
            }
          }
        });
        return content;
      }
      var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
      function pushStartOption(target, props, responseState, formatContext) {
        var selectedValue = formatContext.selectedValue;
        target.push(startChunkForTag("option"));
        var children = null;
        var value = null;
        var selected = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "selected":
                selected = propValue;
                {
                  if (!didWarnSelectedSetOnOption) {
                    error("Use the `defaultValue` or `value` props on <select> instead of " + "setting `selected` on <option>.");
                    didWarnSelectedSetOnOption = true;
                  }
                }
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "value":
                value = propValue;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (selectedValue != null) {
          var stringValue;
          if (value !== null) {
            {
              checkAttributeStringCoercion(value, "value");
            }
            stringValue = "" + value;
          } else {
            {
              if (innerHTML !== null) {
                if (!didWarnInvalidOptionInnerHTML) {
                  didWarnInvalidOptionInnerHTML = true;
                  error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows " + "which value should be selected.");
                }
              }
            }
            stringValue = flattenOptionChildren(children);
          }
          if (isArray(selectedValue)) {
            for (var i = 0;i < selectedValue.length; i++) {
              {
                checkAttributeStringCoercion(selectedValue[i], "value");
              }
              var v3 = "" + selectedValue[i];
              if (v3 === stringValue) {
                target.push(selectedMarkerAttribute);
                break;
              }
            }
          } else {
            {
              checkAttributeStringCoercion(selectedValue, "select.value");
            }
            if ("" + selectedValue === stringValue) {
              target.push(selectedMarkerAttribute);
            }
          }
        } else if (selected) {
          target.push(selectedMarkerAttribute);
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      function pushInput(target, props, responseState) {
        {
          checkControlledValueProps("input", props);
          if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnDefaultChecked) {
            error("%s contains an input of type %s with both checked and defaultChecked props. " + "Input elements must be either controlled or uncontrolled " + "(specify either the checked prop, or the defaultChecked prop, but not " + "both). Decide between using a controlled or uncontrolled input " + "element and remove one of these props. More info: " + "https://reactjs.org/link/controlled-components", "A component", props.type);
            didWarnDefaultChecked = true;
          }
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultInputValue) {
            error("%s contains an input of type %s with both value and defaultValue props. " + "Input elements must be either controlled or uncontrolled " + "(specify either the value prop, or the defaultValue prop, but not " + "both). Decide between using a controlled or uncontrolled input " + "element and remove one of these props. More info: " + "https://reactjs.org/link/controlled-components", "A component", props.type);
            didWarnDefaultInputValue = true;
          }
        }
        target.push(startChunkForTag("input"));
        var value = null;
        var defaultValue = null;
        var checked = null;
        var defaultChecked = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("input" + " is a self-closing tag and must neither have `children` nor " + "use `dangerouslySetInnerHTML`.");
              case "defaultChecked":
                defaultChecked = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "checked":
                checked = propValue;
                break;
              case "value":
                value = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (checked !== null) {
          pushAttribute(target, responseState, "checked", checked);
        } else if (defaultChecked !== null) {
          pushAttribute(target, responseState, "checked", defaultChecked);
        }
        if (value !== null) {
          pushAttribute(target, responseState, "value", value);
        } else if (defaultValue !== null) {
          pushAttribute(target, responseState, "value", defaultValue);
        }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushStartTextArea(target, props, responseState) {
        {
          checkControlledValueProps("textarea", props);
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {
            error("Textarea elements must be either controlled or uncontrolled " + "(specify either the value prop, or the defaultValue prop, but not " + "both). Decide between using a controlled or uncontrolled textarea " + "and remove one of these props. More info: " + "https://reactjs.org/link/controlled-components");
            didWarnDefaultTextareaValue = true;
          }
        }
        target.push(startChunkForTag("textarea"));
        var value = null;
        var defaultValue = null;
        var children = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "value":
                value = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (value === null && defaultValue !== null) {
          value = defaultValue;
        }
        target.push(endOfStartTag);
        if (children != null) {
          {
            error("Use the `defaultValue` or `value` props instead of setting " + "children on <textarea>.");
          }
          if (value != null) {
            throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          }
          if (isArray(children)) {
            if (children.length > 1) {
              throw new Error("<textarea> can only have at most one child.");
            }
            {
              checkHtmlStringCoercion(children[0]);
            }
            value = "" + children[0];
          }
          {
            checkHtmlStringCoercion(children);
          }
          value = "" + children;
        }
        if (typeof value === "string" && value[0] === "\n") {
          target.push(leadingNewline);
        }
        if (value !== null) {
          {
            checkAttributeStringCoercion(value, "value");
          }
          target.push(stringToChunk(encodeHTMLTextNode("" + value)));
        }
        return null;
      }
      function pushSelfClosing(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error(tag + " is a self-closing tag and must neither have `children` nor " + "use `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushStartMenuItem(target, props, responseState) {
        target.push(startChunkForTag("menuitem"));
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        return null;
      }
      function pushStartTitle(target, props, responseState) {
        target.push(startChunkForTag("title"));
        var children = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        {
          var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
          if (Array.isArray(children) && children.length > 1) {
            error("A title element received an array with more than 1 element as children. " + "In browsers title Elements can only have Text Nodes as children. If " + "the children being rendered output more than a single text node in aggregate the browser " + "will display markup and comments as text in the title and hydration will likely fail and " + "fall back to client rendering");
          } else if (child != null && child.$$typeof != null) {
            error("A title element received a React element for children. " + "In the browser title Elements can only have Text Nodes as children. If " + "the children being rendered output more than a single text node in aggregate the browser " + "will display markup and comments as text in the title and hydration will likely fail and " + "fall back to client rendering");
          } else if (child != null && typeof child !== "string" && typeof child !== "number") {
            error("A title element received a value that was not a string or number for children. " + "In the browser title Elements can only have Text Nodes as children. If " + "the children being rendered output more than a single text node in aggregate the browser " + "will display markup and comments as text in the title and hydration will likely fail and " + "fall back to client rendering");
          }
        }
        return children;
      }
      function pushStartGenericElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        if (typeof children === "string") {
          target.push(stringToChunk(encodeHTMLTextNode(children)));
          return null;
        }
        return children;
      }
      function pushStartCustomElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "style":
                pushStyle(target, responseState, propValue);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                  target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                }
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      var leadingNewline = stringToPrecomputedChunk("\n");
      function pushStartPreformattedElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        if (innerHTML != null) {
          if (children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. " + "Please visit https://reactjs.org/link/dangerously-set-inner-html " + "for more information.");
          }
          var html = innerHTML.__html;
          if (html !== null && html !== undefined) {
            if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
              target.push(leadingNewline, stringToChunk(html));
            } else {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        if (typeof children === "string" && children[0] === "\n") {
          target.push(leadingNewline);
        }
        return children;
      }
      var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
      var validatedTagCache = new Map;
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (tagStartChunk === undefined) {
          if (!VALID_TAG_REGEX.test(tag)) {
            throw new Error("Invalid tag: " + tag);
          }
          tagStartChunk = stringToPrecomputedChunk("<" + tag);
          validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
      function pushStartInstance(target, type, props, responseState, formatContext) {
        {
          validateProperties(type, props);
          validateProperties$1(type, props);
          validateProperties$2(type, props, null);
          if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
            error("A component is `contentEditable` and contains `children` managed by " + "React. It is now your responsibility to guarantee that none of " + "those nodes are unexpectedly modified or duplicated. This is " + "probably not intentional.");
          }
          if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
            if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
              error("<%s /> is using incorrect casing. " + "Use PascalCase for React components, " + "or lowercase for HTML elements.", type);
            }
          }
        }
        switch (type) {
          case "select":
            return pushStartSelect(target, props, responseState);
          case "option":
            return pushStartOption(target, props, responseState, formatContext);
          case "textarea":
            return pushStartTextArea(target, props, responseState);
          case "input":
            return pushInput(target, props, responseState);
          case "menuitem":
            return pushStartMenuItem(target, props, responseState);
          case "title":
            return pushStartTitle(target, props, responseState);
          case "listing":
          case "pre": {
            return pushStartPreformattedElement(target, props, type, responseState);
          }
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr": {
            return pushSelfClosing(target, props, type, responseState);
          }
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph": {
            return pushStartGenericElement(target, props, type, responseState);
          }
          case "html": {
            if (formatContext.insertionMode === ROOT_HTML_MODE) {
              target.push(DOCTYPE);
            }
            return pushStartGenericElement(target, props, type, responseState);
          }
          default: {
            if (type.indexOf("-") === -1 && typeof props.is !== "string") {
              return pushStartGenericElement(target, props, type, responseState);
            } else {
              return pushStartCustomElement(target, props, type, responseState);
            }
          }
        }
      }
      var endTag1 = stringToPrecomputedChunk("</");
      var endTag2 = stringToPrecomputedChunk(">");
      function pushEndInstance(target, type, props) {
        switch (type) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr": {
            break;
          }
          default: {
            target.push(endTag1, stringToChunk(type), endTag2);
          }
        }
      }
      function writeCompletedRoot(destination, responseState) {
        var bootstrapChunks = responseState.bootstrapChunks;
        var i = 0;
        for (;i < bootstrapChunks.length - 1; i++) {
          writeChunk(destination, bootstrapChunks[i]);
        }
        if (i < bootstrapChunks.length) {
          return writeChunkAndReturn(destination, bootstrapChunks[i]);
        }
        return true;
      }
      var placeholder1 = stringToPrecomputedChunk('<template id="');
      var placeholder2 = stringToPrecomputedChunk('"></template>');
      function writePlaceholder(destination, responseState, id) {
        writeChunk(destination, placeholder1);
        writeChunk(destination, responseState.placeholderPrefix);
        var formattedID = stringToChunk(id.toString(16));
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, placeholder2);
      }
      var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
      var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
      var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
      var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
      var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
      var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
      var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
      var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
      var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
      var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
      var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
      function writeStartCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
      }
      function writeStartPendingSuspenseBoundary(destination, responseState, id) {
        writeChunk(destination, startPendingSuspenseBoundary1);
        if (id === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        writeChunk(destination, id);
        return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
      }
      function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
        var result2;
        result2 = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
        writeChunk(destination, clientRenderedSuspenseBoundaryError1);
        if (errorDigest) {
          writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
          writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
          writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
        }
        {
          if (errorMesssage) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
        }
        result2 = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
        return result2;
      }
      function writeEndCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndPendingSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
      var startSegmentHTML2 = stringToPrecomputedChunk('">');
      var endSegmentHTML = stringToPrecomputedChunk("</div>");
      var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
      var startSegmentSVG2 = stringToPrecomputedChunk('">');
      var endSegmentSVG = stringToPrecomputedChunk("</svg>");
      var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
      var startSegmentMathML2 = stringToPrecomputedChunk('">');
      var endSegmentMathML = stringToPrecomputedChunk("</math>");
      var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
      var startSegmentTable2 = stringToPrecomputedChunk('">');
      var endSegmentTable = stringToPrecomputedChunk("</table>");
      var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
      var startSegmentTableBody2 = stringToPrecomputedChunk('">');
      var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
      var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
      var startSegmentTableRow2 = stringToPrecomputedChunk('">');
      var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
      var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
      var startSegmentColGroup2 = stringToPrecomputedChunk('">');
      var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
      function writeStartSegment(destination, responseState, formatContext, id) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            writeChunk(destination, startSegmentHTML);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentHTML2);
          }
          case SVG_MODE: {
            writeChunk(destination, startSegmentSVG);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentSVG2);
          }
          case MATHML_MODE: {
            writeChunk(destination, startSegmentMathML);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentMathML2);
          }
          case HTML_TABLE_MODE: {
            writeChunk(destination, startSegmentTable);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTable2);
          }
          case HTML_TABLE_BODY_MODE: {
            writeChunk(destination, startSegmentTableBody);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTableBody2);
          }
          case HTML_TABLE_ROW_MODE: {
            writeChunk(destination, startSegmentTableRow);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTableRow2);
          }
          case HTML_COLGROUP_MODE: {
            writeChunk(destination, startSegmentColGroup);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentColGroup2);
          }
          default: {
            throw new Error("Unknown insertion mode. This is a bug in React.");
          }
        }
      }
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            return writeChunkAndReturn(destination, endSegmentHTML);
          }
          case SVG_MODE: {
            return writeChunkAndReturn(destination, endSegmentSVG);
          }
          case MATHML_MODE: {
            return writeChunkAndReturn(destination, endSegmentMathML);
          }
          case HTML_TABLE_MODE: {
            return writeChunkAndReturn(destination, endSegmentTable);
          }
          case HTML_TABLE_BODY_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableBody);
          }
          case HTML_TABLE_ROW_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableRow);
          }
          case HTML_COLGROUP_MODE: {
            return writeChunkAndReturn(destination, endSegmentColGroup);
          }
          default: {
            throw new Error("Unknown insertion mode. This is a bug in React.");
          }
        }
      }
      var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
      var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
      var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
      var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
      var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
      var completeSegmentScript2 = stringToPrecomputedChunk('","');
      var completeSegmentScript3 = stringToPrecomputedChunk('")</script>');
      function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteSegmentFunction) {
          responseState.sentCompleteSegmentFunction = true;
          writeChunk(destination, completeSegmentScript1Full);
        } else {
          writeChunk(destination, completeSegmentScript1Partial);
        }
        writeChunk(destination, responseState.segmentPrefix);
        var formattedID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, formattedID);
        writeChunk(destination, completeSegmentScript2);
        writeChunk(destination, responseState.placeholderPrefix);
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, completeSegmentScript3);
      }
      var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
      var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
      var completeBoundaryScript2 = stringToPrecomputedChunk('","');
      var completeBoundaryScript3 = stringToPrecomputedChunk('")</script>');
      function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteBoundaryFunction) {
          responseState.sentCompleteBoundaryFunction = true;
          writeChunk(destination, completeBoundaryScript1Full);
        } else {
          writeChunk(destination, completeBoundaryScript1Partial);
        }
        if (boundaryID === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        var formattedContentID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, boundaryID);
        writeChunk(destination, completeBoundaryScript2);
        writeChunk(destination, responseState.segmentPrefix);
        writeChunk(destination, formattedContentID);
        return writeChunkAndReturn(destination, completeBoundaryScript3);
      }
      var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
      var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
      var clientRenderScript1A = stringToPrecomputedChunk('"');
      var clientRenderScript2 = stringToPrecomputedChunk(")</script>");
      var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
      function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentClientRenderFunction) {
          responseState.sentClientRenderFunction = true;
          writeChunk(destination, clientRenderScript1Full);
        } else {
          writeChunk(destination, clientRenderScript1Partial);
        }
        if (boundaryID === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        writeChunk(destination, boundaryID);
        writeChunk(destination, clientRenderScript1A);
        if (errorDigest || errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
        }
        if (errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
        }
        if (errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
        }
        return writeChunkAndReturn(destination, clientRenderScript2);
      }
      var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
      function escapeJSStringsForInstructionScripts(input) {
        var escaped = JSON.stringify(input);
        return escaped.replace(regexForJSStringsInScripts, function(match) {
          switch (match) {
            case "<":
              return "\\u003c";
            case "\u2028":
              return "\\u2028";
            case "\u2029":
              return "\\u2029";
            default: {
              throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
            }
          }
        });
      }
      function createResponseState$1(generateStaticMarkup, identifierPrefix) {
        var responseState = createResponseState(identifierPrefix, undefined);
        return {
          bootstrapChunks: responseState.bootstrapChunks,
          startInlineScript: responseState.startInlineScript,
          placeholderPrefix: responseState.placeholderPrefix,
          segmentPrefix: responseState.segmentPrefix,
          boundaryPrefix: responseState.boundaryPrefix,
          idPrefix: responseState.idPrefix,
          nextSuspenseID: responseState.nextSuspenseID,
          sentCompleteSegmentFunction: responseState.sentCompleteSegmentFunction,
          sentCompleteBoundaryFunction: responseState.sentCompleteBoundaryFunction,
          sentClientRenderFunction: responseState.sentClientRenderFunction,
          generateStaticMarkup
        };
      }
      function createRootFormatContext() {
        return {
          insertionMode: HTML_MODE,
          selectedValue: null
        };
      }
      function pushTextInstance$1(target, text2, responseState, textEmbedded) {
        if (responseState.generateStaticMarkup) {
          target.push(stringToChunk(escapeTextForBrowser(text2)));
          return false;
        } else {
          return pushTextInstance(target, text2, responseState, textEmbedded);
        }
      }
      function pushSegmentFinale$1(target, responseState, lastPushedText, textEmbedded) {
        if (responseState.generateStaticMarkup) {
          return;
        } else {
          return pushSegmentFinale(target, responseState, lastPushedText, textEmbedded);
        }
      }
      function writeStartCompletedSuspenseBoundary$1(destination, responseState) {
        if (responseState.generateStaticMarkup) {
          return true;
        }
        return writeStartCompletedSuspenseBoundary(destination);
      }
      function writeStartClientRenderedSuspenseBoundary$1(destination, responseState, errorDigest, errorMessage, errorComponentStack) {
        if (responseState.generateStaticMarkup) {
          return true;
        }
        return writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMessage, errorComponentStack);
      }
      function writeEndCompletedSuspenseBoundary$1(destination, responseState) {
        if (responseState.generateStaticMarkup) {
          return true;
        }
        return writeEndCompletedSuspenseBoundary(destination);
      }
      function writeEndClientRenderedSuspenseBoundary$1(destination, responseState) {
        if (responseState.generateStaticMarkup) {
          return true;
        }
        return writeEndClientRenderedSuspenseBoundary(destination);
      }
      var assign = Object.assign;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_SCOPE_TYPE = Symbol.for("react.scope");
      var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
      var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
      var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). " + "This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return getComponentNameFromType(init2(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. " + "This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name2, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name2;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn3, construct) {
        if (!fn3 || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn3);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn3, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn3.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn3();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s2 = sampleLines.length - 1;
            var c2 = controlLines.length - 1;
            while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {
              c2--;
            }
            for (;s2 >= 1 && c2 >= 0; s2--, c2--) {
              if (sampleLines[s2] !== controlLines[c2]) {
                if (s2 !== 1 || c2 !== 1) {
                  do {
                    s2--;
                    c2--;
                    if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {
                      var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                      if (fn3.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn3.displayName);
                      }
                      {
                        if (typeof fn3 === "function") {
                          componentFrameCache.set(fn3, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s2 >= 1 && c2 >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name2 = fn3 ? fn3.displayName || fn3.name : "";
        var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
        {
          if (typeof fn3 === "function") {
            componentFrameCache.set(fn3, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        {
          return describeNativeComponentFrame(ctor, true);
        }
      }
      function describeFunctionComponentFrame(fn3, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn3, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values2, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; " + "it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`." + "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s" + " `%s` is invalid; the type checker " + "function must return `null` or an `Error` but returned a %s. " + "You may have forgotten to pass an argument to the type checker " + "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " + "shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var warnedAboutMissingGetChildContext;
      {
        warnedAboutMissingGetChildContext = {};
      }
      var emptyContextObject = {};
      {
        Object.freeze(emptyContextObject);
      }
      function getMaskedContext(type, unmaskedContext) {
        {
          var contextTypes = type.contextTypes;
          if (!contextTypes) {
            return emptyContextObject;
          }
          var context = {};
          for (var key in contextTypes) {
            context[key] = unmaskedContext[key];
          }
          {
            var name2 = getComponentNameFromType(type) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name2);
          }
          return context;
        }
      }
      function processChildContext(instance, type, parentContext, childContextTypes) {
        {
          if (typeof instance.getChildContext !== "function") {
            {
              var componentName = getComponentNameFromType(type) || "Unknown";
              if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true;
                error("%s.childContextTypes is specified but there is no getChildContext() method " + "on the instance. You can either define getChildContext() on %s or remove " + "childContextTypes from it.", componentName, componentName);
              }
            }
            return parentContext;
          }
          var childContext = instance.getChildContext();
          for (var contextKey in childContext) {
            if (!(contextKey in childContextTypes)) {
              throw new Error((getComponentNameFromType(type) || "Unknown") + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes.");
            }
          }
          {
            var name2 = getComponentNameFromType(type) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name2);
          }
          return assign({}, parentContext, childContext);
        }
      }
      var rendererSigil;
      {
        rendererSigil = {};
      }
      var rootContextSnapshot = null;
      var currentActiveSnapshot = null;
      function popNode(prev) {
        {
          prev.context._currentValue2 = prev.parentValue;
        }
      }
      function pushNode(next) {
        {
          next.context._currentValue2 = next.value;
        }
      }
      function popToNearestCommonAncestor(prev, next) {
        if (prev === next)
          ;
        else {
          popNode(prev);
          var parentPrev = prev.parent;
          var parentNext = next.parent;
          if (parentPrev === null) {
            if (parentNext !== null) {
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            }
          } else {
            if (parentNext === null) {
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            }
            popToNearestCommonAncestor(parentPrev, parentNext);
          }
          pushNode(next);
        }
      }
      function popAllPrevious(prev) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev !== null) {
          popAllPrevious(parentPrev);
        }
      }
      function pushAllNext(next) {
        var parentNext = next.parent;
        if (parentNext !== null) {
          pushAllNext(parentNext);
        }
        pushNode(next);
      }
      function popPreviousToCommonLevel(prev, next) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev === null) {
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        }
        if (parentPrev.depth === next.depth) {
          popToNearestCommonAncestor(parentPrev, next);
        } else {
          popPreviousToCommonLevel(parentPrev, next);
        }
      }
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (parentNext === null) {
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        }
        if (prev.depth === parentNext.depth) {
          popToNearestCommonAncestor(prev, parentNext);
        } else {
          popNextToCommonLevel(prev, parentNext);
        }
        pushNode(next);
      }
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot;
        var next = newSnapshot;
        if (prev !== next) {
          if (prev === null) {
            pushAllNext(next);
          } else if (next === null) {
            popAllPrevious(prev);
          } else if (prev.depth === next.depth) {
            popToNearestCommonAncestor(prev, next);
          } else if (prev.depth > next.depth) {
            popPreviousToCommonLevel(prev, next);
          } else {
            popNextToCommonLevel(prev, next);
          }
          currentActiveSnapshot = next;
        }
      }
      function pushProvider(context, nextValue) {
        var prevValue;
        {
          prevValue = context._currentValue2;
          context._currentValue2 = nextValue;
          {
            if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
              error("Detected multiple renderers concurrently rendering the " + "same context provider. This is currently unsupported.");
            }
            context._currentRenderer2 = rendererSigil;
          }
        }
        var prevNode = currentActiveSnapshot;
        var newNode = {
          parent: prevNode,
          depth: prevNode === null ? 0 : prevNode.depth + 1,
          context,
          parentValue: prevValue,
          value: nextValue
        };
        currentActiveSnapshot = newNode;
        return newNode;
      }
      function popProvider(context) {
        var prevSnapshot = currentActiveSnapshot;
        if (prevSnapshot === null) {
          throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
        }
        {
          if (prevSnapshot.context !== context) {
            error("The parent context is not the expected context. This is probably a bug in React.");
          }
        }
        {
          var _value = prevSnapshot.parentValue;
          if (_value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
            prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue;
          } else {
            prevSnapshot.context._currentValue2 = _value;
          }
          {
            if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
              error("Detected multiple renderers concurrently rendering the " + "same context provider. This is currently unsupported.");
            }
            context._currentRenderer2 = rendererSigil;
          }
        }
        return currentActiveSnapshot = prevSnapshot.parent;
      }
      function getActiveContext() {
        return currentActiveSnapshot;
      }
      function readContext(context) {
        var value = context._currentValue2;
        return value;
      }
      function get2(key) {
        return key._reactInternals;
      }
      function set(key, value) {
        key._reactInternals = value;
      }
      var didWarnAboutNoopUpdateForComponent = {};
      var didWarnAboutDeprecatedWillMount = {};
      var didWarnAboutUninitializedState;
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
      var didWarnAboutLegacyLifecyclesAndDerivedState;
      var didWarnAboutUndefinedDerivedState;
      var warnOnUndefinedDerivedState;
      var warnOnInvalidCallback;
      var didWarnAboutDirectlyAssigningPropsToState;
      var didWarnAboutContextTypeAndContextTypes;
      var didWarnAboutInvalidateContextType;
      {
        didWarnAboutUninitializedState = new Set;
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set;
        didWarnAboutLegacyLifecyclesAndDerivedState = new Set;
        didWarnAboutDirectlyAssigningPropsToState = new Set;
        didWarnAboutUndefinedDerivedState = new Set;
        didWarnAboutContextTypeAndContextTypes = new Set;
        didWarnAboutInvalidateContextType = new Set;
        var didWarnOnInvalidCallback = new Set;
        warnOnInvalidCallback = function(callback, callerName) {
          if (callback === null || typeof callback === "function") {
            return;
          }
          var key = callerName + "_" + callback;
          if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            error("%s(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callerName, callback);
          }
        };
        warnOnUndefinedDerivedState = function(type, partialState) {
          if (partialState === undefined) {
            var componentName = getComponentNameFromType(type) || "Component";
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName);
              error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. " + "You have returned undefined.", componentName);
            }
          }
        };
      }
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor;
          var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
          var warningKey = componentName + "." + callerName;
          if (didWarnAboutNoopUpdateForComponent[warningKey]) {
            return;
          }
          error("%s(...): Can only update a mounting component. " + "This usually means you called %s() outside componentWillMount() on the server. " + "This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
          didWarnAboutNoopUpdateForComponent[warningKey] = true;
        }
      }
      var classComponentUpdater = {
        isMounted: function(inst) {
          return false;
        },
        enqueueSetState: function(inst, payload, callback) {
          var internals = get2(inst);
          if (internals.queue === null) {
            warnNoop(inst, "setState");
          } else {
            internals.queue.push(payload);
            {
              if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          }
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var internals = get2(inst);
          internals.replace = true;
          internals.queue = [payload];
          {
            if (callback !== undefined && callback !== null) {
              warnOnInvalidCallback(callback, "setState");
            }
          }
        },
        enqueueForceUpdate: function(inst, callback) {
          var internals = get2(inst);
          if (internals.queue === null) {
            warnNoop(inst, "forceUpdate");
          } else {
            {
              if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          }
        }
      };
      function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        {
          warnOnUndefinedDerivedState(ctor, partialState);
        }
        var newState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);
        return newState;
      }
      function constructClassInstance(ctor, props, maskedLegacyContext) {
        var context = emptyContextObject;
        var contextType = ctor.contextType;
        {
          if ("contextType" in ctor) {
            var isValid2 = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined;
            if (!isValid2 && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor);
              var addendum = "";
              if (contextType === undefined) {
                addendum = " However, it is set to undefined. " + "This can be caused by a typo or by mixing up named and default imports. " + "This can also happen due to a circular dependency, so " + "try moving the createContext() call to a separate file.";
              } else if (typeof contextType !== "object") {
                addendum = " However, it is set to a " + typeof contextType + ".";
              } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                addendum = " Did you accidentally pass the Context.Provider instead?";
              } else if (contextType._context !== undefined) {
                addendum = " Did you accidentally pass the Context.Consumer instead?";
              } else {
                addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              }
              error("%s defines an invalid contextType. " + "contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
            }
          }
        }
        if (typeof contextType === "object" && contextType !== null) {
          context = readContext(contextType);
        } else {
          context = maskedLegacyContext;
        }
        var instance = new ctor(props, context);
        {
          if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === undefined)) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName);
              error("`%s` uses `getDerivedStateFromProps` but its initial state is " + "%s. This is not recommended. Instead, define the initial state by " + "assigning an object to `this.state` in the constructor of `%s`. " + "This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
            }
          }
          if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;
            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
              foundWillMountName = "componentWillMount";
            } else if (typeof instance.UNSAFE_componentWillMount === "function") {
              foundWillMountName = "UNSAFE_componentWillMount";
            }
            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              foundWillReceivePropsName = "componentWillReceiveProps";
            } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
            }
            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              foundWillUpdateName = "componentWillUpdate";
            } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              foundWillUpdateName = "UNSAFE_componentWillUpdate";
            }
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType(ctor) || "Component";
              var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + "%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n" + "The above lifecycles should be removed. Learn more about this warning here:\n" + "https://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
              }
            }
          }
        }
        return instance;
      }
      function checkClassInstance(instance, ctor, newProps) {
        {
          var name2 = getComponentNameFromType(ctor) || "Component";
          var renderPresent = instance.render;
          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === "function") {
              error("%s(...): No `render` method found on the returned component " + "instance: did you accidentally return an object from the constructor?", name2);
            } else {
              error("%s(...): No `render` method found on the returned component " + "instance: you may have forgotten to define `render`.", name2);
            }
          }
          if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
            error("getInitialState was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Did you mean to define a state property instead?", name2);
          }
          if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Use a static property to define defaultProps instead.", name2);
          }
          if (instance.propTypes) {
            error("propTypes was defined as an instance property on %s. Use a static " + "property to define propTypes instead.", name2);
          }
          if (instance.contextType) {
            error("contextType was defined as an instance property on %s. Use a static " + "property to define contextType instead.", name2);
          }
          {
            if (instance.contextTypes) {
              error("contextTypes was defined as an instance property on %s. Use a static " + "property to define contextTypes instead.", name2);
            }
            if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
              didWarnAboutContextTypeAndContextTypes.add(ctor);
              error("%s declares both contextTypes and contextType static properties. " + "The legacy contextTypes property will be ignored.", name2);
            }
          }
          if (typeof instance.componentShouldUpdate === "function") {
            error("%s has a method called " + "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " + "The name is phrased as a question because the function is " + "expected to return a value.", name2);
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
            error("%s has a method called shouldComponentUpdate(). " + "shouldComponentUpdate should not be used when extending React.PureComponent. " + "Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
          }
          if (typeof instance.componentDidUnmount === "function") {
            error("%s has a method called " + "componentDidUnmount(). But there is no such lifecycle method. " + "Did you mean componentWillUnmount()?", name2);
          }
          if (typeof instance.componentDidReceiveProps === "function") {
            error("%s has a method called " + "componentDidReceiveProps(). But there is no such lifecycle method. " + "If you meant to update the state in response to changing props, " + "use componentWillReceiveProps(). If you meant to fetch data or " + "run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name2);
          }
          if (typeof instance.componentWillRecieveProps === "function") {
            error("%s has a method called " + "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name2);
          }
          if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
            error("%s has a method called " + "UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name2);
          }
          var hasMutatedProps = instance.props !== newProps;
          if (instance.props !== undefined && hasMutatedProps) {
            error("%s(...): When calling super() in `%s`, make sure to pass " + "up the same props that your component's constructor was passed.", name2, name2);
          }
          if (instance.defaultProps) {
            error("Setting defaultProps as an instance property on %s is not supported and will be ignored." + " Instead, define defaultProps as a static property on %s.", name2, name2);
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). " + "This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
          }
          if (typeof instance.getDerivedStateFromProps === "function") {
            error("%s: getDerivedStateFromProps() is defined as an instance method " + "and will be ignored. Instead, declare it as a static method.", name2);
          }
          if (typeof instance.getDerivedStateFromError === "function") {
            error("%s: getDerivedStateFromError() is defined as an instance method " + "and will be ignored. Instead, declare it as a static method.", name2);
          }
          if (typeof ctor.getSnapshotBeforeUpdate === "function") {
            error("%s: getSnapshotBeforeUpdate() is defined as a static method " + "and will be ignored. Instead, declare it as an instance method.", name2);
          }
          var _state = instance.state;
          if (_state && (typeof _state !== "object" || isArray(_state))) {
            error("%s.state: must be set to an object or null", name2);
          }
          if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
            error("%s.getChildContext(): childContextTypes must be defined in order to " + "use getChildContext().", name2);
          }
        }
      }
      function callComponentWillMount(type, instance) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount === "function") {
          {
            if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
              var componentName = getComponentNameFromType(type) || "Unknown";
              if (!didWarnAboutDeprecatedWillMount[componentName]) {
                warn("componentWillMount has been renamed, and is not recommended for use. " + "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" + "* Move code from componentWillMount to componentDidMount (preferred in most cases) " + "or the constructor.\n" + "\nPlease update the following components: %s", componentName);
                didWarnAboutDeprecatedWillMount[componentName] = true;
              }
            }
          }
          instance.componentWillMount();
        }
        if (typeof instance.UNSAFE_componentWillMount === "function") {
          instance.UNSAFE_componentWillMount();
        }
        if (oldState !== instance.state) {
          {
            error("%s.componentWillMount(): Assigning directly to this.state is " + "deprecated (except inside a component's " + "constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }
      function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
        if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
          var oldQueue = internalInstance.queue;
          var oldReplace = internalInstance.replace;
          internalInstance.queue = null;
          internalInstance.replace = false;
          if (oldReplace && oldQueue.length === 1) {
            inst.state = oldQueue[0];
          } else {
            var nextState = oldReplace ? oldQueue[0] : inst.state;
            var dontMutate = true;
            for (var i = oldReplace ? 1 : 0;i < oldQueue.length; i++) {
              var partial = oldQueue[i];
              var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
              if (partialState != null) {
                if (dontMutate) {
                  dontMutate = false;
                  nextState = assign({}, nextState, partialState);
                } else {
                  assign(nextState, partialState);
                }
              }
            }
            inst.state = nextState;
          }
        } else {
          internalInstance.queue = null;
        }
      }
      function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
        {
          checkClassInstance(instance, ctor, newProps);
        }
        var initialState = instance.state !== undefined ? instance.state : null;
        instance.updater = classComponentUpdater;
        instance.props = newProps;
        instance.state = initialState;
        var internalInstance = {
          queue: [],
          replace: false
        };
        set(instance, internalInstance);
        var contextType = ctor.contextType;
        if (typeof contextType === "object" && contextType !== null) {
          instance.context = readContext(contextType);
        } else {
          instance.context = maskedLegacyContext;
        }
        {
          if (instance.state === newProps) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName);
              error("%s: It is not recommended to assign props directly to state " + "because updates to props won't be reflected in state. " + "In most cases, it is better to use props directly.", componentName);
            }
          }
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === "function") {
          instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
        }
        if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
          callComponentWillMount(ctor, instance);
          processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
        }
      }
      var emptyTreeContext = {
        id: 1,
        overflow: ""
      };
      function getTreeId(context) {
        var overflow = context.overflow;
        var idWithLeadingBit = context.id;
        var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id.toString(32) + overflow;
      }
      function pushTreeContext(baseContext, totalChildren, index2) {
        var baseIdWithLeadingBit = baseContext.id;
        var baseOverflow = baseContext.overflow;
        var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
        var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
        var slot = index2 + 1;
        var length = getBitLength(totalChildren) + baseLength;
        if (length > 30) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          var newOverflowBits = (1 << numberOfOverflowBits) - 1;
          var newOverflow = (baseId & newOverflowBits).toString(32);
          var restOfBaseId = baseId >> numberOfOverflowBits;
          var restOfBaseLength = baseLength - numberOfOverflowBits;
          var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
          var restOfNewBits = slot << restOfBaseLength;
          var id = restOfNewBits | restOfBaseId;
          var overflow = newOverflow + baseOverflow;
          return {
            id: 1 << restOfLength | id,
            overflow
          };
        } else {
          var newBits = slot << baseLength;
          var _id = newBits | baseId;
          var _overflow = baseOverflow;
          return {
            id: 1 << length | _id,
            overflow: _overflow
          };
        }
      }
      function getBitLength(number) {
        return 32 - clz32(number);
      }
      function getLeadingBit(id) {
        return 1 << getBitLength(id) - 1;
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x) {
        var asUint = x >>> 0;
        if (asUint === 0) {
          return 32;
        }
        return 31 - (log(asUint) / LN2 | 0) | 0;
      }
      function is3(x, y2) {
        return x === y2 && (x !== 0 || 1 / x === 1 / y2) || x !== x && y2 !== y2;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is3;
      var currentlyRenderingComponent = null;
      var currentlyRenderingTask = null;
      var firstWorkInProgressHook = null;
      var workInProgressHook = null;
      var isReRender = false;
      var didScheduleRenderPhaseUpdate = false;
      var localIdCounter = 0;
      var renderPhaseUpdates = null;
      var numberOfReRenders = 0;
      var RE_RENDER_LIMIT = 25;
      var isInHookUserCodeInDev = false;
      var currentHookNameInDev;
      function resolveCurrentlyRenderingComponent() {
        if (currentlyRenderingComponent === null) {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for" + " one of the following reasons:\n" + "1. You might have mismatching versions of React and the renderer (such as React DOM)\n" + "2. You might be breaking the Rules of Hooks\n" + "3. You might have more than one copy of React in the same app\n" + "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        }
        {
          if (isInHookUserCodeInDev) {
            error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. " + "You can only call Hooks at the top level of your React function. " + "For more information, see " + "https://reactjs.org/link/rules-of-hooks");
          }
        }
        return currentlyRenderingComponent;
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null) {
          {
            error("%s received a final argument during this render, but not during " + "the previous render. Even though the final argument is optional, " + "its type cannot change between renders.", currentHookNameInDev);
          }
          return false;
        }
        {
          if (nextDeps.length !== prevDeps.length) {
            error("The final argument passed to %s changed size between renders. The " + "order and size of this array must remain constant.\n\n" + "Previous: %s\n" + "Incoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
          }
        }
        for (var i = 0;i < prevDeps.length && i < nextDeps.length; i++) {
          if (objectIs(nextDeps[i], prevDeps[i])) {
            continue;
          }
          return false;
        }
        return true;
      }
      function createHook() {
        if (numberOfReRenders > 0) {
          throw new Error("Rendered more hooks than during the previous render");
        }
        return {
          memoizedState: null,
          queue: null,
          next: null
        };
      }
      function createWorkInProgressHook() {
        if (workInProgressHook === null) {
          if (firstWorkInProgressHook === null) {
            isReRender = false;
            firstWorkInProgressHook = workInProgressHook = createHook();
          } else {
            isReRender = true;
            workInProgressHook = firstWorkInProgressHook;
          }
        } else {
          if (workInProgressHook.next === null) {
            isReRender = false;
            workInProgressHook = workInProgressHook.next = createHook();
          } else {
            isReRender = true;
            workInProgressHook = workInProgressHook.next;
          }
        }
        return workInProgressHook;
      }
      function prepareToUseHooks(task, componentIdentity) {
        currentlyRenderingComponent = componentIdentity;
        currentlyRenderingTask = task;
        {
          isInHookUserCodeInDev = false;
        }
        localIdCounter = 0;
      }
      function finishHooks(Component, props, children, refOrContext) {
        while (didScheduleRenderPhaseUpdate) {
          didScheduleRenderPhaseUpdate = false;
          localIdCounter = 0;
          numberOfReRenders += 1;
          workInProgressHook = null;
          children = Component(props, refOrContext);
        }
        resetHooksState();
        return children;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0;
        return didRenderIdHook;
      }
      function resetHooksState() {
        {
          isInHookUserCodeInDev = false;
        }
        currentlyRenderingComponent = null;
        currentlyRenderingTask = null;
        didScheduleRenderPhaseUpdate = false;
        firstWorkInProgressHook = null;
        numberOfReRenders = 0;
        renderPhaseUpdates = null;
        workInProgressHook = null;
      }
      function readContext$1(context) {
        {
          if (isInHookUserCodeInDev) {
            error("Context can only be read while React is rendering. " + "In classes, you can read it in the render method or getDerivedStateFromProps. " + "In function components, you can read it directly in the function body, but not " + "inside Hooks like useReducer() or useMemo().");
          }
        }
        return readContext(context);
      }
      function useContext(context) {
        {
          currentHookNameInDev = "useContext";
        }
        resolveCurrentlyRenderingComponent();
        return readContext(context);
      }
      function basicStateReducer(state, action) {
        return typeof action === "function" ? action(state) : action;
      }
      function useState(initialState) {
        {
          currentHookNameInDev = "useState";
        }
        return useReducer(basicStateReducer, initialState);
      }
      function useReducer(reducer, initialArg, init2) {
        {
          if (reducer !== basicStateReducer) {
            currentHookNameInDev = "useReducer";
          }
        }
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        if (isReRender) {
          var queue3 = workInProgressHook.queue;
          var dispatch = queue3.dispatch;
          if (renderPhaseUpdates !== null) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue3);
            if (firstRenderPhaseUpdate !== undefined) {
              renderPhaseUpdates.delete(queue3);
              var newState = workInProgressHook.memoizedState;
              var update = firstRenderPhaseUpdate;
              do {
                var action = update.action;
                {
                  isInHookUserCodeInDev = true;
                }
                newState = reducer(newState, action);
                {
                  isInHookUserCodeInDev = false;
                }
                update = update.next;
              } while (update !== null);
              workInProgressHook.memoizedState = newState;
              return [newState, dispatch];
            }
          }
          return [workInProgressHook.memoizedState, dispatch];
        } else {
          {
            isInHookUserCodeInDev = true;
          }
          var initialState;
          if (reducer === basicStateReducer) {
            initialState = typeof initialArg === "function" ? initialArg() : initialArg;
          } else {
            initialState = init2 !== undefined ? init2(initialArg) : initialArg;
          }
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = initialState;
          var _queue = workInProgressHook.queue = {
            last: null,
            dispatch: null
          };
          var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
          return [workInProgressHook.memoizedState, _dispatch];
        }
      }
      function useMemo(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        if (workInProgressHook !== null) {
          var prevState = workInProgressHook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
        }
        {
          isInHookUserCodeInDev = true;
        }
        var nextValue = nextCreate();
        {
          isInHookUserCodeInDev = false;
        }
        workInProgressHook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }
      function useRef(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var previousRef = workInProgressHook.memoizedState;
        if (previousRef === null) {
          var ref = {
            current: initialValue
          };
          {
            Object.seal(ref);
          }
          workInProgressHook.memoizedState = ref;
          return ref;
        } else {
          return previousRef;
        }
      }
      function useLayoutEffect(create, inputs) {
        {
          currentHookNameInDev = "useLayoutEffect";
          error("useLayoutEffect does nothing on the server, because its effect cannot " + "be encoded into the server renderer's output format. This will lead " + "to a mismatch between the initial, non-hydrated UI and the intended " + "UI. To avoid this, useLayoutEffect should only be used in " + "components that render exclusively on the client. " + "See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
        }
      }
      function dispatchAction(componentIdentity, queue3, action) {
        if (numberOfReRenders >= RE_RENDER_LIMIT) {
          throw new Error("Too many re-renders. React limits the number of renders to prevent " + "an infinite loop.");
        }
        if (componentIdentity === currentlyRenderingComponent) {
          didScheduleRenderPhaseUpdate = true;
          var update = {
            action,
            next: null
          };
          if (renderPhaseUpdates === null) {
            renderPhaseUpdates = new Map;
          }
          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue3);
          if (firstRenderPhaseUpdate === undefined) {
            renderPhaseUpdates.set(queue3, update);
          } else {
            var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
            while (lastRenderPhaseUpdate.next !== null) {
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            }
            lastRenderPhaseUpdate.next = update;
          }
        }
      }
      function useCallback(callback, deps) {
        return useMemo(function() {
          return callback;
        }, deps);
      }
      function useMutableSource(source, getSnapshot, subscribe2) {
        resolveCurrentlyRenderingComponent();
        return getSnapshot(source._source);
      }
      function useSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === undefined) {
          throw new Error("Missing getServerSnapshot, which is required for " + "server-rendered content. Will revert to client rendering.");
        }
        return getServerSnapshot();
      }
      function useDeferredValue(value) {
        resolveCurrentlyRenderingComponent();
        return value;
      }
      function unsupportedStartTransition() {
        throw new Error("startTransition cannot be called during server rendering.");
      }
      function useTransition() {
        resolveCurrentlyRenderingComponent();
        return [false, unsupportedStartTransition];
      }
      function useId() {
        var task = currentlyRenderingTask;
        var treeId = getTreeId(task.treeContext);
        var responseState = currentResponseState;
        if (responseState === null) {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
        }
        var localId = localIdCounter++;
        return makeId(responseState, treeId, localId);
      }
      function noop3() {
      }
      var Dispatcher = {
        readContext: readContext$1,
        useContext,
        useMemo,
        useReducer,
        useRef,
        useState,
        useInsertionEffect: noop3,
        useLayoutEffect,
        useCallback,
        useImperativeHandle: noop3,
        useEffect: noop3,
        useDebugValue: noop3,
        useDeferredValue,
        useTransition,
        useId,
        useMutableSource,
        useSyncExternalStore
      };
      var currentResponseState = null;
      function setCurrentResponseState(responseState) {
        currentResponseState = responseState;
      }
      function getStackByComponentStackNode(componentStack) {
        try {
          var info = "";
          var node3 = componentStack;
          do {
            switch (node3.tag) {
              case 0:
                info += describeBuiltInComponentFrame(node3.type, null, null);
                break;
              case 1:
                info += describeFunctionComponentFrame(node3.type, null, null);
                break;
              case 2:
                info += describeClassComponentFrame(node3.type, null, null);
                break;
            }
            node3 = node3.parent;
          } while (node3);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      var PENDING = 0;
      var COMPLETED = 1;
      var FLUSHED = 2;
      var ABORTED = 3;
      var ERRORED = 4;
      var OPEN = 0;
      var CLOSING = 1;
      var CLOSED = 2;
      var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
      function defaultErrorHandler(error2) {
        console["error"](error2);
        return null;
      }
      function noop$1() {
      }
      function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError) {
        var pingedTasks = [];
        var abortSet = new Set;
        var request = {
          destination: null,
          responseState,
          progressiveChunkSize: progressiveChunkSize === undefined ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
          status: OPEN,
          fatalError: null,
          nextSegmentId: 0,
          allPendingTasks: 0,
          pendingRootTasks: 0,
          completedRootSegment: null,
          abortableTasks: abortSet,
          pingedTasks,
          clientRenderedBoundaries: [],
          completedBoundaries: [],
          partialBoundaries: [],
          onError: onError2 === undefined ? defaultErrorHandler : onError2,
          onAllReady: onAllReady === undefined ? noop$1 : onAllReady,
          onShellReady: onShellReady === undefined ? noop$1 : onShellReady,
          onShellError: onShellError === undefined ? noop$1 : onShellError,
          onFatalError: onFatalError === undefined ? noop$1 : onFatalError
        };
        var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false);
        rootSegment.parentFlushed = true;
        var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
        pingedTasks.push(rootTask);
        return request;
      }
      function pingTask(request, task) {
        var pingedTasks = request.pingedTasks;
        pingedTasks.push(task);
        if (pingedTasks.length === 1) {
          scheduleWork(function() {
            return performWork(request);
          });
        }
      }
      function createSuspenseBoundary(request, fallbackAbortableTasks) {
        return {
          id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
          rootSegmentID: -1,
          parentFlushed: false,
          pendingTasks: 0,
          forceClientRender: false,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null
        };
      }
      function createTask(request, node3, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
        request.allPendingTasks++;
        if (blockedBoundary === null) {
          request.pendingRootTasks++;
        } else {
          blockedBoundary.pendingTasks++;
        }
        var task = {
          node: node3,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment,
          abortSet,
          legacyContext,
          context,
          treeContext
        };
        {
          task.componentStack = null;
        }
        abortSet.add(task);
        return task;
      }
      function createPendingSegment(request, index2, boundary, formatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          id: -1,
          index: index2,
          parentFlushed: false,
          chunks: [],
          children: [],
          formatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      var currentTaskInDEV = null;
      function getCurrentStackInDEV() {
        {
          if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
            return "";
          }
          return getStackByComponentStackNode(currentTaskInDEV.componentStack);
        }
      }
      function pushBuiltInComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 0,
            parent: task.componentStack,
            type
          };
        }
      }
      function pushFunctionComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 1,
            parent: task.componentStack,
            type
          };
        }
      }
      function pushClassComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 2,
            parent: task.componentStack,
            type
          };
        }
      }
      function popComponentStackInDEV(task) {
        {
          if (task.componentStack === null) {
            error("Unexpectedly popped too many stack frames. This is a bug in React.");
          } else {
            task.componentStack = task.componentStack.parent;
          }
        }
      }
      var lastBoundaryErrorComponentStackDev = null;
      function captureBoundaryErrorDetailsDev(boundary, error2) {
        {
          var errorMessage;
          if (typeof error2 === "string") {
            errorMessage = error2;
          } else if (error2 && typeof error2.message === "string") {
            errorMessage = error2.message;
          } else {
            errorMessage = String(error2);
          }
          var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
          lastBoundaryErrorComponentStackDev = null;
          boundary.errorMessage = errorMessage;
          boundary.errorComponentStack = errorComponentStack;
        }
      }
      function logRecoverableError(request, error2) {
        var errorDigest = request.onError(error2);
        if (errorDigest != null && typeof errorDigest !== "string") {
          throw new Error("onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"" + typeof errorDigest + "\" instead");
        }
        return errorDigest;
      }
      function fatalError(request, error2) {
        var onShellError = request.onShellError;
        onShellError(error2);
        var onFatalError = request.onFatalError;
        onFatalError(error2);
        if (request.destination !== null) {
          request.status = CLOSED;
          closeWithError(request.destination, error2);
        } else {
          request.status = CLOSING;
          request.fatalError = error2;
        }
      }
      function renderSuspenseBoundary(request, task, props) {
        pushBuiltInComponentStackInDEV(task, "Suspense");
        var parentBoundary = task.blockedBoundary;
        var parentSegment = task.blockedSegment;
        var fallback = props.fallback;
        var content = props.children;
        var fallbackAbortSet = new Set;
        var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
        var insertionIndex = parentSegment.chunks.length;
        var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, parentSegment.formatContext, false, false);
        parentSegment.children.push(boundarySegment);
        parentSegment.lastPushedText = false;
        var contentRootSegment = createPendingSegment(request, 0, null, parentSegment.formatContext, false, false);
        contentRootSegment.parentFlushed = true;
        task.blockedBoundary = newBoundary;
        task.blockedSegment = contentRootSegment;
        try {
          renderNode2(request, task, content);
          pushSegmentFinale$1(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
          contentRootSegment.status = COMPLETED;
          queueCompletedSegment(newBoundary, contentRootSegment);
          if (newBoundary.pendingTasks === 0) {
            popComponentStackInDEV(task);
            return;
          }
        } catch (error2) {
          contentRootSegment.status = ERRORED;
          newBoundary.forceClientRender = true;
          newBoundary.errorDigest = logRecoverableError(request, error2);
          {
            captureBoundaryErrorDetailsDev(newBoundary, error2);
          }
        } finally {
          task.blockedBoundary = parentBoundary;
          task.blockedSegment = parentSegment;
        }
        var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
        {
          suspendedFallbackTask.componentStack = task.componentStack;
        }
        request.pingedTasks.push(suspendedFallbackTask);
        popComponentStackInDEV(task);
      }
      function renderHostElement(request, task, type, props) {
        pushBuiltInComponentStackInDEV(task, type);
        var segment = task.blockedSegment;
        var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
        segment.lastPushedText = false;
        var prevContext = segment.formatContext;
        segment.formatContext = getChildFormatContext(prevContext, type, props);
        renderNode2(request, task, children);
        segment.formatContext = prevContext;
        pushEndInstance(segment.chunks, type);
        segment.lastPushedText = false;
        popComponentStackInDEV(task);
      }
      function shouldConstruct$1(Component) {
        return Component.prototype && Component.prototype.isReactComponent;
      }
      function renderWithHooks(request, task, Component, props, secondArg) {
        var componentIdentity = {};
        prepareToUseHooks(task, componentIdentity);
        var result2 = Component(props, secondArg);
        return finishHooks(Component, props, result2, secondArg);
      }
      function finishClassComponent(request, task, instance, Component, props) {
        var nextChildren = instance.render();
        {
          if (instance.props !== props) {
            if (!didWarnAboutReassigningProps) {
              error("It looks like %s is reassigning its own `this.props` while rendering. " + "This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
            }
            didWarnAboutReassigningProps = true;
          }
        }
        {
          var childContextTypes = Component.childContextTypes;
          if (childContextTypes !== null && childContextTypes !== undefined) {
            var previousContext = task.legacyContext;
            var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
            task.legacyContext = mergedContext;
            renderNodeDestructive(request, task, nextChildren);
            task.legacyContext = previousContext;
            return;
          }
        }
        renderNodeDestructive(request, task, nextChildren);
      }
      function renderClassComponent(request, task, Component, props) {
        pushClassComponentStackInDEV(task, Component);
        var maskedContext = getMaskedContext(Component, task.legacyContext);
        var instance = constructClassInstance(Component, props, maskedContext);
        mountClassInstance(instance, Component, props, maskedContext);
        finishClassComponent(request, task, instance, Component, props);
        popComponentStackInDEV(task);
      }
      var didWarnAboutBadClass = {};
      var didWarnAboutModulePatternComponent = {};
      var didWarnAboutContextTypeOnFunctionComponent = {};
      var didWarnAboutGetDerivedStateOnFunctionComponent = {};
      var didWarnAboutReassigningProps = false;
      var didWarnAboutGenerators = false;
      var didWarnAboutMaps = false;
      var hasWarnedAboutUsingContextAsConsumer = false;
      function renderIndeterminateComponent(request, task, Component, props) {
        var legacyContext;
        {
          legacyContext = getMaskedContext(Component, task.legacyContext);
        }
        pushFunctionComponentStackInDEV(task, Component);
        {
          if (Component.prototype && typeof Component.prototype.render === "function") {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutBadClass[componentName]) {
              error("The <%s /> component appears to have a render method, but doesn't extend React.Component. " + "This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
              didWarnAboutBadClass[componentName] = true;
            }
          }
        }
        var value = renderWithHooks(request, task, Component, props, legacyContext);
        var hasId = checkDidRenderIdHook();
        {
          if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === undefined) {
            var _componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName]) {
              error("The <%s /> component appears to be a function component that returns a class instance. " + "Change %s to a class that extends React.Component instead. " + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + "cannot be called with `new` by React.", _componentName, _componentName, _componentName);
              didWarnAboutModulePatternComponent[_componentName] = true;
            }
          }
        }
        if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === undefined) {
          {
            var _componentName2 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
              error("The <%s /> component appears to be a function component that returns a class instance. " + "Change %s to a class that extends React.Component instead. " + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + "cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
              didWarnAboutModulePatternComponent[_componentName2] = true;
            }
          }
          mountClassInstance(value, Component, props, legacyContext);
          finishClassComponent(request, task, value, Component, props);
        } else {
          {
            validateFunctionComponentInDev(Component);
          }
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index2 = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index2);
            try {
              renderNodeDestructive(request, task, value);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request, task, value);
          }
        }
        popComponentStackInDEV(task);
      }
      function validateFunctionComponentInDev(Component) {
        {
          if (Component) {
            if (Component.childContextTypes) {
              error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
            }
          }
          if (typeof Component.getDerivedStateFromProps === "function") {
            var _componentName3 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
              error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
            }
          }
          if (typeof Component.contextType === "object" && Component.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
              error("%s: Function components do not support contextType.", _componentName4);
              didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
            }
          }
        }
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = assign({}, baseProps);
          var defaultProps = Component.defaultProps;
          for (var propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
          return props;
        }
        return baseProps;
      }
      function renderForwardRef(request, task, type, props, ref) {
        pushFunctionComponentStackInDEV(task, type.render);
        var children = renderWithHooks(request, task, type.render, props, ref);
        var hasId = checkDidRenderIdHook();
        if (hasId) {
          var prevTreeContext = task.treeContext;
          var totalChildren = 1;
          var index2 = 0;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index2);
          try {
            renderNodeDestructive(request, task, children);
          } finally {
            task.treeContext = prevTreeContext;
          }
        } else {
          renderNodeDestructive(request, task, children);
        }
        popComponentStackInDEV(task);
      }
      function renderMemo(request, task, type, props, ref) {
        var innerType = type.type;
        var resolvedProps = resolveDefaultProps(innerType, props);
        renderElement(request, task, innerType, resolvedProps, ref);
      }
      function renderContextConsumer(request, task, context, props) {
        {
          if (context._context === undefined) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true;
                error("Rendering <Context> directly is not supported and will be removed in " + "a future major release. Did you mean to render <Context.Consumer> instead?");
              }
            }
          } else {
            context = context._context;
          }
        }
        var render2 = props.children;
        {
          if (typeof render2 !== "function") {
            error("A context consumer was rendered with multiple children, or a child " + "that isn't a function. A context consumer expects a single child " + "that is a function. If you did pass a function, make sure there " + "is no trailing or leading whitespace around it.");
          }
        }
        var newValue = readContext(context);
        var newChildren = render2(newValue);
        renderNodeDestructive(request, task, newChildren);
      }
      function renderContextProvider(request, task, type, props) {
        var context = type._context;
        var value = props.value;
        var children = props.children;
        var prevSnapshot;
        {
          prevSnapshot = task.context;
        }
        task.context = pushProvider(context, value);
        renderNodeDestructive(request, task, children);
        task.context = popProvider(context);
        {
          if (prevSnapshot !== task.context) {
            error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
          }
        }
      }
      function renderLazyComponent(request, task, lazyComponent, props, ref) {
        pushBuiltInComponentStackInDEV(task, "Lazy");
        var payload = lazyComponent._payload;
        var init2 = lazyComponent._init;
        var Component = init2(payload);
        var resolvedProps = resolveDefaultProps(Component, props);
        renderElement(request, task, Component, resolvedProps, ref);
        popComponentStackInDEV(task);
      }
      function renderElement(request, task, type, props, ref) {
        if (typeof type === "function") {
          if (shouldConstruct$1(type)) {
            renderClassComponent(request, task, type, props);
            return;
          } else {
            renderIndeterminateComponent(request, task, type, props);
            return;
          }
        }
        if (typeof type === "string") {
          renderHostElement(request, task, type, props);
          return;
        }
        switch (type) {
          case REACT_LEGACY_HIDDEN_TYPE:
          case REACT_DEBUG_TRACING_MODE_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_FRAGMENT_TYPE: {
            renderNodeDestructive(request, task, props.children);
            return;
          }
          case REACT_SUSPENSE_LIST_TYPE: {
            pushBuiltInComponentStackInDEV(task, "SuspenseList");
            renderNodeDestructive(request, task, props.children);
            popComponentStackInDEV(task);
            return;
          }
          case REACT_SCOPE_TYPE: {
            throw new Error("ReactDOMServer does not yet support scope components.");
          }
          case REACT_SUSPENSE_TYPE: {
            {
              renderSuspenseBoundary(request, task, props);
            }
            return;
          }
        }
        if (typeof type === "object" && type !== null) {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE: {
              renderForwardRef(request, task, type, props, ref);
              return;
            }
            case REACT_MEMO_TYPE: {
              renderMemo(request, task, type, props, ref);
              return;
            }
            case REACT_PROVIDER_TYPE: {
              renderContextProvider(request, task, type, props);
              return;
            }
            case REACT_CONTEXT_TYPE: {
              renderContextConsumer(request, task, type, props);
              return;
            }
            case REACT_LAZY_TYPE: {
              renderLazyComponent(request, task, type, props);
              return;
            }
          }
        }
        var info = "";
        {
          if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
            info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and " + "named imports.";
          }
        }
        throw new Error("Element type is invalid: expected a string (for built-in " + "components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
      }
      function validateIterable(iterable, iteratorFn) {
        {
          if (typeof Symbol === "function" && iterable[Symbol.toStringTag] === "Generator") {
            if (!didWarnAboutGenerators) {
              error("Using Generators as children is unsupported and will likely yield " + "unexpected results because enumerating a generator mutates it. " + "You may convert it to an array with `Array.from()` or the " + "`[...spread]` operator before rendering. Keep in mind " + "you might need to polyfill these features for older browsers.");
            }
            didWarnAboutGenerators = true;
          }
          if (iterable.entries === iteratorFn) {
            if (!didWarnAboutMaps) {
              error("Using Maps as children is not supported. " + "Use an array of keyed ReactElements instead.");
            }
            didWarnAboutMaps = true;
          }
        }
      }
      function renderNodeDestructive(request, task, node3) {
        {
          try {
            return renderNodeDestructiveImpl(request, task, node3);
          } catch (x) {
            if (typeof x === "object" && x !== null && typeof x.then === "function")
              ;
            else {
              lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
            }
            throw x;
          }
        }
      }
      function renderNodeDestructiveImpl(request, task, node3) {
        task.node = node3;
        if (typeof node3 === "object" && node3 !== null) {
          switch (node3.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              var element = node3;
              var type = element.type;
              var props = element.props;
              var ref = element.ref;
              renderElement(request, task, type, props, ref);
              return;
            }
            case REACT_PORTAL_TYPE:
              throw new Error("Portals are not currently supported by the server renderer. " + "Render them conditionally so that they only appear on the client render.");
            case REACT_LAZY_TYPE: {
              var lazyNode = node3;
              var payload = lazyNode._payload;
              var init2 = lazyNode._init;
              var resolvedNode;
              {
                try {
                  resolvedNode = init2(payload);
                } catch (x) {
                  if (typeof x === "object" && x !== null && typeof x.then === "function") {
                    pushBuiltInComponentStackInDEV(task, "Lazy");
                  }
                  throw x;
                }
              }
              renderNodeDestructive(request, task, resolvedNode);
              return;
            }
          }
          if (isArray(node3)) {
            renderChildrenArray(request, task, node3);
            return;
          }
          var iteratorFn = getIteratorFn(node3);
          if (iteratorFn) {
            {
              validateIterable(node3, iteratorFn);
            }
            var iterator = iteratorFn.call(node3);
            if (iterator) {
              var step = iterator.next();
              if (!step.done) {
                var children = [];
                do {
                  children.push(step.value);
                  step = iterator.next();
                } while (!step.done);
                renderChildrenArray(request, task, children);
                return;
              }
              return;
            }
          }
          var childString = Object.prototype.toString.call(node3);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node3).join(", ") + "}" : childString) + "). " + "If you meant to render a collection of children, use an array " + "instead.");
        }
        if (typeof node3 === "string") {
          var segment = task.blockedSegment;
          segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, node3, request.responseState, segment.lastPushedText);
          return;
        }
        if (typeof node3 === "number") {
          var _segment = task.blockedSegment;
          _segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, "" + node3, request.responseState, _segment.lastPushedText);
          return;
        }
        {
          if (typeof node3 === "function") {
            error("Functions are not valid as a React child. This may happen if " + "you return a Component instead of <Component /> from render. " + "Or maybe you meant to call this function rather than return it.");
          }
        }
      }
      function renderChildrenArray(request, task, children) {
        var totalChildren = children.length;
        for (var i = 0;i < totalChildren; i++) {
          var prevTreeContext = task.treeContext;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
          try {
            renderNode2(request, task, children[i]);
          } finally {
            task.treeContext = prevTreeContext;
          }
        }
      }
      function spawnNewSuspendedTask(request, task, x) {
        var segment = task.blockedSegment;
        var insertionIndex = segment.chunks.length;
        var newSegment = createPendingSegment(request, insertionIndex, null, segment.formatContext, segment.lastPushedText, true);
        segment.children.push(newSegment);
        segment.lastPushedText = false;
        var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
        {
          if (task.componentStack !== null) {
            newTask.componentStack = task.componentStack.parent;
          }
        }
        var ping = newTask.ping;
        x.then(ping, ping);
      }
      function renderNode2(request, task, node3) {
        var previousFormatContext = task.blockedSegment.formatContext;
        var previousLegacyContext = task.legacyContext;
        var previousContext = task.context;
        var previousComponentStack = null;
        {
          previousComponentStack = task.componentStack;
        }
        try {
          return renderNodeDestructive(request, task, node3);
        } catch (x) {
          resetHooksState();
          if (typeof x === "object" && x !== null && typeof x.then === "function") {
            spawnNewSuspendedTask(request, task, x);
            task.blockedSegment.formatContext = previousFormatContext;
            task.legacyContext = previousLegacyContext;
            task.context = previousContext;
            switchContext(previousContext);
            {
              task.componentStack = previousComponentStack;
            }
            return;
          } else {
            task.blockedSegment.formatContext = previousFormatContext;
            task.legacyContext = previousLegacyContext;
            task.context = previousContext;
            switchContext(previousContext);
            {
              task.componentStack = previousComponentStack;
            }
            throw x;
          }
        }
      }
      function erroredTask(request, boundary, segment, error2) {
        var errorDigest = logRecoverableError(request, error2);
        if (boundary === null) {
          fatalError(request, error2);
        } else {
          boundary.pendingTasks--;
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true;
            boundary.errorDigest = errorDigest;
            {
              captureBoundaryErrorDetailsDev(boundary, error2);
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary);
            }
          }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function abortTaskSoft(task) {
        var request = this;
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        finishedTask(request, boundary, segment);
      }
      function abortTask(task, request, reason) {
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        if (boundary === null) {
          request.allPendingTasks--;
          if (request.status !== CLOSED) {
            request.status = CLOSED;
            if (request.destination !== null) {
              close(request.destination);
            }
          }
        } else {
          boundary.pendingTasks--;
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true;
            var _error = reason === undefined ? new Error("The render was aborted by the server without a reason.") : reason;
            boundary.errorDigest = request.onError(_error);
            {
              var errorPrefix = "The server did not finish this Suspense boundary: ";
              if (_error && typeof _error.message === "string") {
                _error = errorPrefix + _error.message;
              } else {
                _error = errorPrefix + String(_error);
              }
              var previousTaskInDev = currentTaskInDEV;
              currentTaskInDEV = task;
              try {
                captureBoundaryErrorDetailsDev(boundary, _error);
              } finally {
                currentTaskInDEV = previousTaskInDev;
              }
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary);
            }
          }
          boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, reason);
          });
          boundary.fallbackAbortableTasks.clear();
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
      }
      function queueCompletedSegment(boundary, segment) {
        if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id;
          childSegment.parentFlushed = true;
          if (childSegment.status === COMPLETED) {
            queueCompletedSegment(boundary, childSegment);
          }
        } else {
          var completedSegments = boundary.completedSegments;
          completedSegments.push(segment);
        }
      }
      function finishedTask(request, boundary, segment) {
        if (boundary === null) {
          if (segment.parentFlushed) {
            if (request.completedRootSegment !== null) {
              throw new Error("There can only be one root segment. This is a bug in React.");
            }
            request.completedRootSegment = segment;
          }
          request.pendingRootTasks--;
          if (request.pendingRootTasks === 0) {
            request.onShellError = noop$1;
            var onShellReady = request.onShellReady;
            onShellReady();
          }
        } else {
          boundary.pendingTasks--;
          if (boundary.forceClientRender)
            ;
          else if (boundary.pendingTasks === 0) {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment);
              }
            }
            if (boundary.parentFlushed) {
              request.completedBoundaries.push(boundary);
            }
            boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
            boundary.fallbackAbortableTasks.clear();
          } else {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment);
                var completedSegments = boundary.completedSegments;
                if (completedSegments.length === 1) {
                  if (boundary.parentFlushed) {
                    request.partialBoundaries.push(boundary);
                  }
                }
              }
            }
          }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function retryTask(request, task) {
        var segment = task.blockedSegment;
        if (segment.status !== PENDING) {
          return;
        }
        switchContext(task.context);
        var prevTaskInDEV = null;
        {
          prevTaskInDEV = currentTaskInDEV;
          currentTaskInDEV = task;
        }
        try {
          renderNodeDestructive(request, task, task.node);
          pushSegmentFinale$1(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
          task.abortSet.delete(task);
          segment.status = COMPLETED;
          finishedTask(request, task.blockedBoundary, segment);
        } catch (x) {
          resetHooksState();
          if (typeof x === "object" && x !== null && typeof x.then === "function") {
            var ping = task.ping;
            x.then(ping, ping);
          } else {
            task.abortSet.delete(task);
            segment.status = ERRORED;
            erroredTask(request, task.blockedBoundary, segment, x);
          }
        } finally {
          {
            currentTaskInDEV = prevTaskInDEV;
          }
        }
      }
      function performWork(request) {
        if (request.status === CLOSED) {
          return;
        }
        var prevContext = getActiveContext();
        var prevDispatcher = ReactCurrentDispatcher$1.current;
        ReactCurrentDispatcher$1.current = Dispatcher;
        var prevGetCurrentStackImpl;
        {
          prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
          ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
        }
        var prevResponseState = currentResponseState;
        setCurrentResponseState(request.responseState);
        try {
          var pingedTasks = request.pingedTasks;
          var i;
          for (i = 0;i < pingedTasks.length; i++) {
            var task = pingedTasks[i];
            retryTask(request, task);
          }
          pingedTasks.splice(0, i);
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination);
          }
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        } finally {
          setCurrentResponseState(prevResponseState);
          ReactCurrentDispatcher$1.current = prevDispatcher;
          {
            ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
          }
          if (prevDispatcher === Dispatcher) {
            switchContext(prevContext);
          }
        }
      }
      function flushSubtree(request, destination, segment) {
        segment.parentFlushed = true;
        switch (segment.status) {
          case PENDING: {
            var segmentID = segment.id = request.nextSegmentId++;
            segment.lastPushedText = false;
            segment.textEmbedded = false;
            return writePlaceholder(destination, request.responseState, segmentID);
          }
          case COMPLETED: {
            segment.status = FLUSHED;
            var r2 = true;
            var chunks = segment.chunks;
            var chunkIdx = 0;
            var children = segment.children;
            for (var childIdx = 0;childIdx < children.length; childIdx++) {
              var nextChild = children[childIdx];
              for (;chunkIdx < nextChild.index; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              r2 = flushSegment(request, destination, nextChild);
            }
            for (;chunkIdx < chunks.length - 1; chunkIdx++) {
              writeChunk(destination, chunks[chunkIdx]);
            }
            if (chunkIdx < chunks.length) {
              r2 = writeChunkAndReturn(destination, chunks[chunkIdx]);
            }
            return r2;
          }
          default: {
            throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
          }
        }
      }
      function flushSegment(request, destination, segment) {
        var boundary = segment.boundary;
        if (boundary === null) {
          return flushSubtree(request, destination, segment);
        }
        boundary.parentFlushed = true;
        if (boundary.forceClientRender) {
          writeStartClientRenderedSuspenseBoundary$1(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
          flushSubtree(request, destination, segment);
          return writeEndClientRenderedSuspenseBoundary$1(destination, request.responseState);
        } else if (boundary.pendingTasks > 0) {
          boundary.rootSegmentID = request.nextSegmentId++;
          if (boundary.completedSegments.length > 0) {
            request.partialBoundaries.push(boundary);
          }
          var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
          writeStartPendingSuspenseBoundary(destination, request.responseState, id);
          flushSubtree(request, destination, segment);
          return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else if (boundary.byteSize > request.progressiveChunkSize) {
          boundary.rootSegmentID = request.nextSegmentId++;
          request.completedBoundaries.push(boundary);
          writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
          flushSubtree(request, destination, segment);
          return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else {
          writeStartCompletedSuspenseBoundary$1(destination, request.responseState);
          var completedSegments = boundary.completedSegments;
          if (completedSegments.length !== 1) {
            throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
          }
          var contentSegment = completedSegments[0];
          flushSegment(request, destination, contentSegment);
          return writeEndCompletedSuspenseBoundary$1(destination, request.responseState);
        }
      }
      function flushClientRenderedBoundary(request, destination, boundary) {
        return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
      }
      function flushSegmentContainer(request, destination, segment) {
        writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
        flushSegment(request, destination, segment);
        return writeEndSegment(destination, segment.formatContext);
      }
      function flushCompletedBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for (;i < completedSegments.length; i++) {
          var segment = completedSegments[i];
          flushPartiallyCompletedSegment(request, destination, boundary, segment);
        }
        completedSegments.length = 0;
        return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
      }
      function flushPartialBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for (;i < completedSegments.length; i++) {
          var segment = completedSegments[i];
          if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
            i++;
            completedSegments.splice(0, i);
            return false;
          }
        }
        completedSegments.splice(0, i);
        return true;
      }
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED) {
          return true;
        }
        var segmentID = segment.id;
        if (segmentID === -1) {
          var rootSegmentID = segment.id = boundary.rootSegmentID;
          if (rootSegmentID === -1) {
            throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
          }
          return flushSegmentContainer(request, destination, segment);
        } else {
          flushSegmentContainer(request, destination, segment);
          return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
        }
      }
      function flushCompletedQueues(request, destination) {
        try {
          var completedRootSegment = request.completedRootSegment;
          if (completedRootSegment !== null && request.pendingRootTasks === 0) {
            flushSegment(request, destination, completedRootSegment);
            request.completedRootSegment = null;
            writeCompletedRoot(destination, request.responseState);
          }
          var clientRenderedBoundaries = request.clientRenderedBoundaries;
          var i;
          for (i = 0;i < clientRenderedBoundaries.length; i++) {
            var boundary = clientRenderedBoundaries[i];
            if (!flushClientRenderedBoundary(request, destination, boundary)) {
              request.destination = null;
              i++;
              clientRenderedBoundaries.splice(0, i);
              return;
            }
          }
          clientRenderedBoundaries.splice(0, i);
          var completedBoundaries = request.completedBoundaries;
          for (i = 0;i < completedBoundaries.length; i++) {
            var _boundary = completedBoundaries[i];
            if (!flushCompletedBoundary(request, destination, _boundary)) {
              request.destination = null;
              i++;
              completedBoundaries.splice(0, i);
              return;
            }
          }
          completedBoundaries.splice(0, i);
          completeWriting(destination);
          beginWriting(destination);
          var partialBoundaries = request.partialBoundaries;
          for (i = 0;i < partialBoundaries.length; i++) {
            var _boundary2 = partialBoundaries[i];
            if (!flushPartialBoundary(request, destination, _boundary2)) {
              request.destination = null;
              i++;
              partialBoundaries.splice(0, i);
              return;
            }
          }
          partialBoundaries.splice(0, i);
          var largeBoundaries = request.completedBoundaries;
          for (i = 0;i < largeBoundaries.length; i++) {
            var _boundary3 = largeBoundaries[i];
            if (!flushCompletedBoundary(request, destination, _boundary3)) {
              request.destination = null;
              i++;
              largeBoundaries.splice(0, i);
              return;
            }
          }
          largeBoundaries.splice(0, i);
        } finally {
          if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
            {
              if (request.abortableTasks.size !== 0) {
                error("There was still abortable task at the root when we closed. This is a bug in React.");
              }
            }
            close(destination);
          }
        }
      }
      function startWork(request) {
        scheduleWork(function() {
          return performWork(request);
        });
      }
      function startFlowing(request, destination) {
        if (request.status === CLOSING) {
          request.status = CLOSED;
          closeWithError(destination, request.fatalError);
          return;
        }
        if (request.status === CLOSED) {
          return;
        }
        if (request.destination !== null) {
          return;
        }
        request.destination = destination;
        try {
          flushCompletedQueues(request, destination);
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        }
      }
      function abort(request, reason) {
        try {
          var abortableTasks = request.abortableTasks;
          abortableTasks.forEach(function(task) {
            return abortTask(task, request, reason);
          });
          abortableTasks.clear();
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination);
          }
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        }
      }
      function onError() {
      }
      function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
        var didFatal = false;
        var fatalError2 = null;
        var result2 = "";
        var destination = {
          push: function(chunk) {
            if (chunk !== null) {
              result2 += chunk;
            }
            return true;
          },
          destroy: function(error2) {
            didFatal = true;
            fatalError2 = error2;
          }
        };
        var readyToStream = false;
        function onShellReady() {
          readyToStream = true;
        }
        var request = createRequest(children, createResponseState$1(generateStaticMarkup, options ? options.identifierPrefix : undefined), createRootFormatContext(), Infinity, onError, undefined, onShellReady, undefined, undefined);
        startWork(request);
        abort(request, abortReason);
        startFlowing(request, destination);
        if (didFatal) {
          throw fatalError2;
        }
        if (!readyToStream) {
          throw new Error("A component suspended while responding to synchronous input. This " + "will cause the UI to be replaced with a loading indicator. To fix, " + "updates that suspend should be wrapped with startTransition.");
        }
        return result2;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var ReactMarkupReadableStream = /* @__PURE__ */ function(_Readable) {
        _inheritsLoose(ReactMarkupReadableStream2, _Readable);
        function ReactMarkupReadableStream2() {
          var _this;
          _this = _Readable.call(this, {}) || this;
          _this.request = null;
          _this.startedFlowing = false;
          return _this;
        }
        var _proto = ReactMarkupReadableStream2.prototype;
        _proto._destroy = function _destroy(err, callback) {
          abort(this.request);
          callback(err);
        };
        _proto._read = function _read(size2) {
          if (this.startedFlowing) {
            startFlowing(this.request, this);
          }
        };
        return ReactMarkupReadableStream2;
      }(stream.Readable);
      function onError$1() {
      }
      function renderToNodeStreamImpl(children, options, generateStaticMarkup) {
        function onAllReady() {
          destination.startedFlowing = true;
          startFlowing(request, destination);
        }
        var destination = new ReactMarkupReadableStream;
        var request = createRequest(children, createResponseState$1(false, options ? options.identifierPrefix : undefined), createRootFormatContext(), Infinity, onError$1, onAllReady, undefined, undefined);
        destination.request = request;
        startWork(request);
        return destination;
      }
      function renderToNodeStream(children, options) {
        {
          error("renderToNodeStream is deprecated. Use renderToPipeableStream instead.");
        }
        return renderToNodeStreamImpl(children, options);
      }
      function renderToStaticNodeStream(children, options) {
        return renderToNodeStreamImpl(children, options);
      }
      function renderToString(children, options) {
        return renderToStringImpl(children, options, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
      }
      function renderToStaticMarkup(children, options) {
        return renderToStringImpl(children, options, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
      }
      exports.renderToNodeStream = renderToNodeStream;
      exports.renderToStaticMarkup = renderToStaticMarkup;
      exports.renderToStaticNodeStream = renderToStaticNodeStream;
      exports.renderToString = renderToString;
      exports.version = ReactVersion;
    })();
  }
});

// node_modules/react-dom/cjs/react-dom-server.node.development.js
import * as util2 from "util";
var require_react_dom_server_node_development = __commonJS((exports) => {
  var React = __toESM(require_react(), 1);
  if (true) {
    (function() {
      var ReactVersion = "18.2.0";
      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function warn(format) {
        {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
      }
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function scheduleWork(callback) {
        setImmediate(callback);
      }
      function flushBuffered(destination) {
        if (typeof destination.flush === "function") {
          destination.flush();
        }
      }
      var VIEW_SIZE = 2048;
      var currentView = null;
      var writtenBytes = 0;
      var destinationHasCapacity = true;
      function beginWriting(destination) {
        currentView = new Uint8Array(VIEW_SIZE);
        writtenBytes = 0;
        destinationHasCapacity = true;
      }
      function writeStringChunk(destination, stringChunk) {
        if (stringChunk.length === 0) {
          return;
        }
        if (stringChunk.length * 3 > VIEW_SIZE) {
          if (writtenBytes > 0) {
            writeToDestination(destination, currentView.subarray(0, writtenBytes));
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
          }
          writeToDestination(destination, textEncoder.encode(stringChunk));
          return;
        }
        var target = currentView;
        if (writtenBytes > 0) {
          target = currentView.subarray(writtenBytes);
        }
        var _textEncoder$encodeIn = textEncoder.encodeInto(stringChunk, target), read = _textEncoder$encodeIn.read, written = _textEncoder$encodeIn.written;
        writtenBytes += written;
        if (read < stringChunk.length) {
          writeToDestination(destination, currentView);
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = textEncoder.encodeInto(stringChunk.slice(read), currentView).written;
        }
        if (writtenBytes === VIEW_SIZE) {
          writeToDestination(destination, currentView);
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = 0;
        }
      }
      function writeViewChunk(destination, chunk) {
        if (chunk.byteLength === 0) {
          return;
        }
        if (chunk.byteLength > VIEW_SIZE) {
          if (writtenBytes > 0) {
            writeToDestination(destination, currentView.subarray(0, writtenBytes));
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
          }
          writeToDestination(destination, chunk);
          return;
        }
        var bytesToWrite = chunk;
        var allowableBytes = currentView.length - writtenBytes;
        if (allowableBytes < bytesToWrite.byteLength) {
          if (allowableBytes === 0) {
            writeToDestination(destination, currentView);
          } else {
            currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);
            writtenBytes += allowableBytes;
            writeToDestination(destination, currentView);
            bytesToWrite = bytesToWrite.subarray(allowableBytes);
          }
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = 0;
        }
        currentView.set(bytesToWrite, writtenBytes);
        writtenBytes += bytesToWrite.byteLength;
        if (writtenBytes === VIEW_SIZE) {
          writeToDestination(destination, currentView);
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = 0;
        }
      }
      function writeChunk(destination, chunk) {
        if (typeof chunk === "string") {
          writeStringChunk(destination, chunk);
        } else {
          writeViewChunk(destination, chunk);
        }
      }
      function writeToDestination(destination, view) {
        var currentHasCapacity = destination.write(view);
        destinationHasCapacity = destinationHasCapacity && currentHasCapacity;
      }
      function writeChunkAndReturn(destination, chunk) {
        writeChunk(destination, chunk);
        return destinationHasCapacity;
      }
      function completeWriting(destination) {
        if (currentView && writtenBytes > 0) {
          destination.write(currentView.subarray(0, writtenBytes));
        }
        currentView = null;
        writtenBytes = 0;
        destinationHasCapacity = true;
      }
      function close(destination) {
        destination.end();
      }
      var textEncoder = new util2.TextEncoder;
      function stringToChunk(content) {
        return content;
      }
      function stringToPrecomputedChunk(content) {
        return textEncoder.encode(content);
      }
      function closeWithError(destination, error2) {
        destination.destroy(error2);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e2) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkAttributeStringCoercion(value, attributeName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` attribute is an unsupported type %s." + " This value must be coerced to a string before before using it here.", attributeName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkCSSPropertyStringCoercion(value, propName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` CSS property is an unsupported type %s." + " This value must be coerced to a string before before using it here.", propName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkHtmlStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided HTML markup uses a value of unsupported type %s." + " This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var RESERVED = 0;
      var STRING = 1;
      var BOOLEANISH_STRING = 2;
      var BOOLEAN = 3;
      var OVERLOADED_BOOLEAN = 4;
      var NUMERIC = 5;
      var POSITIVE_NUMERIC = 6;
      var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
          return true;
        }
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
          return false;
        }
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
          validatedAttributeNameCache[attributeName] = true;
          return true;
        }
        illegalAttributeNameCache[attributeName] = true;
        {
          error("Invalid attribute name: `%s`", attributeName);
        }
        return false;
      }
      function shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) {
          return false;
        }
        switch (typeof value) {
          case "function":
          case "symbol":
            return true;
          case "boolean": {
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              return !propertyInfo.acceptsBooleans;
            } else {
              var prefix2 = name2.toLowerCase().slice(0, 5);
              return prefix2 !== "data-" && prefix2 !== "aria-";
            }
          }
          default:
            return false;
        }
      }
      function getPropertyInfo(name2) {
        return properties.hasOwnProperty(name2) ? properties[name2] : null;
      }
      function PropertyInfoRecord(name2, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
        this.attributeName = attributeName;
        this.attributeNamespace = attributeNamespace;
        this.mustUseProperty = mustUseProperty;
        this.propertyName = name2;
        this.type = type;
        this.sanitizeURL = sanitizeURL2;
        this.removeEmptyString = removeEmptyString;
      }
      var properties = {};
      var reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(name2, RESERVED, false, name2, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name2 = _ref[0], attributeName = _ref[1];
        properties[name2] = new PropertyInfoRecord(name2, STRING, false, attributeName, null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(name2, BOOLEANISH_STRING, false, name2.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(name2, BOOLEANISH_STRING, false, name2, null, false, false);
      });
      [
        "allowFullScreen",
        "async",
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        "itemScope"
      ].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(name2, BOOLEAN, false, name2.toLowerCase(), null, false, false);
      });
      [
        "checked",
        "multiple",
        "muted",
        "selected"
      ].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(name2, BOOLEAN, true, name2, null, false, false);
      });
      [
        "capture",
        "download"
      ].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(name2, OVERLOADED_BOOLEAN, false, name2, null, false, false);
      });
      [
        "cols",
        "rows",
        "size",
        "span"
      ].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(name2, POSITIVE_NUMERIC, false, name2, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(name2, NUMERIC, false, name2.toLowerCase(), null, false, false);
      });
      var CAMELIZE = /[\-\:]([a-z])/g;
      var capitalize = function(token2) {
        return token2[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
      ].forEach(function(attributeName) {
        var name2 = attributeName.replace(CAMELIZE, capitalize);
        properties[name2] = new PropertyInfoRecord(name2, STRING, false, attributeName, null, false, false);
      });
      [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
      ].forEach(function(attributeName) {
        var name2 = attributeName.replace(CAMELIZE, capitalize);
        properties[name2] = new PropertyInfoRecord(name2, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
      });
      [
        "xml:base",
        "xml:lang",
        "xml:space"
      ].forEach(function(attributeName) {
        var name2 = attributeName.replace(CAMELIZE, capitalize);
        properties[name2] = new PropertyInfoRecord(name2, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
      });
      var xlinkHref = "xlinkHref";
      properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
      });
      var isUnitlessNumber = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      function prefixKey(prefix2, key) {
        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      };
      function checkControlledValueProps(tagName, props) {
        {
          if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
            error("You provided a `value` prop to a form field without an " + "`onChange` handler. This will render a read-only field. If " + "the field should be mutable use `defaultValue`. Otherwise, " + "set either `onChange` or `readOnly`.");
          }
          if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
            error("You provided a `checked` prop to a form field without an " + "`onChange` handler. This will render a read-only field. If " + "the field should be mutable use `defaultChecked`. Otherwise, " + "set either `onChange` or `readOnly`.");
          }
        }
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1) {
          return typeof props.is === "string";
        }
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      };
      var warnedProperties = {};
      var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
      var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
      function validateProperty(tagName, name2) {
        {
          if (hasOwnProperty.call(warnedProperties, name2) && warnedProperties[name2]) {
            return true;
          }
          if (rARIACamel.test(name2)) {
            var ariaName = "aria-" + name2.slice(4).toLowerCase();
            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null) {
              error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name2);
              warnedProperties[name2] = true;
              return true;
            }
            if (name2 !== correctName) {
              error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name2, correctName);
              warnedProperties[name2] = true;
              return true;
            }
          }
          if (rARIA.test(name2)) {
            var lowerCasedName = name2.toLowerCase();
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null) {
              warnedProperties[name2] = true;
              return false;
            }
            if (name2 !== standardName) {
              error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name2, standardName);
              warnedProperties[name2] = true;
              return true;
            }
          }
        }
        return true;
      }
      function warnInvalidARIAProps(type, props) {
        {
          var invalidProps = [];
          for (var key in props) {
            var isValid2 = validateProperty(type, key);
            if (!isValid2) {
              invalidProps.push(key);
            }
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (invalidProps.length === 1) {
            error("Invalid aria prop %s on <%s> tag. " + "For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          } else if (invalidProps.length > 1) {
            error("Invalid aria props %s on <%s> tag. " + "For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          }
        }
      }
      function validateProperties(type, props) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnInvalidARIAProps(type, props);
      }
      var didWarnValueNull = false;
      function validateProperties$1(type, props) {
        {
          if (type !== "input" && type !== "textarea" && type !== "select") {
            return;
          }
          if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true;
            if (type === "select" && props.multiple) {
              error("`value` prop on `%s` should not be null. " + "Consider using an empty array when `multiple` is set to `true` " + "to clear the component or `undefined` for uncontrolled components.", type);
            } else {
              error("`value` prop on `%s` should not be null. " + "Consider using an empty string to clear the component or `undefined` " + "for uncontrolled components.", type);
            }
          }
        }
      }
      var possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      };
      var validateProperty$1 = function() {
      };
      {
        var warnedProperties$1 = {};
        var EVENT_NAME_REGEX = /^on./;
        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
        var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name2, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties$1, name2) && warnedProperties$1[name2]) {
            return true;
          }
          var lowerCasedName = name2.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
            error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. " + "All React events are normalized to bubble, so onFocusIn and onFocusOut " + "are not needed/supported by React.");
            warnedProperties$1[name2] = true;
            return true;
          }
          if (eventRegistry != null) {
            var { registrationNameDependencies, possibleRegistrationNames } = eventRegistry;
            if (registrationNameDependencies.hasOwnProperty(name2)) {
              return true;
            }
            var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
            if (registrationName != null) {
              error("Invalid event handler property `%s`. Did you mean `%s`?", name2, registrationName);
              warnedProperties$1[name2] = true;
              return true;
            }
            if (EVENT_NAME_REGEX.test(name2)) {
              error("Unknown event handler property `%s`. It will be ignored.", name2);
              warnedProperties$1[name2] = true;
              return true;
            }
          } else if (EVENT_NAME_REGEX.test(name2)) {
            if (INVALID_EVENT_NAME_REGEX.test(name2)) {
              error("Invalid event handler property `%s`. " + "React events use the camelCase naming convention, for example `onClick`.", name2);
            }
            warnedProperties$1[name2] = true;
            return true;
          }
          if (rARIA$1.test(name2) || rARIACamel$1.test(name2)) {
            return true;
          }
          if (lowerCasedName === "innerhtml") {
            error("Directly setting property `innerHTML` is not permitted. " + "For more information, lookup documentation on `dangerouslySetInnerHTML`.");
            warnedProperties$1[name2] = true;
            return true;
          }
          if (lowerCasedName === "aria") {
            error("The `aria` attribute is reserved for future use in React. " + "Pass individual `aria-` attributes instead.");
            warnedProperties$1[name2] = true;
            return true;
          }
          if (lowerCasedName === "is" && value !== null && value !== undefined && typeof value !== "string") {
            error("Received a `%s` for a string attribute `is`. If this is expected, cast " + "the value to a string.", typeof value);
            warnedProperties$1[name2] = true;
            return true;
          }
          if (typeof value === "number" && isNaN(value)) {
            error("Received NaN for the `%s` attribute. If this is expected, cast " + "the value to a string.", name2);
            warnedProperties$1[name2] = true;
            return true;
          }
          var propertyInfo = getPropertyInfo(name2);
          var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name2) {
              error("Invalid DOM property `%s`. Did you mean `%s`?", name2, standardName);
              warnedProperties$1[name2] = true;
              return true;
            }
          } else if (!isReserved && name2 !== lowerCasedName) {
            error("React does not recognize the `%s` prop on a DOM element. If you " + "intentionally want it to appear in the DOM as a custom " + "attribute, spell it as lowercase `%s` instead. " + "If you accidentally passed it from a parent component, remove " + "it from the DOM element.", name2, lowerCasedName);
            warnedProperties$1[name2] = true;
            return true;
          }
          if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
            if (value) {
              error("Received `%s` for a non-boolean attribute `%s`.\n\n" + "If you want to write it to the DOM, pass a string instead: " + '%s="%s" or %s={value.toString()}.', value, name2, name2, value, name2);
            } else {
              error("Received `%s` for a non-boolean attribute `%s`.\n\n" + "If you want to write it to the DOM, pass a string instead: " + '%s="%s" or %s={value.toString()}.\n\n' + "If you used to conditionally omit it with %s={condition && value}, " + "pass %s={condition ? value : undefined} instead.", value, name2, name2, value, name2, name2, name2);
            }
            warnedProperties$1[name2] = true;
            return true;
          }
          if (isReserved) {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
            warnedProperties$1[name2] = true;
            return false;
          }
          if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
            error("Received the string `%s` for the boolean attribute `%s`. " + "%s " + "Did you mean %s={%s}?", value, name2, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name2, value);
            warnedProperties$1[name2] = true;
            return true;
          }
          return true;
        };
      }
      var warnUnknownProperties = function(type, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key in props) {
            var isValid2 = validateProperty$1(type, key, props[key], eventRegistry);
            if (!isValid2) {
              unknownProps.push(key);
            }
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (unknownProps.length === 1) {
            error("Invalid value for prop %s on <%s> tag. Either remove it from the element, " + "or pass a string or number value to keep it in the DOM. " + "For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          } else if (unknownProps.length > 1) {
            error("Invalid values for props %s on <%s> tag. Either remove them from the element, " + "or pass a string or number value to keep them in the DOM. " + "For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          }
        }
      };
      function validateProperties$2(type, props, eventRegistry) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnUnknownProperties(type, props, eventRegistry);
      }
      var warnValidStyle = function() {
      };
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
        var msPattern = /^-ms-/;
        var hyphenPattern = /-(.)/g;
        var badStyleValueWithSemicolonPattern = /;\s*$/;
        var warnedStyleNames = {};
        var warnedStyleValues = {};
        var warnedForNaNValue = false;
        var warnedForInfinityValue = false;
        var camelize = function(string) {
          return string.replace(hyphenPattern, function(_3, character) {
            return character.toUpperCase();
          });
        };
        var warnHyphenatedStyleName = function(name2) {
          if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
            return;
          }
          warnedStyleNames[name2] = true;
          error("Unsupported style property %s. Did you mean %s?", name2, camelize(name2.replace(msPattern, "ms-")));
        };
        var warnBadVendoredStyleName = function(name2) {
          if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
            return;
          }
          warnedStyleNames[name2] = true;
          error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name2, name2.charAt(0).toUpperCase() + name2.slice(1));
        };
        var warnStyleValueWithSemicolon = function(name2, value) {
          if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
            return;
          }
          warnedStyleValues[value] = true;
          error("Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.', name2, value.replace(badStyleValueWithSemicolonPattern, ""));
        };
        var warnStyleValueIsNaN = function(name2, value) {
          if (warnedForNaNValue) {
            return;
          }
          warnedForNaNValue = true;
          error("`NaN` is an invalid value for the `%s` css style property.", name2);
        };
        var warnStyleValueIsInfinity = function(name2, value) {
          if (warnedForInfinityValue) {
            return;
          }
          warnedForInfinityValue = true;
          error("`Infinity` is an invalid value for the `%s` css style property.", name2);
        };
        warnValidStyle = function(name2, value) {
          if (name2.indexOf("-") > -1) {
            warnHyphenatedStyleName(name2);
          } else if (badVendoredStyleNamePattern.test(name2)) {
            warnBadVendoredStyleName(name2);
          } else if (badStyleValueWithSemicolonPattern.test(value)) {
            warnStyleValueWithSemicolon(name2, value);
          }
          if (typeof value === "number") {
            if (isNaN(value)) {
              warnStyleValueIsNaN(name2, value);
            } else if (!isFinite(value)) {
              warnStyleValueIsInfinity(name2, value);
            }
          }
        };
      }
      var warnValidStyle$1 = warnValidStyle;
      var matchHtmlRegExp = /["'&<>]/;
      function escapeHtml(string) {
        {
          checkHtmlStringCoercion(string);
        }
        var str = "" + string;
        var match = matchHtmlRegExp.exec(str);
        if (!match) {
          return str;
        }
        var escape4;
        var html = "";
        var index2;
        var lastIndex = 0;
        for (index2 = match.index;index2 < str.length; index2++) {
          switch (str.charCodeAt(index2)) {
            case 34:
              escape4 = "&quot;";
              break;
            case 38:
              escape4 = "&amp;";
              break;
            case 39:
              escape4 = "&#x27;";
              break;
            case 60:
              escape4 = "&lt;";
              break;
            case 62:
              escape4 = "&gt;";
              break;
            default:
              continue;
          }
          if (lastIndex !== index2) {
            html += str.substring(lastIndex, index2);
          }
          lastIndex = index2 + 1;
          html += escape4;
        }
        return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
      }
      function escapeTextForBrowser(text2) {
        if (typeof text2 === "boolean" || typeof text2 === "number") {
          return "" + text2;
        }
        return escapeHtml(text2);
      }
      var uppercasePattern = /([A-Z])/g;
      var msPattern$1 = /^ms-/;
      function hyphenateStyleName(name2) {
        return name2.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
      }
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
      var didWarn = false;
      function sanitizeURL(url) {
        {
          if (!didWarn && isJavaScriptProtocol.test(url)) {
            didWarn = true;
            error("A future version of React will block javascript: URLs as a security precaution. " + "Use event handlers instead if you can. If you need to generate unsafe HTML try " + "using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      var startInlineScript = stringToPrecomputedChunk("<script>");
      var endInlineScript = stringToPrecomputedChunk("</script>");
      var startScriptSrc = stringToPrecomputedChunk('<script src="');
      var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
      var endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
      function escapeBootstrapScriptContent(scriptText) {
        {
          checkHtmlStringCoercion(scriptText);
        }
        return ("" + scriptText).replace(scriptRegex, scriptReplacer);
      }
      var scriptRegex = /(<\/|<)(s)(cript)/gi;
      var scriptReplacer = function(match, prefix2, s2, suffix) {
        return "" + prefix2 + (s2 === "s" ? "\\u0073" : "\\u0053") + suffix;
      };
      function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        var idPrefix = identifierPrefix === undefined ? "" : identifierPrefix;
        var inlineScriptWithNonce = nonce === undefined ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
        var bootstrapChunks = [];
        if (bootstrapScriptContent !== undefined) {
          bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
        }
        if (bootstrapScripts !== undefined) {
          for (var i = 0;i < bootstrapScripts.length; i++) {
            bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);
          }
        }
        if (bootstrapModules !== undefined) {
          for (var _i2 = 0;_i2 < bootstrapModules.length; _i2++) {
            bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i2])), endAsyncScript);
          }
        }
        return {
          bootstrapChunks,
          startInlineScript: inlineScriptWithNonce,
          placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
          segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
          boundaryPrefix: idPrefix + "B:",
          idPrefix,
          nextSuspenseID: 0,
          sentCompleteSegmentFunction: false,
          sentCompleteBoundaryFunction: false,
          sentClientRenderFunction: false
        };
      }
      var ROOT_HTML_MODE = 0;
      var HTML_MODE = 1;
      var SVG_MODE = 2;
      var MATHML_MODE = 3;
      var HTML_TABLE_MODE = 4;
      var HTML_TABLE_BODY_MODE = 5;
      var HTML_TABLE_ROW_MODE = 6;
      var HTML_COLGROUP_MODE = 7;
      function createFormatContext(insertionMode, selectedValue) {
        return {
          insertionMode,
          selectedValue
        };
      }
      function createRootFormatContext(namespaceURI) {
        var insertionMode = namespaceURI === "http://www.w3.org/2000/svg" ? SVG_MODE : namespaceURI === "http://www.w3.org/1998/Math/MathML" ? MATHML_MODE : ROOT_HTML_MODE;
        return createFormatContext(insertionMode, null);
      }
      function getChildFormatContext(parentContext, type, props) {
        switch (type) {
          case "select":
            return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
          case "svg":
            return createFormatContext(SVG_MODE, null);
          case "math":
            return createFormatContext(MATHML_MODE, null);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null);
          case "table":
            return createFormatContext(HTML_TABLE_MODE, null);
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(HTML_TABLE_BODY_MODE, null);
          case "colgroup":
            return createFormatContext(HTML_COLGROUP_MODE, null);
          case "tr":
            return createFormatContext(HTML_TABLE_ROW_MODE, null);
        }
        if (parentContext.insertionMode >= HTML_TABLE_MODE) {
          return createFormatContext(HTML_MODE, null);
        }
        if (parentContext.insertionMode === ROOT_HTML_MODE) {
          return createFormatContext(HTML_MODE, null);
        }
        return parentContext;
      }
      var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
      function assignSuspenseBoundaryID(responseState) {
        var generatedID = responseState.nextSuspenseID++;
        return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
      }
      function makeId(responseState, treeId, localId) {
        var idPrefix = responseState.idPrefix;
        var id = ":" + idPrefix + "R" + treeId;
        if (localId > 0) {
          id += "H" + localId.toString(32);
        }
        return id + ":";
      }
      function encodeHTMLTextNode(text2) {
        return escapeTextForBrowser(text2);
      }
      var textSeparator = stringToPrecomputedChunk("<!-- -->");
      function pushTextInstance(target, text2, responseState, textEmbedded) {
        if (text2 === "") {
          return textEmbedded;
        }
        if (textEmbedded) {
          target.push(textSeparator);
        }
        target.push(stringToChunk(encodeHTMLTextNode(text2)));
        return true;
      }
      function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
        if (lastPushedText && textEmbedded) {
          target.push(textSeparator);
        }
      }
      var styleNameCache = new Map;
      function processStyleName(styleName) {
        var chunk = styleNameCache.get(styleName);
        if (chunk !== undefined) {
          return chunk;
        }
        var result2 = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
        styleNameCache.set(styleName, result2);
        return result2;
      }
      var styleAttributeStart = stringToPrecomputedChunk(' style="');
      var styleAssign = stringToPrecomputedChunk(":");
      var styleSeparator = stringToPrecomputedChunk(";");
      function pushStyle(target, responseState, style) {
        if (typeof style !== "object") {
          throw new Error("The `style` prop expects a mapping from style properties to values, " + "not a string. For example, style={{marginRight: spacing + 'em'}} when " + "using JSX.");
        }
        var isFirst = true;
        for (var styleName in style) {
          if (!hasOwnProperty.call(style, styleName)) {
            continue;
          }
          var styleValue = style[styleName];
          if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
            continue;
          }
          var nameChunk = undefined;
          var valueChunk = undefined;
          var isCustomProperty = styleName.indexOf("--") === 0;
          if (isCustomProperty) {
            nameChunk = stringToChunk(escapeTextForBrowser(styleName));
            {
              checkCSSPropertyStringCoercion(styleValue, styleName);
            }
            valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
          } else {
            {
              warnValidStyle$1(styleName, styleValue);
            }
            nameChunk = processStyleName(styleName);
            if (typeof styleValue === "number") {
              if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                valueChunk = stringToChunk(styleValue + "px");
              } else {
                valueChunk = stringToChunk("" + styleValue);
              }
            } else {
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            }
          }
          if (isFirst) {
            isFirst = false;
            target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
          } else {
            target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
          }
        }
        if (!isFirst) {
          target.push(attributeEnd);
        }
      }
      var attributeSeparator = stringToPrecomputedChunk(" ");
      var attributeAssign = stringToPrecomputedChunk('="');
      var attributeEnd = stringToPrecomputedChunk('"');
      var attributeEmptyString = stringToPrecomputedChunk('=""');
      function pushAttribute(target, responseState, name2, value) {
        switch (name2) {
          case "style": {
            pushStyle(target, responseState, value);
            return;
          }
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            return;
        }
        if (name2.length > 2 && (name2[0] === "o" || name2[0] === "O") && (name2[1] === "n" || name2[1] === "N")) {
          return;
        }
        var propertyInfo = getPropertyInfo(name2);
        if (propertyInfo !== null) {
          switch (typeof value) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              if (!propertyInfo.acceptsBooleans) {
                return;
              }
            }
          }
          var attributeName = propertyInfo.attributeName;
          var attributeNameChunk = stringToChunk(attributeName);
          switch (propertyInfo.type) {
            case BOOLEAN:
              if (value) {
                target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
              }
              return;
            case OVERLOADED_BOOLEAN:
              if (value === true) {
                target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
              } else if (value === false)
                ;
              else {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              return;
            case NUMERIC:
              if (!isNaN(value)) {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              break;
            case POSITIVE_NUMERIC:
              if (!isNaN(value) && value >= 1) {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              break;
            default:
              if (propertyInfo.sanitizeURL) {
                {
                  checkAttributeStringCoercion(value, attributeName);
                }
                value = "" + value;
                sanitizeURL(value);
              }
              target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
          }
        } else if (isAttributeNameSafe(name2)) {
          switch (typeof value) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var prefix2 = name2.toLowerCase().slice(0, 5);
              if (prefix2 !== "data-" && prefix2 !== "aria-") {
                return;
              }
            }
          }
          target.push(attributeSeparator, stringToChunk(name2), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
        }
      }
      var endOfStartTag = stringToPrecomputedChunk(">");
      var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
      function pushInnerHTML(target, innerHTML, children) {
        if (innerHTML != null) {
          if (children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. " + "Please visit https://reactjs.org/link/dangerously-set-inner-html " + "for more information.");
          }
          var html = innerHTML.__html;
          if (html !== null && html !== undefined) {
            {
              checkHtmlStringCoercion(html);
            }
            target.push(stringToChunk("" + html));
          }
        }
      }
      var didWarnDefaultInputValue = false;
      var didWarnDefaultChecked = false;
      var didWarnDefaultSelectValue = false;
      var didWarnDefaultTextareaValue = false;
      var didWarnInvalidOptionChildren = false;
      var didWarnInvalidOptionInnerHTML = false;
      var didWarnSelectedSetOnOption = false;
      function checkSelectProp(props, propName) {
        {
          var value = props[propName];
          if (value != null) {
            var array2 = isArray(value);
            if (props.multiple && !array2) {
              error("The `%s` prop supplied to <select> must be an array if " + "`multiple` is true.", propName);
            } else if (!props.multiple && array2) {
              error("The `%s` prop supplied to <select> must be a scalar " + "value if `multiple` is false.", propName);
            }
          }
        }
      }
      function pushStartSelect(target, props, responseState) {
        {
          checkControlledValueProps("select", props);
          checkSelectProp(props, "value");
          checkSelectProp(props, "defaultValue");
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {
            error("Select elements must be either controlled or uncontrolled " + "(specify either the value prop, or the defaultValue prop, but not " + "both). Decide between using a controlled or uncontrolled select " + "element and remove one of these props. More info: " + "https://reactjs.org/link/controlled-components");
            didWarnDefaultSelectValue = true;
          }
        }
        target.push(startChunkForTag("select"));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      function flattenOptionChildren(children) {
        var content = "";
        React.Children.forEach(children, function(child) {
          if (child == null) {
            return;
          }
          content += child;
          {
            if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
              didWarnInvalidOptionChildren = true;
              error("Cannot infer the option value of complex children. " + "Pass a `value` prop or use a plain string as children to <option>.");
            }
          }
        });
        return content;
      }
      var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
      function pushStartOption(target, props, responseState, formatContext) {
        var selectedValue = formatContext.selectedValue;
        target.push(startChunkForTag("option"));
        var children = null;
        var value = null;
        var selected = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "selected":
                selected = propValue;
                {
                  if (!didWarnSelectedSetOnOption) {
                    error("Use the `defaultValue` or `value` props on <select> instead of " + "setting `selected` on <option>.");
                    didWarnSelectedSetOnOption = true;
                  }
                }
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "value":
                value = propValue;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (selectedValue != null) {
          var stringValue;
          if (value !== null) {
            {
              checkAttributeStringCoercion(value, "value");
            }
            stringValue = "" + value;
          } else {
            {
              if (innerHTML !== null) {
                if (!didWarnInvalidOptionInnerHTML) {
                  didWarnInvalidOptionInnerHTML = true;
                  error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows " + "which value should be selected.");
                }
              }
            }
            stringValue = flattenOptionChildren(children);
          }
          if (isArray(selectedValue)) {
            for (var i = 0;i < selectedValue.length; i++) {
              {
                checkAttributeStringCoercion(selectedValue[i], "value");
              }
              var v3 = "" + selectedValue[i];
              if (v3 === stringValue) {
                target.push(selectedMarkerAttribute);
                break;
              }
            }
          } else {
            {
              checkAttributeStringCoercion(selectedValue, "select.value");
            }
            if ("" + selectedValue === stringValue) {
              target.push(selectedMarkerAttribute);
            }
          }
        } else if (selected) {
          target.push(selectedMarkerAttribute);
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      function pushInput(target, props, responseState) {
        {
          checkControlledValueProps("input", props);
          if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnDefaultChecked) {
            error("%s contains an input of type %s with both checked and defaultChecked props. " + "Input elements must be either controlled or uncontrolled " + "(specify either the checked prop, or the defaultChecked prop, but not " + "both). Decide between using a controlled or uncontrolled input " + "element and remove one of these props. More info: " + "https://reactjs.org/link/controlled-components", "A component", props.type);
            didWarnDefaultChecked = true;
          }
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultInputValue) {
            error("%s contains an input of type %s with both value and defaultValue props. " + "Input elements must be either controlled or uncontrolled " + "(specify either the value prop, or the defaultValue prop, but not " + "both). Decide between using a controlled or uncontrolled input " + "element and remove one of these props. More info: " + "https://reactjs.org/link/controlled-components", "A component", props.type);
            didWarnDefaultInputValue = true;
          }
        }
        target.push(startChunkForTag("input"));
        var value = null;
        var defaultValue = null;
        var checked = null;
        var defaultChecked = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("input" + " is a self-closing tag and must neither have `children` nor " + "use `dangerouslySetInnerHTML`.");
              case "defaultChecked":
                defaultChecked = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "checked":
                checked = propValue;
                break;
              case "value":
                value = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (checked !== null) {
          pushAttribute(target, responseState, "checked", checked);
        } else if (defaultChecked !== null) {
          pushAttribute(target, responseState, "checked", defaultChecked);
        }
        if (value !== null) {
          pushAttribute(target, responseState, "value", value);
        } else if (defaultValue !== null) {
          pushAttribute(target, responseState, "value", defaultValue);
        }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushStartTextArea(target, props, responseState) {
        {
          checkControlledValueProps("textarea", props);
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {
            error("Textarea elements must be either controlled or uncontrolled " + "(specify either the value prop, or the defaultValue prop, but not " + "both). Decide between using a controlled or uncontrolled textarea " + "and remove one of these props. More info: " + "https://reactjs.org/link/controlled-components");
            didWarnDefaultTextareaValue = true;
          }
        }
        target.push(startChunkForTag("textarea"));
        var value = null;
        var defaultValue = null;
        var children = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "value":
                value = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (value === null && defaultValue !== null) {
          value = defaultValue;
        }
        target.push(endOfStartTag);
        if (children != null) {
          {
            error("Use the `defaultValue` or `value` props instead of setting " + "children on <textarea>.");
          }
          if (value != null) {
            throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          }
          if (isArray(children)) {
            if (children.length > 1) {
              throw new Error("<textarea> can only have at most one child.");
            }
            {
              checkHtmlStringCoercion(children[0]);
            }
            value = "" + children[0];
          }
          {
            checkHtmlStringCoercion(children);
          }
          value = "" + children;
        }
        if (typeof value === "string" && value[0] === "\n") {
          target.push(leadingNewline);
        }
        if (value !== null) {
          {
            checkAttributeStringCoercion(value, "value");
          }
          target.push(stringToChunk(encodeHTMLTextNode("" + value)));
        }
        return null;
      }
      function pushSelfClosing(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error(tag + " is a self-closing tag and must neither have `children` nor " + "use `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushStartMenuItem(target, props, responseState) {
        target.push(startChunkForTag("menuitem"));
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        return null;
      }
      function pushStartTitle(target, props, responseState) {
        target.push(startChunkForTag("title"));
        var children = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        {
          var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
          if (Array.isArray(children) && children.length > 1) {
            error("A title element received an array with more than 1 element as children. " + "In browsers title Elements can only have Text Nodes as children. If " + "the children being rendered output more than a single text node in aggregate the browser " + "will display markup and comments as text in the title and hydration will likely fail and " + "fall back to client rendering");
          } else if (child != null && child.$$typeof != null) {
            error("A title element received a React element for children. " + "In the browser title Elements can only have Text Nodes as children. If " + "the children being rendered output more than a single text node in aggregate the browser " + "will display markup and comments as text in the title and hydration will likely fail and " + "fall back to client rendering");
          } else if (child != null && typeof child !== "string" && typeof child !== "number") {
            error("A title element received a value that was not a string or number for children. " + "In the browser title Elements can only have Text Nodes as children. If " + "the children being rendered output more than a single text node in aggregate the browser " + "will display markup and comments as text in the title and hydration will likely fail and " + "fall back to client rendering");
          }
        }
        return children;
      }
      function pushStartGenericElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        if (typeof children === "string") {
          target.push(stringToChunk(encodeHTMLTextNode(children)));
          return null;
        }
        return children;
      }
      function pushStartCustomElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "style":
                pushStyle(target, responseState, propValue);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                  target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                }
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      var leadingNewline = stringToPrecomputedChunk("\n");
      function pushStartPreformattedElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        if (innerHTML != null) {
          if (children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. " + "Please visit https://reactjs.org/link/dangerously-set-inner-html " + "for more information.");
          }
          var html = innerHTML.__html;
          if (html !== null && html !== undefined) {
            if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
              target.push(leadingNewline, stringToChunk(html));
            } else {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        if (typeof children === "string" && children[0] === "\n") {
          target.push(leadingNewline);
        }
        return children;
      }
      var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
      var validatedTagCache = new Map;
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (tagStartChunk === undefined) {
          if (!VALID_TAG_REGEX.test(tag)) {
            throw new Error("Invalid tag: " + tag);
          }
          tagStartChunk = stringToPrecomputedChunk("<" + tag);
          validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
      function pushStartInstance(target, type, props, responseState, formatContext) {
        {
          validateProperties(type, props);
          validateProperties$1(type, props);
          validateProperties$2(type, props, null);
          if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
            error("A component is `contentEditable` and contains `children` managed by " + "React. It is now your responsibility to guarantee that none of " + "those nodes are unexpectedly modified or duplicated. This is " + "probably not intentional.");
          }
          if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
            if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
              error("<%s /> is using incorrect casing. " + "Use PascalCase for React components, " + "or lowercase for HTML elements.", type);
            }
          }
        }
        switch (type) {
          case "select":
            return pushStartSelect(target, props, responseState);
          case "option":
            return pushStartOption(target, props, responseState, formatContext);
          case "textarea":
            return pushStartTextArea(target, props, responseState);
          case "input":
            return pushInput(target, props, responseState);
          case "menuitem":
            return pushStartMenuItem(target, props, responseState);
          case "title":
            return pushStartTitle(target, props, responseState);
          case "listing":
          case "pre": {
            return pushStartPreformattedElement(target, props, type, responseState);
          }
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr": {
            return pushSelfClosing(target, props, type, responseState);
          }
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph": {
            return pushStartGenericElement(target, props, type, responseState);
          }
          case "html": {
            if (formatContext.insertionMode === ROOT_HTML_MODE) {
              target.push(DOCTYPE);
            }
            return pushStartGenericElement(target, props, type, responseState);
          }
          default: {
            if (type.indexOf("-") === -1 && typeof props.is !== "string") {
              return pushStartGenericElement(target, props, type, responseState);
            } else {
              return pushStartCustomElement(target, props, type, responseState);
            }
          }
        }
      }
      var endTag1 = stringToPrecomputedChunk("</");
      var endTag2 = stringToPrecomputedChunk(">");
      function pushEndInstance(target, type, props) {
        switch (type) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr": {
            break;
          }
          default: {
            target.push(endTag1, stringToChunk(type), endTag2);
          }
        }
      }
      function writeCompletedRoot(destination, responseState) {
        var bootstrapChunks = responseState.bootstrapChunks;
        var i = 0;
        for (;i < bootstrapChunks.length - 1; i++) {
          writeChunk(destination, bootstrapChunks[i]);
        }
        if (i < bootstrapChunks.length) {
          return writeChunkAndReturn(destination, bootstrapChunks[i]);
        }
        return true;
      }
      var placeholder1 = stringToPrecomputedChunk('<template id="');
      var placeholder2 = stringToPrecomputedChunk('"></template>');
      function writePlaceholder(destination, responseState, id) {
        writeChunk(destination, placeholder1);
        writeChunk(destination, responseState.placeholderPrefix);
        var formattedID = stringToChunk(id.toString(16));
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, placeholder2);
      }
      var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
      var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
      var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
      var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
      var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
      var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
      var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
      var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
      var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
      var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
      var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
      function writeStartCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
      }
      function writeStartPendingSuspenseBoundary(destination, responseState, id) {
        writeChunk(destination, startPendingSuspenseBoundary1);
        if (id === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        writeChunk(destination, id);
        return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
      }
      function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
        var result2;
        result2 = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
        writeChunk(destination, clientRenderedSuspenseBoundaryError1);
        if (errorDigest) {
          writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
          writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
          writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
        }
        {
          if (errorMesssage) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
        }
        result2 = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
        return result2;
      }
      function writeEndCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndPendingSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
      var startSegmentHTML2 = stringToPrecomputedChunk('">');
      var endSegmentHTML = stringToPrecomputedChunk("</div>");
      var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
      var startSegmentSVG2 = stringToPrecomputedChunk('">');
      var endSegmentSVG = stringToPrecomputedChunk("</svg>");
      var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
      var startSegmentMathML2 = stringToPrecomputedChunk('">');
      var endSegmentMathML = stringToPrecomputedChunk("</math>");
      var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
      var startSegmentTable2 = stringToPrecomputedChunk('">');
      var endSegmentTable = stringToPrecomputedChunk("</table>");
      var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
      var startSegmentTableBody2 = stringToPrecomputedChunk('">');
      var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
      var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
      var startSegmentTableRow2 = stringToPrecomputedChunk('">');
      var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
      var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
      var startSegmentColGroup2 = stringToPrecomputedChunk('">');
      var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
      function writeStartSegment(destination, responseState, formatContext, id) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            writeChunk(destination, startSegmentHTML);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentHTML2);
          }
          case SVG_MODE: {
            writeChunk(destination, startSegmentSVG);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentSVG2);
          }
          case MATHML_MODE: {
            writeChunk(destination, startSegmentMathML);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentMathML2);
          }
          case HTML_TABLE_MODE: {
            writeChunk(destination, startSegmentTable);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTable2);
          }
          case HTML_TABLE_BODY_MODE: {
            writeChunk(destination, startSegmentTableBody);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTableBody2);
          }
          case HTML_TABLE_ROW_MODE: {
            writeChunk(destination, startSegmentTableRow);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTableRow2);
          }
          case HTML_COLGROUP_MODE: {
            writeChunk(destination, startSegmentColGroup);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentColGroup2);
          }
          default: {
            throw new Error("Unknown insertion mode. This is a bug in React.");
          }
        }
      }
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            return writeChunkAndReturn(destination, endSegmentHTML);
          }
          case SVG_MODE: {
            return writeChunkAndReturn(destination, endSegmentSVG);
          }
          case MATHML_MODE: {
            return writeChunkAndReturn(destination, endSegmentMathML);
          }
          case HTML_TABLE_MODE: {
            return writeChunkAndReturn(destination, endSegmentTable);
          }
          case HTML_TABLE_BODY_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableBody);
          }
          case HTML_TABLE_ROW_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableRow);
          }
          case HTML_COLGROUP_MODE: {
            return writeChunkAndReturn(destination, endSegmentColGroup);
          }
          default: {
            throw new Error("Unknown insertion mode. This is a bug in React.");
          }
        }
      }
      var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
      var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
      var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
      var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
      var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
      var completeSegmentScript2 = stringToPrecomputedChunk('","');
      var completeSegmentScript3 = stringToPrecomputedChunk('")</script>');
      function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteSegmentFunction) {
          responseState.sentCompleteSegmentFunction = true;
          writeChunk(destination, completeSegmentScript1Full);
        } else {
          writeChunk(destination, completeSegmentScript1Partial);
        }
        writeChunk(destination, responseState.segmentPrefix);
        var formattedID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, formattedID);
        writeChunk(destination, completeSegmentScript2);
        writeChunk(destination, responseState.placeholderPrefix);
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, completeSegmentScript3);
      }
      var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
      var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
      var completeBoundaryScript2 = stringToPrecomputedChunk('","');
      var completeBoundaryScript3 = stringToPrecomputedChunk('")</script>');
      function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteBoundaryFunction) {
          responseState.sentCompleteBoundaryFunction = true;
          writeChunk(destination, completeBoundaryScript1Full);
        } else {
          writeChunk(destination, completeBoundaryScript1Partial);
        }
        if (boundaryID === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        var formattedContentID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, boundaryID);
        writeChunk(destination, completeBoundaryScript2);
        writeChunk(destination, responseState.segmentPrefix);
        writeChunk(destination, formattedContentID);
        return writeChunkAndReturn(destination, completeBoundaryScript3);
      }
      var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
      var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
      var clientRenderScript1A = stringToPrecomputedChunk('"');
      var clientRenderScript2 = stringToPrecomputedChunk(")</script>");
      var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
      function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentClientRenderFunction) {
          responseState.sentClientRenderFunction = true;
          writeChunk(destination, clientRenderScript1Full);
        } else {
          writeChunk(destination, clientRenderScript1Partial);
        }
        if (boundaryID === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        writeChunk(destination, boundaryID);
        writeChunk(destination, clientRenderScript1A);
        if (errorDigest || errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
        }
        if (errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
        }
        if (errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
        }
        return writeChunkAndReturn(destination, clientRenderScript2);
      }
      var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
      function escapeJSStringsForInstructionScripts(input) {
        var escaped = JSON.stringify(input);
        return escaped.replace(regexForJSStringsInScripts, function(match) {
          switch (match) {
            case "<":
              return "\\u003c";
            case "\u2028":
              return "\\u2028";
            case "\u2029":
              return "\\u2029";
            default: {
              throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
            }
          }
        });
      }
      var assign = Object.assign;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_SCOPE_TYPE = Symbol.for("react.scope");
      var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
      var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
      var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). " + "This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return getComponentNameFromType(init2(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. " + "This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name2, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name2;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn3, construct) {
        if (!fn3 || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn3);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn3, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn3.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn3();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s2 = sampleLines.length - 1;
            var c2 = controlLines.length - 1;
            while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {
              c2--;
            }
            for (;s2 >= 1 && c2 >= 0; s2--, c2--) {
              if (sampleLines[s2] !== controlLines[c2]) {
                if (s2 !== 1 || c2 !== 1) {
                  do {
                    s2--;
                    c2--;
                    if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {
                      var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                      if (fn3.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn3.displayName);
                      }
                      {
                        if (typeof fn3 === "function") {
                          componentFrameCache.set(fn3, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s2 >= 1 && c2 >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name2 = fn3 ? fn3.displayName || fn3.name : "";
        var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
        {
          if (typeof fn3 === "function") {
            componentFrameCache.set(fn3, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        {
          return describeNativeComponentFrame(ctor, true);
        }
      }
      function describeFunctionComponentFrame(fn3, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn3, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values2, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; " + "it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`." + "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s" + " `%s` is invalid; the type checker " + "function must return `null` or an `Error` but returned a %s. " + "You may have forgotten to pass an argument to the type checker " + "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " + "shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var warnedAboutMissingGetChildContext;
      {
        warnedAboutMissingGetChildContext = {};
      }
      var emptyContextObject = {};
      {
        Object.freeze(emptyContextObject);
      }
      function getMaskedContext(type, unmaskedContext) {
        {
          var contextTypes = type.contextTypes;
          if (!contextTypes) {
            return emptyContextObject;
          }
          var context = {};
          for (var key in contextTypes) {
            context[key] = unmaskedContext[key];
          }
          {
            var name2 = getComponentNameFromType(type) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name2);
          }
          return context;
        }
      }
      function processChildContext(instance, type, parentContext, childContextTypes) {
        {
          if (typeof instance.getChildContext !== "function") {
            {
              var componentName = getComponentNameFromType(type) || "Unknown";
              if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true;
                error("%s.childContextTypes is specified but there is no getChildContext() method " + "on the instance. You can either define getChildContext() on %s or remove " + "childContextTypes from it.", componentName, componentName);
              }
            }
            return parentContext;
          }
          var childContext = instance.getChildContext();
          for (var contextKey in childContext) {
            if (!(contextKey in childContextTypes)) {
              throw new Error((getComponentNameFromType(type) || "Unknown") + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes.");
            }
          }
          {
            var name2 = getComponentNameFromType(type) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name2);
          }
          return assign({}, parentContext, childContext);
        }
      }
      var rendererSigil;
      {
        rendererSigil = {};
      }
      var rootContextSnapshot = null;
      var currentActiveSnapshot = null;
      function popNode(prev) {
        {
          prev.context._currentValue = prev.parentValue;
        }
      }
      function pushNode(next) {
        {
          next.context._currentValue = next.value;
        }
      }
      function popToNearestCommonAncestor(prev, next) {
        if (prev === next)
          ;
        else {
          popNode(prev);
          var parentPrev = prev.parent;
          var parentNext = next.parent;
          if (parentPrev === null) {
            if (parentNext !== null) {
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            }
          } else {
            if (parentNext === null) {
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            }
            popToNearestCommonAncestor(parentPrev, parentNext);
          }
          pushNode(next);
        }
      }
      function popAllPrevious(prev) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev !== null) {
          popAllPrevious(parentPrev);
        }
      }
      function pushAllNext(next) {
        var parentNext = next.parent;
        if (parentNext !== null) {
          pushAllNext(parentNext);
        }
        pushNode(next);
      }
      function popPreviousToCommonLevel(prev, next) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev === null) {
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        }
        if (parentPrev.depth === next.depth) {
          popToNearestCommonAncestor(parentPrev, next);
        } else {
          popPreviousToCommonLevel(parentPrev, next);
        }
      }
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (parentNext === null) {
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        }
        if (prev.depth === parentNext.depth) {
          popToNearestCommonAncestor(prev, parentNext);
        } else {
          popNextToCommonLevel(prev, parentNext);
        }
        pushNode(next);
      }
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot;
        var next = newSnapshot;
        if (prev !== next) {
          if (prev === null) {
            pushAllNext(next);
          } else if (next === null) {
            popAllPrevious(prev);
          } else if (prev.depth === next.depth) {
            popToNearestCommonAncestor(prev, next);
          } else if (prev.depth > next.depth) {
            popPreviousToCommonLevel(prev, next);
          } else {
            popNextToCommonLevel(prev, next);
          }
          currentActiveSnapshot = next;
        }
      }
      function pushProvider(context, nextValue) {
        var prevValue;
        {
          prevValue = context._currentValue;
          context._currentValue = nextValue;
          {
            if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
              error("Detected multiple renderers concurrently rendering the " + "same context provider. This is currently unsupported.");
            }
            context._currentRenderer = rendererSigil;
          }
        }
        var prevNode = currentActiveSnapshot;
        var newNode = {
          parent: prevNode,
          depth: prevNode === null ? 0 : prevNode.depth + 1,
          context,
          parentValue: prevValue,
          value: nextValue
        };
        currentActiveSnapshot = newNode;
        return newNode;
      }
      function popProvider(context) {
        var prevSnapshot = currentActiveSnapshot;
        if (prevSnapshot === null) {
          throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
        }
        {
          if (prevSnapshot.context !== context) {
            error("The parent context is not the expected context. This is probably a bug in React.");
          }
        }
        {
          var value = prevSnapshot.parentValue;
          if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
            prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
          } else {
            prevSnapshot.context._currentValue = value;
          }
          {
            if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
              error("Detected multiple renderers concurrently rendering the " + "same context provider. This is currently unsupported.");
            }
            context._currentRenderer = rendererSigil;
          }
        }
        return currentActiveSnapshot = prevSnapshot.parent;
      }
      function getActiveContext() {
        return currentActiveSnapshot;
      }
      function readContext(context) {
        var value = context._currentValue;
        return value;
      }
      function get2(key) {
        return key._reactInternals;
      }
      function set(key, value) {
        key._reactInternals = value;
      }
      var didWarnAboutNoopUpdateForComponent = {};
      var didWarnAboutDeprecatedWillMount = {};
      var didWarnAboutUninitializedState;
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
      var didWarnAboutLegacyLifecyclesAndDerivedState;
      var didWarnAboutUndefinedDerivedState;
      var warnOnUndefinedDerivedState;
      var warnOnInvalidCallback;
      var didWarnAboutDirectlyAssigningPropsToState;
      var didWarnAboutContextTypeAndContextTypes;
      var didWarnAboutInvalidateContextType;
      {
        didWarnAboutUninitializedState = new Set;
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set;
        didWarnAboutLegacyLifecyclesAndDerivedState = new Set;
        didWarnAboutDirectlyAssigningPropsToState = new Set;
        didWarnAboutUndefinedDerivedState = new Set;
        didWarnAboutContextTypeAndContextTypes = new Set;
        didWarnAboutInvalidateContextType = new Set;
        var didWarnOnInvalidCallback = new Set;
        warnOnInvalidCallback = function(callback, callerName) {
          if (callback === null || typeof callback === "function") {
            return;
          }
          var key = callerName + "_" + callback;
          if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            error("%s(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callerName, callback);
          }
        };
        warnOnUndefinedDerivedState = function(type, partialState) {
          if (partialState === undefined) {
            var componentName = getComponentNameFromType(type) || "Component";
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName);
              error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. " + "You have returned undefined.", componentName);
            }
          }
        };
      }
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor;
          var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
          var warningKey = componentName + "." + callerName;
          if (didWarnAboutNoopUpdateForComponent[warningKey]) {
            return;
          }
          error("%s(...): Can only update a mounting component. " + "This usually means you called %s() outside componentWillMount() on the server. " + "This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
          didWarnAboutNoopUpdateForComponent[warningKey] = true;
        }
      }
      var classComponentUpdater = {
        isMounted: function(inst) {
          return false;
        },
        enqueueSetState: function(inst, payload, callback) {
          var internals = get2(inst);
          if (internals.queue === null) {
            warnNoop(inst, "setState");
          } else {
            internals.queue.push(payload);
            {
              if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          }
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var internals = get2(inst);
          internals.replace = true;
          internals.queue = [payload];
          {
            if (callback !== undefined && callback !== null) {
              warnOnInvalidCallback(callback, "setState");
            }
          }
        },
        enqueueForceUpdate: function(inst, callback) {
          var internals = get2(inst);
          if (internals.queue === null) {
            warnNoop(inst, "forceUpdate");
          } else {
            {
              if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          }
        }
      };
      function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        {
          warnOnUndefinedDerivedState(ctor, partialState);
        }
        var newState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);
        return newState;
      }
      function constructClassInstance(ctor, props, maskedLegacyContext) {
        var context = emptyContextObject;
        var contextType = ctor.contextType;
        {
          if ("contextType" in ctor) {
            var isValid2 = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined;
            if (!isValid2 && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor);
              var addendum = "";
              if (contextType === undefined) {
                addendum = " However, it is set to undefined. " + "This can be caused by a typo or by mixing up named and default imports. " + "This can also happen due to a circular dependency, so " + "try moving the createContext() call to a separate file.";
              } else if (typeof contextType !== "object") {
                addendum = " However, it is set to a " + typeof contextType + ".";
              } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                addendum = " Did you accidentally pass the Context.Provider instead?";
              } else if (contextType._context !== undefined) {
                addendum = " Did you accidentally pass the Context.Consumer instead?";
              } else {
                addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              }
              error("%s defines an invalid contextType. " + "contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
            }
          }
        }
        if (typeof contextType === "object" && contextType !== null) {
          context = readContext(contextType);
        } else {
          context = maskedLegacyContext;
        }
        var instance = new ctor(props, context);
        {
          if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === undefined)) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName);
              error("`%s` uses `getDerivedStateFromProps` but its initial state is " + "%s. This is not recommended. Instead, define the initial state by " + "assigning an object to `this.state` in the constructor of `%s`. " + "This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
            }
          }
          if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;
            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
              foundWillMountName = "componentWillMount";
            } else if (typeof instance.UNSAFE_componentWillMount === "function") {
              foundWillMountName = "UNSAFE_componentWillMount";
            }
            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              foundWillReceivePropsName = "componentWillReceiveProps";
            } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
            }
            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              foundWillUpdateName = "componentWillUpdate";
            } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              foundWillUpdateName = "UNSAFE_componentWillUpdate";
            }
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType(ctor) || "Component";
              var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + "%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n" + "The above lifecycles should be removed. Learn more about this warning here:\n" + "https://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
              }
            }
          }
        }
        return instance;
      }
      function checkClassInstance(instance, ctor, newProps) {
        {
          var name2 = getComponentNameFromType(ctor) || "Component";
          var renderPresent = instance.render;
          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === "function") {
              error("%s(...): No `render` method found on the returned component " + "instance: did you accidentally return an object from the constructor?", name2);
            } else {
              error("%s(...): No `render` method found on the returned component " + "instance: you may have forgotten to define `render`.", name2);
            }
          }
          if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
            error("getInitialState was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Did you mean to define a state property instead?", name2);
          }
          if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Use a static property to define defaultProps instead.", name2);
          }
          if (instance.propTypes) {
            error("propTypes was defined as an instance property on %s. Use a static " + "property to define propTypes instead.", name2);
          }
          if (instance.contextType) {
            error("contextType was defined as an instance property on %s. Use a static " + "property to define contextType instead.", name2);
          }
          {
            if (instance.contextTypes) {
              error("contextTypes was defined as an instance property on %s. Use a static " + "property to define contextTypes instead.", name2);
            }
            if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
              didWarnAboutContextTypeAndContextTypes.add(ctor);
              error("%s declares both contextTypes and contextType static properties. " + "The legacy contextTypes property will be ignored.", name2);
            }
          }
          if (typeof instance.componentShouldUpdate === "function") {
            error("%s has a method called " + "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " + "The name is phrased as a question because the function is " + "expected to return a value.", name2);
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
            error("%s has a method called shouldComponentUpdate(). " + "shouldComponentUpdate should not be used when extending React.PureComponent. " + "Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
          }
          if (typeof instance.componentDidUnmount === "function") {
            error("%s has a method called " + "componentDidUnmount(). But there is no such lifecycle method. " + "Did you mean componentWillUnmount()?", name2);
          }
          if (typeof instance.componentDidReceiveProps === "function") {
            error("%s has a method called " + "componentDidReceiveProps(). But there is no such lifecycle method. " + "If you meant to update the state in response to changing props, " + "use componentWillReceiveProps(). If you meant to fetch data or " + "run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name2);
          }
          if (typeof instance.componentWillRecieveProps === "function") {
            error("%s has a method called " + "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name2);
          }
          if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
            error("%s has a method called " + "UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name2);
          }
          var hasMutatedProps = instance.props !== newProps;
          if (instance.props !== undefined && hasMutatedProps) {
            error("%s(...): When calling super() in `%s`, make sure to pass " + "up the same props that your component's constructor was passed.", name2, name2);
          }
          if (instance.defaultProps) {
            error("Setting defaultProps as an instance property on %s is not supported and will be ignored." + " Instead, define defaultProps as a static property on %s.", name2, name2);
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). " + "This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
          }
          if (typeof instance.getDerivedStateFromProps === "function") {
            error("%s: getDerivedStateFromProps() is defined as an instance method " + "and will be ignored. Instead, declare it as a static method.", name2);
          }
          if (typeof instance.getDerivedStateFromError === "function") {
            error("%s: getDerivedStateFromError() is defined as an instance method " + "and will be ignored. Instead, declare it as a static method.", name2);
          }
          if (typeof ctor.getSnapshotBeforeUpdate === "function") {
            error("%s: getSnapshotBeforeUpdate() is defined as a static method " + "and will be ignored. Instead, declare it as an instance method.", name2);
          }
          var _state = instance.state;
          if (_state && (typeof _state !== "object" || isArray(_state))) {
            error("%s.state: must be set to an object or null", name2);
          }
          if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
            error("%s.getChildContext(): childContextTypes must be defined in order to " + "use getChildContext().", name2);
          }
        }
      }
      function callComponentWillMount(type, instance) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount === "function") {
          {
            if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
              var componentName = getComponentNameFromType(type) || "Unknown";
              if (!didWarnAboutDeprecatedWillMount[componentName]) {
                warn("componentWillMount has been renamed, and is not recommended for use. " + "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" + "* Move code from componentWillMount to componentDidMount (preferred in most cases) " + "or the constructor.\n" + "\nPlease update the following components: %s", componentName);
                didWarnAboutDeprecatedWillMount[componentName] = true;
              }
            }
          }
          instance.componentWillMount();
        }
        if (typeof instance.UNSAFE_componentWillMount === "function") {
          instance.UNSAFE_componentWillMount();
        }
        if (oldState !== instance.state) {
          {
            error("%s.componentWillMount(): Assigning directly to this.state is " + "deprecated (except inside a component's " + "constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }
      function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
        if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
          var oldQueue = internalInstance.queue;
          var oldReplace = internalInstance.replace;
          internalInstance.queue = null;
          internalInstance.replace = false;
          if (oldReplace && oldQueue.length === 1) {
            inst.state = oldQueue[0];
          } else {
            var nextState = oldReplace ? oldQueue[0] : inst.state;
            var dontMutate = true;
            for (var i = oldReplace ? 1 : 0;i < oldQueue.length; i++) {
              var partial = oldQueue[i];
              var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
              if (partialState != null) {
                if (dontMutate) {
                  dontMutate = false;
                  nextState = assign({}, nextState, partialState);
                } else {
                  assign(nextState, partialState);
                }
              }
            }
            inst.state = nextState;
          }
        } else {
          internalInstance.queue = null;
        }
      }
      function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
        {
          checkClassInstance(instance, ctor, newProps);
        }
        var initialState = instance.state !== undefined ? instance.state : null;
        instance.updater = classComponentUpdater;
        instance.props = newProps;
        instance.state = initialState;
        var internalInstance = {
          queue: [],
          replace: false
        };
        set(instance, internalInstance);
        var contextType = ctor.contextType;
        if (typeof contextType === "object" && contextType !== null) {
          instance.context = readContext(contextType);
        } else {
          instance.context = maskedLegacyContext;
        }
        {
          if (instance.state === newProps) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName);
              error("%s: It is not recommended to assign props directly to state " + "because updates to props won't be reflected in state. " + "In most cases, it is better to use props directly.", componentName);
            }
          }
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === "function") {
          instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
        }
        if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
          callComponentWillMount(ctor, instance);
          processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
        }
      }
      var emptyTreeContext = {
        id: 1,
        overflow: ""
      };
      function getTreeId(context) {
        var overflow = context.overflow;
        var idWithLeadingBit = context.id;
        var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id.toString(32) + overflow;
      }
      function pushTreeContext(baseContext, totalChildren, index2) {
        var baseIdWithLeadingBit = baseContext.id;
        var baseOverflow = baseContext.overflow;
        var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
        var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
        var slot = index2 + 1;
        var length = getBitLength(totalChildren) + baseLength;
        if (length > 30) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          var newOverflowBits = (1 << numberOfOverflowBits) - 1;
          var newOverflow = (baseId & newOverflowBits).toString(32);
          var restOfBaseId = baseId >> numberOfOverflowBits;
          var restOfBaseLength = baseLength - numberOfOverflowBits;
          var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
          var restOfNewBits = slot << restOfBaseLength;
          var id = restOfNewBits | restOfBaseId;
          var overflow = newOverflow + baseOverflow;
          return {
            id: 1 << restOfLength | id,
            overflow
          };
        } else {
          var newBits = slot << baseLength;
          var _id = newBits | baseId;
          var _overflow = baseOverflow;
          return {
            id: 1 << length | _id,
            overflow: _overflow
          };
        }
      }
      function getBitLength(number) {
        return 32 - clz32(number);
      }
      function getLeadingBit(id) {
        return 1 << getBitLength(id) - 1;
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x) {
        var asUint = x >>> 0;
        if (asUint === 0) {
          return 32;
        }
        return 31 - (log(asUint) / LN2 | 0) | 0;
      }
      function is3(x, y2) {
        return x === y2 && (x !== 0 || 1 / x === 1 / y2) || x !== x && y2 !== y2;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is3;
      var currentlyRenderingComponent = null;
      var currentlyRenderingTask = null;
      var firstWorkInProgressHook = null;
      var workInProgressHook = null;
      var isReRender = false;
      var didScheduleRenderPhaseUpdate = false;
      var localIdCounter = 0;
      var renderPhaseUpdates = null;
      var numberOfReRenders = 0;
      var RE_RENDER_LIMIT = 25;
      var isInHookUserCodeInDev = false;
      var currentHookNameInDev;
      function resolveCurrentlyRenderingComponent() {
        if (currentlyRenderingComponent === null) {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for" + " one of the following reasons:\n" + "1. You might have mismatching versions of React and the renderer (such as React DOM)\n" + "2. You might be breaking the Rules of Hooks\n" + "3. You might have more than one copy of React in the same app\n" + "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        }
        {
          if (isInHookUserCodeInDev) {
            error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. " + "You can only call Hooks at the top level of your React function. " + "For more information, see " + "https://reactjs.org/link/rules-of-hooks");
          }
        }
        return currentlyRenderingComponent;
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null) {
          {
            error("%s received a final argument during this render, but not during " + "the previous render. Even though the final argument is optional, " + "its type cannot change between renders.", currentHookNameInDev);
          }
          return false;
        }
        {
          if (nextDeps.length !== prevDeps.length) {
            error("The final argument passed to %s changed size between renders. The " + "order and size of this array must remain constant.\n\n" + "Previous: %s\n" + "Incoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
          }
        }
        for (var i = 0;i < prevDeps.length && i < nextDeps.length; i++) {
          if (objectIs(nextDeps[i], prevDeps[i])) {
            continue;
          }
          return false;
        }
        return true;
      }
      function createHook() {
        if (numberOfReRenders > 0) {
          throw new Error("Rendered more hooks than during the previous render");
        }
        return {
          memoizedState: null,
          queue: null,
          next: null
        };
      }
      function createWorkInProgressHook() {
        if (workInProgressHook === null) {
          if (firstWorkInProgressHook === null) {
            isReRender = false;
            firstWorkInProgressHook = workInProgressHook = createHook();
          } else {
            isReRender = true;
            workInProgressHook = firstWorkInProgressHook;
          }
        } else {
          if (workInProgressHook.next === null) {
            isReRender = false;
            workInProgressHook = workInProgressHook.next = createHook();
          } else {
            isReRender = true;
            workInProgressHook = workInProgressHook.next;
          }
        }
        return workInProgressHook;
      }
      function prepareToUseHooks(task, componentIdentity) {
        currentlyRenderingComponent = componentIdentity;
        currentlyRenderingTask = task;
        {
          isInHookUserCodeInDev = false;
        }
        localIdCounter = 0;
      }
      function finishHooks(Component, props, children, refOrContext) {
        while (didScheduleRenderPhaseUpdate) {
          didScheduleRenderPhaseUpdate = false;
          localIdCounter = 0;
          numberOfReRenders += 1;
          workInProgressHook = null;
          children = Component(props, refOrContext);
        }
        resetHooksState();
        return children;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0;
        return didRenderIdHook;
      }
      function resetHooksState() {
        {
          isInHookUserCodeInDev = false;
        }
        currentlyRenderingComponent = null;
        currentlyRenderingTask = null;
        didScheduleRenderPhaseUpdate = false;
        firstWorkInProgressHook = null;
        numberOfReRenders = 0;
        renderPhaseUpdates = null;
        workInProgressHook = null;
      }
      function readContext$1(context) {
        {
          if (isInHookUserCodeInDev) {
            error("Context can only be read while React is rendering. " + "In classes, you can read it in the render method or getDerivedStateFromProps. " + "In function components, you can read it directly in the function body, but not " + "inside Hooks like useReducer() or useMemo().");
          }
        }
        return readContext(context);
      }
      function useContext(context) {
        {
          currentHookNameInDev = "useContext";
        }
        resolveCurrentlyRenderingComponent();
        return readContext(context);
      }
      function basicStateReducer(state, action) {
        return typeof action === "function" ? action(state) : action;
      }
      function useState(initialState) {
        {
          currentHookNameInDev = "useState";
        }
        return useReducer(basicStateReducer, initialState);
      }
      function useReducer(reducer, initialArg, init2) {
        {
          if (reducer !== basicStateReducer) {
            currentHookNameInDev = "useReducer";
          }
        }
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        if (isReRender) {
          var queue3 = workInProgressHook.queue;
          var dispatch = queue3.dispatch;
          if (renderPhaseUpdates !== null) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue3);
            if (firstRenderPhaseUpdate !== undefined) {
              renderPhaseUpdates.delete(queue3);
              var newState = workInProgressHook.memoizedState;
              var update = firstRenderPhaseUpdate;
              do {
                var action = update.action;
                {
                  isInHookUserCodeInDev = true;
                }
                newState = reducer(newState, action);
                {
                  isInHookUserCodeInDev = false;
                }
                update = update.next;
              } while (update !== null);
              workInProgressHook.memoizedState = newState;
              return [newState, dispatch];
            }
          }
          return [workInProgressHook.memoizedState, dispatch];
        } else {
          {
            isInHookUserCodeInDev = true;
          }
          var initialState;
          if (reducer === basicStateReducer) {
            initialState = typeof initialArg === "function" ? initialArg() : initialArg;
          } else {
            initialState = init2 !== undefined ? init2(initialArg) : initialArg;
          }
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = initialState;
          var _queue = workInProgressHook.queue = {
            last: null,
            dispatch: null
          };
          var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
          return [workInProgressHook.memoizedState, _dispatch];
        }
      }
      function useMemo(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        if (workInProgressHook !== null) {
          var prevState = workInProgressHook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
        }
        {
          isInHookUserCodeInDev = true;
        }
        var nextValue = nextCreate();
        {
          isInHookUserCodeInDev = false;
        }
        workInProgressHook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }
      function useRef(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var previousRef = workInProgressHook.memoizedState;
        if (previousRef === null) {
          var ref = {
            current: initialValue
          };
          {
            Object.seal(ref);
          }
          workInProgressHook.memoizedState = ref;
          return ref;
        } else {
          return previousRef;
        }
      }
      function useLayoutEffect(create, inputs) {
        {
          currentHookNameInDev = "useLayoutEffect";
          error("useLayoutEffect does nothing on the server, because its effect cannot " + "be encoded into the server renderer's output format. This will lead " + "to a mismatch between the initial, non-hydrated UI and the intended " + "UI. To avoid this, useLayoutEffect should only be used in " + "components that render exclusively on the client. " + "See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
        }
      }
      function dispatchAction(componentIdentity, queue3, action) {
        if (numberOfReRenders >= RE_RENDER_LIMIT) {
          throw new Error("Too many re-renders. React limits the number of renders to prevent " + "an infinite loop.");
        }
        if (componentIdentity === currentlyRenderingComponent) {
          didScheduleRenderPhaseUpdate = true;
          var update = {
            action,
            next: null
          };
          if (renderPhaseUpdates === null) {
            renderPhaseUpdates = new Map;
          }
          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue3);
          if (firstRenderPhaseUpdate === undefined) {
            renderPhaseUpdates.set(queue3, update);
          } else {
            var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
            while (lastRenderPhaseUpdate.next !== null) {
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            }
            lastRenderPhaseUpdate.next = update;
          }
        }
      }
      function useCallback(callback, deps) {
        return useMemo(function() {
          return callback;
        }, deps);
      }
      function useMutableSource(source, getSnapshot, subscribe2) {
        resolveCurrentlyRenderingComponent();
        return getSnapshot(source._source);
      }
      function useSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === undefined) {
          throw new Error("Missing getServerSnapshot, which is required for " + "server-rendered content. Will revert to client rendering.");
        }
        return getServerSnapshot();
      }
      function useDeferredValue(value) {
        resolveCurrentlyRenderingComponent();
        return value;
      }
      function unsupportedStartTransition() {
        throw new Error("startTransition cannot be called during server rendering.");
      }
      function useTransition() {
        resolveCurrentlyRenderingComponent();
        return [false, unsupportedStartTransition];
      }
      function useId() {
        var task = currentlyRenderingTask;
        var treeId = getTreeId(task.treeContext);
        var responseState = currentResponseState;
        if (responseState === null) {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
        }
        var localId = localIdCounter++;
        return makeId(responseState, treeId, localId);
      }
      function noop3() {
      }
      var Dispatcher = {
        readContext: readContext$1,
        useContext,
        useMemo,
        useReducer,
        useRef,
        useState,
        useInsertionEffect: noop3,
        useLayoutEffect,
        useCallback,
        useImperativeHandle: noop3,
        useEffect: noop3,
        useDebugValue: noop3,
        useDeferredValue,
        useTransition,
        useId,
        useMutableSource,
        useSyncExternalStore
      };
      var currentResponseState = null;
      function setCurrentResponseState(responseState) {
        currentResponseState = responseState;
      }
      function getStackByComponentStackNode(componentStack) {
        try {
          var info = "";
          var node3 = componentStack;
          do {
            switch (node3.tag) {
              case 0:
                info += describeBuiltInComponentFrame(node3.type, null, null);
                break;
              case 1:
                info += describeFunctionComponentFrame(node3.type, null, null);
                break;
              case 2:
                info += describeClassComponentFrame(node3.type, null, null);
                break;
            }
            node3 = node3.parent;
          } while (node3);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      var PENDING = 0;
      var COMPLETED = 1;
      var FLUSHED = 2;
      var ABORTED = 3;
      var ERRORED = 4;
      var OPEN = 0;
      var CLOSING = 1;
      var CLOSED = 2;
      var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
      function defaultErrorHandler(error2) {
        console["error"](error2);
        return null;
      }
      function noop$1() {
      }
      function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {
        var pingedTasks = [];
        var abortSet = new Set;
        var request = {
          destination: null,
          responseState,
          progressiveChunkSize: progressiveChunkSize === undefined ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
          status: OPEN,
          fatalError: null,
          nextSegmentId: 0,
          allPendingTasks: 0,
          pendingRootTasks: 0,
          completedRootSegment: null,
          abortableTasks: abortSet,
          pingedTasks,
          clientRenderedBoundaries: [],
          completedBoundaries: [],
          partialBoundaries: [],
          onError: onError === undefined ? defaultErrorHandler : onError,
          onAllReady: onAllReady === undefined ? noop$1 : onAllReady,
          onShellReady: onShellReady === undefined ? noop$1 : onShellReady,
          onShellError: onShellError === undefined ? noop$1 : onShellError,
          onFatalError: onFatalError === undefined ? noop$1 : onFatalError
        };
        var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false);
        rootSegment.parentFlushed = true;
        var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
        pingedTasks.push(rootTask);
        return request;
      }
      function pingTask(request, task) {
        var pingedTasks = request.pingedTasks;
        pingedTasks.push(task);
        if (pingedTasks.length === 1) {
          scheduleWork(function() {
            return performWork(request);
          });
        }
      }
      function createSuspenseBoundary(request, fallbackAbortableTasks) {
        return {
          id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
          rootSegmentID: -1,
          parentFlushed: false,
          pendingTasks: 0,
          forceClientRender: false,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null
        };
      }
      function createTask(request, node3, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
        request.allPendingTasks++;
        if (blockedBoundary === null) {
          request.pendingRootTasks++;
        } else {
          blockedBoundary.pendingTasks++;
        }
        var task = {
          node: node3,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment,
          abortSet,
          legacyContext,
          context,
          treeContext
        };
        {
          task.componentStack = null;
        }
        abortSet.add(task);
        return task;
      }
      function createPendingSegment(request, index2, boundary, formatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          id: -1,
          index: index2,
          parentFlushed: false,
          chunks: [],
          children: [],
          formatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      var currentTaskInDEV = null;
      function getCurrentStackInDEV() {
        {
          if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
            return "";
          }
          return getStackByComponentStackNode(currentTaskInDEV.componentStack);
        }
      }
      function pushBuiltInComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 0,
            parent: task.componentStack,
            type
          };
        }
      }
      function pushFunctionComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 1,
            parent: task.componentStack,
            type
          };
        }
      }
      function pushClassComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 2,
            parent: task.componentStack,
            type
          };
        }
      }
      function popComponentStackInDEV(task) {
        {
          if (task.componentStack === null) {
            error("Unexpectedly popped too many stack frames. This is a bug in React.");
          } else {
            task.componentStack = task.componentStack.parent;
          }
        }
      }
      var lastBoundaryErrorComponentStackDev = null;
      function captureBoundaryErrorDetailsDev(boundary, error2) {
        {
          var errorMessage;
          if (typeof error2 === "string") {
            errorMessage = error2;
          } else if (error2 && typeof error2.message === "string") {
            errorMessage = error2.message;
          } else {
            errorMessage = String(error2);
          }
          var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
          lastBoundaryErrorComponentStackDev = null;
          boundary.errorMessage = errorMessage;
          boundary.errorComponentStack = errorComponentStack;
        }
      }
      function logRecoverableError(request, error2) {
        var errorDigest = request.onError(error2);
        if (errorDigest != null && typeof errorDigest !== "string") {
          throw new Error("onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"" + typeof errorDigest + "\" instead");
        }
        return errorDigest;
      }
      function fatalError(request, error2) {
        var onShellError = request.onShellError;
        onShellError(error2);
        var onFatalError = request.onFatalError;
        onFatalError(error2);
        if (request.destination !== null) {
          request.status = CLOSED;
          closeWithError(request.destination, error2);
        } else {
          request.status = CLOSING;
          request.fatalError = error2;
        }
      }
      function renderSuspenseBoundary(request, task, props) {
        pushBuiltInComponentStackInDEV(task, "Suspense");
        var parentBoundary = task.blockedBoundary;
        var parentSegment = task.blockedSegment;
        var fallback = props.fallback;
        var content = props.children;
        var fallbackAbortSet = new Set;
        var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
        var insertionIndex = parentSegment.chunks.length;
        var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, parentSegment.formatContext, false, false);
        parentSegment.children.push(boundarySegment);
        parentSegment.lastPushedText = false;
        var contentRootSegment = createPendingSegment(request, 0, null, parentSegment.formatContext, false, false);
        contentRootSegment.parentFlushed = true;
        task.blockedBoundary = newBoundary;
        task.blockedSegment = contentRootSegment;
        try {
          renderNode2(request, task, content);
          pushSegmentFinale(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
          contentRootSegment.status = COMPLETED;
          queueCompletedSegment(newBoundary, contentRootSegment);
          if (newBoundary.pendingTasks === 0) {
            popComponentStackInDEV(task);
            return;
          }
        } catch (error2) {
          contentRootSegment.status = ERRORED;
          newBoundary.forceClientRender = true;
          newBoundary.errorDigest = logRecoverableError(request, error2);
          {
            captureBoundaryErrorDetailsDev(newBoundary, error2);
          }
        } finally {
          task.blockedBoundary = parentBoundary;
          task.blockedSegment = parentSegment;
        }
        var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
        {
          suspendedFallbackTask.componentStack = task.componentStack;
        }
        request.pingedTasks.push(suspendedFallbackTask);
        popComponentStackInDEV(task);
      }
      function renderHostElement(request, task, type, props) {
        pushBuiltInComponentStackInDEV(task, type);
        var segment = task.blockedSegment;
        var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
        segment.lastPushedText = false;
        var prevContext = segment.formatContext;
        segment.formatContext = getChildFormatContext(prevContext, type, props);
        renderNode2(request, task, children);
        segment.formatContext = prevContext;
        pushEndInstance(segment.chunks, type);
        segment.lastPushedText = false;
        popComponentStackInDEV(task);
      }
      function shouldConstruct$1(Component) {
        return Component.prototype && Component.prototype.isReactComponent;
      }
      function renderWithHooks(request, task, Component, props, secondArg) {
        var componentIdentity = {};
        prepareToUseHooks(task, componentIdentity);
        var result2 = Component(props, secondArg);
        return finishHooks(Component, props, result2, secondArg);
      }
      function finishClassComponent(request, task, instance, Component, props) {
        var nextChildren = instance.render();
        {
          if (instance.props !== props) {
            if (!didWarnAboutReassigningProps) {
              error("It looks like %s is reassigning its own `this.props` while rendering. " + "This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
            }
            didWarnAboutReassigningProps = true;
          }
        }
        {
          var childContextTypes = Component.childContextTypes;
          if (childContextTypes !== null && childContextTypes !== undefined) {
            var previousContext = task.legacyContext;
            var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
            task.legacyContext = mergedContext;
            renderNodeDestructive(request, task, nextChildren);
            task.legacyContext = previousContext;
            return;
          }
        }
        renderNodeDestructive(request, task, nextChildren);
      }
      function renderClassComponent(request, task, Component, props) {
        pushClassComponentStackInDEV(task, Component);
        var maskedContext = getMaskedContext(Component, task.legacyContext);
        var instance = constructClassInstance(Component, props, maskedContext);
        mountClassInstance(instance, Component, props, maskedContext);
        finishClassComponent(request, task, instance, Component, props);
        popComponentStackInDEV(task);
      }
      var didWarnAboutBadClass = {};
      var didWarnAboutModulePatternComponent = {};
      var didWarnAboutContextTypeOnFunctionComponent = {};
      var didWarnAboutGetDerivedStateOnFunctionComponent = {};
      var didWarnAboutReassigningProps = false;
      var didWarnAboutGenerators = false;
      var didWarnAboutMaps = false;
      var hasWarnedAboutUsingContextAsConsumer = false;
      function renderIndeterminateComponent(request, task, Component, props) {
        var legacyContext;
        {
          legacyContext = getMaskedContext(Component, task.legacyContext);
        }
        pushFunctionComponentStackInDEV(task, Component);
        {
          if (Component.prototype && typeof Component.prototype.render === "function") {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutBadClass[componentName]) {
              error("The <%s /> component appears to have a render method, but doesn't extend React.Component. " + "This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
              didWarnAboutBadClass[componentName] = true;
            }
          }
        }
        var value = renderWithHooks(request, task, Component, props, legacyContext);
        var hasId = checkDidRenderIdHook();
        {
          if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === undefined) {
            var _componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName]) {
              error("The <%s /> component appears to be a function component that returns a class instance. " + "Change %s to a class that extends React.Component instead. " + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + "cannot be called with `new` by React.", _componentName, _componentName, _componentName);
              didWarnAboutModulePatternComponent[_componentName] = true;
            }
          }
        }
        if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === undefined) {
          {
            var _componentName2 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
              error("The <%s /> component appears to be a function component that returns a class instance. " + "Change %s to a class that extends React.Component instead. " + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + "cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
              didWarnAboutModulePatternComponent[_componentName2] = true;
            }
          }
          mountClassInstance(value, Component, props, legacyContext);
          finishClassComponent(request, task, value, Component, props);
        } else {
          {
            validateFunctionComponentInDev(Component);
          }
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index2 = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index2);
            try {
              renderNodeDestructive(request, task, value);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request, task, value);
          }
        }
        popComponentStackInDEV(task);
      }
      function validateFunctionComponentInDev(Component) {
        {
          if (Component) {
            if (Component.childContextTypes) {
              error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
            }
          }
          if (typeof Component.getDerivedStateFromProps === "function") {
            var _componentName3 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
              error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
            }
          }
          if (typeof Component.contextType === "object" && Component.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
              error("%s: Function components do not support contextType.", _componentName4);
              didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
            }
          }
        }
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = assign({}, baseProps);
          var defaultProps = Component.defaultProps;
          for (var propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
          return props;
        }
        return baseProps;
      }
      function renderForwardRef(request, task, type, props, ref) {
        pushFunctionComponentStackInDEV(task, type.render);
        var children = renderWithHooks(request, task, type.render, props, ref);
        var hasId = checkDidRenderIdHook();
        if (hasId) {
          var prevTreeContext = task.treeContext;
          var totalChildren = 1;
          var index2 = 0;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index2);
          try {
            renderNodeDestructive(request, task, children);
          } finally {
            task.treeContext = prevTreeContext;
          }
        } else {
          renderNodeDestructive(request, task, children);
        }
        popComponentStackInDEV(task);
      }
      function renderMemo(request, task, type, props, ref) {
        var innerType = type.type;
        var resolvedProps = resolveDefaultProps(innerType, props);
        renderElement(request, task, innerType, resolvedProps, ref);
      }
      function renderContextConsumer(request, task, context, props) {
        {
          if (context._context === undefined) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true;
                error("Rendering <Context> directly is not supported and will be removed in " + "a future major release. Did you mean to render <Context.Consumer> instead?");
              }
            }
          } else {
            context = context._context;
          }
        }
        var render2 = props.children;
        {
          if (typeof render2 !== "function") {
            error("A context consumer was rendered with multiple children, or a child " + "that isn't a function. A context consumer expects a single child " + "that is a function. If you did pass a function, make sure there " + "is no trailing or leading whitespace around it.");
          }
        }
        var newValue = readContext(context);
        var newChildren = render2(newValue);
        renderNodeDestructive(request, task, newChildren);
      }
      function renderContextProvider(request, task, type, props) {
        var context = type._context;
        var value = props.value;
        var children = props.children;
        var prevSnapshot;
        {
          prevSnapshot = task.context;
        }
        task.context = pushProvider(context, value);
        renderNodeDestructive(request, task, children);
        task.context = popProvider(context);
        {
          if (prevSnapshot !== task.context) {
            error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
          }
        }
      }
      function renderLazyComponent(request, task, lazyComponent, props, ref) {
        pushBuiltInComponentStackInDEV(task, "Lazy");
        var payload = lazyComponent._payload;
        var init2 = lazyComponent._init;
        var Component = init2(payload);
        var resolvedProps = resolveDefaultProps(Component, props);
        renderElement(request, task, Component, resolvedProps, ref);
        popComponentStackInDEV(task);
      }
      function renderElement(request, task, type, props, ref) {
        if (typeof type === "function") {
          if (shouldConstruct$1(type)) {
            renderClassComponent(request, task, type, props);
            return;
          } else {
            renderIndeterminateComponent(request, task, type, props);
            return;
          }
        }
        if (typeof type === "string") {
          renderHostElement(request, task, type, props);
          return;
        }
        switch (type) {
          case REACT_LEGACY_HIDDEN_TYPE:
          case REACT_DEBUG_TRACING_MODE_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_FRAGMENT_TYPE: {
            renderNodeDestructive(request, task, props.children);
            return;
          }
          case REACT_SUSPENSE_LIST_TYPE: {
            pushBuiltInComponentStackInDEV(task, "SuspenseList");
            renderNodeDestructive(request, task, props.children);
            popComponentStackInDEV(task);
            return;
          }
          case REACT_SCOPE_TYPE: {
            throw new Error("ReactDOMServer does not yet support scope components.");
          }
          case REACT_SUSPENSE_TYPE: {
            {
              renderSuspenseBoundary(request, task, props);
            }
            return;
          }
        }
        if (typeof type === "object" && type !== null) {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE: {
              renderForwardRef(request, task, type, props, ref);
              return;
            }
            case REACT_MEMO_TYPE: {
              renderMemo(request, task, type, props, ref);
              return;
            }
            case REACT_PROVIDER_TYPE: {
              renderContextProvider(request, task, type, props);
              return;
            }
            case REACT_CONTEXT_TYPE: {
              renderContextConsumer(request, task, type, props);
              return;
            }
            case REACT_LAZY_TYPE: {
              renderLazyComponent(request, task, type, props);
              return;
            }
          }
        }
        var info = "";
        {
          if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
            info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and " + "named imports.";
          }
        }
        throw new Error("Element type is invalid: expected a string (for built-in " + "components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
      }
      function validateIterable(iterable, iteratorFn) {
        {
          if (typeof Symbol === "function" && iterable[Symbol.toStringTag] === "Generator") {
            if (!didWarnAboutGenerators) {
              error("Using Generators as children is unsupported and will likely yield " + "unexpected results because enumerating a generator mutates it. " + "You may convert it to an array with `Array.from()` or the " + "`[...spread]` operator before rendering. Keep in mind " + "you might need to polyfill these features for older browsers.");
            }
            didWarnAboutGenerators = true;
          }
          if (iterable.entries === iteratorFn) {
            if (!didWarnAboutMaps) {
              error("Using Maps as children is not supported. " + "Use an array of keyed ReactElements instead.");
            }
            didWarnAboutMaps = true;
          }
        }
      }
      function renderNodeDestructive(request, task, node3) {
        {
          try {
            return renderNodeDestructiveImpl(request, task, node3);
          } catch (x) {
            if (typeof x === "object" && x !== null && typeof x.then === "function")
              ;
            else {
              lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
            }
            throw x;
          }
        }
      }
      function renderNodeDestructiveImpl(request, task, node3) {
        task.node = node3;
        if (typeof node3 === "object" && node3 !== null) {
          switch (node3.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              var element = node3;
              var type = element.type;
              var props = element.props;
              var ref = element.ref;
              renderElement(request, task, type, props, ref);
              return;
            }
            case REACT_PORTAL_TYPE:
              throw new Error("Portals are not currently supported by the server renderer. " + "Render them conditionally so that they only appear on the client render.");
            case REACT_LAZY_TYPE: {
              var lazyNode = node3;
              var payload = lazyNode._payload;
              var init2 = lazyNode._init;
              var resolvedNode;
              {
                try {
                  resolvedNode = init2(payload);
                } catch (x) {
                  if (typeof x === "object" && x !== null && typeof x.then === "function") {
                    pushBuiltInComponentStackInDEV(task, "Lazy");
                  }
                  throw x;
                }
              }
              renderNodeDestructive(request, task, resolvedNode);
              return;
            }
          }
          if (isArray(node3)) {
            renderChildrenArray(request, task, node3);
            return;
          }
          var iteratorFn = getIteratorFn(node3);
          if (iteratorFn) {
            {
              validateIterable(node3, iteratorFn);
            }
            var iterator = iteratorFn.call(node3);
            if (iterator) {
              var step = iterator.next();
              if (!step.done) {
                var children = [];
                do {
                  children.push(step.value);
                  step = iterator.next();
                } while (!step.done);
                renderChildrenArray(request, task, children);
                return;
              }
              return;
            }
          }
          var childString = Object.prototype.toString.call(node3);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node3).join(", ") + "}" : childString) + "). " + "If you meant to render a collection of children, use an array " + "instead.");
        }
        if (typeof node3 === "string") {
          var segment = task.blockedSegment;
          segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, node3, request.responseState, segment.lastPushedText);
          return;
        }
        if (typeof node3 === "number") {
          var _segment = task.blockedSegment;
          _segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, "" + node3, request.responseState, _segment.lastPushedText);
          return;
        }
        {
          if (typeof node3 === "function") {
            error("Functions are not valid as a React child. This may happen if " + "you return a Component instead of <Component /> from render. " + "Or maybe you meant to call this function rather than return it.");
          }
        }
      }
      function renderChildrenArray(request, task, children) {
        var totalChildren = children.length;
        for (var i = 0;i < totalChildren; i++) {
          var prevTreeContext = task.treeContext;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
          try {
            renderNode2(request, task, children[i]);
          } finally {
            task.treeContext = prevTreeContext;
          }
        }
      }
      function spawnNewSuspendedTask(request, task, x) {
        var segment = task.blockedSegment;
        var insertionIndex = segment.chunks.length;
        var newSegment = createPendingSegment(request, insertionIndex, null, segment.formatContext, segment.lastPushedText, true);
        segment.children.push(newSegment);
        segment.lastPushedText = false;
        var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
        {
          if (task.componentStack !== null) {
            newTask.componentStack = task.componentStack.parent;
          }
        }
        var ping = newTask.ping;
        x.then(ping, ping);
      }
      function renderNode2(request, task, node3) {
        var previousFormatContext = task.blockedSegment.formatContext;
        var previousLegacyContext = task.legacyContext;
        var previousContext = task.context;
        var previousComponentStack = null;
        {
          previousComponentStack = task.componentStack;
        }
        try {
          return renderNodeDestructive(request, task, node3);
        } catch (x) {
          resetHooksState();
          if (typeof x === "object" && x !== null && typeof x.then === "function") {
            spawnNewSuspendedTask(request, task, x);
            task.blockedSegment.formatContext = previousFormatContext;
            task.legacyContext = previousLegacyContext;
            task.context = previousContext;
            switchContext(previousContext);
            {
              task.componentStack = previousComponentStack;
            }
            return;
          } else {
            task.blockedSegment.formatContext = previousFormatContext;
            task.legacyContext = previousLegacyContext;
            task.context = previousContext;
            switchContext(previousContext);
            {
              task.componentStack = previousComponentStack;
            }
            throw x;
          }
        }
      }
      function erroredTask(request, boundary, segment, error2) {
        var errorDigest = logRecoverableError(request, error2);
        if (boundary === null) {
          fatalError(request, error2);
        } else {
          boundary.pendingTasks--;
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true;
            boundary.errorDigest = errorDigest;
            {
              captureBoundaryErrorDetailsDev(boundary, error2);
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary);
            }
          }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function abortTaskSoft(task) {
        var request = this;
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        finishedTask(request, boundary, segment);
      }
      function abortTask(task, request, reason) {
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        if (boundary === null) {
          request.allPendingTasks--;
          if (request.status !== CLOSED) {
            request.status = CLOSED;
            if (request.destination !== null) {
              close(request.destination);
            }
          }
        } else {
          boundary.pendingTasks--;
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true;
            var _error = reason === undefined ? new Error("The render was aborted by the server without a reason.") : reason;
            boundary.errorDigest = request.onError(_error);
            {
              var errorPrefix = "The server did not finish this Suspense boundary: ";
              if (_error && typeof _error.message === "string") {
                _error = errorPrefix + _error.message;
              } else {
                _error = errorPrefix + String(_error);
              }
              var previousTaskInDev = currentTaskInDEV;
              currentTaskInDEV = task;
              try {
                captureBoundaryErrorDetailsDev(boundary, _error);
              } finally {
                currentTaskInDEV = previousTaskInDev;
              }
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary);
            }
          }
          boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, reason);
          });
          boundary.fallbackAbortableTasks.clear();
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
      }
      function queueCompletedSegment(boundary, segment) {
        if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id;
          childSegment.parentFlushed = true;
          if (childSegment.status === COMPLETED) {
            queueCompletedSegment(boundary, childSegment);
          }
        } else {
          var completedSegments = boundary.completedSegments;
          completedSegments.push(segment);
        }
      }
      function finishedTask(request, boundary, segment) {
        if (boundary === null) {
          if (segment.parentFlushed) {
            if (request.completedRootSegment !== null) {
              throw new Error("There can only be one root segment. This is a bug in React.");
            }
            request.completedRootSegment = segment;
          }
          request.pendingRootTasks--;
          if (request.pendingRootTasks === 0) {
            request.onShellError = noop$1;
            var onShellReady = request.onShellReady;
            onShellReady();
          }
        } else {
          boundary.pendingTasks--;
          if (boundary.forceClientRender)
            ;
          else if (boundary.pendingTasks === 0) {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment);
              }
            }
            if (boundary.parentFlushed) {
              request.completedBoundaries.push(boundary);
            }
            boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
            boundary.fallbackAbortableTasks.clear();
          } else {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment);
                var completedSegments = boundary.completedSegments;
                if (completedSegments.length === 1) {
                  if (boundary.parentFlushed) {
                    request.partialBoundaries.push(boundary);
                  }
                }
              }
            }
          }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function retryTask(request, task) {
        var segment = task.blockedSegment;
        if (segment.status !== PENDING) {
          return;
        }
        switchContext(task.context);
        var prevTaskInDEV = null;
        {
          prevTaskInDEV = currentTaskInDEV;
          currentTaskInDEV = task;
        }
        try {
          renderNodeDestructive(request, task, task.node);
          pushSegmentFinale(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
          task.abortSet.delete(task);
          segment.status = COMPLETED;
          finishedTask(request, task.blockedBoundary, segment);
        } catch (x) {
          resetHooksState();
          if (typeof x === "object" && x !== null && typeof x.then === "function") {
            var ping = task.ping;
            x.then(ping, ping);
          } else {
            task.abortSet.delete(task);
            segment.status = ERRORED;
            erroredTask(request, task.blockedBoundary, segment, x);
          }
        } finally {
          {
            currentTaskInDEV = prevTaskInDEV;
          }
        }
      }
      function performWork(request) {
        if (request.status === CLOSED) {
          return;
        }
        var prevContext = getActiveContext();
        var prevDispatcher = ReactCurrentDispatcher$1.current;
        ReactCurrentDispatcher$1.current = Dispatcher;
        var prevGetCurrentStackImpl;
        {
          prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
          ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
        }
        var prevResponseState = currentResponseState;
        setCurrentResponseState(request.responseState);
        try {
          var pingedTasks = request.pingedTasks;
          var i;
          for (i = 0;i < pingedTasks.length; i++) {
            var task = pingedTasks[i];
            retryTask(request, task);
          }
          pingedTasks.splice(0, i);
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination);
          }
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        } finally {
          setCurrentResponseState(prevResponseState);
          ReactCurrentDispatcher$1.current = prevDispatcher;
          {
            ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
          }
          if (prevDispatcher === Dispatcher) {
            switchContext(prevContext);
          }
        }
      }
      function flushSubtree(request, destination, segment) {
        segment.parentFlushed = true;
        switch (segment.status) {
          case PENDING: {
            var segmentID = segment.id = request.nextSegmentId++;
            segment.lastPushedText = false;
            segment.textEmbedded = false;
            return writePlaceholder(destination, request.responseState, segmentID);
          }
          case COMPLETED: {
            segment.status = FLUSHED;
            var r2 = true;
            var chunks = segment.chunks;
            var chunkIdx = 0;
            var children = segment.children;
            for (var childIdx = 0;childIdx < children.length; childIdx++) {
              var nextChild = children[childIdx];
              for (;chunkIdx < nextChild.index; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              r2 = flushSegment(request, destination, nextChild);
            }
            for (;chunkIdx < chunks.length - 1; chunkIdx++) {
              writeChunk(destination, chunks[chunkIdx]);
            }
            if (chunkIdx < chunks.length) {
              r2 = writeChunkAndReturn(destination, chunks[chunkIdx]);
            }
            return r2;
          }
          default: {
            throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
          }
        }
      }
      function flushSegment(request, destination, segment) {
        var boundary = segment.boundary;
        if (boundary === null) {
          return flushSubtree(request, destination, segment);
        }
        boundary.parentFlushed = true;
        if (boundary.forceClientRender) {
          writeStartClientRenderedSuspenseBoundary(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
          flushSubtree(request, destination, segment);
          return writeEndClientRenderedSuspenseBoundary(destination, request.responseState);
        } else if (boundary.pendingTasks > 0) {
          boundary.rootSegmentID = request.nextSegmentId++;
          if (boundary.completedSegments.length > 0) {
            request.partialBoundaries.push(boundary);
          }
          var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
          writeStartPendingSuspenseBoundary(destination, request.responseState, id);
          flushSubtree(request, destination, segment);
          return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else if (boundary.byteSize > request.progressiveChunkSize) {
          boundary.rootSegmentID = request.nextSegmentId++;
          request.completedBoundaries.push(boundary);
          writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
          flushSubtree(request, destination, segment);
          return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else {
          writeStartCompletedSuspenseBoundary(destination, request.responseState);
          var completedSegments = boundary.completedSegments;
          if (completedSegments.length !== 1) {
            throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
          }
          var contentSegment = completedSegments[0];
          flushSegment(request, destination, contentSegment);
          return writeEndCompletedSuspenseBoundary(destination, request.responseState);
        }
      }
      function flushClientRenderedBoundary(request, destination, boundary) {
        return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
      }
      function flushSegmentContainer(request, destination, segment) {
        writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
        flushSegment(request, destination, segment);
        return writeEndSegment(destination, segment.formatContext);
      }
      function flushCompletedBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for (;i < completedSegments.length; i++) {
          var segment = completedSegments[i];
          flushPartiallyCompletedSegment(request, destination, boundary, segment);
        }
        completedSegments.length = 0;
        return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
      }
      function flushPartialBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for (;i < completedSegments.length; i++) {
          var segment = completedSegments[i];
          if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
            i++;
            completedSegments.splice(0, i);
            return false;
          }
        }
        completedSegments.splice(0, i);
        return true;
      }
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED) {
          return true;
        }
        var segmentID = segment.id;
        if (segmentID === -1) {
          var rootSegmentID = segment.id = boundary.rootSegmentID;
          if (rootSegmentID === -1) {
            throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
          }
          return flushSegmentContainer(request, destination, segment);
        } else {
          flushSegmentContainer(request, destination, segment);
          return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
        }
      }
      function flushCompletedQueues(request, destination) {
        beginWriting();
        try {
          var completedRootSegment = request.completedRootSegment;
          if (completedRootSegment !== null && request.pendingRootTasks === 0) {
            flushSegment(request, destination, completedRootSegment);
            request.completedRootSegment = null;
            writeCompletedRoot(destination, request.responseState);
          }
          var clientRenderedBoundaries = request.clientRenderedBoundaries;
          var i;
          for (i = 0;i < clientRenderedBoundaries.length; i++) {
            var boundary = clientRenderedBoundaries[i];
            if (!flushClientRenderedBoundary(request, destination, boundary)) {
              request.destination = null;
              i++;
              clientRenderedBoundaries.splice(0, i);
              return;
            }
          }
          clientRenderedBoundaries.splice(0, i);
          var completedBoundaries = request.completedBoundaries;
          for (i = 0;i < completedBoundaries.length; i++) {
            var _boundary = completedBoundaries[i];
            if (!flushCompletedBoundary(request, destination, _boundary)) {
              request.destination = null;
              i++;
              completedBoundaries.splice(0, i);
              return;
            }
          }
          completedBoundaries.splice(0, i);
          completeWriting(destination);
          beginWriting(destination);
          var partialBoundaries = request.partialBoundaries;
          for (i = 0;i < partialBoundaries.length; i++) {
            var _boundary2 = partialBoundaries[i];
            if (!flushPartialBoundary(request, destination, _boundary2)) {
              request.destination = null;
              i++;
              partialBoundaries.splice(0, i);
              return;
            }
          }
          partialBoundaries.splice(0, i);
          var largeBoundaries = request.completedBoundaries;
          for (i = 0;i < largeBoundaries.length; i++) {
            var _boundary3 = largeBoundaries[i];
            if (!flushCompletedBoundary(request, destination, _boundary3)) {
              request.destination = null;
              i++;
              largeBoundaries.splice(0, i);
              return;
            }
          }
          largeBoundaries.splice(0, i);
        } finally {
          completeWriting(destination);
          flushBuffered(destination);
          if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
            {
              if (request.abortableTasks.size !== 0) {
                error("There was still abortable task at the root when we closed. This is a bug in React.");
              }
            }
            close(destination);
          }
        }
      }
      function startWork(request) {
        scheduleWork(function() {
          return performWork(request);
        });
      }
      function startFlowing(request, destination) {
        if (request.status === CLOSING) {
          request.status = CLOSED;
          closeWithError(destination, request.fatalError);
          return;
        }
        if (request.status === CLOSED) {
          return;
        }
        if (request.destination !== null) {
          return;
        }
        request.destination = destination;
        try {
          flushCompletedQueues(request, destination);
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        }
      }
      function abort(request, reason) {
        try {
          var abortableTasks = request.abortableTasks;
          abortableTasks.forEach(function(task) {
            return abortTask(task, request, reason);
          });
          abortableTasks.clear();
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination);
          }
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        }
      }
      function createDrainHandler(destination, request) {
        return function() {
          return startFlowing(request, destination);
        };
      }
      function createAbortHandler(request, reason) {
        return function() {
          return abort(request, reason);
        };
      }
      function createRequestImpl(children, options) {
        return createRequest(children, createResponseState(options ? options.identifierPrefix : undefined, options ? options.nonce : undefined, options ? options.bootstrapScriptContent : undefined, options ? options.bootstrapScripts : undefined, options ? options.bootstrapModules : undefined), createRootFormatContext(options ? options.namespaceURI : undefined), options ? options.progressiveChunkSize : undefined, options ? options.onError : undefined, options ? options.onAllReady : undefined, options ? options.onShellReady : undefined, options ? options.onShellError : undefined, undefined);
      }
      function renderToPipeableStream(children, options) {
        var request = createRequestImpl(children, options);
        var hasStartedFlowing = false;
        startWork(request);
        return {
          pipe: function(destination) {
            if (hasStartedFlowing) {
              throw new Error("React currently only supports piping to one writable stream.");
            }
            hasStartedFlowing = true;
            startFlowing(request, destination);
            destination.on("drain", createDrainHandler(destination, request));
            destination.on("error", createAbortHandler(request, new Error("The destination stream errored while writing data.")));
            destination.on("close", createAbortHandler(request, new Error("The destination stream closed early.")));
            return destination;
          },
          abort: function(reason) {
            abort(request, reason);
          }
        };
      }
      exports.renderToPipeableStream = renderToPipeableStream;
      exports.version = ReactVersion;
    })();
  }
});

// node_modules/react-dom/server.node.js
var exports_server_node = {};
__export(exports_server_node, {
  version: () => $version,
  renderToString: () => $renderToString,
  renderToStaticNodeStream: () => $renderToStaticNodeStream,
  renderToStaticMarkup: () => $renderToStaticMarkup,
  renderToPipeableStream: () => $renderToPipeableStream,
  renderToNodeStream: () => $renderToNodeStream
});
var react_dom_server_legacy_node_development, react_dom_server_node_development, l2, s2, $version, $renderToString, $renderToStaticMarkup, $renderToNodeStream, $renderToStaticNodeStream, $renderToPipeableStream;
var init_server_node = __esm(() => {
  react_dom_server_legacy_node_development = __toESM(require_react_dom_server_legacy_node_development(), 1);
  react_dom_server_node_development = __toESM(require_react_dom_server_node_development(), 1);
  if (false) {
  } else {
    l2 = react_dom_server_legacy_node_development;
    s2 = react_dom_server_node_development;
  }
  $version = l2.version;
  $renderToString = l2.renderToString;
  $renderToStaticMarkup = l2.renderToStaticMarkup;
  $renderToNodeStream = l2.renderToNodeStream;
  $renderToStaticNodeStream = l2.renderToStaticNodeStream;
  $renderToPipeableStream = s2.renderToPipeableStream;
});

// node_modules/react/cjs/react-jsx-dev-runtime.development.js
var require_react_jsx_dev_runtime_development = __commonJS((exports) => {
  var React3 = __toESM(require_react(), 1);
  if (true) {
    (function() {
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). " + "This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return getComponentNameFromType(init2(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. " + "This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name2, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name2;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn4, construct) {
        if (!fn4 || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn4);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn4, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn4.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn4();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s3 = sampleLines.length - 1;
            var c2 = controlLines.length - 1;
            while (s3 >= 1 && c2 >= 0 && sampleLines[s3] !== controlLines[c2]) {
              c2--;
            }
            for (;s3 >= 1 && c2 >= 0; s3--, c2--) {
              if (sampleLines[s3] !== controlLines[c2]) {
                if (s3 !== 1 || c2 !== 1) {
                  do {
                    s3--;
                    c2--;
                    if (c2 < 0 || sampleLines[s3] !== controlLines[c2]) {
                      var _frame = "\n" + sampleLines[s3].replace(" at new ", " at ");
                      if (fn4.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn4.displayName);
                      }
                      {
                        if (typeof fn4 === "function") {
                          componentFrameCache.set(fn4, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s3 >= 1 && c2 >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name2 = fn4 ? fn4.displayName || fn4.name : "";
        var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
        {
          if (typeof fn4 === "function") {
            componentFrameCache.set(fn4, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn4, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn4, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values2, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; " + "it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`." + "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex2) {
                error$1 = ex2;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s" + " `%s` is invalid; the type checker " + "function must return `null` or an `Error` but returned a %s. " + "You may have forgotten to pass an argument to the type checker " + "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " + "shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e2) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s." + " This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      var didWarnAboutStringRefs;
      {
        didWarnAboutStringRefs = {};
      }
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== undefined;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== undefined;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self2) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
              error('Component "%s" contains the string ref "%s". ' + "Support for string refs will be removed in a future major release. " + "This case cannot be automatically converted to an arrow function. " + "We ask you to manually fix this case by using useRef() or createRef() instead. " + "Learn more about using refs safely here: " + "https://reactjs.org/link/strict-mode-string-ref", getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
              didWarnAboutStringRefs[componentName] = true;
            }
          }
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result " + "in `undefined` being returned. If you need to access the same " + "value within the child component, you should pass it as a different " + "prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result " + "in `undefined` being returned. If you need to access the same " + "value within the child component, you should pass it as a different " + "prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref,
          props,
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function jsxDEV(type, config, maybeKey, source, self2) {
        {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          if (maybeKey !== undefined) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key = "" + maybeKey;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          if (hasValidRef(config)) {
            ref = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self2);
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === undefined) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement2(object) {
        {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name2 = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name2) {
              return "\n\nCheck the render method of `" + name2 + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          if (source !== undefined) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.' + "%s%s See https://reactjs.org/link/warning-keys for more information.", currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node3, parentType) {
        {
          if (typeof node3 !== "object") {
            return;
          }
          if (isArray(node3)) {
            for (var i = 0;i < node3.length; i++) {
              var child = node3[i];
              if (isValidElement2(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement2(node3)) {
            if (node3._store) {
              node3._store.validated = true;
            }
          } else if (node3) {
            var iteratorFn = getIteratorFn(node3);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node3.entries) {
                var iterator = iteratorFn.call(node3);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement2(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === undefined || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name2 = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name2, element);
          } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass " + "definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment2) {
        {
          var keys = Object.keys(fragment2.props);
          for (var i = 0;i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment2);
              error("Invalid prop `%s` supplied to `React.Fragment`. " + "React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment2.ref !== null) {
            setCurrentlyValidatingElement$1(fragment2);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
        {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum(source);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            error("React.jsx: type is invalid -- expected a string (for " + "built-in components) or a class/function (for composite " + "components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV(type, props, key, source, self2);
          if (element == null) {
            return element;
          }
          if (validType) {
            var children = props.children;
            if (children !== undefined) {
              if (isStaticChildren) {
                if (isArray(children)) {
                  for (var i = 0;i < children.length; i++) {
                    validateChildKeys(children[i], type);
                  }
                  if (Object.freeze) {
                    Object.freeze(children);
                  }
                } else {
                  error("React.jsx: Static children should always be an array. " + "You are likely explicitly calling React.jsxs or React.jsxDEV. " + "Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children, type);
              }
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
      }
      var jsxDEV$1 = jsxWithValidation;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsxDEV = jsxDEV$1;
    })();
  }
});

// node_modules/react/jsx-dev-runtime.js
var require_jsx_dev_runtime = __commonJS((exports, module) => {
  var react_jsx_dev_runtime_development = __toESM(require_react_jsx_dev_runtime_development(), 1);
  if (false) {
  } else {
    module.exports = react_jsx_dev_runtime_development;
  }
});

// node_modules/cookie/index.js
var require_cookie3 = __commonJS((exports) => {
  function parse2(str, options) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var opt = options || {};
    var dec = opt.decode || decode3;
    var index2 = 0;
    while (index2 < str.length) {
      var eqIdx = str.indexOf("=", index2);
      if (eqIdx === -1) {
        break;
      }
      var endIdx = str.indexOf(";", index2);
      if (endIdx === -1) {
        endIdx = str.length;
      } else if (endIdx < eqIdx) {
        index2 = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      var key = str.slice(index2, eqIdx).trim();
      if (obj[key] === undefined) {
        var val = str.slice(eqIdx + 1, endIdx).trim();
        if (val.charCodeAt(0) === 34) {
          val = val.slice(1, -1);
        }
        obj[key] = tryDecode(val, dec);
      }
      index2 = endIdx + 1;
    }
    return obj;
  }
  function serialize2(name2, val, options) {
    var opt = options || {};
    var enc = opt.encode || encode;
    if (typeof enc !== "function") {
      throw new TypeError("option encode is invalid");
    }
    if (!fieldContentRegExp.test(name2)) {
      throw new TypeError("argument name is invalid");
    }
    var value = enc(val);
    if (value && !fieldContentRegExp.test(value)) {
      throw new TypeError("argument val is invalid");
    }
    var str = name2 + "=" + value;
    if (opt.maxAge != null) {
      var maxAge = opt.maxAge - 0;
      if (isNaN(maxAge) || !isFinite(maxAge)) {
        throw new TypeError("option maxAge is invalid");
      }
      str += "; Max-Age=" + Math.floor(maxAge);
    }
    if (opt.domain) {
      if (!fieldContentRegExp.test(opt.domain)) {
        throw new TypeError("option domain is invalid");
      }
      str += "; Domain=" + opt.domain;
    }
    if (opt.path) {
      if (!fieldContentRegExp.test(opt.path)) {
        throw new TypeError("option path is invalid");
      }
      str += "; Path=" + opt.path;
    }
    if (opt.expires) {
      var expires = opt.expires;
      if (!isDate(expires) || isNaN(expires.valueOf())) {
        throw new TypeError("option expires is invalid");
      }
      str += "; Expires=" + expires.toUTCString();
    }
    if (opt.httpOnly) {
      str += "; HttpOnly";
    }
    if (opt.secure) {
      str += "; Secure";
    }
    if (opt.priority) {
      var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError("option priority is invalid");
      }
    }
    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
      switch (sameSite) {
        case true:
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return str;
  }
  function decode3(str) {
    return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
  }
  function encode(val) {
    return encodeURIComponent(val);
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]" || val instanceof Date;
  }
  function tryDecode(str, decode4) {
    try {
      return decode4(str);
    } catch (e2) {
      return str;
    }
  }
  /*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  exports.parse = parse2;
  exports.serialize = serialize2;
  var __toString = Object.prototype.toString;
  var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
});

// node_modules/cookie-signature/index.js
var require_cookie_signature = __commonJS((exports) => {
  var crypto3 = __require("crypto");
  exports.sign = function(val, secret) {
    if (typeof val != "string")
      throw new TypeError("Cookie value must be provided as a string.");
    if (secret == null)
      throw new TypeError("Secret key must be provided.");
    return val + "." + crypto3.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
  };
  exports.unsign = function(input, secret) {
    if (typeof input != "string")
      throw new TypeError("Signed cookie string must be provided.");
    if (secret == null)
      throw new TypeError("Secret key must be provided.");
    var tentativeValue = input.slice(0, input.lastIndexOf(".")), expectedInput = exports.sign(tentativeValue, secret), expectedBuffer = Buffer.from(expectedInput), inputBuffer = Buffer.from(input);
    return expectedBuffer.length === inputBuffer.length && crypto3.timingSafeEqual(expectedBuffer, inputBuffer) ? tentativeValue : false;
  };
});

// node_modules/@elysiajs/cookie/dist/cjs/index.js
var require_cjs5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cookie = undefined;
  var elysia_1 = require_cjs2();
  var cookie_1 = require_cookie3();
  var cookie_signature_1 = require_cookie_signature();
  var cookie = (options = {}) => {
    const { signed, secret: secretKey, ...defaultOptions } = options;
    const secret = !secretKey ? undefined : typeof secretKey === "string" ? secretKey : secretKey[0];
    const isStringKey = typeof secret === "string";
    return new elysia_1.Elysia({
      name: "@elysiajs/cookie",
      seed: options
    }).decorate("unsignCookie", (value) => {
      if (!secret)
        throw new Error("No secret is provided to cookie plugin");
      let unsigned = isStringKey ? (0, cookie_signature_1.unsign)(value, secret) : false;
      if (isStringKey === false)
        for (let i = 0;i < secret.length; i++) {
          const temp = (0, cookie_signature_1.unsign)(value, secret[i]);
          if (temp) {
            unsigned = temp;
            break;
          }
        }
      return {
        valid: unsigned !== false,
        value: unsigned || undefined
      };
    }).derive((context) => {
      let _cookie;
      const getCookie = () => {
        if (_cookie)
          return _cookie;
        try {
          const headerCookie = context.request.headers.get("cookie");
          _cookie = headerCookie ? (0, cookie_1.parse)(headerCookie) : {};
        } catch (error) {
          _cookie = {};
        }
        return _cookie;
      };
      return {
        get cookie() {
          return getCookie();
        },
        setCookie(name2, value, { signed: signed2 = false, ...options2 } = {}) {
          if (signed2) {
            if (!secret)
              throw new Error("No secret is provided to cookie plugin");
            value = (0, cookie_signature_1.sign)(value, secret);
          }
          if (!Array.isArray(context.set.headers["Set-Cookie"]))
            context.set.headers["Set-Cookie"] = [];
          context.set.headers["Set-Cookie"].push((0, cookie_1.serialize)(name2, value, {
            path: "/",
            ...defaultOptions,
            ...options2
          }));
          if (!_cookie)
            getCookie();
          _cookie[name2] = value;
        },
        removeCookie(name2) {
          if (!getCookie()[name2])
            return;
          context.set.headers["Set-Cookie"] = (0, cookie_1.serialize)(name2, "", {
            expires: new Date("Thu, Jan 01 1970 00:00:00 UTC")
          });
          delete _cookie[name2];
        }
      };
    });
  };
  exports.cookie = cookie;
  exports.default = exports.cookie;
});

// node_modules/jose/dist/node/cjs/runtime/digest.js
var require_digest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto_1 = __require("crypto");
  var digest = (algorithm, data) => (0, crypto_1.createHash)(algorithm).update(data).digest();
  exports.default = digest;
});

// node_modules/jose/dist/node/cjs/lib/buffer_utils.js
var require_buffer_utils = __commonJS((exports) => {
  function concat(...buffers) {
    const size2 = buffers.reduce((acc, { length }) => acc + length, 0);
    const buf = new Uint8Array(size2);
    let i = 0;
    buffers.forEach((buffer2) => {
      buf.set(buffer2, i);
      i += buffer2.length;
    });
    return buf;
  }
  function p2s(alg, p2sInput) {
    return concat(exports.encoder.encode(alg), new Uint8Array([0]), p2sInput);
  }
  function writeUInt32BE(buf, value, offset) {
    if (value < 0 || value >= MAX_INT32) {
      throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
    }
    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 255], offset);
  }
  function uint64be(value) {
    const high = Math.floor(value / MAX_INT32);
    const low = value % MAX_INT32;
    const buf = new Uint8Array(8);
    writeUInt32BE(buf, high, 0);
    writeUInt32BE(buf, low, 4);
    return buf;
  }
  function uint32be(value) {
    const buf = new Uint8Array(4);
    writeUInt32BE(buf, value);
    return buf;
  }
  function lengthAndInput(input) {
    return concat(uint32be(input.length), input);
  }
  async function concatKdf(secret, bits, value) {
    const iterations = Math.ceil((bits >> 3) / 32);
    const res = new Uint8Array(iterations * 32);
    for (let iter = 0;iter < iterations; iter++) {
      const buf = new Uint8Array(4 + secret.length + value.length);
      buf.set(uint32be(iter + 1));
      buf.set(secret, 4);
      buf.set(value, 4 + secret.length);
      res.set(await (0, digest_js_1.default)("sha256", buf), iter * 32);
    }
    return res.slice(0, bits >> 3);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatKdf = exports.lengthAndInput = exports.uint32be = exports.uint64be = exports.p2s = exports.concat = exports.decoder = exports.encoder = undefined;
  var digest_js_1 = require_digest();
  exports.encoder = new TextEncoder;
  exports.decoder = new TextDecoder;
  var MAX_INT32 = 2 ** 32;
  exports.concat = concat;
  exports.p2s = p2s;
  exports.uint64be = uint64be;
  exports.uint32be = uint32be;
  exports.lengthAndInput = lengthAndInput;
  exports.concatKdf = concatKdf;
});

// node_modules/jose/dist/node/cjs/runtime/base64url.js
var require_base64url = __commonJS((exports) => {
  function normalize2(input) {
    let encoded = input;
    if (encoded instanceof Uint8Array) {
      encoded = buffer_utils_js_1.decoder.decode(encoded);
    }
    return encoded;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decode = exports.encode = exports.encodeBase64 = exports.decodeBase64 = undefined;
  var buffer_1 = __require("buffer");
  var buffer_utils_js_1 = require_buffer_utils();
  var encode;
  if (buffer_1.Buffer.isEncoding("base64url")) {
    exports.encode = encode = (input) => buffer_1.Buffer.from(input).toString("base64url");
  } else {
    exports.encode = encode = (input) => buffer_1.Buffer.from(input).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  var decodeBase64 = (input) => buffer_1.Buffer.from(input, "base64");
  exports.decodeBase64 = decodeBase64;
  var encodeBase64 = (input) => buffer_1.Buffer.from(input).toString("base64");
  exports.encodeBase64 = encodeBase64;
  var decode3 = (input) => buffer_1.Buffer.from(normalize2(input), "base64");
  exports.decode = decode3;
});

// node_modules/jose/dist/node/cjs/util/errors.js
var require_errors3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JWSSignatureVerificationFailed = exports.JWKSTimeout = exports.JWKSMultipleMatchingKeys = exports.JWKSNoMatchingKey = exports.JWKSInvalid = exports.JWKInvalid = exports.JWTInvalid = exports.JWSInvalid = exports.JWEInvalid = exports.JWEDecryptionFailed = exports.JOSENotSupported = exports.JOSEAlgNotAllowed = exports.JWTExpired = exports.JWTClaimValidationFailed = exports.JOSEError = undefined;

  class JOSEError extends Error {
    static get code() {
      return "ERR_JOSE_GENERIC";
    }
    constructor(message) {
      var _a3;
      super(message);
      this.code = "ERR_JOSE_GENERIC";
      this.name = this.constructor.name;
      (_a3 = Error.captureStackTrace) === null || _a3 === undefined || _a3.call(Error, this, this.constructor);
    }
  }
  exports.JOSEError = JOSEError;

  class JWTClaimValidationFailed extends JOSEError {
    static get code() {
      return "ERR_JWT_CLAIM_VALIDATION_FAILED";
    }
    constructor(message, claim = "unspecified", reason = "unspecified") {
      super(message);
      this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
      this.claim = claim;
      this.reason = reason;
    }
  }
  exports.JWTClaimValidationFailed = JWTClaimValidationFailed;

  class JWTExpired extends JOSEError {
    static get code() {
      return "ERR_JWT_EXPIRED";
    }
    constructor(message, claim = "unspecified", reason = "unspecified") {
      super(message);
      this.code = "ERR_JWT_EXPIRED";
      this.claim = claim;
      this.reason = reason;
    }
  }
  exports.JWTExpired = JWTExpired;

  class JOSEAlgNotAllowed extends JOSEError {
    constructor() {
      super(...arguments);
      this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
    }
    static get code() {
      return "ERR_JOSE_ALG_NOT_ALLOWED";
    }
  }
  exports.JOSEAlgNotAllowed = JOSEAlgNotAllowed;

  class JOSENotSupported extends JOSEError {
    constructor() {
      super(...arguments);
      this.code = "ERR_JOSE_NOT_SUPPORTED";
    }
    static get code() {
      return "ERR_JOSE_NOT_SUPPORTED";
    }
  }
  exports.JOSENotSupported = JOSENotSupported;

  class JWEDecryptionFailed extends JOSEError {
    constructor() {
      super(...arguments);
      this.code = "ERR_JWE_DECRYPTION_FAILED";
      this.message = "decryption operation failed";
    }
    static get code() {
      return "ERR_JWE_DECRYPTION_FAILED";
    }
  }
  exports.JWEDecryptionFailed = JWEDecryptionFailed;

  class JWEInvalid extends JOSEError {
    constructor() {
      super(...arguments);
      this.code = "ERR_JWE_INVALID";
    }
    static get code() {
      return "ERR_JWE_INVALID";
    }
  }
  exports.JWEInvalid = JWEInvalid;

  class JWSInvalid extends JOSEError {
    constructor() {
      super(...arguments);
      this.code = "ERR_JWS_INVALID";
    }
    static get code() {
      return "ERR_JWS_INVALID";
    }
  }
  exports.JWSInvalid = JWSInvalid;

  class JWTInvalid extends JOSEError {
    constructor() {
      super(...arguments);
      this.code = "ERR_JWT_INVALID";
    }
    static get code() {
      return "ERR_JWT_INVALID";
    }
  }
  exports.JWTInvalid = JWTInvalid;

  class JWKInvalid extends JOSEError {
    constructor() {
      super(...arguments);
      this.code = "ERR_JWK_INVALID";
    }
    static get code() {
      return "ERR_JWK_INVALID";
    }
  }
  exports.JWKInvalid = JWKInvalid;

  class JWKSInvalid extends JOSEError {
    constructor() {
      super(...arguments);
      this.code = "ERR_JWKS_INVALID";
    }
    static get code() {
      return "ERR_JWKS_INVALID";
    }
  }
  exports.JWKSInvalid = JWKSInvalid;

  class JWKSNoMatchingKey extends JOSEError {
    constructor() {
      super(...arguments);
      this.code = "ERR_JWKS_NO_MATCHING_KEY";
      this.message = "no applicable key found in the JSON Web Key Set";
    }
    static get code() {
      return "ERR_JWKS_NO_MATCHING_KEY";
    }
  }
  exports.JWKSNoMatchingKey = JWKSNoMatchingKey;

  class JWKSMultipleMatchingKeys extends JOSEError {
    constructor() {
      super(...arguments);
      this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
      this.message = "multiple matching keys found in the JSON Web Key Set";
    }
    static get code() {
      return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
    }
  }
  exports.JWKSMultipleMatchingKeys = JWKSMultipleMatchingKeys;

  class JWKSTimeout extends JOSEError {
    constructor() {
      super(...arguments);
      this.code = "ERR_JWKS_TIMEOUT";
      this.message = "request timed out";
    }
    static get code() {
      return "ERR_JWKS_TIMEOUT";
    }
  }
  exports.JWKSTimeout = JWKSTimeout;

  class JWSSignatureVerificationFailed extends JOSEError {
    constructor() {
      super(...arguments);
      this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
      this.message = "signature verification failed";
    }
    static get code() {
      return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
    }
  }
  exports.JWSSignatureVerificationFailed = JWSSignatureVerificationFailed;
});

// node_modules/jose/dist/node/cjs/runtime/random.js
var require_random = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = undefined;
  var crypto_1 = __require("crypto");
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return crypto_1.randomFillSync;
  } });
});

// node_modules/jose/dist/node/cjs/lib/iv.js
var require_iv = __commonJS((exports) => {
  function bitLength(alg) {
    switch (alg) {
      case "A128GCM":
      case "A128GCMKW":
      case "A192GCM":
      case "A192GCMKW":
      case "A256GCM":
      case "A256GCMKW":
        return 96;
      case "A128CBC-HS256":
      case "A192CBC-HS384":
      case "A256CBC-HS512":
        return 128;
      default:
        throw new errors_js_1.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bitLength = undefined;
  var errors_js_1 = require_errors3();
  var random_js_1 = require_random();
  exports.bitLength = bitLength;
  exports.default = (alg) => (0, random_js_1.default)(new Uint8Array(bitLength(alg) >> 3));
});

// node_modules/jose/dist/node/cjs/lib/check_iv_length.js
var require_check_iv_length = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var errors_js_1 = require_errors3();
  var iv_js_1 = require_iv();
  var checkIvLength = (enc, iv2) => {
    if (iv2.length << 3 !== (0, iv_js_1.bitLength)(enc)) {
      throw new errors_js_1.JWEInvalid("Invalid Initialization Vector length");
    }
  };
  exports.default = checkIvLength;
});

// node_modules/jose/dist/node/cjs/runtime/is_key_object.js
var require_is_key_object = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto_1 = __require("crypto");
  var util3 = __require("util");
  exports.default = util3.types.isKeyObject ? (obj) => util3.types.isKeyObject(obj) : (obj) => obj != null && obj instanceof crypto_1.KeyObject;
});

// node_modules/jose/dist/node/cjs/runtime/check_cek_length.js
var require_check_cek_length = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var errors_js_1 = require_errors3();
  var is_key_object_js_1 = require_is_key_object();
  var checkCekLength = (enc, cek) => {
    let expected;
    switch (enc) {
      case "A128CBC-HS256":
      case "A192CBC-HS384":
      case "A256CBC-HS512":
        expected = parseInt(enc.slice(-3), 10);
        break;
      case "A128GCM":
      case "A192GCM":
      case "A256GCM":
        expected = parseInt(enc.slice(1, 4), 10);
        break;
      default:
        throw new errors_js_1.JOSENotSupported(`Content Encryption Algorithm ${enc} is not supported either by JOSE or your javascript runtime`);
    }
    if (cek instanceof Uint8Array) {
      const actual = cek.byteLength << 3;
      if (actual !== expected) {
        throw new errors_js_1.JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
      }
      return;
    }
    if ((0, is_key_object_js_1.default)(cek) && cek.type === "secret") {
      const actual = cek.symmetricKeySize << 3;
      if (actual !== expected) {
        throw new errors_js_1.JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
      }
      return;
    }
    throw new TypeError("Invalid Content Encryption Key type");
  };
  exports.default = checkCekLength;
});

// node_modules/jose/dist/node/cjs/runtime/timing_safe_equal.js
var require_timing_safe_equal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto_1 = __require("crypto");
  var timingSafeEqual = crypto_1.timingSafeEqual;
  exports.default = timingSafeEqual;
});

// node_modules/jose/dist/node/cjs/runtime/cbc_tag.js
var require_cbc_tag = __commonJS((exports) => {
  function cbcTag(aad, iv2, ciphertext, macSize, macKey, keySize) {
    const macData = (0, buffer_utils_js_1.concat)(aad, iv2, ciphertext, (0, buffer_utils_js_1.uint64be)(aad.length << 3));
    const hmac2 = (0, crypto_1.createHmac)(`sha${macSize}`, macKey);
    hmac2.update(macData);
    return hmac2.digest().slice(0, keySize >> 3);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto_1 = __require("crypto");
  var buffer_utils_js_1 = require_buffer_utils();
  exports.default = cbcTag;
});

// node_modules/jose/dist/node/cjs/runtime/webcrypto.js
var require_webcrypto = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isCryptoKey = undefined;
  var crypto3 = __require("crypto");
  var util3 = __require("util");
  var webcrypto = crypto3.webcrypto;
  exports.default = webcrypto;
  exports.isCryptoKey = util3.types.isCryptoKey ? (key) => util3.types.isCryptoKey(key) : (key) => false;
});

// node_modules/jose/dist/node/cjs/lib/crypto_key.js
var require_crypto_key = __commonJS((exports) => {
  function unusable(name2, prop = "algorithm.name") {
    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name2}`);
  }
  function isAlgorithm(algorithm, name2) {
    return algorithm.name === name2;
  }
  function getHashLength(hash) {
    return parseInt(hash.name.slice(4), 10);
  }
  function getNamedCurve(alg) {
    switch (alg) {
      case "ES256":
        return "P-256";
      case "ES384":
        return "P-384";
      case "ES512":
        return "P-521";
      default:
        throw new Error("unreachable");
    }
  }
  function checkUsage(key, usages) {
    if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
      let msg = "CryptoKey does not support this operation, its usages must include ";
      if (usages.length > 2) {
        const last = usages.pop();
        msg += `one of ${usages.join(", ")}, or ${last}.`;
      } else if (usages.length === 2) {
        msg += `one of ${usages[0]} or ${usages[1]}.`;
      } else {
        msg += `${usages[0]}.`;
      }
      throw new TypeError(msg);
    }
  }
  function checkSigCryptoKey(key, alg, ...usages) {
    switch (alg) {
      case "HS256":
      case "HS384":
      case "HS512": {
        if (!isAlgorithm(key.algorithm, "HMAC"))
          throw unusable("HMAC");
        const expected = parseInt(alg.slice(2), 10);
        const actual = getHashLength(key.algorithm.hash);
        if (actual !== expected)
          throw unusable(`SHA-${expected}`, "algorithm.hash");
        break;
      }
      case "RS256":
      case "RS384":
      case "RS512": {
        if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
          throw unusable("RSASSA-PKCS1-v1_5");
        const expected = parseInt(alg.slice(2), 10);
        const actual = getHashLength(key.algorithm.hash);
        if (actual !== expected)
          throw unusable(`SHA-${expected}`, "algorithm.hash");
        break;
      }
      case "PS256":
      case "PS384":
      case "PS512": {
        if (!isAlgorithm(key.algorithm, "RSA-PSS"))
          throw unusable("RSA-PSS");
        const expected = parseInt(alg.slice(2), 10);
        const actual = getHashLength(key.algorithm.hash);
        if (actual !== expected)
          throw unusable(`SHA-${expected}`, "algorithm.hash");
        break;
      }
      case "EdDSA": {
        if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
          throw unusable("Ed25519 or Ed448");
        }
        break;
      }
      case "ES256":
      case "ES384":
      case "ES512": {
        if (!isAlgorithm(key.algorithm, "ECDSA"))
          throw unusable("ECDSA");
        const expected = getNamedCurve(alg);
        const actual = key.algorithm.namedCurve;
        if (actual !== expected)
          throw unusable(expected, "algorithm.namedCurve");
        break;
      }
      default:
        throw new TypeError("CryptoKey does not support this operation");
    }
    checkUsage(key, usages);
  }
  function checkEncCryptoKey(key, alg, ...usages) {
    switch (alg) {
      case "A128GCM":
      case "A192GCM":
      case "A256GCM": {
        if (!isAlgorithm(key.algorithm, "AES-GCM"))
          throw unusable("AES-GCM");
        const expected = parseInt(alg.slice(1, 4), 10);
        const actual = key.algorithm.length;
        if (actual !== expected)
          throw unusable(expected, "algorithm.length");
        break;
      }
      case "A128KW":
      case "A192KW":
      case "A256KW": {
        if (!isAlgorithm(key.algorithm, "AES-KW"))
          throw unusable("AES-KW");
        const expected = parseInt(alg.slice(1, 4), 10);
        const actual = key.algorithm.length;
        if (actual !== expected)
          throw unusable(expected, "algorithm.length");
        break;
      }
      case "ECDH": {
        switch (key.algorithm.name) {
          case "ECDH":
          case "X25519":
          case "X448":
            break;
          default:
            throw unusable("ECDH, X25519, or X448");
        }
        break;
      }
      case "PBES2-HS256+A128KW":
      case "PBES2-HS384+A192KW":
      case "PBES2-HS512+A256KW":
        if (!isAlgorithm(key.algorithm, "PBKDF2"))
          throw unusable("PBKDF2");
        break;
      case "RSA-OAEP":
      case "RSA-OAEP-256":
      case "RSA-OAEP-384":
      case "RSA-OAEP-512": {
        if (!isAlgorithm(key.algorithm, "RSA-OAEP"))
          throw unusable("RSA-OAEP");
        const expected = parseInt(alg.slice(9), 10) || 1;
        const actual = getHashLength(key.algorithm.hash);
        if (actual !== expected)
          throw unusable(`SHA-${expected}`, "algorithm.hash");
        break;
      }
      default:
        throw new TypeError("CryptoKey does not support this operation");
    }
    checkUsage(key, usages);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkEncCryptoKey = exports.checkSigCryptoKey = undefined;
  exports.checkSigCryptoKey = checkSigCryptoKey;
  exports.checkEncCryptoKey = checkEncCryptoKey;
});

// node_modules/jose/dist/node/cjs/lib/invalid_key_input.js
var require_invalid_key_input = __commonJS((exports) => {
  function message(msg, actual, ...types4) {
    if (types4.length > 2) {
      const last = types4.pop();
      msg += `one of type ${types4.join(", ")}, or ${last}.`;
    } else if (types4.length === 2) {
      msg += `one of type ${types4[0]} or ${types4[1]}.`;
    } else {
      msg += `of type ${types4[0]}.`;
    }
    if (actual == null) {
      msg += ` Received ${actual}`;
    } else if (typeof actual === "function" && actual.name) {
      msg += ` Received function ${actual.name}`;
    } else if (typeof actual === "object" && actual != null) {
      if (actual.constructor && actual.constructor.name) {
        msg += ` Received an instance of ${actual.constructor.name}`;
      }
    }
    return msg;
  }
  function withAlg(alg, actual, ...types4) {
    return message(`Key for the ${alg} algorithm must be `, actual, ...types4);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.withAlg = undefined;
  exports.default = (actual, ...types4) => {
    return message("Key must be ", actual, ...types4);
  };
  exports.withAlg = withAlg;
});

// node_modules/jose/dist/node/cjs/runtime/ciphers.js
var require_ciphers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto_1 = __require("crypto");
  var ciphers;
  exports.default = (algorithm) => {
    ciphers || (ciphers = new Set((0, crypto_1.getCiphers)()));
    return ciphers.has(algorithm);
  };
});

// node_modules/jose/dist/node/cjs/runtime/is_key_like.js
var require_is_key_like = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.types = undefined;
  var webcrypto_js_1 = require_webcrypto();
  var is_key_object_js_1 = require_is_key_object();
  exports.default = (key) => (0, is_key_object_js_1.default)(key) || (0, webcrypto_js_1.isCryptoKey)(key);
  var types4 = ["KeyObject"];
  exports.types = types4;
  if (globalThis.CryptoKey || (webcrypto_js_1.default === null || webcrypto_js_1.default === undefined ? undefined : webcrypto_js_1.default.CryptoKey)) {
    types4.push("CryptoKey");
  }
});

// node_modules/jose/dist/node/cjs/runtime/decrypt.js
var require_decrypt = __commonJS((exports) => {
  function cbcDecrypt(enc, cek, ciphertext, iv2, tag, aad) {
    const keySize = parseInt(enc.slice(1, 4), 10);
    if ((0, is_key_object_js_1.default)(cek)) {
      cek = cek.export();
    }
    const encKey = cek.subarray(keySize >> 3);
    const macKey = cek.subarray(0, keySize >> 3);
    const macSize = parseInt(enc.slice(-3), 10);
    const algorithm = `aes-${keySize}-cbc`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
      throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
    }
    const expectedTag = (0, cbc_tag_js_1.default)(aad, iv2, ciphertext, macSize, macKey, keySize);
    let macCheckPassed;
    try {
      macCheckPassed = (0, timing_safe_equal_js_1.default)(tag, expectedTag);
    } catch {
    }
    if (!macCheckPassed) {
      throw new errors_js_1.JWEDecryptionFailed;
    }
    let plaintext;
    try {
      const decipher = (0, crypto_1.createDecipheriv)(algorithm, encKey, iv2);
      plaintext = (0, buffer_utils_js_1.concat)(decipher.update(ciphertext), decipher.final());
    } catch {
    }
    if (!plaintext) {
      throw new errors_js_1.JWEDecryptionFailed;
    }
    return plaintext;
  }
  function gcmDecrypt(enc, cek, ciphertext, iv2, tag, aad) {
    const keySize = parseInt(enc.slice(1, 4), 10);
    const algorithm = `aes-${keySize}-gcm`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
      throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
    }
    try {
      const decipher = (0, crypto_1.createDecipheriv)(algorithm, cek, iv2, { authTagLength: 16 });
      decipher.setAuthTag(tag);
      if (aad.byteLength) {
        decipher.setAAD(aad, { plaintextLength: ciphertext.length });
      }
      const plaintext = decipher.update(ciphertext);
      decipher.final();
      return plaintext;
    } catch {
      throw new errors_js_1.JWEDecryptionFailed;
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto_1 = __require("crypto");
  var check_iv_length_js_1 = require_check_iv_length();
  var check_cek_length_js_1 = require_check_cek_length();
  var buffer_utils_js_1 = require_buffer_utils();
  var errors_js_1 = require_errors3();
  var timing_safe_equal_js_1 = require_timing_safe_equal();
  var cbc_tag_js_1 = require_cbc_tag();
  var webcrypto_js_1 = require_webcrypto();
  var crypto_key_js_1 = require_crypto_key();
  var is_key_object_js_1 = require_is_key_object();
  var invalid_key_input_js_1 = require_invalid_key_input();
  var ciphers_js_1 = require_ciphers();
  var is_key_like_js_1 = require_is_key_like();
  var decrypt = (enc, cek, ciphertext, iv2, tag, aad) => {
    let key;
    if ((0, webcrypto_js_1.isCryptoKey)(cek)) {
      (0, crypto_key_js_1.checkEncCryptoKey)(cek, enc, "decrypt");
      key = crypto_1.KeyObject.from(cek);
    } else if (cek instanceof Uint8Array || (0, is_key_object_js_1.default)(cek)) {
      key = cek;
    } else {
      throw new TypeError((0, invalid_key_input_js_1.default)(cek, ...is_key_like_js_1.types, "Uint8Array"));
    }
    (0, check_cek_length_js_1.default)(enc, key);
    (0, check_iv_length_js_1.default)(enc, iv2);
    switch (enc) {
      case "A128CBC-HS256":
      case "A192CBC-HS384":
      case "A256CBC-HS512":
        return cbcDecrypt(enc, key, ciphertext, iv2, tag, aad);
      case "A128GCM":
      case "A192GCM":
      case "A256GCM":
        return gcmDecrypt(enc, key, ciphertext, iv2, tag, aad);
      default:
        throw new errors_js_1.JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
    }
  };
  exports.default = decrypt;
});

// node_modules/jose/dist/node/cjs/runtime/zlib.js
var require_zlib = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deflate = exports.inflate = undefined;
  var util_1 = __require("util");
  var zlib_1 = __require("zlib");
  var inflateRaw = (0, util_1.promisify)(zlib_1.inflateRaw);
  var deflateRaw = (0, util_1.promisify)(zlib_1.deflateRaw);
  var inflate = (input) => inflateRaw(input);
  exports.inflate = inflate;
  var deflate = (input) => deflateRaw(input);
  exports.deflate = deflate;
});

// node_modules/jose/dist/node/cjs/lib/is_disjoint.js
var require_is_disjoint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var isDisjoint = (...headers) => {
    const sources = headers.filter(Boolean);
    if (sources.length === 0 || sources.length === 1) {
      return true;
    }
    let acc;
    for (const header of sources) {
      const parameters = Object.keys(header);
      if (!acc || acc.size === 0) {
        acc = new Set(parameters);
        continue;
      }
      for (const parameter of parameters) {
        if (acc.has(parameter)) {
          return false;
        }
        acc.add(parameter);
      }
    }
    return true;
  };
  exports.default = isDisjoint;
});

// node_modules/jose/dist/node/cjs/lib/is_object.js
var require_is_object = __commonJS((exports) => {
  function isObjectLike(value) {
    return typeof value === "object" && value !== null;
  }
  function isObject(input) {
    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
      return false;
    }
    if (Object.getPrototypeOf(input) === null) {
      return true;
    }
    let proto = input;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(input) === proto;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = isObject;
});

// node_modules/jose/dist/node/cjs/runtime/aeskw.js
var require_aeskw = __commonJS((exports) => {
  function checkKeySize(key, alg) {
    if (key.symmetricKeySize << 3 !== parseInt(alg.slice(1, 4), 10)) {
      throw new TypeError(`Invalid key size for alg: ${alg}`);
    }
  }
  function ensureKeyObject(key, alg, usage) {
    if ((0, is_key_object_js_1.default)(key)) {
      return key;
    }
    if (key instanceof Uint8Array) {
      return (0, crypto_1.createSecretKey)(key);
    }
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
      (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, usage);
      return crypto_1.KeyObject.from(key);
    }
    throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, "Uint8Array"));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unwrap = exports.wrap = undefined;
  var buffer_1 = __require("buffer");
  var crypto_1 = __require("crypto");
  var errors_js_1 = require_errors3();
  var buffer_utils_js_1 = require_buffer_utils();
  var webcrypto_js_1 = require_webcrypto();
  var crypto_key_js_1 = require_crypto_key();
  var is_key_object_js_1 = require_is_key_object();
  var invalid_key_input_js_1 = require_invalid_key_input();
  var ciphers_js_1 = require_ciphers();
  var is_key_like_js_1 = require_is_key_like();
  var wrap = (alg, key, cek) => {
    const size2 = parseInt(alg.slice(1, 4), 10);
    const algorithm = `aes${size2}-wrap`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
      throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
    const keyObject = ensureKeyObject(key, alg, "wrapKey");
    checkKeySize(keyObject, alg);
    const cipher = (0, crypto_1.createCipheriv)(algorithm, keyObject, buffer_1.Buffer.alloc(8, 166));
    return (0, buffer_utils_js_1.concat)(cipher.update(cek), cipher.final());
  };
  exports.wrap = wrap;
  var unwrap = (alg, key, encryptedKey) => {
    const size2 = parseInt(alg.slice(1, 4), 10);
    const algorithm = `aes${size2}-wrap`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
      throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
    const keyObject = ensureKeyObject(key, alg, "unwrapKey");
    checkKeySize(keyObject, alg);
    const cipher = (0, crypto_1.createDecipheriv)(algorithm, keyObject, buffer_1.Buffer.alloc(8, 166));
    return (0, buffer_utils_js_1.concat)(cipher.update(encryptedKey), cipher.final());
  };
  exports.unwrap = unwrap;
});

// node_modules/jose/dist/node/cjs/runtime/get_named_curve.js
var require_get_named_curve = __commonJS((exports) => {
  function setCurve(keyObject, curve) {
    exports.weakMap.set(keyObject, curve);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setCurve = exports.weakMap = undefined;
  var buffer_1 = __require("buffer");
  var crypto_1 = __require("crypto");
  var errors_js_1 = require_errors3();
  var webcrypto_js_1 = require_webcrypto();
  var is_key_object_js_1 = require_is_key_object();
  var invalid_key_input_js_1 = require_invalid_key_input();
  var is_key_like_js_1 = require_is_key_like();
  var p256 = buffer_1.Buffer.from([42, 134, 72, 206, 61, 3, 1, 7]);
  var p384 = buffer_1.Buffer.from([43, 129, 4, 0, 34]);
  var p521 = buffer_1.Buffer.from([43, 129, 4, 0, 35]);
  var secp256k1 = buffer_1.Buffer.from([43, 129, 4, 0, 10]);
  exports.weakMap = new WeakMap;
  var namedCurveToJOSE = (namedCurve) => {
    switch (namedCurve) {
      case "prime256v1":
        return "P-256";
      case "secp384r1":
        return "P-384";
      case "secp521r1":
        return "P-521";
      case "secp256k1":
        return "secp256k1";
      default:
        throw new errors_js_1.JOSENotSupported("Unsupported key curve for this operation");
    }
  };
  var getNamedCurve = (kee, raw) => {
    var _a3;
    let key;
    if ((0, webcrypto_js_1.isCryptoKey)(kee)) {
      key = crypto_1.KeyObject.from(kee);
    } else if ((0, is_key_object_js_1.default)(kee)) {
      key = kee;
    } else {
      throw new TypeError((0, invalid_key_input_js_1.default)(kee, ...is_key_like_js_1.types));
    }
    if (key.type === "secret") {
      throw new TypeError('only "private" or "public" type keys can be used for this operation');
    }
    switch (key.asymmetricKeyType) {
      case "ed25519":
      case "ed448":
        return `Ed${key.asymmetricKeyType.slice(2)}`;
      case "x25519":
      case "x448":
        return `X${key.asymmetricKeyType.slice(1)}`;
      case "ec": {
        if (exports.weakMap.has(key)) {
          return exports.weakMap.get(key);
        }
        let namedCurve = (_a3 = key.asymmetricKeyDetails) === null || _a3 === undefined ? undefined : _a3.namedCurve;
        if (!namedCurve && key.type === "private") {
          namedCurve = getNamedCurve((0, crypto_1.createPublicKey)(key), true);
        } else if (!namedCurve) {
          const buf = key.export({ format: "der", type: "spki" });
          const i = buf[1] < 128 ? 14 : 15;
          const len = buf[i];
          const curveOid = buf.slice(i + 1, i + 1 + len);
          if (curveOid.equals(p256)) {
            namedCurve = "prime256v1";
          } else if (curveOid.equals(p384)) {
            namedCurve = "secp384r1";
          } else if (curveOid.equals(p521)) {
            namedCurve = "secp521r1";
          } else if (curveOid.equals(secp256k1)) {
            namedCurve = "secp256k1";
          } else {
            throw new errors_js_1.JOSENotSupported("Unsupported key curve for this operation");
          }
        }
        if (raw)
          return namedCurve;
        const curve = namedCurveToJOSE(namedCurve);
        exports.weakMap.set(key, curve);
        return curve;
      }
      default:
        throw new TypeError("Invalid asymmetric key type for this operation");
    }
  };
  exports.setCurve = setCurve;
  exports.default = getNamedCurve;
});

// node_modules/jose/dist/node/cjs/runtime/ecdhes.js
var require_ecdhes = __commonJS((exports) => {
  async function deriveKey(publicKee, privateKee, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {
    let publicKey;
    if ((0, webcrypto_js_1.isCryptoKey)(publicKee)) {
      (0, crypto_key_js_1.checkEncCryptoKey)(publicKee, "ECDH");
      publicKey = crypto_1.KeyObject.from(publicKee);
    } else if ((0, is_key_object_js_1.default)(publicKee)) {
      publicKey = publicKee;
    } else {
      throw new TypeError((0, invalid_key_input_js_1.default)(publicKee, ...is_key_like_js_1.types));
    }
    let privateKey;
    if ((0, webcrypto_js_1.isCryptoKey)(privateKee)) {
      (0, crypto_key_js_1.checkEncCryptoKey)(privateKee, "ECDH", "deriveBits");
      privateKey = crypto_1.KeyObject.from(privateKee);
    } else if ((0, is_key_object_js_1.default)(privateKee)) {
      privateKey = privateKee;
    } else {
      throw new TypeError((0, invalid_key_input_js_1.default)(privateKee, ...is_key_like_js_1.types));
    }
    const value = (0, buffer_utils_js_1.concat)((0, buffer_utils_js_1.lengthAndInput)(buffer_utils_js_1.encoder.encode(algorithm)), (0, buffer_utils_js_1.lengthAndInput)(apu), (0, buffer_utils_js_1.lengthAndInput)(apv), (0, buffer_utils_js_1.uint32be)(keyLength));
    const sharedSecret = (0, crypto_1.diffieHellman)({ privateKey, publicKey });
    return (0, buffer_utils_js_1.concatKdf)(sharedSecret, keyLength, value);
  }
  async function generateEpk(kee) {
    let key;
    if ((0, webcrypto_js_1.isCryptoKey)(kee)) {
      key = crypto_1.KeyObject.from(kee);
    } else if ((0, is_key_object_js_1.default)(kee)) {
      key = kee;
    } else {
      throw new TypeError((0, invalid_key_input_js_1.default)(kee, ...is_key_like_js_1.types));
    }
    switch (key.asymmetricKeyType) {
      case "x25519":
        return generateKeyPair("x25519");
      case "x448": {
        return generateKeyPair("x448");
      }
      case "ec": {
        const namedCurve = (0, get_named_curve_js_1.default)(key);
        return generateKeyPair("ec", { namedCurve });
      }
      default:
        throw new errors_js_1.JOSENotSupported("Invalid or unsupported EPK");
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ecdhAllowed = exports.generateEpk = exports.deriveKey = undefined;
  var crypto_1 = __require("crypto");
  var util_1 = __require("util");
  var get_named_curve_js_1 = require_get_named_curve();
  var buffer_utils_js_1 = require_buffer_utils();
  var errors_js_1 = require_errors3();
  var webcrypto_js_1 = require_webcrypto();
  var crypto_key_js_1 = require_crypto_key();
  var is_key_object_js_1 = require_is_key_object();
  var invalid_key_input_js_1 = require_invalid_key_input();
  var is_key_like_js_1 = require_is_key_like();
  var generateKeyPair = (0, util_1.promisify)(crypto_1.generateKeyPair);
  exports.deriveKey = deriveKey;
  exports.generateEpk = generateEpk;
  var ecdhAllowed = (key) => ["P-256", "P-384", "P-521", "X25519", "X448"].includes((0, get_named_curve_js_1.default)(key));
  exports.ecdhAllowed = ecdhAllowed;
});

// node_modules/jose/dist/node/cjs/lib/check_p2s.js
var require_check_p2s = __commonJS((exports) => {
  function checkP2s(p2s) {
    if (!(p2s instanceof Uint8Array) || p2s.length < 8) {
      throw new errors_js_1.JWEInvalid("PBES2 Salt Input must be 8 or more octets");
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  var errors_js_1 = require_errors3();
  exports.default = checkP2s;
});

// node_modules/jose/dist/node/cjs/runtime/pbes2kw.js
var require_pbes2kw = __commonJS((exports) => {
  function getPassword(key, alg) {
    if ((0, is_key_object_js_1.default)(key)) {
      return key.export();
    }
    if (key instanceof Uint8Array) {
      return key;
    }
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
      (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, "deriveBits", "deriveKey");
      return crypto_1.KeyObject.from(key).export();
    }
    throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, "Uint8Array"));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decrypt = exports.encrypt = undefined;
  var util_1 = __require("util");
  var crypto_1 = __require("crypto");
  var random_js_1 = require_random();
  var buffer_utils_js_1 = require_buffer_utils();
  var base64url_js_1 = require_base64url();
  var aeskw_js_1 = require_aeskw();
  var check_p2s_js_1 = require_check_p2s();
  var webcrypto_js_1 = require_webcrypto();
  var crypto_key_js_1 = require_crypto_key();
  var is_key_object_js_1 = require_is_key_object();
  var invalid_key_input_js_1 = require_invalid_key_input();
  var is_key_like_js_1 = require_is_key_like();
  var pbkdf2 = (0, util_1.promisify)(crypto_1.pbkdf2);
  var encrypt = async (alg, key, cek, p2c = 2048, p2s = (0, random_js_1.default)(new Uint8Array(16))) => {
    (0, check_p2s_js_1.default)(p2s);
    const salt = (0, buffer_utils_js_1.p2s)(alg, p2s);
    const keylen = parseInt(alg.slice(13, 16), 10) >> 3;
    const password = getPassword(key, alg);
    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);
    const encryptedKey = await (0, aeskw_js_1.wrap)(alg.slice(-6), derivedKey, cek);
    return { encryptedKey, p2c, p2s: (0, base64url_js_1.encode)(p2s) };
  };
  exports.encrypt = encrypt;
  var decrypt = async (alg, key, encryptedKey, p2c, p2s) => {
    (0, check_p2s_js_1.default)(p2s);
    const salt = (0, buffer_utils_js_1.p2s)(alg, p2s);
    const keylen = parseInt(alg.slice(13, 16), 10) >> 3;
    const password = getPassword(key, alg);
    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);
    return (0, aeskw_js_1.unwrap)(alg.slice(-6), derivedKey, encryptedKey);
  };
  exports.decrypt = decrypt;
});

// node_modules/jose/dist/node/cjs/runtime/check_modulus_length.js
var require_check_modulus_length = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setModulusLength = exports.weakMap = undefined;
  exports.weakMap = new WeakMap;
  var getLength = (buf, index2) => {
    let len = buf.readUInt8(1);
    if ((len & 128) === 0) {
      if (index2 === 0) {
        return len;
      }
      return getLength(buf.subarray(2 + len), index2 - 1);
    }
    const num = len & 127;
    len = 0;
    for (let i = 0;i < num; i++) {
      len <<= 8;
      const j3 = buf.readUInt8(2 + i);
      len |= j3;
    }
    if (index2 === 0) {
      return len;
    }
    return getLength(buf.subarray(2 + len), index2 - 1);
  };
  var getLengthOfSeqIndex = (sequence, index2) => {
    const len = sequence.readUInt8(1);
    if ((len & 128) === 0) {
      return getLength(sequence.subarray(2), index2);
    }
    const num = len & 127;
    return getLength(sequence.subarray(2 + num), index2);
  };
  var getModulusLength = (key) => {
    var _a3, _b;
    if (exports.weakMap.has(key)) {
      return exports.weakMap.get(key);
    }
    const modulusLength = (_b = (_a3 = key.asymmetricKeyDetails) === null || _a3 === undefined ? undefined : _a3.modulusLength) !== null && _b !== undefined ? _b : getLengthOfSeqIndex(key.export({ format: "der", type: "pkcs1" }), key.type === "private" ? 1 : 0) - 1 << 3;
    exports.weakMap.set(key, modulusLength);
    return modulusLength;
  };
  var setModulusLength = (keyObject, modulusLength) => {
    exports.weakMap.set(keyObject, modulusLength);
  };
  exports.setModulusLength = setModulusLength;
  exports.default = (key, alg) => {
    if (getModulusLength(key) < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  };
});

// node_modules/jose/dist/node/cjs/runtime/rsaes.js
var require_rsaes = __commonJS((exports) => {
  function ensureKeyObject(key, alg, ...usages) {
    if ((0, is_key_object_js_1.default)(key)) {
      return key;
    }
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
      (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, ...usages);
      return crypto_1.KeyObject.from(key);
    }
    throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decrypt = exports.encrypt = undefined;
  var crypto_1 = __require("crypto");
  var check_modulus_length_js_1 = require_check_modulus_length();
  var webcrypto_js_1 = require_webcrypto();
  var crypto_key_js_1 = require_crypto_key();
  var is_key_object_js_1 = require_is_key_object();
  var invalid_key_input_js_1 = require_invalid_key_input();
  var is_key_like_js_1 = require_is_key_like();
  var checkKey = (key, alg) => {
    if (key.asymmetricKeyType !== "rsa") {
      throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
    }
    (0, check_modulus_length_js_1.default)(key, alg);
  };
  var resolvePadding = (alg) => {
    switch (alg) {
      case "RSA-OAEP":
      case "RSA-OAEP-256":
      case "RSA-OAEP-384":
      case "RSA-OAEP-512":
        return crypto_1.constants.RSA_PKCS1_OAEP_PADDING;
      case "RSA1_5":
        return crypto_1.constants.RSA_PKCS1_PADDING;
      default:
        return;
    }
  };
  var resolveOaepHash = (alg) => {
    switch (alg) {
      case "RSA-OAEP":
        return "sha1";
      case "RSA-OAEP-256":
        return "sha256";
      case "RSA-OAEP-384":
        return "sha384";
      case "RSA-OAEP-512":
        return "sha512";
      default:
        return;
    }
  };
  var encrypt = (alg, key, cek) => {
    const padding = resolvePadding(alg);
    const oaepHash = resolveOaepHash(alg);
    const keyObject = ensureKeyObject(key, alg, "wrapKey", "encrypt");
    checkKey(keyObject, alg);
    return (0, crypto_1.publicEncrypt)({ key: keyObject, oaepHash, padding }, cek);
  };
  exports.encrypt = encrypt;
  var decrypt = (alg, key, encryptedKey) => {
    const padding = resolvePadding(alg);
    const oaepHash = resolveOaepHash(alg);
    const keyObject = ensureKeyObject(key, alg, "unwrapKey", "decrypt");
    checkKey(keyObject, alg);
    return (0, crypto_1.privateDecrypt)({ key: keyObject, oaepHash, padding }, encryptedKey);
  };
  exports.decrypt = decrypt;
});

// node_modules/jose/dist/node/cjs/lib/cek.js
var require_cek = __commonJS((exports) => {
  function bitLength(alg) {
    switch (alg) {
      case "A128GCM":
        return 128;
      case "A192GCM":
        return 192;
      case "A256GCM":
      case "A128CBC-HS256":
        return 256;
      case "A192CBC-HS384":
        return 384;
      case "A256CBC-HS512":
        return 512;
      default:
        throw new errors_js_1.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bitLength = undefined;
  var errors_js_1 = require_errors3();
  var random_js_1 = require_random();
  exports.bitLength = bitLength;
  exports.default = (alg) => (0, random_js_1.default)(new Uint8Array(bitLength(alg) >> 3));
});

// node_modules/jose/dist/node/cjs/runtime/asn1.js
var require_asn1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromX509 = exports.fromSPKI = exports.fromPKCS8 = exports.toPKCS8 = exports.toSPKI = undefined;
  var crypto_1 = __require("crypto");
  var buffer_1 = __require("buffer");
  var webcrypto_js_1 = require_webcrypto();
  var is_key_object_js_1 = require_is_key_object();
  var invalid_key_input_js_1 = require_invalid_key_input();
  var is_key_like_js_1 = require_is_key_like();
  var genericExport = (keyType, keyFormat, key) => {
    let keyObject;
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
      if (!key.extractable) {
        throw new TypeError("CryptoKey is not extractable");
      }
      keyObject = crypto_1.KeyObject.from(key);
    } else if ((0, is_key_object_js_1.default)(key)) {
      keyObject = key;
    } else {
      throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
    }
    if (keyObject.type !== keyType) {
      throw new TypeError(`key is not a ${keyType} key`);
    }
    return keyObject.export({ format: "pem", type: keyFormat });
  };
  var toSPKI = (key) => {
    return genericExport("public", "spki", key);
  };
  exports.toSPKI = toSPKI;
  var toPKCS8 = (key) => {
    return genericExport("private", "pkcs8", key);
  };
  exports.toPKCS8 = toPKCS8;
  var fromPKCS8 = (pem) => (0, crypto_1.createPrivateKey)({
    key: buffer_1.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, ""), "base64"),
    type: "pkcs8",
    format: "der"
  });
  exports.fromPKCS8 = fromPKCS8;
  var fromSPKI = (pem) => (0, crypto_1.createPublicKey)({
    key: buffer_1.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, ""), "base64"),
    type: "spki",
    format: "der"
  });
  exports.fromSPKI = fromSPKI;
  var fromX509 = (pem) => (0, crypto_1.createPublicKey)({
    key: pem,
    type: "spki",
    format: "pem"
  });
  exports.fromX509 = fromX509;
});

// node_modules/jose/dist/node/cjs/runtime/asn1_sequence_encoder.js
var require_asn1_sequence_encoder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var buffer_1 = __require("buffer");
  var errors_js_1 = require_errors3();
  var tagInteger = 2;
  var tagBitStr = 3;
  var tagOctStr = 4;
  var tagSequence = 48;
  var bZero = buffer_1.Buffer.from([0]);
  var bTagInteger = buffer_1.Buffer.from([tagInteger]);
  var bTagBitStr = buffer_1.Buffer.from([tagBitStr]);
  var bTagSequence = buffer_1.Buffer.from([tagSequence]);
  var bTagOctStr = buffer_1.Buffer.from([tagOctStr]);
  var encodeLength = (len) => {
    if (len < 128)
      return buffer_1.Buffer.from([len]);
    const buffer2 = buffer_1.Buffer.alloc(5);
    buffer2.writeUInt32BE(len, 1);
    let offset = 1;
    while (buffer2[offset] === 0)
      offset++;
    buffer2[offset - 1] = 128 | 5 - offset;
    return buffer2.slice(offset - 1);
  };
  var oids = new Map([
    ["P-256", buffer_1.Buffer.from("06 08 2A 86 48 CE 3D 03 01 07".replace(/ /g, ""), "hex")],
    ["secp256k1", buffer_1.Buffer.from("06 05 2B 81 04 00 0A".replace(/ /g, ""), "hex")],
    ["P-384", buffer_1.Buffer.from("06 05 2B 81 04 00 22".replace(/ /g, ""), "hex")],
    ["P-521", buffer_1.Buffer.from("06 05 2B 81 04 00 23".replace(/ /g, ""), "hex")],
    ["ecPublicKey", buffer_1.Buffer.from("06 07 2A 86 48 CE 3D 02 01".replace(/ /g, ""), "hex")],
    ["X25519", buffer_1.Buffer.from("06 03 2B 65 6E".replace(/ /g, ""), "hex")],
    ["X448", buffer_1.Buffer.from("06 03 2B 65 6F".replace(/ /g, ""), "hex")],
    ["Ed25519", buffer_1.Buffer.from("06 03 2B 65 70".replace(/ /g, ""), "hex")],
    ["Ed448", buffer_1.Buffer.from("06 03 2B 65 71".replace(/ /g, ""), "hex")]
  ]);

  class DumbAsn1Encoder {
    constructor() {
      this.length = 0;
      this.elements = [];
    }
    oidFor(oid) {
      const bOid = oids.get(oid);
      if (!bOid) {
        throw new errors_js_1.JOSENotSupported("Invalid or unsupported OID");
      }
      this.elements.push(bOid);
      this.length += bOid.length;
    }
    zero() {
      this.elements.push(bTagInteger, buffer_1.Buffer.from([1]), bZero);
      this.length += 3;
    }
    one() {
      this.elements.push(bTagInteger, buffer_1.Buffer.from([1]), buffer_1.Buffer.from([1]));
      this.length += 3;
    }
    unsignedInteger(integer2) {
      if (integer2[0] & 128) {
        const len = encodeLength(integer2.length + 1);
        this.elements.push(bTagInteger, len, bZero, integer2);
        this.length += 2 + len.length + integer2.length;
      } else {
        let i = 0;
        while (integer2[i] === 0 && (integer2[i + 1] & 128) === 0)
          i++;
        const len = encodeLength(integer2.length - i);
        this.elements.push(bTagInteger, encodeLength(integer2.length - i), integer2.slice(i));
        this.length += 1 + len.length + integer2.length - i;
      }
    }
    octStr(octStr) {
      const len = encodeLength(octStr.length);
      this.elements.push(bTagOctStr, encodeLength(octStr.length), octStr);
      this.length += 1 + len.length + octStr.length;
    }
    bitStr(bitS) {
      const len = encodeLength(bitS.length + 1);
      this.elements.push(bTagBitStr, encodeLength(bitS.length + 1), bZero, bitS);
      this.length += 1 + len.length + bitS.length + 1;
    }
    add(seq) {
      this.elements.push(seq);
      this.length += seq.length;
    }
    end(tag = bTagSequence) {
      const len = encodeLength(this.length);
      return buffer_1.Buffer.concat([tag, len, ...this.elements], 1 + len.length + this.length);
    }
  }
  exports.default = DumbAsn1Encoder;
});

// node_modules/jose/dist/node/cjs/runtime/flags.js
var require_flags = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.jwkImport = exports.jwkExport = exports.rsaPssParams = exports.oneShotCallback = undefined;
  var [major, minor] = process.versions.node.split(".").map((str) => parseInt(str, 10));
  exports.oneShotCallback = major >= 16 || major === 15 && minor >= 13;
  exports.rsaPssParams = !("electron" in process.versions) && (major >= 17 || major === 16 && minor >= 9);
  exports.jwkExport = major >= 16 || major === 15 && minor >= 9;
  exports.jwkImport = major >= 16 || major === 15 && minor >= 12;
});

// node_modules/jose/dist/node/cjs/runtime/jwk_to_key.js
var require_jwk_to_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var buffer_1 = __require("buffer");
  var crypto_1 = __require("crypto");
  var base64url_js_1 = require_base64url();
  var errors_js_1 = require_errors3();
  var get_named_curve_js_1 = require_get_named_curve();
  var check_modulus_length_js_1 = require_check_modulus_length();
  var asn1_sequence_encoder_js_1 = require_asn1_sequence_encoder();
  var flags_js_1 = require_flags();
  var parse2 = (jwk) => {
    if (flags_js_1.jwkImport && jwk.kty !== "oct") {
      return jwk.d ? (0, crypto_1.createPrivateKey)({ format: "jwk", key: jwk }) : (0, crypto_1.createPublicKey)({ format: "jwk", key: jwk });
    }
    switch (jwk.kty) {
      case "oct": {
        return (0, crypto_1.createSecretKey)((0, base64url_js_1.decode)(jwk.k));
      }
      case "RSA": {
        const enc = new asn1_sequence_encoder_js_1.default;
        const isPrivate = jwk.d !== undefined;
        const modulus = buffer_1.Buffer.from(jwk.n, "base64");
        const exponent = buffer_1.Buffer.from(jwk.e, "base64");
        if (isPrivate) {
          enc.zero();
          enc.unsignedInteger(modulus);
          enc.unsignedInteger(exponent);
          enc.unsignedInteger(buffer_1.Buffer.from(jwk.d, "base64"));
          enc.unsignedInteger(buffer_1.Buffer.from(jwk.p, "base64"));
          enc.unsignedInteger(buffer_1.Buffer.from(jwk.q, "base64"));
          enc.unsignedInteger(buffer_1.Buffer.from(jwk.dp, "base64"));
          enc.unsignedInteger(buffer_1.Buffer.from(jwk.dq, "base64"));
          enc.unsignedInteger(buffer_1.Buffer.from(jwk.qi, "base64"));
        } else {
          enc.unsignedInteger(modulus);
          enc.unsignedInteger(exponent);
        }
        const der = enc.end();
        const createInput = {
          key: der,
          format: "der",
          type: "pkcs1"
        };
        const keyObject = isPrivate ? (0, crypto_1.createPrivateKey)(createInput) : (0, crypto_1.createPublicKey)(createInput);
        (0, check_modulus_length_js_1.setModulusLength)(keyObject, modulus.length << 3);
        return keyObject;
      }
      case "EC": {
        const enc = new asn1_sequence_encoder_js_1.default;
        const isPrivate = jwk.d !== undefined;
        const pub = buffer_1.Buffer.concat([
          buffer_1.Buffer.alloc(1, 4),
          buffer_1.Buffer.from(jwk.x, "base64"),
          buffer_1.Buffer.from(jwk.y, "base64")
        ]);
        if (isPrivate) {
          enc.zero();
          const enc$12 = new asn1_sequence_encoder_js_1.default;
          enc$12.oidFor("ecPublicKey");
          enc$12.oidFor(jwk.crv);
          enc.add(enc$12.end());
          const enc$2 = new asn1_sequence_encoder_js_1.default;
          enc$2.one();
          enc$2.octStr(buffer_1.Buffer.from(jwk.d, "base64"));
          const enc$3 = new asn1_sequence_encoder_js_1.default;
          enc$3.bitStr(pub);
          const f2 = enc$3.end(buffer_1.Buffer.from([161]));
          enc$2.add(f2);
          const f = enc$2.end();
          const enc$4 = new asn1_sequence_encoder_js_1.default;
          enc$4.add(f);
          const f3 = enc$4.end(buffer_1.Buffer.from([4]));
          enc.add(f3);
          const der2 = enc.end();
          const keyObject2 = (0, crypto_1.createPrivateKey)({ key: der2, format: "der", type: "pkcs8" });
          (0, get_named_curve_js_1.setCurve)(keyObject2, jwk.crv);
          return keyObject2;
        }
        const enc$1 = new asn1_sequence_encoder_js_1.default;
        enc$1.oidFor("ecPublicKey");
        enc$1.oidFor(jwk.crv);
        enc.add(enc$1.end());
        enc.bitStr(pub);
        const der = enc.end();
        const keyObject = (0, crypto_1.createPublicKey)({ key: der, format: "der", type: "spki" });
        (0, get_named_curve_js_1.setCurve)(keyObject, jwk.crv);
        return keyObject;
      }
      case "OKP": {
        const enc = new asn1_sequence_encoder_js_1.default;
        const isPrivate = jwk.d !== undefined;
        if (isPrivate) {
          enc.zero();
          const enc$12 = new asn1_sequence_encoder_js_1.default;
          enc$12.oidFor(jwk.crv);
          enc.add(enc$12.end());
          const enc$2 = new asn1_sequence_encoder_js_1.default;
          enc$2.octStr(buffer_1.Buffer.from(jwk.d, "base64"));
          const f = enc$2.end(buffer_1.Buffer.from([4]));
          enc.add(f);
          const der2 = enc.end();
          return (0, crypto_1.createPrivateKey)({ key: der2, format: "der", type: "pkcs8" });
        }
        const enc$1 = new asn1_sequence_encoder_js_1.default;
        enc$1.oidFor(jwk.crv);
        enc.add(enc$1.end());
        enc.bitStr(buffer_1.Buffer.from(jwk.x, "base64"));
        const der = enc.end();
        return (0, crypto_1.createPublicKey)({ key: der, format: "der", type: "spki" });
      }
      default:
        throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
    }
  };
  exports.default = parse2;
});

// node_modules/jose/dist/node/cjs/key/import.js
var require_import = __commonJS((exports) => {
  async function importSPKI(spki, alg, options) {
    if (typeof spki !== "string" || spki.indexOf("-----BEGIN PUBLIC KEY-----") !== 0) {
      throw new TypeError('"spki" must be SPKI formatted string');
    }
    return (0, asn1_js_1.fromSPKI)(spki, alg, options);
  }
  async function importX509(x509, alg, options) {
    if (typeof x509 !== "string" || x509.indexOf("-----BEGIN CERTIFICATE-----") !== 0) {
      throw new TypeError('"x509" must be X.509 formatted string');
    }
    return (0, asn1_js_1.fromX509)(x509, alg, options);
  }
  async function importPKCS8(pkcs8, alg, options) {
    if (typeof pkcs8 !== "string" || pkcs8.indexOf("-----BEGIN PRIVATE KEY-----") !== 0) {
      throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
    }
    return (0, asn1_js_1.fromPKCS8)(pkcs8, alg, options);
  }
  async function importJWK(jwk, alg, octAsKeyObject) {
    var _a3;
    if (!(0, is_object_js_1.default)(jwk)) {
      throw new TypeError("JWK must be an object");
    }
    alg || (alg = jwk.alg);
    switch (jwk.kty) {
      case "oct":
        if (typeof jwk.k !== "string" || !jwk.k) {
          throw new TypeError('missing "k" (Key Value) Parameter value');
        }
        octAsKeyObject !== null && octAsKeyObject !== undefined || (octAsKeyObject = jwk.ext !== true);
        if (octAsKeyObject) {
          return (0, jwk_to_key_js_1.default)({ ...jwk, alg, ext: (_a3 = jwk.ext) !== null && _a3 !== undefined ? _a3 : false });
        }
        return (0, base64url_js_1.decode)(jwk.k);
      case "RSA":
        if (jwk.oth !== undefined) {
          throw new errors_js_1.JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
        }
      case "EC":
      case "OKP":
        return (0, jwk_to_key_js_1.default)({ ...jwk, alg });
      default:
        throw new errors_js_1.JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.importJWK = exports.importPKCS8 = exports.importX509 = exports.importSPKI = undefined;
  var base64url_js_1 = require_base64url();
  var asn1_js_1 = require_asn1();
  var jwk_to_key_js_1 = require_jwk_to_key();
  var errors_js_1 = require_errors3();
  var is_object_js_1 = require_is_object();
  exports.importSPKI = importSPKI;
  exports.importX509 = importX509;
  exports.importPKCS8 = importPKCS8;
  exports.importJWK = importJWK;
});

// node_modules/jose/dist/node/cjs/lib/check_key_type.js
var require_check_key_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var invalid_key_input_js_1 = require_invalid_key_input();
  var is_key_like_js_1 = require_is_key_like();
  var symmetricTypeCheck = (alg, key) => {
    if (key instanceof Uint8Array)
      return;
    if (!(0, is_key_like_js_1.default)(key)) {
      throw new TypeError((0, invalid_key_input_js_1.withAlg)(alg, key, ...is_key_like_js_1.types, "Uint8Array"));
    }
    if (key.type !== "secret") {
      throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
    }
  };
  var asymmetricTypeCheck = (alg, key, usage) => {
    if (!(0, is_key_like_js_1.default)(key)) {
      throw new TypeError((0, invalid_key_input_js_1.withAlg)(alg, key, ...is_key_like_js_1.types));
    }
    if (key.type === "secret") {
      throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
    }
    if (usage === "sign" && key.type === "public") {
      throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
    }
    if (usage === "decrypt" && key.type === "public") {
      throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
    }
    if (key.algorithm && usage === "verify" && key.type === "private") {
      throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
    }
    if (key.algorithm && usage === "encrypt" && key.type === "private") {
      throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
    }
  };
  var checkKeyType = (alg, key, usage) => {
    const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
    if (symmetric) {
      symmetricTypeCheck(alg, key);
    } else {
      asymmetricTypeCheck(alg, key, usage);
    }
  };
  exports.default = checkKeyType;
});

// node_modules/jose/dist/node/cjs/runtime/encrypt.js
var require_encrypt = __commonJS((exports) => {
  function cbcEncrypt(enc, plaintext, cek, iv2, aad) {
    const keySize = parseInt(enc.slice(1, 4), 10);
    if ((0, is_key_object_js_1.default)(cek)) {
      cek = cek.export();
    }
    const encKey = cek.subarray(keySize >> 3);
    const macKey = cek.subarray(0, keySize >> 3);
    const algorithm = `aes-${keySize}-cbc`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
      throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
    }
    const cipher = (0, crypto_1.createCipheriv)(algorithm, encKey, iv2);
    const ciphertext = (0, buffer_utils_js_1.concat)(cipher.update(plaintext), cipher.final());
    const macSize = parseInt(enc.slice(-3), 10);
    const tag = (0, cbc_tag_js_1.default)(aad, iv2, ciphertext, macSize, macKey, keySize);
    return { ciphertext, tag };
  }
  function gcmEncrypt(enc, plaintext, cek, iv2, aad) {
    const keySize = parseInt(enc.slice(1, 4), 10);
    const algorithm = `aes-${keySize}-gcm`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
      throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
    }
    const cipher = (0, crypto_1.createCipheriv)(algorithm, cek, iv2, { authTagLength: 16 });
    if (aad.byteLength) {
      cipher.setAAD(aad, { plaintextLength: plaintext.length });
    }
    const ciphertext = cipher.update(plaintext);
    cipher.final();
    const tag = cipher.getAuthTag();
    return { ciphertext, tag };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto_1 = __require("crypto");
  var check_iv_length_js_1 = require_check_iv_length();
  var check_cek_length_js_1 = require_check_cek_length();
  var buffer_utils_js_1 = require_buffer_utils();
  var cbc_tag_js_1 = require_cbc_tag();
  var webcrypto_js_1 = require_webcrypto();
  var crypto_key_js_1 = require_crypto_key();
  var is_key_object_js_1 = require_is_key_object();
  var invalid_key_input_js_1 = require_invalid_key_input();
  var errors_js_1 = require_errors3();
  var ciphers_js_1 = require_ciphers();
  var is_key_like_js_1 = require_is_key_like();
  var encrypt = (enc, plaintext, cek, iv2, aad) => {
    let key;
    if ((0, webcrypto_js_1.isCryptoKey)(cek)) {
      (0, crypto_key_js_1.checkEncCryptoKey)(cek, enc, "encrypt");
      key = crypto_1.KeyObject.from(cek);
    } else if (cek instanceof Uint8Array || (0, is_key_object_js_1.default)(cek)) {
      key = cek;
    } else {
      throw new TypeError((0, invalid_key_input_js_1.default)(cek, ...is_key_like_js_1.types, "Uint8Array"));
    }
    (0, check_cek_length_js_1.default)(enc, key);
    (0, check_iv_length_js_1.default)(enc, iv2);
    switch (enc) {
      case "A128CBC-HS256":
      case "A192CBC-HS384":
      case "A256CBC-HS512":
        return cbcEncrypt(enc, plaintext, key, iv2, aad);
      case "A128GCM":
      case "A192GCM":
      case "A256GCM":
        return gcmEncrypt(enc, plaintext, key, iv2, aad);
      default:
        throw new errors_js_1.JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
    }
  };
  exports.default = encrypt;
});

// node_modules/jose/dist/node/cjs/lib/aesgcmkw.js
var require_aesgcmkw = __commonJS((exports) => {
  async function wrap(alg, key, cek, iv2) {
    const jweAlgorithm = alg.slice(0, 7);
    iv2 || (iv2 = (0, iv_js_1.default)(jweAlgorithm));
    const { ciphertext: encryptedKey, tag } = await (0, encrypt_js_1.default)(jweAlgorithm, cek, key, iv2, new Uint8Array(0));
    return { encryptedKey, iv: (0, base64url_js_1.encode)(iv2), tag: (0, base64url_js_1.encode)(tag) };
  }
  async function unwrap(alg, key, encryptedKey, iv2, tag) {
    const jweAlgorithm = alg.slice(0, 7);
    return (0, decrypt_js_1.default)(jweAlgorithm, key, encryptedKey, iv2, tag, new Uint8Array(0));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unwrap = exports.wrap = undefined;
  var encrypt_js_1 = require_encrypt();
  var decrypt_js_1 = require_decrypt();
  var iv_js_1 = require_iv();
  var base64url_js_1 = require_base64url();
  exports.wrap = wrap;
  exports.unwrap = unwrap;
});

// node_modules/jose/dist/node/cjs/lib/decrypt_key_management.js
var require_decrypt_key_management = __commonJS((exports) => {
  async function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {
    (0, check_key_type_js_1.default)(alg, key, "decrypt");
    switch (alg) {
      case "dir": {
        if (encryptedKey !== undefined)
          throw new errors_js_1.JWEInvalid("Encountered unexpected JWE Encrypted Key");
        return key;
      }
      case "ECDH-ES":
        if (encryptedKey !== undefined)
          throw new errors_js_1.JWEInvalid("Encountered unexpected JWE Encrypted Key");
      case "ECDH-ES+A128KW":
      case "ECDH-ES+A192KW":
      case "ECDH-ES+A256KW": {
        if (!(0, is_object_js_1.default)(joseHeader.epk))
          throw new errors_js_1.JWEInvalid(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
        if (!ECDH.ecdhAllowed(key))
          throw new errors_js_1.JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
        const epk = await (0, import_js_1.importJWK)(joseHeader.epk, alg);
        let partyUInfo;
        let partyVInfo;
        if (joseHeader.apu !== undefined) {
          if (typeof joseHeader.apu !== "string")
            throw new errors_js_1.JWEInvalid(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
          try {
            partyUInfo = (0, base64url_js_1.decode)(joseHeader.apu);
          } catch {
            throw new errors_js_1.JWEInvalid("Failed to base64url decode the apu");
          }
        }
        if (joseHeader.apv !== undefined) {
          if (typeof joseHeader.apv !== "string")
            throw new errors_js_1.JWEInvalid(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
          try {
            partyVInfo = (0, base64url_js_1.decode)(joseHeader.apv);
          } catch {
            throw new errors_js_1.JWEInvalid("Failed to base64url decode the apv");
          }
        }
        const sharedSecret = await ECDH.deriveKey(epk, key, alg === "ECDH-ES" ? joseHeader.enc : alg, alg === "ECDH-ES" ? (0, cek_js_1.bitLength)(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);
        if (alg === "ECDH-ES")
          return sharedSecret;
        if (encryptedKey === undefined)
          throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
        return (0, aeskw_js_1.unwrap)(alg.slice(-6), sharedSecret, encryptedKey);
      }
      case "RSA1_5":
      case "RSA-OAEP":
      case "RSA-OAEP-256":
      case "RSA-OAEP-384":
      case "RSA-OAEP-512": {
        if (encryptedKey === undefined)
          throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
        return (0, rsaes_js_1.decrypt)(alg, key, encryptedKey);
      }
      case "PBES2-HS256+A128KW":
      case "PBES2-HS384+A192KW":
      case "PBES2-HS512+A256KW": {
        if (encryptedKey === undefined)
          throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
        if (typeof joseHeader.p2c !== "number")
          throw new errors_js_1.JWEInvalid(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
        const p2cLimit = (options === null || options === undefined ? undefined : options.maxPBES2Count) || 1e4;
        if (joseHeader.p2c > p2cLimit)
          throw new errors_js_1.JWEInvalid(`JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds`);
        if (typeof joseHeader.p2s !== "string")
          throw new errors_js_1.JWEInvalid(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
        let p2s;
        try {
          p2s = (0, base64url_js_1.decode)(joseHeader.p2s);
        } catch {
          throw new errors_js_1.JWEInvalid("Failed to base64url decode the p2s");
        }
        return (0, pbes2kw_js_1.decrypt)(alg, key, encryptedKey, joseHeader.p2c, p2s);
      }
      case "A128KW":
      case "A192KW":
      case "A256KW": {
        if (encryptedKey === undefined)
          throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
        return (0, aeskw_js_1.unwrap)(alg, key, encryptedKey);
      }
      case "A128GCMKW":
      case "A192GCMKW":
      case "A256GCMKW": {
        if (encryptedKey === undefined)
          throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
        if (typeof joseHeader.iv !== "string")
          throw new errors_js_1.JWEInvalid(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
        if (typeof joseHeader.tag !== "string")
          throw new errors_js_1.JWEInvalid(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
        let iv2;
        try {
          iv2 = (0, base64url_js_1.decode)(joseHeader.iv);
        } catch {
          throw new errors_js_1.JWEInvalid("Failed to base64url decode the iv");
        }
        let tag;
        try {
          tag = (0, base64url_js_1.decode)(joseHeader.tag);
        } catch {
          throw new errors_js_1.JWEInvalid("Failed to base64url decode the tag");
        }
        return (0, aesgcmkw_js_1.unwrap)(alg, key, encryptedKey, iv2, tag);
      }
      default: {
        throw new errors_js_1.JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
      }
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  var aeskw_js_1 = require_aeskw();
  var ECDH = require_ecdhes();
  var pbes2kw_js_1 = require_pbes2kw();
  var rsaes_js_1 = require_rsaes();
  var base64url_js_1 = require_base64url();
  var errors_js_1 = require_errors3();
  var cek_js_1 = require_cek();
  var import_js_1 = require_import();
  var check_key_type_js_1 = require_check_key_type();
  var is_object_js_1 = require_is_object();
  var aesgcmkw_js_1 = require_aesgcmkw();
  exports.default = decryptKeyManagement;
});

// node_modules/jose/dist/node/cjs/lib/validate_crit.js
var require_validate_crit = __commonJS((exports) => {
  function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
    if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {
      throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
    }
    if (!protectedHeader || protectedHeader.crit === undefined) {
      return new Set;
    }
    if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
      throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
    }
    let recognized;
    if (recognizedOption !== undefined) {
      recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
    } else {
      recognized = recognizedDefault;
    }
    for (const parameter of protectedHeader.crit) {
      if (!recognized.has(parameter)) {
        throw new errors_js_1.JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
      }
      if (joseHeader[parameter] === undefined) {
        throw new Err(`Extension Header Parameter "${parameter}" is missing`);
      } else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
        throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
      }
    }
    return new Set(protectedHeader.crit);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  var errors_js_1 = require_errors3();
  exports.default = validateCrit;
});

// node_modules/jose/dist/node/cjs/lib/validate_algorithms.js
var require_validate_algorithms = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var validateAlgorithms = (option2, algorithms) => {
    if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some((s3) => typeof s3 !== "string"))) {
      throw new TypeError(`"${option2}" option must be an array of strings`);
    }
    if (!algorithms) {
      return;
    }
    return new Set(algorithms);
  };
  exports.default = validateAlgorithms;
});

// node_modules/jose/dist/node/cjs/jwe/flattened/decrypt.js
var require_decrypt2 = __commonJS((exports) => {
  async function flattenedDecrypt(jwe, key, options) {
    var _a3;
    if (!(0, is_object_js_1.default)(jwe)) {
      throw new errors_js_1.JWEInvalid("Flattened JWE must be an object");
    }
    if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) {
      throw new errors_js_1.JWEInvalid("JOSE Header missing");
    }
    if (typeof jwe.iv !== "string") {
      throw new errors_js_1.JWEInvalid("JWE Initialization Vector missing or incorrect type");
    }
    if (typeof jwe.ciphertext !== "string") {
      throw new errors_js_1.JWEInvalid("JWE Ciphertext missing or incorrect type");
    }
    if (typeof jwe.tag !== "string") {
      throw new errors_js_1.JWEInvalid("JWE Authentication Tag missing or incorrect type");
    }
    if (jwe.protected !== undefined && typeof jwe.protected !== "string") {
      throw new errors_js_1.JWEInvalid("JWE Protected Header incorrect type");
    }
    if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== "string") {
      throw new errors_js_1.JWEInvalid("JWE Encrypted Key incorrect type");
    }
    if (jwe.aad !== undefined && typeof jwe.aad !== "string") {
      throw new errors_js_1.JWEInvalid("JWE AAD incorrect type");
    }
    if (jwe.header !== undefined && !(0, is_object_js_1.default)(jwe.header)) {
      throw new errors_js_1.JWEInvalid("JWE Shared Unprotected Header incorrect type");
    }
    if (jwe.unprotected !== undefined && !(0, is_object_js_1.default)(jwe.unprotected)) {
      throw new errors_js_1.JWEInvalid("JWE Per-Recipient Unprotected Header incorrect type");
    }
    let parsedProt;
    if (jwe.protected) {
      try {
        const protectedHeader2 = (0, base64url_js_1.decode)(jwe.protected);
        parsedProt = JSON.parse(buffer_utils_js_1.decoder.decode(protectedHeader2));
      } catch {
        throw new errors_js_1.JWEInvalid("JWE Protected Header is invalid");
      }
    }
    if (!(0, is_disjoint_js_1.default)(parsedProt, jwe.header, jwe.unprotected)) {
      throw new errors_js_1.JWEInvalid("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...parsedProt,
      ...jwe.header,
      ...jwe.unprotected
    };
    (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, new Map, options === null || options === undefined ? undefined : options.crit, parsedProt, joseHeader);
    if (joseHeader.zip !== undefined) {
      if (!parsedProt || !parsedProt.zip) {
        throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
      }
      if (joseHeader.zip !== "DEF") {
        throw new errors_js_1.JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
      }
    }
    const { alg, enc } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new errors_js_1.JWEInvalid("missing JWE Algorithm (alg) in JWE Header");
    }
    if (typeof enc !== "string" || !enc) {
      throw new errors_js_1.JWEInvalid("missing JWE Encryption Algorithm (enc) in JWE Header");
    }
    const keyManagementAlgorithms = options && (0, validate_algorithms_js_1.default)("keyManagementAlgorithms", options.keyManagementAlgorithms);
    const contentEncryptionAlgorithms = options && (0, validate_algorithms_js_1.default)("contentEncryptionAlgorithms", options.contentEncryptionAlgorithms);
    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {
      throw new errors_js_1.JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
    }
    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {
      throw new errors_js_1.JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter not allowed');
    }
    let encryptedKey;
    if (jwe.encrypted_key !== undefined) {
      try {
        encryptedKey = (0, base64url_js_1.decode)(jwe.encrypted_key);
      } catch {
        throw new errors_js_1.JWEInvalid("Failed to base64url decode the encrypted_key");
      }
    }
    let resolvedKey = false;
    if (typeof key === "function") {
      key = await key(parsedProt, jwe);
      resolvedKey = true;
    }
    let cek;
    try {
      cek = await (0, decrypt_key_management_js_1.default)(alg, key, encryptedKey, joseHeader, options);
    } catch (err) {
      if (err instanceof TypeError || err instanceof errors_js_1.JWEInvalid || err instanceof errors_js_1.JOSENotSupported) {
        throw err;
      }
      cek = (0, cek_js_1.default)(enc);
    }
    let iv2;
    let tag;
    try {
      iv2 = (0, base64url_js_1.decode)(jwe.iv);
    } catch {
      throw new errors_js_1.JWEInvalid("Failed to base64url decode the iv");
    }
    try {
      tag = (0, base64url_js_1.decode)(jwe.tag);
    } catch {
      throw new errors_js_1.JWEInvalid("Failed to base64url decode the tag");
    }
    const protectedHeader = buffer_utils_js_1.encoder.encode((_a3 = jwe.protected) !== null && _a3 !== undefined ? _a3 : "");
    let additionalData;
    if (jwe.aad !== undefined) {
      additionalData = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode("."), buffer_utils_js_1.encoder.encode(jwe.aad));
    } else {
      additionalData = protectedHeader;
    }
    let ciphertext;
    try {
      ciphertext = (0, base64url_js_1.decode)(jwe.ciphertext);
    } catch {
      throw new errors_js_1.JWEInvalid("Failed to base64url decode the ciphertext");
    }
    let plaintext = await (0, decrypt_js_1.default)(enc, cek, ciphertext, iv2, tag, additionalData);
    if (joseHeader.zip === "DEF") {
      plaintext = await ((options === null || options === undefined ? undefined : options.inflateRaw) || zlib_js_1.inflate)(plaintext);
    }
    const result2 = { plaintext };
    if (jwe.protected !== undefined) {
      result2.protectedHeader = parsedProt;
    }
    if (jwe.aad !== undefined) {
      try {
        result2.additionalAuthenticatedData = (0, base64url_js_1.decode)(jwe.aad);
      } catch {
        throw new errors_js_1.JWEInvalid("Failed to base64url decode the aad");
      }
    }
    if (jwe.unprotected !== undefined) {
      result2.sharedUnprotectedHeader = jwe.unprotected;
    }
    if (jwe.header !== undefined) {
      result2.unprotectedHeader = jwe.header;
    }
    if (resolvedKey) {
      return { ...result2, key };
    }
    return result2;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flattenedDecrypt = undefined;
  var base64url_js_1 = require_base64url();
  var decrypt_js_1 = require_decrypt();
  var zlib_js_1 = require_zlib();
  var errors_js_1 = require_errors3();
  var is_disjoint_js_1 = require_is_disjoint();
  var is_object_js_1 = require_is_object();
  var decrypt_key_management_js_1 = require_decrypt_key_management();
  var buffer_utils_js_1 = require_buffer_utils();
  var cek_js_1 = require_cek();
  var validate_crit_js_1 = require_validate_crit();
  var validate_algorithms_js_1 = require_validate_algorithms();
  exports.flattenedDecrypt = flattenedDecrypt;
});

// node_modules/jose/dist/node/cjs/jwe/compact/decrypt.js
var require_decrypt3 = __commonJS((exports) => {
  async function compactDecrypt(jwe, key, options) {
    if (jwe instanceof Uint8Array) {
      jwe = buffer_utils_js_1.decoder.decode(jwe);
    }
    if (typeof jwe !== "string") {
      throw new errors_js_1.JWEInvalid("Compact JWE must be a string or Uint8Array");
    }
    const { 0: protectedHeader, 1: encryptedKey, 2: iv2, 3: ciphertext, 4: tag, length } = jwe.split(".");
    if (length !== 5) {
      throw new errors_js_1.JWEInvalid("Invalid Compact JWE");
    }
    const decrypted = await (0, decrypt_js_1.flattenedDecrypt)({
      ciphertext,
      iv: iv2 || undefined,
      protected: protectedHeader || undefined,
      tag: tag || undefined,
      encrypted_key: encryptedKey || undefined
    }, key, options);
    const result2 = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };
    if (typeof key === "function") {
      return { ...result2, key: decrypted.key };
    }
    return result2;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compactDecrypt = undefined;
  var decrypt_js_1 = require_decrypt2();
  var errors_js_1 = require_errors3();
  var buffer_utils_js_1 = require_buffer_utils();
  exports.compactDecrypt = compactDecrypt;
});

// node_modules/jose/dist/node/cjs/jwe/general/decrypt.js
var require_decrypt4 = __commonJS((exports) => {
  async function generalDecrypt(jwe, key, options) {
    if (!(0, is_object_js_1.default)(jwe)) {
      throw new errors_js_1.JWEInvalid("General JWE must be an object");
    }
    if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(is_object_js_1.default)) {
      throw new errors_js_1.JWEInvalid("JWE Recipients missing or incorrect type");
    }
    if (!jwe.recipients.length) {
      throw new errors_js_1.JWEInvalid("JWE Recipients has no members");
    }
    for (const recipient of jwe.recipients) {
      try {
        return await (0, decrypt_js_1.flattenedDecrypt)({
          aad: jwe.aad,
          ciphertext: jwe.ciphertext,
          encrypted_key: recipient.encrypted_key,
          header: recipient.header,
          iv: jwe.iv,
          protected: jwe.protected,
          tag: jwe.tag,
          unprotected: jwe.unprotected
        }, key, options);
      } catch {
      }
    }
    throw new errors_js_1.JWEDecryptionFailed;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generalDecrypt = undefined;
  var decrypt_js_1 = require_decrypt2();
  var errors_js_1 = require_errors3();
  var is_object_js_1 = require_is_object();
  exports.generalDecrypt = generalDecrypt;
});

// node_modules/jose/dist/node/cjs/runtime/asn1_sequence_decoder.js
var require_asn1_sequence_decoder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tagInteger = 2;
  var tagSequence = 48;

  class Asn1SequenceDecoder {
    constructor(buffer2) {
      if (buffer2[0] !== tagSequence) {
        throw new TypeError;
      }
      this.buffer = buffer2;
      this.offset = 1;
      const len = this.decodeLength();
      if (len !== buffer2.length - this.offset) {
        throw new TypeError;
      }
    }
    decodeLength() {
      let length = this.buffer[this.offset++];
      if (length & 128) {
        const nBytes = length & ~128;
        length = 0;
        for (let i = 0;i < nBytes; i++)
          length = length << 8 | this.buffer[this.offset + i];
        this.offset += nBytes;
      }
      return length;
    }
    unsignedInteger() {
      if (this.buffer[this.offset++] !== tagInteger) {
        throw new TypeError;
      }
      let length = this.decodeLength();
      if (this.buffer[this.offset] === 0) {
        this.offset++;
        length--;
      }
      const result2 = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return result2;
    }
    end() {
      if (this.offset !== this.buffer.length) {
        throw new TypeError;
      }
    }
  }
  exports.default = Asn1SequenceDecoder;
});

// node_modules/jose/dist/node/cjs/runtime/key_to_jwk.js
var require_key_to_jwk = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto_1 = __require("crypto");
  var base64url_js_1 = require_base64url();
  var asn1_sequence_decoder_js_1 = require_asn1_sequence_decoder();
  var errors_js_1 = require_errors3();
  var get_named_curve_js_1 = require_get_named_curve();
  var webcrypto_js_1 = require_webcrypto();
  var is_key_object_js_1 = require_is_key_object();
  var invalid_key_input_js_1 = require_invalid_key_input();
  var is_key_like_js_1 = require_is_key_like();
  var flags_js_1 = require_flags();
  var keyToJWK = (key) => {
    let keyObject;
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
      if (!key.extractable) {
        throw new TypeError("CryptoKey is not extractable");
      }
      keyObject = crypto_1.KeyObject.from(key);
    } else if ((0, is_key_object_js_1.default)(key)) {
      keyObject = key;
    } else if (key instanceof Uint8Array) {
      return {
        kty: "oct",
        k: (0, base64url_js_1.encode)(key)
      };
    } else {
      throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, "Uint8Array"));
    }
    if (flags_js_1.jwkExport) {
      if (keyObject.type !== "secret" && !["rsa", "ec", "ed25519", "x25519", "ed448", "x448"].includes(keyObject.asymmetricKeyType)) {
        throw new errors_js_1.JOSENotSupported("Unsupported key asymmetricKeyType");
      }
      return keyObject.export({ format: "jwk" });
    }
    switch (keyObject.type) {
      case "secret":
        return {
          kty: "oct",
          k: (0, base64url_js_1.encode)(keyObject.export())
        };
      case "private":
      case "public": {
        switch (keyObject.asymmetricKeyType) {
          case "rsa": {
            const der = keyObject.export({ format: "der", type: "pkcs1" });
            const dec = new asn1_sequence_decoder_js_1.default(der);
            if (keyObject.type === "private") {
              dec.unsignedInteger();
            }
            const n2 = (0, base64url_js_1.encode)(dec.unsignedInteger());
            const e2 = (0, base64url_js_1.encode)(dec.unsignedInteger());
            let jwk;
            if (keyObject.type === "private") {
              jwk = {
                d: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                p: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                q: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                dp: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                dq: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                qi: (0, base64url_js_1.encode)(dec.unsignedInteger())
              };
            }
            dec.end();
            return { kty: "RSA", n: n2, e: e2, ...jwk };
          }
          case "ec": {
            const crv = (0, get_named_curve_js_1.default)(keyObject);
            let len;
            let offset;
            let correction;
            switch (crv) {
              case "secp256k1":
                len = 64;
                offset = 31 + 2;
                correction = -1;
                break;
              case "P-256":
                len = 64;
                offset = 34 + 2;
                correction = -1;
                break;
              case "P-384":
                len = 96;
                offset = 33 + 2;
                correction = -3;
                break;
              case "P-521":
                len = 132;
                offset = 33 + 2;
                correction = -3;
                break;
              default:
                throw new errors_js_1.JOSENotSupported("Unsupported curve");
            }
            if (keyObject.type === "public") {
              const der2 = keyObject.export({ type: "spki", format: "der" });
              return {
                kty: "EC",
                crv,
                x: (0, base64url_js_1.encode)(der2.subarray(-len, -len / 2)),
                y: (0, base64url_js_1.encode)(der2.subarray(-len / 2))
              };
            }
            const der = keyObject.export({ type: "pkcs8", format: "der" });
            if (der.length < 100) {
              offset += correction;
            }
            return {
              ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
              d: (0, base64url_js_1.encode)(der.subarray(offset, offset + len / 2))
            };
          }
          case "ed25519":
          case "x25519": {
            const crv = (0, get_named_curve_js_1.default)(keyObject);
            if (keyObject.type === "public") {
              const der2 = keyObject.export({ type: "spki", format: "der" });
              return {
                kty: "OKP",
                crv,
                x: (0, base64url_js_1.encode)(der2.subarray(-32))
              };
            }
            const der = keyObject.export({ type: "pkcs8", format: "der" });
            return {
              ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
              d: (0, base64url_js_1.encode)(der.subarray(-32))
            };
          }
          case "ed448":
          case "x448": {
            const crv = (0, get_named_curve_js_1.default)(keyObject);
            if (keyObject.type === "public") {
              const der2 = keyObject.export({ type: "spki", format: "der" });
              return {
                kty: "OKP",
                crv,
                x: (0, base64url_js_1.encode)(der2.subarray(crv === "Ed448" ? -57 : -56))
              };
            }
            const der = keyObject.export({ type: "pkcs8", format: "der" });
            return {
              ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
              d: (0, base64url_js_1.encode)(der.subarray(crv === "Ed448" ? -57 : -56))
            };
          }
          default:
            throw new errors_js_1.JOSENotSupported("Unsupported key asymmetricKeyType");
        }
      }
      default:
        throw new errors_js_1.JOSENotSupported("Unsupported key type");
    }
  };
  exports.default = keyToJWK;
});

// node_modules/jose/dist/node/cjs/key/export.js
var require_export = __commonJS((exports) => {
  async function exportSPKI(key) {
    return (0, asn1_js_1.toSPKI)(key);
  }
  async function exportPKCS8(key) {
    return (0, asn1_js_2.toPKCS8)(key);
  }
  async function exportJWK(key) {
    return (0, key_to_jwk_js_1.default)(key);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exportJWK = exports.exportPKCS8 = exports.exportSPKI = undefined;
  var asn1_js_1 = require_asn1();
  var asn1_js_2 = require_asn1();
  var key_to_jwk_js_1 = require_key_to_jwk();
  exports.exportSPKI = exportSPKI;
  exports.exportPKCS8 = exportPKCS8;
  exports.exportJWK = exportJWK;
});

// node_modules/jose/dist/node/cjs/lib/encrypt_key_management.js
var require_encrypt_key_management = __commonJS((exports) => {
  async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {
    let encryptedKey;
    let parameters;
    let cek;
    (0, check_key_type_js_1.default)(alg, key, "encrypt");
    switch (alg) {
      case "dir": {
        cek = key;
        break;
      }
      case "ECDH-ES":
      case "ECDH-ES+A128KW":
      case "ECDH-ES+A192KW":
      case "ECDH-ES+A256KW": {
        if (!ECDH.ecdhAllowed(key)) {
          throw new errors_js_1.JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
        }
        const { apu, apv } = providedParameters;
        let { epk: ephemeralKey } = providedParameters;
        ephemeralKey || (ephemeralKey = (await ECDH.generateEpk(key)).privateKey);
        const { x, y: y2, crv, kty } = await (0, export_js_1.exportJWK)(ephemeralKey);
        const sharedSecret = await ECDH.deriveKey(key, ephemeralKey, alg === "ECDH-ES" ? enc : alg, alg === "ECDH-ES" ? (0, cek_js_1.bitLength)(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);
        parameters = { epk: { x, crv, kty } };
        if (kty === "EC")
          parameters.epk.y = y2;
        if (apu)
          parameters.apu = (0, base64url_js_1.encode)(apu);
        if (apv)
          parameters.apv = (0, base64url_js_1.encode)(apv);
        if (alg === "ECDH-ES") {
          cek = sharedSecret;
          break;
        }
        cek = providedCek || (0, cek_js_1.default)(enc);
        const kwAlg = alg.slice(-6);
        encryptedKey = await (0, aeskw_js_1.wrap)(kwAlg, sharedSecret, cek);
        break;
      }
      case "RSA1_5":
      case "RSA-OAEP":
      case "RSA-OAEP-256":
      case "RSA-OAEP-384":
      case "RSA-OAEP-512": {
        cek = providedCek || (0, cek_js_1.default)(enc);
        encryptedKey = await (0, rsaes_js_1.encrypt)(alg, key, cek);
        break;
      }
      case "PBES2-HS256+A128KW":
      case "PBES2-HS384+A192KW":
      case "PBES2-HS512+A256KW": {
        cek = providedCek || (0, cek_js_1.default)(enc);
        const { p2c, p2s } = providedParameters;
        ({ encryptedKey, ...parameters } = await (0, pbes2kw_js_1.encrypt)(alg, key, cek, p2c, p2s));
        break;
      }
      case "A128KW":
      case "A192KW":
      case "A256KW": {
        cek = providedCek || (0, cek_js_1.default)(enc);
        encryptedKey = await (0, aeskw_js_1.wrap)(alg, key, cek);
        break;
      }
      case "A128GCMKW":
      case "A192GCMKW":
      case "A256GCMKW": {
        cek = providedCek || (0, cek_js_1.default)(enc);
        const { iv: iv2 } = providedParameters;
        ({ encryptedKey, ...parameters } = await (0, aesgcmkw_js_1.wrap)(alg, key, cek, iv2));
        break;
      }
      default: {
        throw new errors_js_1.JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
      }
    }
    return { cek, encryptedKey, parameters };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  var aeskw_js_1 = require_aeskw();
  var ECDH = require_ecdhes();
  var pbes2kw_js_1 = require_pbes2kw();
  var rsaes_js_1 = require_rsaes();
  var base64url_js_1 = require_base64url();
  var cek_js_1 = require_cek();
  var errors_js_1 = require_errors3();
  var export_js_1 = require_export();
  var check_key_type_js_1 = require_check_key_type();
  var aesgcmkw_js_1 = require_aesgcmkw();
  exports.default = encryptKeyManagement;
});

// node_modules/jose/dist/node/cjs/jwe/flattened/encrypt.js
var require_encrypt2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FlattenedEncrypt = exports.unprotected = undefined;
  var base64url_js_1 = require_base64url();
  var encrypt_js_1 = require_encrypt();
  var zlib_js_1 = require_zlib();
  var iv_js_1 = require_iv();
  var encrypt_key_management_js_1 = require_encrypt_key_management();
  var errors_js_1 = require_errors3();
  var is_disjoint_js_1 = require_is_disjoint();
  var buffer_utils_js_1 = require_buffer_utils();
  var validate_crit_js_1 = require_validate_crit();
  exports.unprotected = Symbol();

  class FlattenedEncrypt {
    constructor(plaintext) {
      if (!(plaintext instanceof Uint8Array)) {
        throw new TypeError("plaintext must be an instance of Uint8Array");
      }
      this._plaintext = plaintext;
    }
    setKeyManagementParameters(parameters) {
      if (this._keyManagementParameters) {
        throw new TypeError("setKeyManagementParameters can only be called once");
      }
      this._keyManagementParameters = parameters;
      return this;
    }
    setProtectedHeader(protectedHeader) {
      if (this._protectedHeader) {
        throw new TypeError("setProtectedHeader can only be called once");
      }
      this._protectedHeader = protectedHeader;
      return this;
    }
    setSharedUnprotectedHeader(sharedUnprotectedHeader) {
      if (this._sharedUnprotectedHeader) {
        throw new TypeError("setSharedUnprotectedHeader can only be called once");
      }
      this._sharedUnprotectedHeader = sharedUnprotectedHeader;
      return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
      if (this._unprotectedHeader) {
        throw new TypeError("setUnprotectedHeader can only be called once");
      }
      this._unprotectedHeader = unprotectedHeader;
      return this;
    }
    setAdditionalAuthenticatedData(aad) {
      this._aad = aad;
      return this;
    }
    setContentEncryptionKey(cek) {
      if (this._cek) {
        throw new TypeError("setContentEncryptionKey can only be called once");
      }
      this._cek = cek;
      return this;
    }
    setInitializationVector(iv2) {
      if (this._iv) {
        throw new TypeError("setInitializationVector can only be called once");
      }
      this._iv = iv2;
      return this;
    }
    async encrypt(key, options) {
      if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {
        throw new errors_js_1.JWEInvalid("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");
      }
      if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {
        throw new errors_js_1.JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
      }
      const joseHeader = {
        ...this._protectedHeader,
        ...this._unprotectedHeader,
        ...this._sharedUnprotectedHeader
      };
      (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, new Map, options === null || options === undefined ? undefined : options.crit, this._protectedHeader, joseHeader);
      if (joseHeader.zip !== undefined) {
        if (!this._protectedHeader || !this._protectedHeader.zip) {
          throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
        }
        if (joseHeader.zip !== "DEF") {
          throw new errors_js_1.JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
        }
      }
      const { alg, enc } = joseHeader;
      if (typeof alg !== "string" || !alg) {
        throw new errors_js_1.JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
      }
      if (typeof enc !== "string" || !enc) {
        throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
      }
      let encryptedKey;
      if (alg === "dir") {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption");
        }
      } else if (alg === "ECDH-ES") {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");
        }
      }
      let cek;
      {
        let parameters;
        ({ cek, encryptedKey, parameters } = await (0, encrypt_key_management_js_1.default)(alg, enc, key, this._cek, this._keyManagementParameters));
        if (parameters) {
          if (options && exports.unprotected in options) {
            if (!this._unprotectedHeader) {
              this.setUnprotectedHeader(parameters);
            } else {
              this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };
            }
          } else {
            if (!this._protectedHeader) {
              this.setProtectedHeader(parameters);
            } else {
              this._protectedHeader = { ...this._protectedHeader, ...parameters };
            }
          }
        }
      }
      this._iv || (this._iv = (0, iv_js_1.default)(enc));
      let additionalData;
      let protectedHeader;
      let aadMember;
      if (this._protectedHeader) {
        protectedHeader = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(JSON.stringify(this._protectedHeader)));
      } else {
        protectedHeader = buffer_utils_js_1.encoder.encode("");
      }
      if (this._aad) {
        aadMember = (0, base64url_js_1.encode)(this._aad);
        additionalData = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode("."), buffer_utils_js_1.encoder.encode(aadMember));
      } else {
        additionalData = protectedHeader;
      }
      let ciphertext;
      let tag;
      if (joseHeader.zip === "DEF") {
        const deflated = await ((options === null || options === undefined ? undefined : options.deflateRaw) || zlib_js_1.deflate)(this._plaintext);
        ({ ciphertext, tag } = await (0, encrypt_js_1.default)(enc, deflated, cek, this._iv, additionalData));
      } else {
        ({ ciphertext, tag } = await (0, encrypt_js_1.default)(enc, this._plaintext, cek, this._iv, additionalData));
      }
      const jwe = {
        ciphertext: (0, base64url_js_1.encode)(ciphertext),
        iv: (0, base64url_js_1.encode)(this._iv),
        tag: (0, base64url_js_1.encode)(tag)
      };
      if (encryptedKey) {
        jwe.encrypted_key = (0, base64url_js_1.encode)(encryptedKey);
      }
      if (aadMember) {
        jwe.aad = aadMember;
      }
      if (this._protectedHeader) {
        jwe.protected = buffer_utils_js_1.decoder.decode(protectedHeader);
      }
      if (this._sharedUnprotectedHeader) {
        jwe.unprotected = this._sharedUnprotectedHeader;
      }
      if (this._unprotectedHeader) {
        jwe.header = this._unprotectedHeader;
      }
      return jwe;
    }
  }
  exports.FlattenedEncrypt = FlattenedEncrypt;
});

// node_modules/jose/dist/node/cjs/jwe/general/encrypt.js
var require_encrypt3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GeneralEncrypt = undefined;
  var encrypt_js_1 = require_encrypt2();
  var errors_js_1 = require_errors3();
  var cek_js_1 = require_cek();
  var is_disjoint_js_1 = require_is_disjoint();
  var encrypt_key_management_js_1 = require_encrypt_key_management();
  var base64url_js_1 = require_base64url();
  var validate_crit_js_1 = require_validate_crit();

  class IndividualRecipient {
    constructor(enc, key, options) {
      this.parent = enc;
      this.key = key;
      this.options = options;
    }
    setUnprotectedHeader(unprotectedHeader) {
      if (this.unprotectedHeader) {
        throw new TypeError("setUnprotectedHeader can only be called once");
      }
      this.unprotectedHeader = unprotectedHeader;
      return this;
    }
    addRecipient(...args) {
      return this.parent.addRecipient(...args);
    }
    encrypt(...args) {
      return this.parent.encrypt(...args);
    }
    done() {
      return this.parent;
    }
  }

  class GeneralEncrypt {
    constructor(plaintext) {
      this._recipients = [];
      this._plaintext = plaintext;
    }
    addRecipient(key, options) {
      const recipient = new IndividualRecipient(this, key, { crit: options === null || options === undefined ? undefined : options.crit });
      this._recipients.push(recipient);
      return recipient;
    }
    setProtectedHeader(protectedHeader) {
      if (this._protectedHeader) {
        throw new TypeError("setProtectedHeader can only be called once");
      }
      this._protectedHeader = protectedHeader;
      return this;
    }
    setSharedUnprotectedHeader(sharedUnprotectedHeader) {
      if (this._unprotectedHeader) {
        throw new TypeError("setSharedUnprotectedHeader can only be called once");
      }
      this._unprotectedHeader = sharedUnprotectedHeader;
      return this;
    }
    setAdditionalAuthenticatedData(aad) {
      this._aad = aad;
      return this;
    }
    async encrypt(options) {
      var _a3, _b, _c;
      if (!this._recipients.length) {
        throw new errors_js_1.JWEInvalid("at least one recipient must be added");
      }
      options = { deflateRaw: options === null || options === undefined ? undefined : options.deflateRaw };
      if (this._recipients.length === 1) {
        const [recipient] = this._recipients;
        const flattened = await new encrypt_js_1.FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key, { ...recipient.options, ...options });
        let jwe2 = {
          ciphertext: flattened.ciphertext,
          iv: flattened.iv,
          recipients: [{}],
          tag: flattened.tag
        };
        if (flattened.aad)
          jwe2.aad = flattened.aad;
        if (flattened.protected)
          jwe2.protected = flattened.protected;
        if (flattened.unprotected)
          jwe2.unprotected = flattened.unprotected;
        if (flattened.encrypted_key)
          jwe2.recipients[0].encrypted_key = flattened.encrypted_key;
        if (flattened.header)
          jwe2.recipients[0].header = flattened.header;
        return jwe2;
      }
      let enc;
      for (let i = 0;i < this._recipients.length; i++) {
        const recipient = this._recipients[i];
        if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {
          throw new errors_js_1.JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader,
          ...recipient.unprotectedHeader
        };
        const { alg } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new errors_js_1.JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
        }
        if (alg === "dir" || alg === "ECDH-ES") {
          throw new errors_js_1.JWEInvalid('"dir" and "ECDH-ES" alg may only be used with a single recipient');
        }
        if (typeof joseHeader.enc !== "string" || !joseHeader.enc) {
          throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
        }
        if (!enc) {
          enc = joseHeader.enc;
        } else if (enc !== joseHeader.enc) {
          throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');
        }
        (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, new Map, recipient.options.crit, this._protectedHeader, joseHeader);
        if (joseHeader.zip !== undefined) {
          if (!this._protectedHeader || !this._protectedHeader.zip) {
            throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
          }
        }
      }
      const cek = (0, cek_js_1.default)(enc);
      let jwe = {
        ciphertext: "",
        iv: "",
        recipients: [],
        tag: ""
      };
      for (let i = 0;i < this._recipients.length; i++) {
        const recipient = this._recipients[i];
        const target = {};
        jwe.recipients.push(target);
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader,
          ...recipient.unprotectedHeader
        };
        const p2c = joseHeader.alg.startsWith("PBES2") ? 2048 + i : undefined;
        if (i === 0) {
          const flattened = await new encrypt_js_1.FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(cek).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).setKeyManagementParameters({ p2c }).encrypt(recipient.key, {
            ...recipient.options,
            ...options,
            [encrypt_js_1.unprotected]: true
          });
          jwe.ciphertext = flattened.ciphertext;
          jwe.iv = flattened.iv;
          jwe.tag = flattened.tag;
          if (flattened.aad)
            jwe.aad = flattened.aad;
          if (flattened.protected)
            jwe.protected = flattened.protected;
          if (flattened.unprotected)
            jwe.unprotected = flattened.unprotected;
          target.encrypted_key = flattened.encrypted_key;
          if (flattened.header)
            target.header = flattened.header;
          continue;
        }
        const { encryptedKey, parameters } = await (0, encrypt_key_management_js_1.default)(((_a3 = recipient.unprotectedHeader) === null || _a3 === undefined ? undefined : _a3.alg) || ((_b = this._protectedHeader) === null || _b === undefined ? undefined : _b.alg) || ((_c = this._unprotectedHeader) === null || _c === undefined ? undefined : _c.alg), enc, recipient.key, cek, { p2c });
        target.encrypted_key = (0, base64url_js_1.encode)(encryptedKey);
        if (recipient.unprotectedHeader || parameters)
          target.header = { ...recipient.unprotectedHeader, ...parameters };
      }
      return jwe;
    }
  }
  exports.GeneralEncrypt = GeneralEncrypt;
});

// node_modules/jose/dist/node/cjs/runtime/dsa_digest.js
var require_dsa_digest = __commonJS((exports) => {
  function dsaDigest(alg) {
    switch (alg) {
      case "PS256":
      case "RS256":
      case "ES256":
      case "ES256K":
        return "sha256";
      case "PS384":
      case "RS384":
      case "ES384":
        return "sha384";
      case "PS512":
      case "RS512":
      case "ES512":
        return "sha512";
      case "EdDSA":
        return;
      default:
        throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  var errors_js_1 = require_errors3();
  exports.default = dsaDigest;
});

// node_modules/jose/dist/node/cjs/runtime/node_key.js
var require_node_key = __commonJS((exports) => {
  function keyForCrypto(alg, key) {
    switch (alg) {
      case "EdDSA":
        if (!["ed25519", "ed448"].includes(key.asymmetricKeyType)) {
          throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448");
        }
        return key;
      case "RS256":
      case "RS384":
      case "RS512":
        if (key.asymmetricKeyType !== "rsa") {
          throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
        }
        (0, check_modulus_length_js_1.default)(key, alg);
        return key;
      case (flags_js_1.rsaPssParams && "PS256"):
      case (flags_js_1.rsaPssParams && "PS384"):
      case (flags_js_1.rsaPssParams && "PS512"):
        if (key.asymmetricKeyType === "rsa-pss") {
          const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
          const length = parseInt(alg.slice(-3), 10);
          if (hashAlgorithm !== undefined && (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm)) {
            throw new TypeError(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${alg}`);
          }
          if (saltLength !== undefined && saltLength > length >> 3) {
            throw new TypeError(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${alg}`);
          }
        } else if (key.asymmetricKeyType !== "rsa") {
          throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss");
        }
        (0, check_modulus_length_js_1.default)(key, alg);
        return { key, ...PSS };
      case (!flags_js_1.rsaPssParams && "PS256"):
      case (!flags_js_1.rsaPssParams && "PS384"):
      case (!flags_js_1.rsaPssParams && "PS512"):
        if (key.asymmetricKeyType !== "rsa") {
          throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
        }
        (0, check_modulus_length_js_1.default)(key, alg);
        return { key, ...PSS };
      case "ES256":
      case "ES256K":
      case "ES384":
      case "ES512": {
        if (key.asymmetricKeyType !== "ec") {
          throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be ec");
        }
        const actual = (0, get_named_curve_js_1.default)(key);
        const expected = ecCurveAlgMap.get(alg);
        if (actual !== expected) {
          throw new TypeError(`Invalid key curve for the algorithm, its curve must be ${expected}, got ${actual}`);
        }
        return { dsaEncoding: "ieee-p1363", key };
      }
      default:
        throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto_1 = __require("crypto");
  var get_named_curve_js_1 = require_get_named_curve();
  var errors_js_1 = require_errors3();
  var check_modulus_length_js_1 = require_check_modulus_length();
  var flags_js_1 = require_flags();
  var PSS = {
    padding: crypto_1.constants.RSA_PKCS1_PSS_PADDING,
    saltLength: crypto_1.constants.RSA_PSS_SALTLEN_DIGEST
  };
  var ecCurveAlgMap = new Map([
    ["ES256", "P-256"],
    ["ES256K", "secp256k1"],
    ["ES384", "P-384"],
    ["ES512", "P-521"]
  ]);
  exports.default = keyForCrypto;
});

// node_modules/jose/dist/node/cjs/runtime/hmac_digest.js
var require_hmac_digest = __commonJS((exports) => {
  function hmacDigest(alg) {
    switch (alg) {
      case "HS256":
        return "sha256";
      case "HS384":
        return "sha384";
      case "HS512":
        return "sha512";
      default:
        throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  var errors_js_1 = require_errors3();
  exports.default = hmacDigest;
});

// node_modules/jose/dist/node/cjs/runtime/get_sign_verify_key.js
var require_get_sign_verify_key = __commonJS((exports) => {
  function getSignVerifyKey(alg, key, usage) {
    if (key instanceof Uint8Array) {
      if (!alg.startsWith("HS")) {
        throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
      }
      return (0, crypto_1.createSecretKey)(key);
    }
    if (key instanceof crypto_1.KeyObject) {
      return key;
    }
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
      (0, crypto_key_js_1.checkSigCryptoKey)(key, alg, usage);
      return crypto_1.KeyObject.from(key);
    }
    throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, "Uint8Array"));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto_1 = __require("crypto");
  var webcrypto_js_1 = require_webcrypto();
  var crypto_key_js_1 = require_crypto_key();
  var invalid_key_input_js_1 = require_invalid_key_input();
  var is_key_like_js_1 = require_is_key_like();
  exports.default = getSignVerifyKey;
});

// node_modules/jose/dist/node/cjs/runtime/sign.js
var require_sign2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto3 = __require("crypto");
  var util_1 = __require("util");
  var dsa_digest_js_1 = require_dsa_digest();
  var hmac_digest_js_1 = require_hmac_digest();
  var node_key_js_1 = require_node_key();
  var get_sign_verify_key_js_1 = require_get_sign_verify_key();
  var oneShotSign;
  if (crypto3.sign.length > 3) {
    oneShotSign = (0, util_1.promisify)(crypto3.sign);
  } else {
    oneShotSign = crypto3.sign;
  }
  var sign = async (alg, key, data) => {
    const keyObject = (0, get_sign_verify_key_js_1.default)(alg, key, "sign");
    if (alg.startsWith("HS")) {
      const hmac2 = crypto3.createHmac((0, hmac_digest_js_1.default)(alg), keyObject);
      hmac2.update(data);
      return hmac2.digest();
    }
    return oneShotSign((0, dsa_digest_js_1.default)(alg), data, (0, node_key_js_1.default)(alg, keyObject));
  };
  exports.default = sign;
});

// node_modules/jose/dist/node/cjs/runtime/verify.js
var require_verify = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto3 = __require("crypto");
  var util_1 = __require("util");
  var dsa_digest_js_1 = require_dsa_digest();
  var node_key_js_1 = require_node_key();
  var sign_js_1 = require_sign2();
  var get_sign_verify_key_js_1 = require_get_sign_verify_key();
  var flags_js_1 = require_flags();
  var oneShotVerify;
  if (crypto3.verify.length > 4 && flags_js_1.oneShotCallback) {
    oneShotVerify = (0, util_1.promisify)(crypto3.verify);
  } else {
    oneShotVerify = crypto3.verify;
  }
  var verify = async (alg, key, signature, data) => {
    const keyObject = (0, get_sign_verify_key_js_1.default)(alg, key, "verify");
    if (alg.startsWith("HS")) {
      const expected = await (0, sign_js_1.default)(alg, keyObject, data);
      const actual = signature;
      try {
        return crypto3.timingSafeEqual(actual, expected);
      } catch {
        return false;
      }
    }
    const algorithm = (0, dsa_digest_js_1.default)(alg);
    const keyInput = (0, node_key_js_1.default)(alg, keyObject);
    try {
      return await oneShotVerify(algorithm, data, keyInput, signature);
    } catch {
      return false;
    }
  };
  exports.default = verify;
});

// node_modules/jose/dist/node/cjs/jws/flattened/verify.js
var require_verify2 = __commonJS((exports) => {
  async function flattenedVerify(jws, key, options) {
    var _a3;
    if (!(0, is_object_js_1.default)(jws)) {
      throw new errors_js_1.JWSInvalid("Flattened JWS must be an object");
    }
    if (jws.protected === undefined && jws.header === undefined) {
      throw new errors_js_1.JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
    }
    if (jws.protected !== undefined && typeof jws.protected !== "string") {
      throw new errors_js_1.JWSInvalid("JWS Protected Header incorrect type");
    }
    if (jws.payload === undefined) {
      throw new errors_js_1.JWSInvalid("JWS Payload missing");
    }
    if (typeof jws.signature !== "string") {
      throw new errors_js_1.JWSInvalid("JWS Signature missing or incorrect type");
    }
    if (jws.header !== undefined && !(0, is_object_js_1.default)(jws.header)) {
      throw new errors_js_1.JWSInvalid("JWS Unprotected Header incorrect type");
    }
    let parsedProt = {};
    if (jws.protected) {
      try {
        const protectedHeader = (0, base64url_js_1.decode)(jws.protected);
        parsedProt = JSON.parse(buffer_utils_js_1.decoder.decode(protectedHeader));
      } catch {
        throw new errors_js_1.JWSInvalid("JWS Protected Header is invalid");
      }
    }
    if (!(0, is_disjoint_js_1.default)(parsedProt, jws.header)) {
      throw new errors_js_1.JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...parsedProt,
      ...jws.header
    };
    const extensions = (0, validate_crit_js_1.default)(errors_js_1.JWSInvalid, new Map([["b64", true]]), options === null || options === undefined ? undefined : options.crit, parsedProt, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = parsedProt.b64;
      if (typeof b64 !== "boolean") {
        throw new errors_js_1.JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new errors_js_1.JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    const algorithms = options && (0, validate_algorithms_js_1.default)("algorithms", options.algorithms);
    if (algorithms && !algorithms.has(alg)) {
      throw new errors_js_1.JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
    }
    if (b64) {
      if (typeof jws.payload !== "string") {
        throw new errors_js_1.JWSInvalid("JWS Payload must be a string");
      }
    } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
      throw new errors_js_1.JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
    }
    let resolvedKey = false;
    if (typeof key === "function") {
      key = await key(parsedProt, jws);
      resolvedKey = true;
    }
    (0, check_key_type_js_1.default)(alg, key, "verify");
    const data = (0, buffer_utils_js_1.concat)(buffer_utils_js_1.encoder.encode((_a3 = jws.protected) !== null && _a3 !== undefined ? _a3 : ""), buffer_utils_js_1.encoder.encode("."), typeof jws.payload === "string" ? buffer_utils_js_1.encoder.encode(jws.payload) : jws.payload);
    let signature;
    try {
      signature = (0, base64url_js_1.decode)(jws.signature);
    } catch {
      throw new errors_js_1.JWSInvalid("Failed to base64url decode the signature");
    }
    const verified = await (0, verify_js_1.default)(alg, key, signature, data);
    if (!verified) {
      throw new errors_js_1.JWSSignatureVerificationFailed;
    }
    let payload;
    if (b64) {
      try {
        payload = (0, base64url_js_1.decode)(jws.payload);
      } catch {
        throw new errors_js_1.JWSInvalid("Failed to base64url decode the payload");
      }
    } else if (typeof jws.payload === "string") {
      payload = buffer_utils_js_1.encoder.encode(jws.payload);
    } else {
      payload = jws.payload;
    }
    const result2 = { payload };
    if (jws.protected !== undefined) {
      result2.protectedHeader = parsedProt;
    }
    if (jws.header !== undefined) {
      result2.unprotectedHeader = jws.header;
    }
    if (resolvedKey) {
      return { ...result2, key };
    }
    return result2;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flattenedVerify = undefined;
  var base64url_js_1 = require_base64url();
  var verify_js_1 = require_verify();
  var errors_js_1 = require_errors3();
  var buffer_utils_js_1 = require_buffer_utils();
  var is_disjoint_js_1 = require_is_disjoint();
  var is_object_js_1 = require_is_object();
  var check_key_type_js_1 = require_check_key_type();
  var validate_crit_js_1 = require_validate_crit();
  var validate_algorithms_js_1 = require_validate_algorithms();
  exports.flattenedVerify = flattenedVerify;
});

// node_modules/jose/dist/node/cjs/jws/compact/verify.js
var require_verify3 = __commonJS((exports) => {
  async function compactVerify(jws, key, options) {
    if (jws instanceof Uint8Array) {
      jws = buffer_utils_js_1.decoder.decode(jws);
    }
    if (typeof jws !== "string") {
      throw new errors_js_1.JWSInvalid("Compact JWS must be a string or Uint8Array");
    }
    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
    if (length !== 3) {
      throw new errors_js_1.JWSInvalid("Invalid Compact JWS");
    }
    const verified = await (0, verify_js_1.flattenedVerify)({ payload, protected: protectedHeader, signature }, key, options);
    const result2 = { payload: verified.payload, protectedHeader: verified.protectedHeader };
    if (typeof key === "function") {
      return { ...result2, key: verified.key };
    }
    return result2;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compactVerify = undefined;
  var verify_js_1 = require_verify2();
  var errors_js_1 = require_errors3();
  var buffer_utils_js_1 = require_buffer_utils();
  exports.compactVerify = compactVerify;
});

// node_modules/jose/dist/node/cjs/jws/general/verify.js
var require_verify4 = __commonJS((exports) => {
  async function generalVerify(jws, key, options) {
    if (!(0, is_object_js_1.default)(jws)) {
      throw new errors_js_1.JWSInvalid("General JWS must be an object");
    }
    if (!Array.isArray(jws.signatures) || !jws.signatures.every(is_object_js_1.default)) {
      throw new errors_js_1.JWSInvalid("JWS Signatures missing or incorrect type");
    }
    for (const signature of jws.signatures) {
      try {
        return await (0, verify_js_1.flattenedVerify)({
          header: signature.header,
          payload: jws.payload,
          protected: signature.protected,
          signature: signature.signature
        }, key, options);
      } catch {
      }
    }
    throw new errors_js_1.JWSSignatureVerificationFailed;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generalVerify = undefined;
  var verify_js_1 = require_verify2();
  var errors_js_1 = require_errors3();
  var is_object_js_1 = require_is_object();
  exports.generalVerify = generalVerify;
});

// node_modules/jose/dist/node/cjs/lib/epoch.js
var require_epoch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = (date) => Math.floor(date.getTime() / 1000);
});

// node_modules/jose/dist/node/cjs/lib/secs.js
var require_secs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var minute = 60;
  var hour = minute * 60;
  var day = hour * 24;
  var week = day * 7;
  var year = day * 365.25;
  var REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
  exports.default = (str) => {
    const matched = REGEX.exec(str);
    if (!matched) {
      throw new TypeError("Invalid time period format");
    }
    const value = parseFloat(matched[1]);
    const unit = matched[2].toLowerCase();
    switch (unit) {
      case "sec":
      case "secs":
      case "second":
      case "seconds":
      case "s":
        return Math.round(value);
      case "minute":
      case "minutes":
      case "min":
      case "mins":
      case "m":
        return Math.round(value * minute);
      case "hour":
      case "hours":
      case "hr":
      case "hrs":
      case "h":
        return Math.round(value * hour);
      case "day":
      case "days":
      case "d":
        return Math.round(value * day);
      case "week":
      case "weeks":
      case "w":
        return Math.round(value * week);
      default:
        return Math.round(value * year);
    }
  };
});

// node_modules/jose/dist/node/cjs/lib/jwt_claims_set.js
var require_jwt_claims_set = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var errors_js_1 = require_errors3();
  var buffer_utils_js_1 = require_buffer_utils();
  var epoch_js_1 = require_epoch();
  var secs_js_1 = require_secs();
  var is_object_js_1 = require_is_object();
  var normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
  var checkAudiencePresence = (audPayload, audOption) => {
    if (typeof audPayload === "string") {
      return audOption.includes(audPayload);
    }
    if (Array.isArray(audPayload)) {
      return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
    }
    return false;
  };
  exports.default = (protectedHeader, encodedPayload, options = {}) => {
    const { typ } = options;
    if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
      throw new errors_js_1.JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
    }
    let payload;
    try {
      payload = JSON.parse(buffer_utils_js_1.decoder.decode(encodedPayload));
    } catch {
    }
    if (!(0, is_object_js_1.default)(payload)) {
      throw new errors_js_1.JWTInvalid("JWT Claims Set must be a top-level JSON object");
    }
    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
    if (maxTokenAge !== undefined)
      requiredClaims.push("iat");
    if (audience !== undefined)
      requiredClaims.push("aud");
    if (subject !== undefined)
      requiredClaims.push("sub");
    if (issuer !== undefined)
      requiredClaims.push("iss");
    for (const claim of new Set(requiredClaims.reverse())) {
      if (!(claim in payload)) {
        throw new errors_js_1.JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, "missing");
      }
    }
    if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
      throw new errors_js_1.JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
    }
    if (subject && payload.sub !== subject) {
      throw new errors_js_1.JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
    }
    if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
      throw new errors_js_1.JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
    }
    let tolerance;
    switch (typeof options.clockTolerance) {
      case "string":
        tolerance = (0, secs_js_1.default)(options.clockTolerance);
        break;
      case "number":
        tolerance = options.clockTolerance;
        break;
      case "undefined":
        tolerance = 0;
        break;
      default:
        throw new TypeError("Invalid clockTolerance option type");
    }
    const { currentDate } = options;
    const now = (0, epoch_js_1.default)(currentDate || new Date);
    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== "number") {
      throw new errors_js_1.JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
    }
    if (payload.nbf !== undefined) {
      if (typeof payload.nbf !== "number") {
        throw new errors_js_1.JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
      }
      if (payload.nbf > now + tolerance) {
        throw new errors_js_1.JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
      }
    }
    if (payload.exp !== undefined) {
      if (typeof payload.exp !== "number") {
        throw new errors_js_1.JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
      }
      if (payload.exp <= now - tolerance) {
        throw new errors_js_1.JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
      }
    }
    if (maxTokenAge) {
      const age = now - payload.iat;
      const max = typeof maxTokenAge === "number" ? maxTokenAge : (0, secs_js_1.default)(maxTokenAge);
      if (age - tolerance > max) {
        throw new errors_js_1.JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
      }
      if (age < 0 - tolerance) {
        throw new errors_js_1.JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
      }
    }
    return payload;
  };
});

// node_modules/jose/dist/node/cjs/jwt/verify.js
var require_verify5 = __commonJS((exports) => {
  async function jwtVerify(jwt, key, options) {
    var _a3;
    const verified = await (0, verify_js_1.compactVerify)(jwt, key, options);
    if (((_a3 = verified.protectedHeader.crit) === null || _a3 === undefined ? undefined : _a3.includes("b64")) && verified.protectedHeader.b64 === false) {
      throw new errors_js_1.JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    const payload = (0, jwt_claims_set_js_1.default)(verified.protectedHeader, verified.payload, options);
    const result2 = { payload, protectedHeader: verified.protectedHeader };
    if (typeof key === "function") {
      return { ...result2, key: verified.key };
    }
    return result2;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.jwtVerify = undefined;
  var verify_js_1 = require_verify3();
  var jwt_claims_set_js_1 = require_jwt_claims_set();
  var errors_js_1 = require_errors3();
  exports.jwtVerify = jwtVerify;
});

// node_modules/jose/dist/node/cjs/jwt/decrypt.js
var require_decrypt5 = __commonJS((exports) => {
  async function jwtDecrypt(jwt, key, options) {
    const decrypted = await (0, decrypt_js_1.compactDecrypt)(jwt, key, options);
    const payload = (0, jwt_claims_set_js_1.default)(decrypted.protectedHeader, decrypted.plaintext, options);
    const { protectedHeader } = decrypted;
    if (protectedHeader.iss !== undefined && protectedHeader.iss !== payload.iss) {
      throw new errors_js_1.JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch', "iss", "mismatch");
    }
    if (protectedHeader.sub !== undefined && protectedHeader.sub !== payload.sub) {
      throw new errors_js_1.JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch', "sub", "mismatch");
    }
    if (protectedHeader.aud !== undefined && JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {
      throw new errors_js_1.JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch', "aud", "mismatch");
    }
    const result2 = { payload, protectedHeader };
    if (typeof key === "function") {
      return { ...result2, key: decrypted.key };
    }
    return result2;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.jwtDecrypt = undefined;
  var decrypt_js_1 = require_decrypt3();
  var jwt_claims_set_js_1 = require_jwt_claims_set();
  var errors_js_1 = require_errors3();
  exports.jwtDecrypt = jwtDecrypt;
});

// node_modules/jose/dist/node/cjs/jwe/compact/encrypt.js
var require_encrypt4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CompactEncrypt = undefined;
  var encrypt_js_1 = require_encrypt2();

  class CompactEncrypt {
    constructor(plaintext) {
      this._flattened = new encrypt_js_1.FlattenedEncrypt(plaintext);
    }
    setContentEncryptionKey(cek) {
      this._flattened.setContentEncryptionKey(cek);
      return this;
    }
    setInitializationVector(iv2) {
      this._flattened.setInitializationVector(iv2);
      return this;
    }
    setProtectedHeader(protectedHeader) {
      this._flattened.setProtectedHeader(protectedHeader);
      return this;
    }
    setKeyManagementParameters(parameters) {
      this._flattened.setKeyManagementParameters(parameters);
      return this;
    }
    async encrypt(key, options) {
      const jwe = await this._flattened.encrypt(key, options);
      return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join(".");
    }
  }
  exports.CompactEncrypt = CompactEncrypt;
});

// node_modules/jose/dist/node/cjs/jws/flattened/sign.js
var require_sign3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FlattenedSign = undefined;
  var base64url_js_1 = require_base64url();
  var sign_js_1 = require_sign2();
  var is_disjoint_js_1 = require_is_disjoint();
  var errors_js_1 = require_errors3();
  var buffer_utils_js_1 = require_buffer_utils();
  var check_key_type_js_1 = require_check_key_type();
  var validate_crit_js_1 = require_validate_crit();

  class FlattenedSign {
    constructor(payload) {
      if (!(payload instanceof Uint8Array)) {
        throw new TypeError("payload must be an instance of Uint8Array");
      }
      this._payload = payload;
    }
    setProtectedHeader(protectedHeader) {
      if (this._protectedHeader) {
        throw new TypeError("setProtectedHeader can only be called once");
      }
      this._protectedHeader = protectedHeader;
      return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
      if (this._unprotectedHeader) {
        throw new TypeError("setUnprotectedHeader can only be called once");
      }
      this._unprotectedHeader = unprotectedHeader;
      return this;
    }
    async sign(key, options) {
      if (!this._protectedHeader && !this._unprotectedHeader) {
        throw new errors_js_1.JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
      }
      if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader)) {
        throw new errors_js_1.JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
      }
      const joseHeader = {
        ...this._protectedHeader,
        ...this._unprotectedHeader
      };
      const extensions = (0, validate_crit_js_1.default)(errors_js_1.JWSInvalid, new Map([["b64", true]]), options === null || options === undefined ? undefined : options.crit, this._protectedHeader, joseHeader);
      let b64 = true;
      if (extensions.has("b64")) {
        b64 = this._protectedHeader.b64;
        if (typeof b64 !== "boolean") {
          throw new errors_js_1.JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
        }
      }
      const { alg } = joseHeader;
      if (typeof alg !== "string" || !alg) {
        throw new errors_js_1.JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
      }
      (0, check_key_type_js_1.default)(alg, key, "sign");
      let payload = this._payload;
      if (b64) {
        payload = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(payload));
      }
      let protectedHeader;
      if (this._protectedHeader) {
        protectedHeader = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(JSON.stringify(this._protectedHeader)));
      } else {
        protectedHeader = buffer_utils_js_1.encoder.encode("");
      }
      const data = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode("."), payload);
      const signature = await (0, sign_js_1.default)(alg, key, data);
      const jws = {
        signature: (0, base64url_js_1.encode)(signature),
        payload: ""
      };
      if (b64) {
        jws.payload = buffer_utils_js_1.decoder.decode(payload);
      }
      if (this._unprotectedHeader) {
        jws.header = this._unprotectedHeader;
      }
      if (this._protectedHeader) {
        jws.protected = buffer_utils_js_1.decoder.decode(protectedHeader);
      }
      return jws;
    }
  }
  exports.FlattenedSign = FlattenedSign;
});

// node_modules/jose/dist/node/cjs/jws/compact/sign.js
var require_sign4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CompactSign = undefined;
  var sign_js_1 = require_sign3();

  class CompactSign {
    constructor(payload) {
      this._flattened = new sign_js_1.FlattenedSign(payload);
    }
    setProtectedHeader(protectedHeader) {
      this._flattened.setProtectedHeader(protectedHeader);
      return this;
    }
    async sign(key, options) {
      const jws = await this._flattened.sign(key, options);
      if (jws.payload === undefined) {
        throw new TypeError("use the flattened module for creating JWS with b64: false");
      }
      return `${jws.protected}.${jws.payload}.${jws.signature}`;
    }
  }
  exports.CompactSign = CompactSign;
});

// node_modules/jose/dist/node/cjs/jws/general/sign.js
var require_sign5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GeneralSign = undefined;
  var sign_js_1 = require_sign3();
  var errors_js_1 = require_errors3();

  class IndividualSignature {
    constructor(sig, key, options) {
      this.parent = sig;
      this.key = key;
      this.options = options;
    }
    setProtectedHeader(protectedHeader) {
      if (this.protectedHeader) {
        throw new TypeError("setProtectedHeader can only be called once");
      }
      this.protectedHeader = protectedHeader;
      return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
      if (this.unprotectedHeader) {
        throw new TypeError("setUnprotectedHeader can only be called once");
      }
      this.unprotectedHeader = unprotectedHeader;
      return this;
    }
    addSignature(...args) {
      return this.parent.addSignature(...args);
    }
    sign(...args) {
      return this.parent.sign(...args);
    }
    done() {
      return this.parent;
    }
  }

  class GeneralSign {
    constructor(payload) {
      this._signatures = [];
      this._payload = payload;
    }
    addSignature(key, options) {
      const signature = new IndividualSignature(this, key, options);
      this._signatures.push(signature);
      return signature;
    }
    async sign() {
      if (!this._signatures.length) {
        throw new errors_js_1.JWSInvalid("at least one signature must be added");
      }
      const jws = {
        signatures: [],
        payload: ""
      };
      for (let i = 0;i < this._signatures.length; i++) {
        const signature = this._signatures[i];
        const flattened = new sign_js_1.FlattenedSign(this._payload);
        flattened.setProtectedHeader(signature.protectedHeader);
        flattened.setUnprotectedHeader(signature.unprotectedHeader);
        const { payload, ...rest } = await flattened.sign(signature.key, signature.options);
        if (i === 0) {
          jws.payload = payload;
        } else if (jws.payload !== payload) {
          throw new errors_js_1.JWSInvalid("inconsistent use of JWS Unencoded Payload (RFC7797)");
        }
        jws.signatures.push(rest);
      }
      return jws;
    }
  }
  exports.GeneralSign = GeneralSign;
});

// node_modules/jose/dist/node/cjs/jwt/produce.js
var require_produce = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProduceJWT = undefined;
  var epoch_js_1 = require_epoch();
  var is_object_js_1 = require_is_object();
  var secs_js_1 = require_secs();

  class ProduceJWT {
    constructor(payload) {
      if (!(0, is_object_js_1.default)(payload)) {
        throw new TypeError("JWT Claims Set MUST be an object");
      }
      this._payload = payload;
    }
    setIssuer(issuer) {
      this._payload = { ...this._payload, iss: issuer };
      return this;
    }
    setSubject(subject) {
      this._payload = { ...this._payload, sub: subject };
      return this;
    }
    setAudience(audience) {
      this._payload = { ...this._payload, aud: audience };
      return this;
    }
    setJti(jwtId) {
      this._payload = { ...this._payload, jti: jwtId };
      return this;
    }
    setNotBefore(input) {
      if (typeof input === "number") {
        this._payload = { ...this._payload, nbf: input };
      } else {
        this._payload = { ...this._payload, nbf: (0, epoch_js_1.default)(new Date) + (0, secs_js_1.default)(input) };
      }
      return this;
    }
    setExpirationTime(input) {
      if (typeof input === "number") {
        this._payload = { ...this._payload, exp: input };
      } else {
        this._payload = { ...this._payload, exp: (0, epoch_js_1.default)(new Date) + (0, secs_js_1.default)(input) };
      }
      return this;
    }
    setIssuedAt(input) {
      if (typeof input === "undefined") {
        this._payload = { ...this._payload, iat: (0, epoch_js_1.default)(new Date) };
      } else {
        this._payload = { ...this._payload, iat: input };
      }
      return this;
    }
  }
  exports.ProduceJWT = ProduceJWT;
});

// node_modules/jose/dist/node/cjs/jwt/sign.js
var require_sign6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SignJWT = undefined;
  var sign_js_1 = require_sign4();
  var errors_js_1 = require_errors3();
  var buffer_utils_js_1 = require_buffer_utils();
  var produce_js_1 = require_produce();

  class SignJWT extends produce_js_1.ProduceJWT {
    setProtectedHeader(protectedHeader) {
      this._protectedHeader = protectedHeader;
      return this;
    }
    async sign(key, options) {
      var _a3;
      const sig = new sign_js_1.CompactSign(buffer_utils_js_1.encoder.encode(JSON.stringify(this._payload)));
      sig.setProtectedHeader(this._protectedHeader);
      if (Array.isArray((_a3 = this._protectedHeader) === null || _a3 === undefined ? undefined : _a3.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
        throw new errors_js_1.JWTInvalid("JWTs MUST NOT use unencoded payload");
      }
      return sig.sign(key, options);
    }
  }
  exports.SignJWT = SignJWT;
});

// node_modules/jose/dist/node/cjs/jwt/encrypt.js
var require_encrypt5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EncryptJWT = undefined;
  var encrypt_js_1 = require_encrypt4();
  var buffer_utils_js_1 = require_buffer_utils();
  var produce_js_1 = require_produce();

  class EncryptJWT extends produce_js_1.ProduceJWT {
    setProtectedHeader(protectedHeader) {
      if (this._protectedHeader) {
        throw new TypeError("setProtectedHeader can only be called once");
      }
      this._protectedHeader = protectedHeader;
      return this;
    }
    setKeyManagementParameters(parameters) {
      if (this._keyManagementParameters) {
        throw new TypeError("setKeyManagementParameters can only be called once");
      }
      this._keyManagementParameters = parameters;
      return this;
    }
    setContentEncryptionKey(cek) {
      if (this._cek) {
        throw new TypeError("setContentEncryptionKey can only be called once");
      }
      this._cek = cek;
      return this;
    }
    setInitializationVector(iv2) {
      if (this._iv) {
        throw new TypeError("setInitializationVector can only be called once");
      }
      this._iv = iv2;
      return this;
    }
    replicateIssuerAsHeader() {
      this._replicateIssuerAsHeader = true;
      return this;
    }
    replicateSubjectAsHeader() {
      this._replicateSubjectAsHeader = true;
      return this;
    }
    replicateAudienceAsHeader() {
      this._replicateAudienceAsHeader = true;
      return this;
    }
    async encrypt(key, options) {
      const enc = new encrypt_js_1.CompactEncrypt(buffer_utils_js_1.encoder.encode(JSON.stringify(this._payload)));
      if (this._replicateIssuerAsHeader) {
        this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };
      }
      if (this._replicateSubjectAsHeader) {
        this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };
      }
      if (this._replicateAudienceAsHeader) {
        this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };
      }
      enc.setProtectedHeader(this._protectedHeader);
      if (this._iv) {
        enc.setInitializationVector(this._iv);
      }
      if (this._cek) {
        enc.setContentEncryptionKey(this._cek);
      }
      if (this._keyManagementParameters) {
        enc.setKeyManagementParameters(this._keyManagementParameters);
      }
      return enc.encrypt(key, options);
    }
  }
  exports.EncryptJWT = EncryptJWT;
});

// node_modules/jose/dist/node/cjs/jwk/thumbprint.js
var require_thumbprint = __commonJS((exports) => {
  async function calculateJwkThumbprint(jwk, digestAlgorithm) {
    if (!(0, is_object_js_1.default)(jwk)) {
      throw new TypeError("JWK must be an object");
    }
    digestAlgorithm !== null && digestAlgorithm !== undefined || (digestAlgorithm = "sha256");
    if (digestAlgorithm !== "sha256" && digestAlgorithm !== "sha384" && digestAlgorithm !== "sha512") {
      throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
    }
    let components2;
    switch (jwk.kty) {
      case "EC":
        check(jwk.crv, '"crv" (Curve) Parameter');
        check(jwk.x, '"x" (X Coordinate) Parameter');
        check(jwk.y, '"y" (Y Coordinate) Parameter');
        components2 = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
        break;
      case "OKP":
        check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
        check(jwk.x, '"x" (Public Key) Parameter');
        components2 = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
        break;
      case "RSA":
        check(jwk.e, '"e" (Exponent) Parameter');
        check(jwk.n, '"n" (Modulus) Parameter');
        components2 = { e: jwk.e, kty: jwk.kty, n: jwk.n };
        break;
      case "oct":
        check(jwk.k, '"k" (Key Value) Parameter');
        components2 = { k: jwk.k, kty: jwk.kty };
        break;
      default:
        throw new errors_js_1.JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
    }
    const data = buffer_utils_js_1.encoder.encode(JSON.stringify(components2));
    return (0, base64url_js_1.encode)(await (0, digest_js_1.default)(digestAlgorithm, data));
  }
  async function calculateJwkThumbprintUri(jwk, digestAlgorithm) {
    digestAlgorithm !== null && digestAlgorithm !== undefined || (digestAlgorithm = "sha256");
    const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);
    return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.calculateJwkThumbprintUri = exports.calculateJwkThumbprint = undefined;
  var digest_js_1 = require_digest();
  var base64url_js_1 = require_base64url();
  var errors_js_1 = require_errors3();
  var buffer_utils_js_1 = require_buffer_utils();
  var is_object_js_1 = require_is_object();
  var check = (value, description) => {
    if (typeof value !== "string" || !value) {
      throw new errors_js_1.JWKInvalid(`${description} missing or invalid`);
    }
  };
  exports.calculateJwkThumbprint = calculateJwkThumbprint;
  exports.calculateJwkThumbprintUri = calculateJwkThumbprintUri;
});

// node_modules/jose/dist/node/cjs/jwk/embedded.js
var require_embedded = __commonJS((exports) => {
  async function EmbeddedJWK(protectedHeader, token2) {
    const joseHeader = {
      ...protectedHeader,
      ...token2 === null || token2 === undefined ? undefined : token2.header
    };
    if (!(0, is_object_js_1.default)(joseHeader.jwk)) {
      throw new errors_js_1.JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');
    }
    const key = await (0, import_js_1.importJWK)({ ...joseHeader.jwk, ext: true }, joseHeader.alg, true);
    if (key instanceof Uint8Array || key.type !== "public") {
      throw new errors_js_1.JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');
    }
    return key;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmbeddedJWK = undefined;
  var import_js_1 = require_import();
  var is_object_js_1 = require_is_object();
  var errors_js_1 = require_errors3();
  exports.EmbeddedJWK = EmbeddedJWK;
});

// node_modules/jose/dist/node/cjs/jwks/local.js
var require_local = __commonJS((exports) => {
  function getKtyFromAlg(alg) {
    switch (typeof alg === "string" && alg.slice(0, 2)) {
      case "RS":
      case "PS":
        return "RSA";
      case "ES":
        return "EC";
      case "Ed":
        return "OKP";
      default:
        throw new errors_js_1.JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
    }
  }
  function isJWKSLike(jwks) {
    return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
  }
  function isJWKLike(key) {
    return (0, is_object_js_1.default)(key);
  }
  function clone(obj) {
    if (typeof structuredClone === "function") {
      return structuredClone(obj);
    }
    return JSON.parse(JSON.stringify(obj));
  }
  async function importWithAlgCache(cache, jwk, alg) {
    const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);
    if (cached[alg] === undefined) {
      const key = await (0, import_js_1.importJWK)({ ...jwk, ext: true }, alg);
      if (key instanceof Uint8Array || key.type !== "public") {
        throw new errors_js_1.JWKSInvalid("JSON Web Key Set members must be public keys");
      }
      cached[alg] = key;
    }
    return cached[alg];
  }
  function createLocalJWKSet(jwks) {
    const set = new LocalJWKSet(jwks);
    return async function(protectedHeader, token2) {
      return set.getKey(protectedHeader, token2);
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createLocalJWKSet = exports.LocalJWKSet = exports.isJWKSLike = undefined;
  var import_js_1 = require_import();
  var errors_js_1 = require_errors3();
  var is_object_js_1 = require_is_object();
  exports.isJWKSLike = isJWKSLike;

  class LocalJWKSet {
    constructor(jwks) {
      this._cached = new WeakMap;
      if (!isJWKSLike(jwks)) {
        throw new errors_js_1.JWKSInvalid("JSON Web Key Set malformed");
      }
      this._jwks = clone(jwks);
    }
    async getKey(protectedHeader, token2) {
      const { alg, kid } = { ...protectedHeader, ...token2 === null || token2 === undefined ? undefined : token2.header };
      const kty = getKtyFromAlg(alg);
      const candidates = this._jwks.keys.filter((jwk2) => {
        let candidate = kty === jwk2.kty;
        if (candidate && typeof kid === "string") {
          candidate = kid === jwk2.kid;
        }
        if (candidate && typeof jwk2.alg === "string") {
          candidate = alg === jwk2.alg;
        }
        if (candidate && typeof jwk2.use === "string") {
          candidate = jwk2.use === "sig";
        }
        if (candidate && Array.isArray(jwk2.key_ops)) {
          candidate = jwk2.key_ops.includes("verify");
        }
        if (candidate && alg === "EdDSA") {
          candidate = jwk2.crv === "Ed25519" || jwk2.crv === "Ed448";
        }
        if (candidate) {
          switch (alg) {
            case "ES256":
              candidate = jwk2.crv === "P-256";
              break;
            case "ES256K":
              candidate = jwk2.crv === "secp256k1";
              break;
            case "ES384":
              candidate = jwk2.crv === "P-384";
              break;
            case "ES512":
              candidate = jwk2.crv === "P-521";
              break;
          }
        }
        return candidate;
      });
      const { 0: jwk, length } = candidates;
      if (length === 0) {
        throw new errors_js_1.JWKSNoMatchingKey;
      } else if (length !== 1) {
        const error = new errors_js_1.JWKSMultipleMatchingKeys;
        const { _cached } = this;
        error[Symbol.asyncIterator] = async function* () {
          for (const jwk2 of candidates) {
            try {
              yield await importWithAlgCache(_cached, jwk2, alg);
            } catch {
              continue;
            }
          }
        };
        throw error;
      }
      return importWithAlgCache(this._cached, jwk, alg);
    }
  }
  exports.LocalJWKSet = LocalJWKSet;
  exports.createLocalJWKSet = createLocalJWKSet;
});

// node_modules/jose/dist/node/cjs/runtime/fetch_jwks.js
var require_fetch_jwks = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var http = __require("http");
  var https = __require("https");
  var events_1 = __require("events");
  var errors_js_1 = require_errors3();
  var buffer_utils_js_1 = require_buffer_utils();
  var fetchJwks = async (url, timeout, options) => {
    let get2;
    switch (url.protocol) {
      case "https:":
        get2 = https.get;
        break;
      case "http:":
        get2 = http.get;
        break;
      default:
        throw new TypeError("Unsupported URL protocol.");
    }
    const { agent, headers } = options;
    const req = get2(url.href, {
      agent,
      timeout,
      headers
    });
    const [response] = await Promise.race([(0, events_1.once)(req, "response"), (0, events_1.once)(req, "timeout")]);
    if (!response) {
      req.destroy();
      throw new errors_js_1.JWKSTimeout;
    }
    if (response.statusCode !== 200) {
      throw new errors_js_1.JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
    }
    const parts = [];
    for await (const part of response) {
      parts.push(part);
    }
    try {
      return JSON.parse(buffer_utils_js_1.decoder.decode((0, buffer_utils_js_1.concat)(...parts)));
    } catch {
      throw new errors_js_1.JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
    }
  };
  exports.default = fetchJwks;
});

// node_modules/jose/dist/node/cjs/jwks/remote.js
var require_remote = __commonJS((exports) => {
  function isCloudflareWorkers() {
    return typeof WebSocketPair !== "undefined" || typeof navigator !== "undefined" && navigator.userAgent === "Cloudflare-Workers" || typeof EdgeRuntime !== "undefined" && EdgeRuntime === "vercel";
  }
  function createRemoteJWKSet(url, options) {
    const set = new RemoteJWKSet(url, options);
    return async function(protectedHeader, token2) {
      return set.getKey(protectedHeader, token2);
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createRemoteJWKSet = undefined;
  var fetch_jwks_js_1 = require_fetch_jwks();
  var errors_js_1 = require_errors3();
  var local_js_1 = require_local();

  class RemoteJWKSet extends local_js_1.LocalJWKSet {
    constructor(url, options) {
      super({ keys: [] });
      this._jwks = undefined;
      if (!(url instanceof URL)) {
        throw new TypeError("url must be an instance of URL");
      }
      this._url = new URL(url.href);
      this._options = { agent: options === null || options === undefined ? undefined : options.agent, headers: options === null || options === undefined ? undefined : options.headers };
      this._timeoutDuration = typeof (options === null || options === undefined ? undefined : options.timeoutDuration) === "number" ? options === null || options === undefined ? undefined : options.timeoutDuration : 5000;
      this._cooldownDuration = typeof (options === null || options === undefined ? undefined : options.cooldownDuration) === "number" ? options === null || options === undefined ? undefined : options.cooldownDuration : 30000;
      this._cacheMaxAge = typeof (options === null || options === undefined ? undefined : options.cacheMaxAge) === "number" ? options === null || options === undefined ? undefined : options.cacheMaxAge : 600000;
    }
    coolingDown() {
      return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
    }
    fresh() {
      return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
    }
    async getKey(protectedHeader, token2) {
      if (!this._jwks || !this.fresh()) {
        await this.reload();
      }
      try {
        return await super.getKey(protectedHeader, token2);
      } catch (err) {
        if (err instanceof errors_js_1.JWKSNoMatchingKey) {
          if (this.coolingDown() === false) {
            await this.reload();
            return super.getKey(protectedHeader, token2);
          }
        }
        throw err;
      }
    }
    async reload() {
      if (this._pendingFetch && isCloudflareWorkers()) {
        this._pendingFetch = undefined;
      }
      this._pendingFetch || (this._pendingFetch = (0, fetch_jwks_js_1.default)(this._url, this._timeoutDuration, this._options).then((json) => {
        if (!(0, local_js_1.isJWKSLike)(json)) {
          throw new errors_js_1.JWKSInvalid("JSON Web Key Set malformed");
        }
        this._jwks = { keys: json.keys };
        this._jwksTimestamp = Date.now();
        this._pendingFetch = undefined;
      }).catch((err) => {
        this._pendingFetch = undefined;
        throw err;
      }));
      await this._pendingFetch;
    }
  }
  exports.createRemoteJWKSet = createRemoteJWKSet;
});

// node_modules/jose/dist/node/cjs/jwt/unsecured.js
var require_unsecured = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnsecuredJWT = undefined;
  var base64url = require_base64url();
  var buffer_utils_js_1 = require_buffer_utils();
  var errors_js_1 = require_errors3();
  var jwt_claims_set_js_1 = require_jwt_claims_set();
  var produce_js_1 = require_produce();

  class UnsecuredJWT extends produce_js_1.ProduceJWT {
    encode() {
      const header = base64url.encode(JSON.stringify({ alg: "none" }));
      const payload = base64url.encode(JSON.stringify(this._payload));
      return `${header}.${payload}.`;
    }
    static decode(jwt, options) {
      if (typeof jwt !== "string") {
        throw new errors_js_1.JWTInvalid("Unsecured JWT must be a string");
      }
      const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split(".");
      if (length !== 3 || signature !== "") {
        throw new errors_js_1.JWTInvalid("Invalid Unsecured JWT");
      }
      let header;
      try {
        header = JSON.parse(buffer_utils_js_1.decoder.decode(base64url.decode(encodedHeader)));
        if (header.alg !== "none")
          throw new Error;
      } catch {
        throw new errors_js_1.JWTInvalid("Invalid Unsecured JWT");
      }
      const payload = (0, jwt_claims_set_js_1.default)(header, base64url.decode(encodedPayload), options);
      return { payload, header };
    }
  }
  exports.UnsecuredJWT = UnsecuredJWT;
});

// node_modules/jose/dist/node/cjs/util/base64url.js
var require_base64url2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decode = exports.encode = undefined;
  var base64url = require_base64url();
  exports.encode = base64url.encode;
  exports.decode = base64url.decode;
});

// node_modules/jose/dist/node/cjs/util/decode_protected_header.js
var require_decode_protected_header = __commonJS((exports) => {
  function decodeProtectedHeader(token2) {
    let protectedB64u;
    if (typeof token2 === "string") {
      const parts = token2.split(".");
      if (parts.length === 3 || parts.length === 5) {
        [protectedB64u] = parts;
      }
    } else if (typeof token2 === "object" && token2) {
      if ("protected" in token2) {
        protectedB64u = token2.protected;
      } else {
        throw new TypeError("Token does not contain a Protected Header");
      }
    }
    try {
      if (typeof protectedB64u !== "string" || !protectedB64u) {
        throw new Error;
      }
      const result2 = JSON.parse(buffer_utils_js_1.decoder.decode((0, base64url_js_1.decode)(protectedB64u)));
      if (!(0, is_object_js_1.default)(result2)) {
        throw new Error;
      }
      return result2;
    } catch {
      throw new TypeError("Invalid Token or Protected Header formatting");
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeProtectedHeader = undefined;
  var base64url_js_1 = require_base64url2();
  var buffer_utils_js_1 = require_buffer_utils();
  var is_object_js_1 = require_is_object();
  exports.decodeProtectedHeader = decodeProtectedHeader;
});

// node_modules/jose/dist/node/cjs/util/decode_jwt.js
var require_decode_jwt = __commonJS((exports) => {
  function decodeJwt(jwt) {
    if (typeof jwt !== "string")
      throw new errors_js_1.JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
    const { 1: payload, length } = jwt.split(".");
    if (length === 5)
      throw new errors_js_1.JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
    if (length !== 3)
      throw new errors_js_1.JWTInvalid("Invalid JWT");
    if (!payload)
      throw new errors_js_1.JWTInvalid("JWTs must contain a payload");
    let decoded;
    try {
      decoded = (0, base64url_js_1.decode)(payload);
    } catch {
      throw new errors_js_1.JWTInvalid("Failed to base64url decode the payload");
    }
    let result2;
    try {
      result2 = JSON.parse(buffer_utils_js_1.decoder.decode(decoded));
    } catch {
      throw new errors_js_1.JWTInvalid("Failed to parse the decoded payload as JSON");
    }
    if (!(0, is_object_js_1.default)(result2))
      throw new errors_js_1.JWTInvalid("Invalid JWT Claims Set");
    return result2;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeJwt = undefined;
  var base64url_js_1 = require_base64url2();
  var buffer_utils_js_1 = require_buffer_utils();
  var is_object_js_1 = require_is_object();
  var errors_js_1 = require_errors3();
  exports.decodeJwt = decodeJwt;
});

// node_modules/jose/dist/node/cjs/runtime/generate.js
var require_generate = __commonJS((exports) => {
  async function generateSecret(alg, options) {
    let length;
    switch (alg) {
      case "HS256":
      case "HS384":
      case "HS512":
      case "A128CBC-HS256":
      case "A192CBC-HS384":
      case "A256CBC-HS512":
        length = parseInt(alg.slice(-3), 10);
        break;
      case "A128KW":
      case "A192KW":
      case "A256KW":
      case "A128GCMKW":
      case "A192GCMKW":
      case "A256GCMKW":
      case "A128GCM":
      case "A192GCM":
      case "A256GCM":
        length = parseInt(alg.slice(1, 4), 10);
        break;
      default:
        throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
    }
    return (0, crypto_1.createSecretKey)((0, random_js_1.default)(new Uint8Array(length >> 3)));
  }
  async function generateKeyPair(alg, options) {
    var _a3, _b;
    switch (alg) {
      case "RS256":
      case "RS384":
      case "RS512":
      case "PS256":
      case "PS384":
      case "PS512":
      case "RSA-OAEP":
      case "RSA-OAEP-256":
      case "RSA-OAEP-384":
      case "RSA-OAEP-512":
      case "RSA1_5": {
        const modulusLength = (_a3 = options === null || options === undefined ? undefined : options.modulusLength) !== null && _a3 !== undefined ? _a3 : 2048;
        if (typeof modulusLength !== "number" || modulusLength < 2048) {
          throw new errors_js_1.JOSENotSupported("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");
        }
        const keypair = await generate("rsa", {
          modulusLength,
          publicExponent: 65537
        });
        (0, check_modulus_length_js_1.setModulusLength)(keypair.privateKey, modulusLength);
        (0, check_modulus_length_js_1.setModulusLength)(keypair.publicKey, modulusLength);
        return keypair;
      }
      case "ES256":
        return generate("ec", { namedCurve: "P-256" });
      case "ES256K":
        return generate("ec", { namedCurve: "secp256k1" });
      case "ES384":
        return generate("ec", { namedCurve: "P-384" });
      case "ES512":
        return generate("ec", { namedCurve: "P-521" });
      case "EdDSA": {
        switch (options === null || options === undefined ? undefined : options.crv) {
          case undefined:
          case "Ed25519":
            return generate("ed25519");
          case "Ed448":
            return generate("ed448");
          default:
            throw new errors_js_1.JOSENotSupported("Invalid or unsupported crv option provided, supported values are Ed25519 and Ed448");
        }
      }
      case "ECDH-ES":
      case "ECDH-ES+A128KW":
      case "ECDH-ES+A192KW":
      case "ECDH-ES+A256KW":
        const crv = (_b = options === null || options === undefined ? undefined : options.crv) !== null && _b !== undefined ? _b : "P-256";
        switch (crv) {
          case undefined:
          case "P-256":
          case "P-384":
          case "P-521":
            return generate("ec", { namedCurve: crv });
          case "X25519":
            return generate("x25519");
          case "X448":
            return generate("x448");
          default:
            throw new errors_js_1.JOSENotSupported("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448");
        }
      default:
        throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generateKeyPair = exports.generateSecret = undefined;
  var crypto_1 = __require("crypto");
  var util_1 = __require("util");
  var random_js_1 = require_random();
  var check_modulus_length_js_1 = require_check_modulus_length();
  var errors_js_1 = require_errors3();
  var generate = (0, util_1.promisify)(crypto_1.generateKeyPair);
  exports.generateSecret = generateSecret;
  exports.generateKeyPair = generateKeyPair;
});

// node_modules/jose/dist/node/cjs/key/generate_key_pair.js
var require_generate_key_pair = __commonJS((exports) => {
  async function generateKeyPair(alg, options) {
    return (0, generate_js_1.generateKeyPair)(alg, options);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generateKeyPair = undefined;
  var generate_js_1 = require_generate();
  exports.generateKeyPair = generateKeyPair;
});

// node_modules/jose/dist/node/cjs/key/generate_secret.js
var require_generate_secret = __commonJS((exports) => {
  async function generateSecret(alg, options) {
    return (0, generate_js_1.generateSecret)(alg, options);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generateSecret = undefined;
  var generate_js_1 = require_generate();
  exports.generateSecret = generateSecret;
});

// node_modules/jose/dist/node/cjs/runtime/runtime.js
var require_runtime = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = "node:crypto";
});

// node_modules/jose/dist/node/cjs/util/runtime.js
var require_runtime2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var runtime_js_1 = require_runtime();
  exports.default = runtime_js_1.default;
});

// node_modules/jose/dist/node/cjs/index.js
var require_cjs6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cryptoRuntime = exports.base64url = exports.generateSecret = exports.generateKeyPair = exports.errors = exports.decodeJwt = exports.decodeProtectedHeader = exports.importJWK = exports.importX509 = exports.importPKCS8 = exports.importSPKI = exports.exportJWK = exports.exportSPKI = exports.exportPKCS8 = exports.UnsecuredJWT = exports.createRemoteJWKSet = exports.createLocalJWKSet = exports.EmbeddedJWK = exports.calculateJwkThumbprintUri = exports.calculateJwkThumbprint = exports.EncryptJWT = exports.SignJWT = exports.GeneralSign = exports.FlattenedSign = exports.CompactSign = exports.FlattenedEncrypt = exports.CompactEncrypt = exports.jwtDecrypt = exports.jwtVerify = exports.generalVerify = exports.flattenedVerify = exports.compactVerify = exports.GeneralEncrypt = exports.generalDecrypt = exports.flattenedDecrypt = exports.compactDecrypt = undefined;
  var decrypt_js_1 = require_decrypt3();
  Object.defineProperty(exports, "compactDecrypt", { enumerable: true, get: function() {
    return decrypt_js_1.compactDecrypt;
  } });
  var decrypt_js_2 = require_decrypt2();
  Object.defineProperty(exports, "flattenedDecrypt", { enumerable: true, get: function() {
    return decrypt_js_2.flattenedDecrypt;
  } });
  var decrypt_js_3 = require_decrypt4();
  Object.defineProperty(exports, "generalDecrypt", { enumerable: true, get: function() {
    return decrypt_js_3.generalDecrypt;
  } });
  var encrypt_js_1 = require_encrypt3();
  Object.defineProperty(exports, "GeneralEncrypt", { enumerable: true, get: function() {
    return encrypt_js_1.GeneralEncrypt;
  } });
  var verify_js_1 = require_verify3();
  Object.defineProperty(exports, "compactVerify", { enumerable: true, get: function() {
    return verify_js_1.compactVerify;
  } });
  var verify_js_2 = require_verify2();
  Object.defineProperty(exports, "flattenedVerify", { enumerable: true, get: function() {
    return verify_js_2.flattenedVerify;
  } });
  var verify_js_3 = require_verify4();
  Object.defineProperty(exports, "generalVerify", { enumerable: true, get: function() {
    return verify_js_3.generalVerify;
  } });
  var verify_js_4 = require_verify5();
  Object.defineProperty(exports, "jwtVerify", { enumerable: true, get: function() {
    return verify_js_4.jwtVerify;
  } });
  var decrypt_js_4 = require_decrypt5();
  Object.defineProperty(exports, "jwtDecrypt", { enumerable: true, get: function() {
    return decrypt_js_4.jwtDecrypt;
  } });
  var encrypt_js_2 = require_encrypt4();
  Object.defineProperty(exports, "CompactEncrypt", { enumerable: true, get: function() {
    return encrypt_js_2.CompactEncrypt;
  } });
  var encrypt_js_3 = require_encrypt2();
  Object.defineProperty(exports, "FlattenedEncrypt", { enumerable: true, get: function() {
    return encrypt_js_3.FlattenedEncrypt;
  } });
  var sign_js_1 = require_sign4();
  Object.defineProperty(exports, "CompactSign", { enumerable: true, get: function() {
    return sign_js_1.CompactSign;
  } });
  var sign_js_2 = require_sign3();
  Object.defineProperty(exports, "FlattenedSign", { enumerable: true, get: function() {
    return sign_js_2.FlattenedSign;
  } });
  var sign_js_3 = require_sign5();
  Object.defineProperty(exports, "GeneralSign", { enumerable: true, get: function() {
    return sign_js_3.GeneralSign;
  } });
  var sign_js_4 = require_sign6();
  Object.defineProperty(exports, "SignJWT", { enumerable: true, get: function() {
    return sign_js_4.SignJWT;
  } });
  var encrypt_js_4 = require_encrypt5();
  Object.defineProperty(exports, "EncryptJWT", { enumerable: true, get: function() {
    return encrypt_js_4.EncryptJWT;
  } });
  var thumbprint_js_1 = require_thumbprint();
  Object.defineProperty(exports, "calculateJwkThumbprint", { enumerable: true, get: function() {
    return thumbprint_js_1.calculateJwkThumbprint;
  } });
  Object.defineProperty(exports, "calculateJwkThumbprintUri", { enumerable: true, get: function() {
    return thumbprint_js_1.calculateJwkThumbprintUri;
  } });
  var embedded_js_1 = require_embedded();
  Object.defineProperty(exports, "EmbeddedJWK", { enumerable: true, get: function() {
    return embedded_js_1.EmbeddedJWK;
  } });
  var local_js_1 = require_local();
  Object.defineProperty(exports, "createLocalJWKSet", { enumerable: true, get: function() {
    return local_js_1.createLocalJWKSet;
  } });
  var remote_js_1 = require_remote();
  Object.defineProperty(exports, "createRemoteJWKSet", { enumerable: true, get: function() {
    return remote_js_1.createRemoteJWKSet;
  } });
  var unsecured_js_1 = require_unsecured();
  Object.defineProperty(exports, "UnsecuredJWT", { enumerable: true, get: function() {
    return unsecured_js_1.UnsecuredJWT;
  } });
  var export_js_1 = require_export();
  Object.defineProperty(exports, "exportPKCS8", { enumerable: true, get: function() {
    return export_js_1.exportPKCS8;
  } });
  Object.defineProperty(exports, "exportSPKI", { enumerable: true, get: function() {
    return export_js_1.exportSPKI;
  } });
  Object.defineProperty(exports, "exportJWK", { enumerable: true, get: function() {
    return export_js_1.exportJWK;
  } });
  var import_js_1 = require_import();
  Object.defineProperty(exports, "importSPKI", { enumerable: true, get: function() {
    return import_js_1.importSPKI;
  } });
  Object.defineProperty(exports, "importPKCS8", { enumerable: true, get: function() {
    return import_js_1.importPKCS8;
  } });
  Object.defineProperty(exports, "importX509", { enumerable: true, get: function() {
    return import_js_1.importX509;
  } });
  Object.defineProperty(exports, "importJWK", { enumerable: true, get: function() {
    return import_js_1.importJWK;
  } });
  var decode_protected_header_js_1 = require_decode_protected_header();
  Object.defineProperty(exports, "decodeProtectedHeader", { enumerable: true, get: function() {
    return decode_protected_header_js_1.decodeProtectedHeader;
  } });
  var decode_jwt_js_1 = require_decode_jwt();
  Object.defineProperty(exports, "decodeJwt", { enumerable: true, get: function() {
    return decode_jwt_js_1.decodeJwt;
  } });
  exports.errors = require_errors3();
  var generate_key_pair_js_1 = require_generate_key_pair();
  Object.defineProperty(exports, "generateKeyPair", { enumerable: true, get: function() {
    return generate_key_pair_js_1.generateKeyPair;
  } });
  var generate_secret_js_1 = require_generate_secret();
  Object.defineProperty(exports, "generateSecret", { enumerable: true, get: function() {
    return generate_secret_js_1.generateSecret;
  } });
  exports.base64url = require_base64url2();
  var runtime_js_1 = require_runtime2();
  Object.defineProperty(exports, "cryptoRuntime", { enumerable: true, get: function() {
    return runtime_js_1.default;
  } });
});

// node_modules/@elysiajs/jwt/dist/cjs/index.js
var require_cjs7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.jwt = undefined;
  var elysia_1 = require_cjs2();
  var jose_1 = require_cjs6();
  var typebox_1 = require_typebox();
  var jwt = ({ name: name2 = "jwt", secret, alg = "HS256", crit, schema: schema4, nbf, exp, ...payload }) => {
    if (!secret)
      throw new Error("Secret can't be empty");
    const key = typeof secret === "string" ? new TextEncoder().encode(secret) : secret;
    const validator = schema4 ? (0, elysia_1.getSchemaValidator)(typebox_1.Type.Intersect([
      schema4,
      typebox_1.Type.Object({
        iss: typebox_1.Type.Optional(typebox_1.Type.String()),
        sub: typebox_1.Type.Optional(typebox_1.Type.String()),
        aud: typebox_1.Type.Optional(typebox_1.Type.Union([typebox_1.Type.String(), typebox_1.Type.Array(typebox_1.Type.String())])),
        jti: typebox_1.Type.Optional(typebox_1.Type.String()),
        nbf: typebox_1.Type.Optional(typebox_1.Type.Union([typebox_1.Type.String(), typebox_1.Type.Number()])),
        exp: typebox_1.Type.Optional(typebox_1.Type.Union([typebox_1.Type.String(), typebox_1.Type.Number()])),
        iat: typebox_1.Type.Optional(typebox_1.Type.String())
      })
    ]), {}) : undefined;
    return new elysia_1.Elysia({
      name: "@elysiajs/jwt",
      seed: {
        name: name2,
        secret,
        alg,
        crit,
        schema: schema4,
        nbf,
        exp,
        ...payload
      }
    }).decorate(name2, {
      sign: (morePayload) => {
        let jwt2 = new jose_1.SignJWT({
          ...payload,
          ...morePayload,
          nbf: undefined,
          exp: undefined
        }).setProtectedHeader({
          alg,
          crit
        });
        if (nbf)
          jwt2 = jwt2.setNotBefore(nbf);
        if (exp)
          jwt2 = jwt2.setExpirationTime(exp);
        return jwt2.sign(key);
      },
      verify: async (jwt2) => {
        if (!jwt2)
          return false;
        try {
          const data = (await (0, jose_1.jwtVerify)(jwt2, key)).payload;
          if (validator && !validator.Check(data))
            throw new elysia_1.ValidationError("JWT", validator, data);
          return data;
        } catch (_3) {
          return false;
        }
      }
    });
  };
  exports.jwt = jwt;
  exports.default = exports.jwt;
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS((exports, module) => {
  (function(t19, e3) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = e3() : typeof define == "function" && define.amd ? define(e3) : (t19 = typeof globalThis != "undefined" ? globalThis : t19 || self).dayjs = e3();
  })(exports, function() {
    var t19 = 1000, e3 = 60000, n2 = 3600000, r2 = "millisecond", i = "second", s3 = "minute", u2 = "hour", a = "day", o2 = "week", c3 = "month", f2 = "quarter", h2 = "year", d3 = "date", l3 = "Invalid Date", $3 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y3 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M3 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t20) {
      var e4 = ["th", "st", "nd", "rd"], n3 = t20 % 100;
      return "[" + t20 + (e4[(n3 - 20) % 10] || e4[n3] || e4[0]) + "]";
    } }, m = function(t20, e4, n3) {
      var r3 = String(t20);
      return !r3 || r3.length >= e4 ? t20 : "" + Array(e4 + 1 - r3.length).join(n3) + t20;
    }, v3 = { s: m, z: function(t20) {
      var e4 = -t20.utcOffset(), n3 = Math.abs(e4), r3 = Math.floor(n3 / 60), i2 = n3 % 60;
      return (e4 <= 0 ? "+" : "-") + m(r3, 2, "0") + ":" + m(i2, 2, "0");
    }, m: function t(e4, n3) {
      if (e4.date() < n3.date())
        return -t(n3, e4);
      var r3 = 12 * (n3.year() - e4.year()) + (n3.month() - e4.month()), i2 = e4.clone().add(r3, c3), s4 = n3 - i2 < 0, u3 = e4.clone().add(r3 + (s4 ? -1 : 1), c3);
      return +(-(r3 + (n3 - i2) / (s4 ? i2 - u3 : u3 - i2)) || 0);
    }, a: function(t20) {
      return t20 < 0 ? Math.ceil(t20) || 0 : Math.floor(t20);
    }, p: function(t20) {
      return { M: c3, y: h2, w: o2, d: a, D: d3, h: u2, m: s3, s: i, ms: r2, Q: f2 }[t20] || String(t20 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t20) {
      return t20 === undefined;
    } }, g2 = "en", D = {};
    D[g2] = M3;
    var p = "$isDayjsObject", S4 = function(t20) {
      return t20 instanceof _3 || !(!t20 || !t20[p]);
    }, w3 = function t(e4, n3, r3) {
      var i2;
      if (!e4)
        return g2;
      if (typeof e4 == "string") {
        var s4 = e4.toLowerCase();
        D[s4] && (i2 = s4), n3 && (D[s4] = n3, i2 = s4);
        var u3 = e4.split("-");
        if (!i2 && u3.length > 1)
          return t(u3[0]);
      } else {
        var a2 = e4.name;
        D[a2] = e4, i2 = a2;
      }
      return !r3 && i2 && (g2 = i2), i2 || !r3 && g2;
    }, O3 = function(t20, e4) {
      if (S4(t20))
        return t20.clone();
      var n3 = typeof e4 == "object" ? e4 : {};
      return n3.date = t20, n3.args = arguments, new _3(n3);
    }, b5 = v3;
    b5.l = w3, b5.i = S4, b5.w = function(t20, e4) {
      return O3(t20, { locale: e4.$L, utc: e4.$u, x: e4.$x, $offset: e4.$offset });
    };
    var _3 = function() {
      function M4(t20) {
        this.$L = w3(t20.locale, null, true), this.parse(t20), this.$x = this.$x || t20.x || {}, this[p] = true;
      }
      var m2 = M4.prototype;
      return m2.parse = function(t20) {
        this.$d = function(t21) {
          var { date: e4, utc: n3 } = t21;
          if (e4 === null)
            return new Date(NaN);
          if (b5.u(e4))
            return new Date;
          if (e4 instanceof Date)
            return new Date(e4);
          if (typeof e4 == "string" && !/Z$/i.test(e4)) {
            var r3 = e4.match($3);
            if (r3) {
              var i2 = r3[2] - 1 || 0, s4 = (r3[7] || "0").substring(0, 3);
              return n3 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s4)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s4);
            }
          }
          return new Date(e4);
        }(t20), this.init();
      }, m2.init = function() {
        var t20 = this.$d;
        this.$y = t20.getFullYear(), this.$M = t20.getMonth(), this.$D = t20.getDate(), this.$W = t20.getDay(), this.$H = t20.getHours(), this.$m = t20.getMinutes(), this.$s = t20.getSeconds(), this.$ms = t20.getMilliseconds();
      }, m2.$utils = function() {
        return b5;
      }, m2.isValid = function() {
        return !(this.$d.toString() === l3);
      }, m2.isSame = function(t20, e4) {
        var n3 = O3(t20);
        return this.startOf(e4) <= n3 && n3 <= this.endOf(e4);
      }, m2.isAfter = function(t20, e4) {
        return O3(t20) < this.startOf(e4);
      }, m2.isBefore = function(t20, e4) {
        return this.endOf(e4) < O3(t20);
      }, m2.$g = function(t20, e4, n3) {
        return b5.u(t20) ? this[e4] : this.set(n3, t20);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1000);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t20, e4) {
        var n3 = this, r3 = !!b5.u(e4) || e4, f3 = b5.p(t20), l4 = function(t21, e5) {
          var i2 = b5.w(n3.$u ? Date.UTC(n3.$y, e5, t21) : new Date(n3.$y, e5, t21), n3);
          return r3 ? i2 : i2.endOf(a);
        }, $4 = function(t21, e5) {
          return b5.w(n3.toDate()[t21].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e5)), n3);
        }, y4 = this.$W, M5 = this.$M, m3 = this.$D, v4 = "set" + (this.$u ? "UTC" : "");
        switch (f3) {
          case h2:
            return r3 ? l4(1, 0) : l4(31, 11);
          case c3:
            return r3 ? l4(1, M5) : l4(0, M5 + 1);
          case o2:
            var g3 = this.$locale().weekStart || 0, D2 = (y4 < g3 ? y4 + 7 : y4) - g3;
            return l4(r3 ? m3 - D2 : m3 + (6 - D2), M5);
          case a:
          case d3:
            return $4(v4 + "Hours", 0);
          case u2:
            return $4(v4 + "Minutes", 1);
          case s3:
            return $4(v4 + "Seconds", 2);
          case i:
            return $4(v4 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t20) {
        return this.startOf(t20, false);
      }, m2.$set = function(t20, e4) {
        var n3, o3 = b5.p(t20), f3 = "set" + (this.$u ? "UTC" : ""), l4 = (n3 = {}, n3[a] = f3 + "Date", n3[d3] = f3 + "Date", n3[c3] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s3] = f3 + "Minutes", n3[i] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $4 = o3 === a ? this.$D + (e4 - this.$W) : e4;
        if (o3 === c3 || o3 === h2) {
          var y4 = this.clone().set(d3, 1);
          y4.$d[l4]($4), y4.init(), this.$d = y4.set(d3, Math.min(this.$D, y4.daysInMonth())).$d;
        } else
          l4 && this.$d[l4]($4);
        return this.init(), this;
      }, m2.set = function(t20, e4) {
        return this.clone().$set(t20, e4);
      }, m2.get = function(t20) {
        return this[b5.p(t20)]();
      }, m2.add = function(r3, f3) {
        var d4, l4 = this;
        r3 = Number(r3);
        var $4 = b5.p(f3), y4 = function(t20) {
          var e4 = O3(l4);
          return b5.w(e4.date(e4.date() + Math.round(t20 * r3)), l4);
        };
        if ($4 === c3)
          return this.set(c3, this.$M + r3);
        if ($4 === h2)
          return this.set(h2, this.$y + r3);
        if ($4 === a)
          return y4(1);
        if ($4 === o2)
          return y4(7);
        var M5 = (d4 = {}, d4[s3] = e3, d4[u2] = n2, d4[i] = t19, d4)[$4] || 1, m3 = this.$d.getTime() + r3 * M5;
        return b5.w(m3, this);
      }, m2.subtract = function(t20, e4) {
        return this.add(-1 * t20, e4);
      }, m2.format = function(t20) {
        var e4 = this, n3 = this.$locale();
        if (!this.isValid())
          return n3.invalidDate || l3;
        var r3 = t20 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b5.z(this), s4 = this.$H, u3 = this.$m, a2 = this.$M, o3 = n3.weekdays, c4 = n3.months, f3 = n3.meridiem, h3 = function(t21, n4, i3, s5) {
          return t21 && (t21[n4] || t21(e4, r3)) || i3[n4].slice(0, s5);
        }, d4 = function(t21) {
          return b5.s(s4 % 12 || 12, t21, "0");
        }, $4 = f3 || function(t21, e5, n4) {
          var r4 = t21 < 12 ? "AM" : "PM";
          return n4 ? r4.toLowerCase() : r4;
        };
        return r3.replace(y3, function(t21, r4) {
          return r4 || function(t22) {
            switch (t22) {
              case "YY":
                return String(e4.$y).slice(-2);
              case "YYYY":
                return b5.s(e4.$y, 4, "0");
              case "M":
                return a2 + 1;
              case "MM":
                return b5.s(a2 + 1, 2, "0");
              case "MMM":
                return h3(n3.monthsShort, a2, c4, 3);
              case "MMMM":
                return h3(c4, a2);
              case "D":
                return e4.$D;
              case "DD":
                return b5.s(e4.$D, 2, "0");
              case "d":
                return String(e4.$W);
              case "dd":
                return h3(n3.weekdaysMin, e4.$W, o3, 2);
              case "ddd":
                return h3(n3.weekdaysShort, e4.$W, o3, 3);
              case "dddd":
                return o3[e4.$W];
              case "H":
                return String(s4);
              case "HH":
                return b5.s(s4, 2, "0");
              case "h":
                return d4(1);
              case "hh":
                return d4(2);
              case "a":
                return $4(s4, u3, true);
              case "A":
                return $4(s4, u3, false);
              case "m":
                return String(u3);
              case "mm":
                return b5.s(u3, 2, "0");
              case "s":
                return String(e4.$s);
              case "ss":
                return b5.s(e4.$s, 2, "0");
              case "SSS":
                return b5.s(e4.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t21) || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r3, d4, l4) {
        var $4, y4 = this, M5 = b5.p(d4), m3 = O3(r3), v4 = (m3.utcOffset() - this.utcOffset()) * e3, g3 = this - m3, D2 = function() {
          return b5.m(y4, m3);
        };
        switch (M5) {
          case h2:
            $4 = D2() / 12;
            break;
          case c3:
            $4 = D2();
            break;
          case f2:
            $4 = D2() / 3;
            break;
          case o2:
            $4 = (g3 - v4) / 604800000;
            break;
          case a:
            $4 = (g3 - v4) / 86400000;
            break;
          case u2:
            $4 = g3 / n2;
            break;
          case s3:
            $4 = g3 / e3;
            break;
          case i:
            $4 = g3 / t19;
            break;
          default:
            $4 = g3;
        }
        return l4 ? $4 : b5.a($4);
      }, m2.daysInMonth = function() {
        return this.endOf(c3).$D;
      }, m2.$locale = function() {
        return D[this.$L];
      }, m2.locale = function(t20, e4) {
        if (!t20)
          return this.$L;
        var n3 = this.clone(), r3 = w3(t20, e4, true);
        return r3 && (n3.$L = r3), n3;
      }, m2.clone = function() {
        return b5.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M4;
    }(), k3 = _3.prototype;
    return O3.prototype = k3, [["$ms", r2], ["$s", i], ["$m", s3], ["$H", u2], ["$W", a], ["$M", c3], ["$y", h2], ["$D", d3]].forEach(function(t20) {
      k3[t20[1]] = function(e4) {
        return this.$g(e4, t20[0], t20[1]);
      };
    }), O3.extend = function(t20, e4) {
      return t20.$i || (t20(e4, _3, O3), t20.$i = true), O3;
    }, O3.locale = w3, O3.isDayjs = S4, O3.unix = function(t20) {
      return O3(1000 * t20);
    }, O3.en = D[g2], O3.Ls = D, O3.p = {}, O3;
  });
});

// src/http/server.ts
var import_elysia26 = __toESM(require_cjs2(), 1);
var cors = __toESM(require_cjs3(), 1);

// src/db/schema/index.ts
var exports_schema = {};
__export(exports_schema, {
  usersRelations: () => usersRelations,
  users: () => users,
  userRoleEnum: () => userRoleEnum,
  restaurantsRelations: () => restaurantsRelations,
  restaurants: () => restaurants,
  productsRelations: () => productsRelations,
  products: () => products,
  ordersRelations: () => ordersRelations,
  orders: () => orders,
  orderStatusEnum: () => orderStatusEnum,
  orderItemsRelations: () => orderItemsRelations,
  orderItems: () => orderItems,
  evaluationsRelations: () => evaluationsRelations,
  evaluations: () => evaluations,
  authLinks: () => authLinks
});

// node_modules/@paralleldrive/cuid2/index.js
var { createId, init, getConstants, isCuid } = require_src();
var $createId = createId;

// node_modules/drizzle-orm/entity.js
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(`Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
  }
  let cls = value.constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");

// node_modules/drizzle-orm/column.js
class Column {
  constructor(table, config) {
    this.table = table;
    this.config = config;
    this.name = config.name;
    this.notNull = config.notNull;
    this.default = config.default;
    this.defaultFn = config.defaultFn;
    this.hasDefault = config.hasDefault;
    this.primary = config.primaryKey;
    this.isUnique = config.isUnique;
    this.uniqueName = config.uniqueName;
    this.uniqueType = config.uniqueType;
    this.dataType = config.dataType;
    this.columnType = config.columnType;
  }
  static [entityKind] = "Column";
  name;
  primary;
  notNull;
  default;
  defaultFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = undefined;
  config;
  mapFromDriverValue(value) {
    return value;
  }
  mapToDriverValue(value) {
    return value;
  }
}

// node_modules/drizzle-orm/table.js
function isTable(table) {
  return typeof table === "object" && table !== null && IsDrizzleTable in table;
}
function getTableName(table) {
  return table[TableName];
}
var TableName = Symbol.for("drizzle:Name");
var Schema = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");

class Table {
  static [entityKind] = "Table";
  static Symbol = {
    Name: TableName,
    Schema,
    OriginalName,
    Columns,
    BaseName,
    IsAlias,
    ExtraConfigBuilder
  };
  [TableName];
  [OriginalName];
  [Schema];
  [Columns];
  [BaseName];
  [IsAlias] = false;
  [ExtraConfigBuilder] = undefined;
  [IsDrizzleTable] = true;
  constructor(name, schema, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema] = schema;
    this[BaseName] = baseName;
  }
}

// node_modules/drizzle-orm/pg-core/table.js
function pgTableWithSchema(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new PgTable(name, schema, baseName);
  const builtColumns = Object.fromEntries(Object.entries(columns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    const column = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
    return [name2, column];
  }));
  const table2 = Object.assign(rawTable, builtColumns);
  table2[Table.Symbol.Columns] = builtColumns;
  if (extraConfig) {
    table2[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table2;
}
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");

class PgTable extends Table {
  static [entityKind] = "PgTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys
  });
  [InlineForeignKeys] = [];
  [Table.Symbol.ExtraConfigBuilder] = undefined;
}
var pgTable = (name, columns, extraConfig) => {
  return pgTableWithSchema(name, columns, extraConfig, undefined);
};

// node_modules/drizzle-orm/pg-core/primary-keys.js
class PrimaryKeyBuilder {
  static [entityKind] = "PgPrimaryKeyBuilder";
  columns;
  name;
  constructor(columns, name) {
    this.columns = columns;
    this.name = name;
  }
  build(table3) {
    return new PrimaryKey(table3, this.columns, this.name);
  }
}

class PrimaryKey {
  constructor(table3, columns, name) {
    this.table = table3;
    this.columns = columns;
    this.name = name;
  }
  static [entityKind] = "PgPrimaryKey";
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
}

// node_modules/drizzle-orm/sql/expressions/conditions.js
function bindIfParam(value, column2) {
  if (isDriverValueEncoder(column2) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column2);
  }
  return value;
}
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql2.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql2.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql2`not ${condition}`;
}
function inArray(column2, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("inArray requires at least one value");
    }
    return sql2`${column2} in ${values.map((v) => bindIfParam(v, column2))}`;
  }
  return sql2`${column2} in ${bindIfParam(values, column2)}`;
}
function notInArray(column2, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("notInArray requires at least one value");
    }
    return sql2`${column2} not in ${values.map((v) => bindIfParam(v, column2))}`;
  }
  return sql2`${column2} not in ${bindIfParam(values, column2)}`;
}
function isNull(value) {
  return sql2`${value} is null`;
}
function isNotNull(value) {
  return sql2`${value} is not null`;
}
function exists(subquery) {
  return sql2`exists (${subquery})`;
}
function notExists(subquery) {
  return sql2`not exists (${subquery})`;
}
function between(column2, min, max) {
  return sql2`${column2} between ${bindIfParam(min, column2)} and ${bindIfParam(max, column2)}`;
}
function notBetween(column2, min, max) {
  return sql2`${column2} not between ${bindIfParam(min, column2)} and ${bindIfParam(max, column2)}`;
}
function like(column2, value) {
  return sql2`${column2} like ${value}`;
}
function notLike(column2, value) {
  return sql2`${column2} not like ${value}`;
}
function ilike(column2, value) {
  return sql2`${column2} ilike ${value}`;
}
function notIlike(column2, value) {
  return sql2`${column2} not ilike ${value}`;
}
var eq = (left, right) => {
  return sql2`${left} = ${bindIfParam(right, left)}`;
};
var ne = (left, right) => {
  return sql2`${left} <> ${bindIfParam(right, left)}`;
};
var gt = (left, right) => {
  return sql2`${left} > ${bindIfParam(right, left)}`;
};
var gte = (left, right) => {
  return sql2`${left} >= ${bindIfParam(right, left)}`;
};
var lt = (left, right) => {
  return sql2`${left} < ${bindIfParam(right, left)}`;
};
var lte = (left, right) => {
  return sql2`${left} <= ${bindIfParam(right, left)}`;
};

// node_modules/drizzle-orm/sql/expressions/select.js
function asc(column2) {
  return sql2`${column2} asc`;
}
function desc(column2) {
  return sql2`${column2} desc`;
}

// node_modules/drizzle-orm/relations.js
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql: sql2
  };
}
function getOrderByOperators() {
  return {
    sql: sql2,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema)) {
    if (isTable(value)) {
      const dbName = value[Table.Symbol.Name];
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column3 of Object.values(value[Table.Symbol.Columns])) {
        if (column3.primary) {
          tablesConfig[key].primaryKey.push(column3);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = value.table[Table.Symbol.Name];
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(configHelpers(value.table));
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function relations(table5, relations2) {
  return new Relations(table5, (helpers) => Object.fromEntries(Object.entries(relations2(helpers)).map(([key, value]) => [
    key,
    value.withFieldName(key)
  ])));
}
function createOne(sourceTable) {
  return function one(table5, config) {
    return new One(sourceTable, table5, config, config?.fields.reduce((res, f) => res && f.notNull, true) ?? false);
  };
}
function createMany(sourceTable) {
  return function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  };
}
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[relation.referencedTable[Table.Symbol.Name]];
  if (!referencedTableTsName) {
    throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[sourceTable[Table.Symbol.Name]];
  if (!sourceTableTsName) {
    throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`) : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue) : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
    }
  }
  return result;
}

class Relation {
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  static [entityKind] = "Relation";
  referencedTableName;
  fieldName;
}

class Relations {
  constructor(table5, config) {
    this.table = table5;
    this.config = config;
  }
  static [entityKind] = "Relations";
}

class One extends Relation {
  constructor(sourceTable, referencedTable, config, isNullable) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
    this.isNullable = isNullable;
  }
  static [entityKind] = "One";
  withFieldName(fieldName) {
    const relation = new One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
    relation.fieldName = fieldName;
    return relation;
  }
}

class Many extends Relation {
  constructor(sourceTable, referencedTable, config) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
  }
  static [entityKind] = "Many";
  withFieldName(fieldName) {
    const relation = new Many(this.sourceTable, this.referencedTable, this.config);
    relation.fieldName = fieldName;
    return relation;
  }
}

// node_modules/drizzle-orm/subquery.js
var SubqueryConfig = Symbol.for("drizzle:SubqueryConfig");

class Subquery {
  static [entityKind] = "Subquery";
  [SubqueryConfig];
  constructor(sql5, selection, alias, isWith = false) {
    this[SubqueryConfig] = {
      sql: sql5,
      selection,
      alias,
      isWith
    };
  }
}

class WithSubquery extends Subquery {
  static [entityKind] = "WithSubquery";
}

// node_modules/drizzle-orm/tracing-utils.js
function iife(fn, ...args) {
  return fn(...args);
}

// node_modules/drizzle-orm/version.js
var version = "0.29.1";

// node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer = {
  startActiveSpan(name, fn) {
    if (!otel) {
      return fn();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version);
    }
    return iife((otel2, rawTracer2) => rawTracer2.startActiveSpan(name, (span) => {
      try {
        return fn(span);
      } catch (e) {
        span.setStatus({
          code: otel2.SpanStatusCode.ERROR,
          message: e instanceof Error ? e.message : "Unknown error"
        });
        throw e;
      } finally {
        span.end();
      }
    }), otel, rawTracer);
  }
};

// node_modules/drizzle-orm/view-common.js
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

// node_modules/drizzle-orm/sql/sql.js
function isSQLWrapper(value) {
  return typeof value === "object" && value !== null && "getSQL" in value && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
function sql2(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
function fillPlaceholders(params, values) {
  return params.map((p) => {
    if (is(p, Placeholder)) {
      if (!(p.name in values)) {
        throw new Error(`No value for placeholder "${p.name}" was provided`);
      }
      return values[p.name];
    }
    return p;
  });
}
class StringChunk {
  static [entityKind] = "StringChunk";
  value;
  constructor(value) {
    this.value = Array.isArray(value) ? value : [value];
  }
  getSQL() {
    return new SQL([this]);
  }
}

class SQL {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
  }
  static [entityKind] = "SQL";
  decoder = noopDecoder;
  shouldInlineParams = false;
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const {
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === undefined) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk("(")];
        for (const [i, p] of chunk.entries()) {
          result.push(p);
          if (i < chunk.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config);
      }
      if (is(chunk, SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === undefined ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        return { sql: escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(chunk.name), params: [] };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === undefined ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config), params: [] };
        }
        let typings;
        if (prepareTyping !== undefined) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
      }
      if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk[SubqueryConfig].isWith) {
          return { sql: escapeName(chunk[SubqueryConfig].alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk[SubqueryConfig].sql,
          new StringChunk(") "),
          new Name(chunk[SubqueryConfig].alias)
        ], config);
      }
      if (isSQLWrapper(chunk)) {
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config);
      }
      if (is(chunk, Relation)) {
        return this.buildQueryFromSourceParams([
          chunk.sourceTable,
          new StringChunk("."),
          sql2.identifier(chunk.fieldName)
        ], config);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === undefined) {
      return this;
    }
    return new SQL.Aliased(this, alias);
  }
  mapWith(decoder) {
    this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
}

class Name {
  constructor(value) {
    this.value = value;
  }
  static [entityKind] = "Name";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
var noopDecoder = {
  mapFromDriverValue: (value) => value
};
var noopEncoder = {
  mapToDriverValue: (value) => value
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};

class Param {
  constructor(value, encoder = noopEncoder) {
    this.value = value;
    this.encoder = encoder;
  }
  static [entityKind] = "Param";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
((sql22) => {
  function empty() {
    return new SQL([]);
  }
  sql22.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  sql22.fromList = fromList;
  function raw(str) {
    return new SQL([new StringChunk(str)]);
  }
  sql22.raw = raw;
  function join(chunks, separator) {
    const result = [];
    for (const [i, chunk] of chunks.entries()) {
      if (i > 0 && separator !== undefined) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL(result);
  }
  sql22.join = join;
  function identifier(value) {
    return new Name(value);
  }
  sql22.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  sql22.placeholder = placeholder2;
  function param2(value, encoder) {
    return new Param(value, encoder);
  }
  sql22.param = param2;
})(sql2 || (sql2 = {}));
((SQL2) => {

  class Aliased {
    constructor(sql22, fieldAlias) {
      this.sql = sql22;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));

class Placeholder {
  constructor(name2) {
    this.name = name2;
  }
  static [entityKind] = "Placeholder";
  getSQL() {
    return new SQL([this]);
  }
}

class View {
  static [entityKind] = "View";
  [ViewBaseConfig];
  constructor({ name: name2, schema, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
}
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// node_modules/drizzle-orm/alias.js
function aliasedTable(table7, tableAlias) {
  return new Proxy(table7, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column5, tableAlias) {
  return new Proxy(column5, new ColumnAliasProxyHandler(new Proxy(column5.table, new TableAliasProxyHandler(tableAlias, false))));
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql2.join(query.queryChunks.map((c) => {
    if (is(c, Column)) {
      return aliasedTableColumn(c, alias);
    }
    if (is(c, SQL)) {
      return mapColumnsInSQLToAlias(c, alias);
    }
    if (is(c, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c, alias);
    }
    return c;
  }));
}

class ColumnAliasProxyHandler {
  constructor(table7) {
    this.table = table7;
  }
  static [entityKind] = "ColumnAliasProxyHandler";
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
}

class TableAliasProxyHandler {
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  static [entityKind] = "TableAliasProxyHandler";
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
      });
      return proxiedColumns;
    }
    const value = target[prop];
    if (is(value, Column)) {
      return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value;
  }
}

// node_modules/drizzle-orm/column-builder.js
class ColumnBuilder {
  static [entityKind] = "ColumnBuilder";
  config;
  constructor(name, dataType, columnType) {
    this.config = {
      name,
      notNull: false,
      default: undefined,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: undefined,
      uniqueType: undefined,
      dataType,
      columnType
    };
  }
  $type() {
    return this;
  }
  notNull() {
    this.config.notNull = true;
    return this;
  }
  default(value) {
    this.config.default = value;
    this.config.hasDefault = true;
    return this;
  }
  $defaultFn(fn) {
    this.config.defaultFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $default = this.$defaultFn;
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
}

// node_modules/drizzle-orm/errors.js
class DrizzleError extends Error {
  static [entityKind] = "DrizzleError";
  constructor({ message, cause }) {
    super(message);
    this.name = "DrizzleError";
    this.cause = cause;
  }
}

class TransactionRollbackError extends DrizzleError {
  static [entityKind] = "TransactionRollbackError";
  constructor() {
    super({ message: "Rollback" });
  }
}

// node_modules/drizzle-orm/logger.js
class ConsoleLogWriter {
  static [entityKind] = "ConsoleLogWriter";
  write(message) {
    console.log(message);
  }
}

class DefaultLogger {
  static [entityKind] = "DefaultLogger";
  writer;
  constructor(config) {
    this.writer = config?.writer ?? new ConsoleLogWriter;
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p) => {
      try {
        return JSON.stringify(p);
      } catch {
        return String(p);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
}

class NoopLogger {
  static [entityKind] = "NoopLogger";
  logQuery() {
  }
}

// node_modules/drizzle-orm/query-promise.js
class QueryPromise {
  static [entityKind] = "QueryPromise";
  [Symbol.toStringTag] = "QueryPromise";
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
}

// node_modules/drizzle-orm/sql/functions/aggregate.js
function count(expression) {
  return sql2`count(${expression || sql2.raw("*")})`.mapWith(Number);
}
function sum(expression) {
  return sql2`sum(${expression})`.mapWith(String);
}

// node_modules/drizzle-orm/utils.js
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce((result2, { path, field }, columnIndex) => {
    let decoder;
    if (is(field, Column)) {
      decoder = field;
    } else if (is(field, SQL)) {
      decoder = field.decoder;
    } else {
      decoder = field.sql.decoder;
    }
    let node = result2;
    for (const [pathChunkIndex, pathChunk] of path.entries()) {
      if (pathChunkIndex < path.length - 1) {
        if (!(pathChunk in node)) {
          node[pathChunk] = {};
        }
        node = node[pathChunk];
      } else {
        const rawValue = row[columnIndex];
        const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
        if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
          const objectName = path[0];
          if (!(objectName in nullifyMap)) {
            nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
          } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
            nullifyMap[objectName] = false;
          }
        }
      }
    }
    return result2;
  }, {});
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index, key] of leftKeys.entries()) {
    if (key !== rightKeys[index]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table8, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== undefined).map(([key, value]) => {
    if (is(value, SQL)) {
      return [key, value];
    } else {
      return [key, new Param(value, table8[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      Object.defineProperty(baseClass.prototype, name, Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null));
    }
  }
}
function getTableColumns(table8) {
  return table8[Table.Symbol.Columns];
}
function getTableLikeName(table8) {
  return is(table8, Subquery) ? table8[SubqueryConfig].alias : is(table8, View) ? table8[ViewBaseConfig].name : is(table8, SQL) ? undefined : table8[Table.Symbol.IsAlias] ? table8[Table.Symbol.Name] : table8[Table.Symbol.BaseName];
}

// node_modules/drizzle-orm/pg-core/foreign-keys.js
class ForeignKeyBuilder {
  static [entityKind] = "PgForeignKeyBuilder";
  reference;
  _onUpdate = "no action";
  _onDelete = "no action";
  constructor(config, actions) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action === undefined ? "no action" : action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action === undefined ? "no action" : action;
    return this;
  }
  build(table9) {
    return new ForeignKey(table9, this);
  }
}

class ForeignKey {
  constructor(table9, builder) {
    this.table = table9;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  static [entityKind] = "PgForeignKey";
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column6) => column6.name);
    const foreignColumnNames = foreignColumns.map((column6) => column6.name);
    const chunks = [
      this.table[PgTable.Symbol.Name],
      ...columnNames,
      foreignColumns[0].table[PgTable.Symbol.Name],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
}

// node_modules/drizzle-orm/pg-core/unique-constraint.js
function uniqueKeyName(table10, columns) {
  return `${table10[PgTable.Symbol.Name]}_${columns.join("_")}_unique`;
}

// node_modules/drizzle-orm/pg-core/utils/array.js
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i = startFrom;i < arrayString.length; i++) {
    const char = arrayString[i];
    if (char === "\\") {
      i++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i = startFrom;
  let lastCharIsComma = false;
  while (i < arrayString.length) {
    const char = arrayString[i];
    if (char === ",") {
      if (lastCharIsComma || i === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i + 1, true);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i + 1);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);
    result.push(value);
    i = newStartFrom;
  }
  return [result, i];
}
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
function makePgArray(array) {
  return `{${array.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string" && item.includes(",")) {
      return `"${item.replace(/"/g, '\\"')}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}

// node_modules/drizzle-orm/pg-core/columns/common.js
class PgColumnBuilder extends ColumnBuilder {
  foreignKeyConfigs = [];
  static [entityKind] = "PgColumnBuilder";
  array(size) {
    return new PgArrayBuilder(this.config.name, this, size);
  }
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name, config) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    this.config.uniqueType = config?.nulls;
    return this;
  }
  buildForeignKeys(column7, table10) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return iife((ref2, actions2) => {
        const builder = new ForeignKeyBuilder(() => {
          const foreignColumn = ref2();
          return { columns: [column7], foreignColumns: [foreignColumn] };
        });
        if (actions2.onUpdate) {
          builder.onUpdate(actions2.onUpdate);
        }
        if (actions2.onDelete) {
          builder.onDelete(actions2.onDelete);
        }
        return builder.build(table10);
      }, ref, actions);
    });
  }
}

class PgColumn extends Column {
  constructor(table10, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName(table10, [config.name]);
    }
    super(table10, config);
    this.table = table10;
  }
  static [entityKind] = "PgColumn";
}

class PgArrayBuilder extends PgColumnBuilder {
  static [entityKind] = "PgArrayBuilder";
  constructor(name, baseBuilder, size) {
    super(name, "array", "PgArray");
    this.config.baseBuilder = baseBuilder;
    this.config.size = size;
  }
  build(table10) {
    const baseColumn = this.config.baseBuilder.build(table10);
    return new PgArray(table10, this.config, baseColumn);
  }
}

class PgArray extends PgColumn {
  constructor(table10, config, baseColumn, range) {
    super(table10, config);
    this.baseColumn = baseColumn;
    this.range = range;
    this.size = config.size;
  }
  size;
  static [entityKind] = "PgArray";
  getSQLType() {
    return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      value = parsePgArray(value);
    }
    return value.map((v) => this.baseColumn.mapFromDriverValue(v));
  }
  mapToDriverValue(value, isNestedArray = false) {
    const a = value.map((v) => v === null ? null : is(this.baseColumn, PgArray) ? this.baseColumn.mapToDriverValue(v, true) : this.baseColumn.mapToDriverValue(v));
    if (isNestedArray)
      return a;
    return makePgArray(a);
  }
}

// node_modules/drizzle-orm/pg-core/columns/char.js
class PgChar extends PgColumn {
  static [entityKind] = "PgChar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `char` : `char(${this.length})`;
  }
}

// node_modules/drizzle-orm/pg-core/columns/date.common.js
class PgDateColumnBaseBuilder extends PgColumnBuilder {
  static [entityKind] = "PgDateColumnBaseBuilder";
  defaultNow() {
    return this.default(sql2`now()`);
  }
}

// node_modules/drizzle-orm/pg-core/columns/date.js
class PgDate extends PgColumn {
  static [entityKind] = "PgDate";
  getSQLType() {
    return "date";
  }
  mapFromDriverValue(value) {
    return new Date(value);
  }
  mapToDriverValue(value) {
    return value.toISOString();
  }
}

// node_modules/drizzle-orm/pg-core/columns/enum.js
function pgEnum(enumName, values) {
  const enumInstance = Object.assign((name) => new PgEnumColumnBuilder(name, enumInstance), {
    enumName,
    enumValues: values,
    [isPgEnumSym]: true
  });
  return enumInstance;
}
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");

class PgEnumColumnBuilder extends PgColumnBuilder {
  static [entityKind] = "PgEnumColumnBuilder";
  constructor(name, enumInstance) {
    super(name, "string", "PgEnumColumn");
    this.config.enum = enumInstance;
  }
  build(table10) {
    return new PgEnumColumn(table10, this.config);
  }
}

class PgEnumColumn extends PgColumn {
  static [entityKind] = "PgEnumColumn";
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table10, config) {
    super(table10, config);
    this.enum = config.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}

// node_modules/drizzle-orm/pg-core/columns/integer.js
function integer(name) {
  return new PgIntegerBuilder(name);
}

class PgIntegerBuilder extends PgColumnBuilder {
  static [entityKind] = "PgIntegerBuilder";
  constructor(name) {
    super(name, "number", "PgInteger");
  }
  build(table10) {
    return new PgInteger(table10, this.config);
  }
}

class PgInteger extends PgColumn {
  static [entityKind] = "PgInteger";
  getSQLType() {
    return "integer";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseInt(value);
    }
    return value;
  }
}

// node_modules/drizzle-orm/pg-core/columns/json.js
class PgJson extends PgColumn {
  static [entityKind] = "PgJson";
  constructor(table10, config) {
    super(table10, config);
  }
  getSQLType() {
    return "json";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
}

// node_modules/drizzle-orm/pg-core/columns/jsonb.js
class PgJsonb extends PgColumn {
  static [entityKind] = "PgJsonb";
  constructor(table10, config) {
    super(table10, config);
  }
  getSQLType() {
    return "jsonb";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
}

// node_modules/drizzle-orm/pg-core/columns/numeric.js
class PgNumeric extends PgColumn {
  static [entityKind] = "PgNumeric";
  precision;
  scale;
  constructor(table10, config) {
    super(table10, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}

// node_modules/drizzle-orm/pg-core/columns/text.js
function text(name, config = {}) {
  return new PgTextBuilder(name, config);
}

class PgTextBuilder extends PgColumnBuilder {
  static [entityKind] = "PgTextBuilder";
  constructor(name, config) {
    super(name, "string", "PgText");
    this.config.enumValues = config.enum;
  }
  build(table10) {
    return new PgText(table10, this.config);
  }
}

class PgText extends PgColumn {
  static [entityKind] = "PgText";
  enumValues = this.config.enumValues;
  getSQLType() {
    return "text";
  }
}

// node_modules/drizzle-orm/pg-core/columns/time.js
class PgTime extends PgColumn {
  static [entityKind] = "PgTime";
  withTimezone;
  precision;
  constructor(table10, config) {
    super(table10, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}

// node_modules/drizzle-orm/pg-core/columns/timestamp.js
function timestamp(name, config = {}) {
  if (config.mode === "string") {
    return new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);
  }
  return new PgTimestampBuilder(name, config.withTimezone ?? false, config.precision);
}

class PgTimestampBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "date", "PgTimestamp");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table10) {
    return new PgTimestamp(table10, this.config);
  }
}

class PgTimestamp extends PgColumn {
  static [entityKind] = "PgTimestamp";
  withTimezone;
  precision;
  constructor(table10, config) {
    super(table10, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : ` (${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
  mapFromDriverValue = (value) => {
    return new Date(this.withTimezone ? value : value + "+0000");
  };
  mapToDriverValue = (value) => {
    return this.withTimezone ? value.toUTCString() : value.toISOString();
  };
}

class PgTimestampStringBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampStringBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTimestampString");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table10) {
    return new PgTimestampString(table10, this.config);
  }
}

class PgTimestampString extends PgColumn {
  static [entityKind] = "PgTimestampString";
  withTimezone;
  precision;
  constructor(table10, config) {
    super(table10, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}

// node_modules/drizzle-orm/pg-core/columns/uuid.js
class PgUUID extends PgColumn {
  static [entityKind] = "PgUUID";
  getSQLType() {
    return "uuid";
  }
}

// node_modules/drizzle-orm/pg-core/columns/varchar.js
class PgVarchar extends PgColumn {
  static [entityKind] = "PgVarchar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `varchar` : `varchar(${this.length})`;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/delete.js
class PgDeleteBase extends QueryPromise {
  constructor(table11, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table: table11 };
  }
  static [entityKind] = "PgDelete";
  config;
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/insert.js
class PgInsertBuilder {
  constructor(table12, session, dialect) {
    this.table = table12;
    this.session = session;
    this.dialect = dialect;
  }
  static [entityKind] = "PgInsertBuilder";
  values(values) {
    values = Array.isArray(values) ? values : [values];
    if (values.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new PgInsertBase(this.table, mappedValues, this.session, this.dialect);
  }
}

class PgInsertBase extends QueryPromise {
  constructor(table12, values, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table: table12, values };
  }
  static [entityKind] = "PgInsert";
  config;
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  onConflictDoNothing(config = {}) {
    if (config.target === undefined) {
      this.config.onConflict = sql2`do nothing`;
    } else {
      let targetColumn = "";
      targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(it.name)).join(",") : this.dialect.escapeName(config.target.name);
      const whereSql = config.where ? sql2` where ${config.where}` : undefined;
      this.config.onConflict = sql2`(${sql2.raw(targetColumn)}) do nothing${whereSql}`;
    }
    return this;
  }
  onConflictDoUpdate(config) {
    const whereSql = config.where ? sql2` where ${config.where}` : undefined;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
    let targetColumn = "";
    targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(it.name)).join(",") : this.dialect.escapeName(config.target.name);
    this.config.onConflict = sql2`(${sql2.raw(targetColumn)}) do update set ${setSql}${whereSql}`;
    return this;
  }
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/view-base.js
class PgViewBase extends View {
  static [entityKind] = "PgViewBase";
}

// node_modules/drizzle-orm/pg-core/dialect.js
class PgDialect {
  static [entityKind] = "PgDialect";
  async migrate(migrations, session) {
    const migrationTableCreate = sql2`
			CREATE TABLE IF NOT EXISTS "drizzle"."__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
    await session.execute(sql2`CREATE SCHEMA IF NOT EXISTS "drizzle"`);
    await session.execute(migrationTableCreate);
    const dbMigrations = await session.all(sql2`select id, hash, created_at from "drizzle"."__drizzle_migrations" order by created_at desc limit 1`);
    const lastDbMigration = dbMigrations[0];
    await session.transaction(async (tx) => {
      for await (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.execute(sql2.raw(stmt));
          }
          await tx.execute(sql2`insert into "drizzle"."__drizzle_migrations" ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
        }
      }
    });
  }
  escapeName(name) {
    return `"${name}"`;
  }
  escapeParam(num) {
    return `\$${num + 1}`;
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildDeleteQuery({ table: table14, where, returning }) {
    const returningSql = returning ? sql2` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql2` where ${where}` : undefined;
    return sql2`delete from ${table14}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table14, set) {
    const setEntries = Object.entries(set);
    const setSize = setEntries.length;
    return sql2.join(setEntries.flatMap(([colName, value], i) => {
      const col = table14[Table.Symbol.Columns][colName];
      const res = sql2`${sql2.identifier(col.name)} = ${value}`;
      if (i < setSize - 1) {
        return [res, sql2.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table: table14, set, where, returning }) {
    const setSql = this.buildUpdateSet(table14, set);
    const returningSql = returning ? sql2` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql2` where ${where}` : undefined;
    return sql2`update ${table14} set ${setSql}${whereSql}${returningSql}`;
  }
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql2.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(new SQL(query.queryChunks.map((c) => {
            if (is(c, PgColumn)) {
              return sql2.identifier(c.name);
            }
            return c;
          })));
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql2` as ${sql2.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        if (isSingleTable) {
          chunk.push(sql2.identifier(field.name));
        } else {
          chunk.push(field);
        }
      }
      if (i < columnsLen - 1) {
        chunk.push(sql2`, `);
      }
      return chunk;
    });
    return sql2.join(chunks);
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table: table14,
    joins,
    orderBy,
    groupBy,
    limit,
    offset,
    lockingClause,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f of fieldsList) {
      if (is(f.field, Column) && getTableName(f.field.table) !== (is(table14, Subquery) ? table14[SubqueryConfig].alias : is(table14, PgViewBase) ? table14[ViewBaseConfig].name : is(table14, SQL) ? undefined : getTableName(table14)) && !((table22) => joins?.some(({ alias: alias2 }) => alias2 === (table22[Table.Symbol.IsAlias] ? getTableName(table22) : table22[Table.Symbol.BaseName])))(f.field.table)) {
        const tableName = getTableName(f.field.table);
        throw new Error(`Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    let withSql;
    if (withList?.length) {
      const withSqlChunks = [sql2`with `];
      for (const [i, w] of withList.entries()) {
        withSqlChunks.push(sql2`${sql2.identifier(w[SubqueryConfig].alias)} as (${w[SubqueryConfig].sql})`);
        if (i < withList.length - 1) {
          withSqlChunks.push(sql2`, `);
        }
      }
      withSqlChunks.push(sql2` `);
      withSql = sql2.join(withSqlChunks);
    }
    let distinctSql;
    if (distinct) {
      distinctSql = distinct === true ? sql2` distinct` : sql2` distinct on (${sql2.join(distinct.on, sql2`, `)})`;
    }
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = (() => {
      if (is(table14, Table) && table14[Table.Symbol.OriginalName] !== table14[Table.Symbol.Name]) {
        let fullName = sql2`${sql2.identifier(table14[Table.Symbol.OriginalName])}`;
        if (table14[Table.Symbol.Schema]) {
          fullName = sql2`${sql2.identifier(table14[Table.Symbol.Schema])}.${fullName}`;
        }
        return sql2`${fullName} ${sql2.identifier(table14[Table.Symbol.Name])}`;
      }
      return table14;
    })();
    const joinsArray = [];
    if (joins) {
      for (const [index, joinMeta] of joins.entries()) {
        if (index === 0) {
          joinsArray.push(sql2` `);
        }
        const table22 = joinMeta.table;
        const lateralSql = joinMeta.lateral ? sql2` lateral` : undefined;
        if (is(table22, PgTable)) {
          const tableName = table22[PgTable.Symbol.Name];
          const tableSchema = table22[PgTable.Symbol.Schema];
          const origTableName = table22[PgTable.Symbol.OriginalName];
          const alias2 = tableName === origTableName ? undefined : joinMeta.alias;
          joinsArray.push(sql2`${sql2.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql2`${sql2.identifier(tableSchema)}.` : undefined}${sql2.identifier(origTableName)}${alias2 && sql2` ${sql2.identifier(alias2)}`} on ${joinMeta.on}`);
        } else if (is(table22, View)) {
          const viewName = table22[ViewBaseConfig].name;
          const viewSchema = table22[ViewBaseConfig].schema;
          const origViewName = table22[ViewBaseConfig].originalName;
          const alias2 = viewName === origViewName ? undefined : joinMeta.alias;
          joinsArray.push(sql2`${sql2.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql2`${sql2.identifier(viewSchema)}.` : undefined}${sql2.identifier(origViewName)}${alias2 && sql2` ${sql2.identifier(alias2)}`} on ${joinMeta.on}`);
        } else {
          joinsArray.push(sql2`${sql2.raw(joinMeta.joinType)} join${lateralSql} ${table22} on ${joinMeta.on}`);
        }
        if (index < joins.length - 1) {
          joinsArray.push(sql2` `);
        }
      }
    }
    const joinsSql = sql2.join(joinsArray);
    const whereSql = where ? sql2` where ${where}` : undefined;
    const havingSql = having ? sql2` having ${having}` : undefined;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      orderBySql = sql2` order by ${sql2.join(orderBy, sql2`, `)}`;
    }
    let groupBySql;
    if (groupBy && groupBy.length > 0) {
      groupBySql = sql2` group by ${sql2.join(groupBy, sql2`, `)}`;
    }
    const limitSql = limit ? sql2` limit ${limit}` : undefined;
    const offsetSql = offset ? sql2` offset ${offset}` : undefined;
    const lockingClauseSql = sql2.empty();
    if (lockingClause) {
      const clauseSql = sql2` for ${sql2.raw(lockingClause.strength)}`;
      if (lockingClause.config.of) {
        clauseSql.append(sql2` of ${sql2.join(Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of], sql2`, `)}`);
      }
      if (lockingClause.config.noWait) {
        clauseSql.append(sql2` no wait`);
      } else if (lockingClause.config.skipLocked) {
        clauseSql.append(sql2` skip locked`);
      }
      lockingClauseSql.append(clauseSql);
    }
    const finalQuery = sql2`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(this.buildSetOperationQuery({ leftSelect, setOperator }), rest);
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql2`(${leftSelect.getSQL()}) `;
    const rightChunk = sql2`(${rightSelect.getSQL()})`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is(singleOrderBy, PgColumn)) {
          orderByValues.push(sql2.identifier(singleOrderBy.name));
        } else if (is(singleOrderBy, SQL)) {
          for (let i = 0;i < singleOrderBy.queryChunks.length; i++) {
            const chunk = singleOrderBy.queryChunks[i];
            if (is(chunk, PgColumn)) {
              singleOrderBy.queryChunks[i] = sql2.identifier(chunk.name);
            }
          }
          orderByValues.push(sql2`${singleOrderBy}`);
        } else {
          orderByValues.push(sql2`${singleOrderBy}`);
        }
      }
      orderBySql = sql2` order by ${sql2.join(orderByValues, sql2`, `)} `;
    }
    const limitSql = limit ? sql2` limit ${limit}` : undefined;
    const operatorChunk = sql2.raw(`${type} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql2` offset ${offset}` : undefined;
    return sql2`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table: table14, values, onConflict, returning }) {
    const valuesSqlList = [];
    const columns2 = table14[Table.Symbol.Columns];
    const colEntries = Object.entries(columns2);
    const insertOrder = colEntries.map(([, column8]) => sql2.identifier(column8.name));
    for (const [valueIndex, value] of values.entries()) {
      const valueList = [];
      for (const [fieldName, col] of colEntries) {
        const colValue = value[fieldName];
        if (colValue === undefined || is(colValue, Param) && colValue.value === undefined) {
          if (col.defaultFn !== undefined) {
            const defaultFnResult = col.defaultFn();
            const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql2.param(defaultFnResult, col);
            valueList.push(defaultValue);
          } else {
            valueList.push(sql2`default`);
          }
        } else {
          valueList.push(colValue);
        }
      }
      valuesSqlList.push(valueList);
      if (valueIndex < values.length - 1) {
        valuesSqlList.push(sql2`, `);
      }
    }
    const valuesSql = sql2.join(valuesSqlList);
    const returningSql = returning ? sql2` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const onConflictSql = onConflict ? sql2` on conflict ${onConflict}` : undefined;
    return sql2`insert into ${table14} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
  }
  buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
    const concurrentlySql = concurrently ? sql2` concurrently` : undefined;
    const withNoDataSql = withNoData ? sql2` with no data` : undefined;
    return sql2`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
  }
  prepareTyping(encoder) {
    if (is(encoder, PgJsonb) || is(encoder, PgJson)) {
      return "json";
    } else if (is(encoder, PgNumeric)) {
      return "decimal";
    } else if (is(encoder, PgTime)) {
      return "time";
    } else if (is(encoder, PgTimestamp)) {
      return "timestamp";
    } else if (is(encoder, PgDate)) {
      return "date";
    } else if (is(encoder, PgUUID)) {
      return "uuid";
    } else {
      return "none";
    }
  }
  sqlToQuery(sql22) {
    return sql22.toQuery({
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      prepareTyping: this.prepareTyping
    });
  }
  buildRelationalQueryWithoutPK({
    fullSchema,
    schema,
    tableNamesMap,
    table: table14,
    tableConfig,
    queryConfig: config,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: undefined,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
      if (config.where) {
        const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config.columns)) {
          if (value === undefined) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column8 = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column8 });
      }
      let selectedRelations = [];
      if (config.with) {
        selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config.extras) {
        extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql: sql2 }) : config.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: undefined,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config.limit;
      offset = config.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = relation.referencedTable[Table.Symbol.Name];
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(...normalizedRelation.fields.map((field2, i) => eq(aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
        const builtRelation = this.buildRelationalQueryWithoutPK({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql2`${sql2.identifier(relationTableAlias)}.${sql2.identifier("data")}`.as(selectedRelationTsKey);
        joins.push({
          on: sql2`true`,
          table: new Subquery(builtRelation.sql, {}, relationTableAlias),
          alias: relationTableAlias,
          joinType: "left",
          lateral: true
        });
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql2`json_build_array(${sql2.join(selection.map(({ field: field2, tsKey, isJson }) => isJson ? sql2`${sql2.identifier(`${tableAlias}_${tsKey}`)}.${sql2.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2), sql2`, `)})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql2`coalesce(json_agg(${field}${orderBy.length > 0 ? sql2` order by ${sql2.join(orderBy, sql2`, `)}` : undefined}), '[]'::json)`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table14, tableAlias),
          fields: {},
          fieldsFlat: [{
            path: [],
            field: sql2.raw("*")
          }],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = undefined;
        limit = undefined;
        offset = undefined;
        orderBy = [];
      } else {
        result = aliasedTable(table14, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table14, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
}

// node_modules/drizzle-orm/query-builders/query-builder.js
class TypedQueryBuilder {
  static [entityKind] = "TypedQueryBuilder";
  getSelectedFields() {
    return this._.selectedFields;
  }
}

// node_modules/drizzle-orm/selection-proxy.js
class SelectionProxyHandler {
  static [entityKind] = "SelectionProxyHandler";
  config;
  constructor(config) {
    this.config = { ...config };
  }
  get(subquery5, prop) {
    if (prop === SubqueryConfig) {
      return {
        ...subquery5[SubqueryConfig],
        selection: new Proxy(subquery5[SubqueryConfig].selection, this)
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery5[ViewBaseConfig],
        selectedFields: new Proxy(subquery5[ViewBaseConfig].selectedFields, this)
      };
    }
    if (typeof prop === "symbol") {
      return subquery5[prop];
    }
    const columns2 = is(subquery5, Subquery) ? subquery5[SubqueryConfig].selection : is(subquery5, View) ? subquery5[ViewBaseConfig].selectedFields : subquery5;
    const value = columns2[prop];
    if (is(value, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
        return value.sql;
      }
      const newValue = value.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value;
      }
      throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
    }
    if (is(value, Column)) {
      if (this.config.alias) {
        return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(value.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
      }
      return value;
    }
    if (typeof value !== "object" || value === null) {
      return value;
    }
    return new Proxy(value, new SelectionProxyHandler(this.config));
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/select.js
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}

class PgSelectBuilder {
  static [entityKind] = "PgSelectBuilder";
  fields;
  session;
  dialect;
  withList = [];
  distinct;
  constructor(config) {
    this.fields = config.fields;
    this.session = config.session;
    this.dialect = config.dialect;
    if (config.withList) {
      this.withList = config.withList;
    }
    this.distinct = config.distinct;
  }
  from(source) {
    const isPartialSelect = !!this.fields;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(source, Subquery)) {
      fields = Object.fromEntries(Object.keys(source[SubqueryConfig].selection).map((key) => [key, source[key]]));
    } else if (is(source, PgViewBase)) {
      fields = source[ViewBaseConfig].selectedFields;
    } else if (is(source, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(source);
    }
    return new PgSelectBase({
      table: source,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    });
  }
}

class PgSelectQueryBuilderBase extends TypedQueryBuilder {
  static [entityKind] = "PgSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  constructor({ table: table15, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table: table15,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields
    };
    this.tableName = getTableLikeName(table15);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  createJoin(joinType) {
    return (table15, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table15);
      if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table15, SQL)) {
          const selection = is(table15, Subquery) ? table15[SubqueryConfig].selection : is(table15, View) ? table15[ViewBaseConfig].selectedFields : table15[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table: table15, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  createSetOperator(type, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getPgSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
      this.config.setOperators.push({ type, isAll, rightSelect });
      return this;
    };
  }
  union = this.createSetOperator("union", false);
  unionAll = this.createSetOperator("union", true);
  intersect = this.createSetOperator("intersect", false);
  intersectAll = this.createSetOperator("intersect", true);
  except = this.createSetOperator("except", false);
  exceptAll = this.createSetOperator("except", true);
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns2) {
    if (typeof columns2[0] === "function") {
      const groupBy = columns2[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns2;
    }
    return this;
  }
  orderBy(...columns2) {
    if (typeof columns2[0] === "function") {
      const orderBy = columns2[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns2;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  for(strength, config = {}) {
    this.config.lockingClause = { strength, config };
    return this;
  }
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias3) {
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias3), new SelectionProxyHandler({ alias: alias3, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  getSelectedFields() {
    return new Proxy(this.config.fields, new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  $dynamic() {
    return this;
  }
}

class PgSelectBase extends PgSelectQueryBuilderBase {
  static [entityKind] = "PgSelect";
  _prepare(name) {
    const { session, config, dialect, joinsNotNullableMap } = this;
    if (!session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const fieldsList = orderSelectedFields(config.fields);
      const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name);
      query.joinsNotNullableMap = joinsNotNullableMap;
      return query;
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
}
applyMixins(PgSelectBase, [QueryPromise]);
var getPgSetOperators = () => ({
  union,
  unionAll,
  intersect,
  intersectAll,
  except,
  exceptAll
});
var union = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect = createSetOperator("intersect", false);
var intersectAll = createSetOperator("intersect", true);
var except = createSetOperator("except", false);
var exceptAll = createSetOperator("except", true);

// node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
class QueryBuilder {
  static [entityKind] = "PgQueryBuilder";
  dialect;
  $with(alias3) {
    const queryBuilder = this;
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(queryBuilder);
        }
        return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias3, true), new SelectionProxyHandler({ alias: alias3, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select2(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        distinct: { on }
      });
    }
    return { select: select2, selectDistinct, selectDistinctOn };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect()
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: { on }
    });
  }
  getDialect() {
    if (!this.dialect) {
      this.dialect = new PgDialect;
    }
    return this.dialect;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js
class PgRefreshMaterializedView extends QueryPromise {
  constructor(view, session, dialect2) {
    super();
    this.session = session;
    this.dialect = dialect2;
    this.config = { view };
  }
  static [entityKind] = "PgRefreshMaterializedView";
  config;
  concurrently() {
    if (this.config.withNoData !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.concurrently = true;
    return this;
  }
  withNoData() {
    if (this.config.concurrently !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.withNoData = true;
    return this;
  }
  getSQL() {
    return this.dialect.buildRefreshMaterializedViewQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), undefined, name);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
}

// node_modules/drizzle-orm/pg-core/query-builders/update.js
class PgUpdateBuilder {
  constructor(table16, session, dialect2) {
    this.table = table16;
    this.session = session;
    this.dialect = dialect2;
  }
  static [entityKind] = "PgUpdateBuilder";
  set(values) {
    return new PgUpdateBase(this.table, mapUpdateSet(this.table, values), this.session, this.dialect);
  }
}

class PgUpdateBase extends QueryPromise {
  constructor(table16, set, session, dialect2) {
    super();
    this.session = session;
    this.dialect = dialect2;
    this.config = { set, table: table16 };
  }
  static [entityKind] = "PgUpdate";
  config;
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return this._prepare().execute(placeholderValues);
  };
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/query.js
class RelationalQueryBuilder {
  constructor(fullSchema, schema, tableNamesMap, table16, tableConfig, dialect2, session) {
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table16;
    this.tableConfig = tableConfig;
    this.dialect = dialect2;
    this.session = session;
  }
  static [entityKind] = "PgRelationalQueryBuilder";
  findMany(config) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, "many");
  }
  findFirst(config) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, "first");
  }
}

class PgRelationalQuery extends QueryPromise {
  constructor(fullSchema, schema, tableNamesMap, table16, tableConfig, dialect2, session, config, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table16;
    this.tableConfig = tableConfig;
    this.dialect = dialect2;
    this.session = session;
    this.config = config;
    this.mode = mode;
  }
  static [entityKind] = "PgRelationalQuery";
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const { query, builtQuery } = this._toSQL();
      return this.session.prepareQuery(builtQuery, undefined, name, (rawRows, mapColumnValue) => {
        const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
        if (this.mode === "first") {
          return rows[0];
        }
        return rows;
      });
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  _getQuery() {
    return this.dialect.buildRelationalQueryWithoutPK({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
  }
  getSQL() {
    return this._getQuery().sql;
  }
  _toSQL() {
    const query = this._getQuery();
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  execute() {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute();
    });
  }
}

// node_modules/drizzle-orm/pg-core/db.js
class PgDatabase {
  constructor(dialect2, session, schema) {
    this.dialect = dialect2;
    this.session = session;
    this._ = schema ? { schema: schema.schema, tableNamesMap: schema.tableNamesMap } : { schema: undefined, tableNamesMap: {} };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns2] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns2, dialect2, session);
      }
    }
  }
  static [entityKind] = "PgDatabase";
  query;
  $with(alias3) {
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder);
        }
        return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias3, true), new SelectionProxyHandler({ alias: alias3, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select2(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries
      });
    }
    return { select: select2 };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: { on }
    });
  }
  update(table16) {
    return new PgUpdateBuilder(table16, this.session, this.dialect);
  }
  insert(table16) {
    return new PgInsertBuilder(table16, this.session, this.dialect);
  }
  delete(table16) {
    return new PgDeleteBase(table16, this.session, this.dialect);
  }
  refreshMaterializedView(view) {
    return new PgRefreshMaterializedView(view, this.session, this.dialect);
  }
  execute(query2) {
    return this.session.execute(query2.getSQL());
  }
  transaction(transaction, config) {
    return this.session.transaction(transaction, config);
  }
}

// node_modules/drizzle-orm/pg-core/indexes.js
function index(name) {
  return new IndexBuilderOn(false, name);
}
class IndexBuilderOn {
  constructor(unique, name) {
    this.unique = unique;
    this.name = name;
  }
  static [entityKind] = "PgIndexBuilderOn";
  on(...columns2) {
    return new IndexBuilder(columns2, this.unique, false, this.name);
  }
  onOnly(...columns2) {
    return new IndexBuilder(columns2, this.unique, true, this.name);
  }
}

class IndexBuilder {
  static [entityKind] = "PgIndexBuilder";
  config;
  constructor(columns2, unique, only, name) {
    this.config = {
      name,
      columns: columns2,
      unique,
      only
    };
  }
  concurrently() {
    this.config.concurrently = true;
    return this;
  }
  using(method) {
    this.config.using = method;
    return this;
  }
  asc() {
    this.config.order = "asc";
    return this;
  }
  desc() {
    this.config.order = "desc";
    return this;
  }
  nullsFirst() {
    this.config.nulls = "first";
    return this;
  }
  nullsLast() {
    this.config.nulls = "last";
    return this;
  }
  where(condition) {
    this.config.where = condition;
    return this;
  }
  build(table16) {
    return new Index(this.config, table16);
  }
}

class Index {
  static [entityKind] = "PgIndex";
  config;
  constructor(config, table16) {
    this.config = { ...config, table: table16 };
  }
}

// node_modules/drizzle-orm/pg-core/session.js
class PreparedQuery {
  static [entityKind] = "PgPreparedQuery";
  joinsNotNullableMap;
}

class PgSession {
  constructor(dialect2) {
    this.dialect = dialect2;
  }
  static [entityKind] = "PgSession";
  execute(query2) {
    return tracer.startActiveSpan("drizzle.operation", () => {
      const prepared = tracer.startActiveSpan("drizzle.prepareQuery", () => {
        return this.prepareQuery(this.dialect.sqlToQuery(query2), undefined, undefined);
      });
      return prepared.execute();
    });
  }
  all(query2) {
    return this.prepareQuery(this.dialect.sqlToQuery(query2), undefined, undefined).all();
  }
}

class PgTransaction extends PgDatabase {
  constructor(dialect2, session, schema, nestedIndex = 0) {
    super(dialect2, session, schema);
    this.schema = schema;
    this.nestedIndex = nestedIndex;
  }
  static [entityKind] = "PgTransaction";
  rollback() {
    throw new TransactionRollbackError;
  }
  getTransactionConfigSQL(config) {
    const chunks = [];
    if (config.isolationLevel) {
      chunks.push(`isolation level ${config.isolationLevel}`);
    }
    if (config.accessMode) {
      chunks.push(config.accessMode);
    }
    if (typeof config.deferrable === "boolean") {
      chunks.push(config.deferrable ? "deferrable" : "not deferrable");
    }
    return sql2.raw(chunks.join(" "));
  }
  setTransaction(config) {
    return this.session.execute(sql2`set transaction ${this.getTransactionConfigSQL(config)}`);
  }
}

// src/db/schema/order-items.ts
var orderItems = pgTable("order_items", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  orderId: text("order_id").notNull().references(() => orders.id, {
    onDelete: "cascade"
  }),
  productId: text("product_id").references(() => products.id, {
    onDelete: "set null"
  }),
  quantity: integer("quantity").default(1),
  priceInCents: integer("price_in_cents").notNull()
});
var orderItemsRelations = relations(orderItems, ({ one }) => ({
  order: one(orders, {
    fields: [orderItems.orderId],
    references: [orders.id]
  }),
  product: one(products, {
    fields: [orderItems.productId],
    references: [products.id]
  })
}));

// src/db/schema/orders.ts
var orderStatusEnum = pgEnum("order_status", [
  "pending",
  "canceled",
  "processing",
  "delivering",
  "delivered"
]);
var orders = pgTable("orders", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  customerId: text("customer_id").references(() => users.id, {
    onDelete: "set null"
  }).notNull(),
  restaurantId: text("restaurant_id").references(() => restaurants.id, {
    onDelete: "set null"
  }).notNull(),
  status: orderStatusEnum("status").default("pending").notNull(),
  totalInCents: integer("total_in_cents").notNull(),
  createdAt: timestamp("created_at").defaultNow()
});
var ordersRelations = relations(orders, ({ one, many }) => ({
  customer: one(users, {
    fields: [orders.customerId],
    references: [users.id]
  }),
  restaurant: one(restaurants, {
    fields: [orders.restaurantId],
    references: [restaurants.id]
  }),
  orderItems: many(orderItems)
}));

// src/db/schema/users.ts
var userRoleEnum = pgEnum("user_role", ["manager", "customer"]);
var users = pgTable("users", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  phone: text("phone"),
  role: userRoleEnum("role").default("customer").notNull(),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var usersRelations = relations(users, ({ many }) => ({
  orders: many(orders)
}));
// src/db/schema/restaurants.ts
var restaurants = pgTable("restaurants", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  name: text("name").notNull(),
  description: text("description"),
  managerId: text("manager_id").references(() => users.id, {
    onDelete: "set null"
  }),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var restaurantsRelations = relations(restaurants, ({ one, many }) => ({
  manager: one(users, {
    fields: [restaurants.managerId],
    references: [users.id],
    relationName: "restaurantManager"
  }),
  orders: many(orders),
  products: many(products)
}));
// src/db/schema/evaluations.ts
var evaluations = pgTable("evaluations", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  customerId: text("customer_id").references(() => users.id),
  restaurantId: text("restaurant_id").references(() => users.id),
  rate: integer("rate").notNull(),
  comment: text("comment"),
  createdAt: timestamp("created_at").defaultNow()
});
var evaluationsRelations = relations(evaluations, ({ one }) => ({
  customer: one(users, {
    fields: [evaluations.customerId],
    references: [users.id]
  }),
  restaurant: one(restaurants, {
    fields: [evaluations.restaurantId],
    references: [restaurants.id]
  })
}));
// src/db/schema/auth-links.ts
var authLinks = pgTable("auth_links", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  code: text("code").notNull().unique(),
  userId: text("user_id").references(() => users.id).notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  expiresAt: timestamp("expires_at", { withTimezone: true }).notNull(),
  usedAt: timestamp("used_at", { withTimezone: true })
}, (t) => ({
  byUserCreated: index("auth_links_user_created_idx").on(t.userId, t.createdAt)
}));
// src/db/schema/products.ts
var products = pgTable("products", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  name: text("name").notNull(),
  description: text("description"),
  priceInCents: integer("price_in_cents").notNull(),
  restaurantId: text("restaurant_id").references(() => restaurants.id, {
    onDelete: "cascade"
  }).notNull(),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var productsRelations = relations(products, ({ one, many }) => ({
  restaurant: one(restaurants, {
    fields: [products.restaurantId],
    references: [restaurants.id],
    relationName: "productRestaurant"
  }),
  orderItems: many(orderItems)
}));
// node_modules/drizzle-orm/postgres-js/session.js
class PostgresJsPreparedQuery extends PreparedQuery {
  constructor(client, query2, params, logger2, fields, customResultMapper) {
    super();
    this.client = client;
    this.query = query2;
    this.params = params;
    this.logger = logger2;
    this.fields = fields;
    this.customResultMapper = customResultMapper;
  }
  static [entityKind] = "PostgresJsPreparedQuery";
  async execute(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", async (span) => {
      const params = fillPlaceholders(this.params, placeholderValues);
      span?.setAttributes({
        "drizzle.query.text": this.query,
        "drizzle.query.params": JSON.stringify(params)
      });
      this.logger.logQuery(this.query, params);
      const { fields, query: query2, client, joinsNotNullableMap, customResultMapper } = this;
      if (!fields && !customResultMapper) {
        return tracer.startActiveSpan("drizzle.driver.execute", () => {
          return client.unsafe(query2, params);
        });
      }
      const rows = await tracer.startActiveSpan("drizzle.driver.execute", () => {
        span?.setAttributes({
          "drizzle.query.text": query2,
          "drizzle.query.params": JSON.stringify(params)
        });
        return client.unsafe(query2, params).values();
      });
      return tracer.startActiveSpan("drizzle.mapResponse", () => {
        return customResultMapper ? customResultMapper(rows) : rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
      });
    });
  }
  all(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", async (span) => {
      const params = fillPlaceholders(this.params, placeholderValues);
      span?.setAttributes({
        "drizzle.query.text": this.query,
        "drizzle.query.params": JSON.stringify(params)
      });
      this.logger.logQuery(this.query, params);
      return tracer.startActiveSpan("drizzle.driver.execute", () => {
        span?.setAttributes({
          "drizzle.query.text": this.query,
          "drizzle.query.params": JSON.stringify(params)
        });
        return this.client.unsafe(this.query, params);
      });
    });
  }
}

class PostgresJsSession extends PgSession {
  constructor(client, dialect2, schema, options = {}) {
    super(dialect2);
    this.client = client;
    this.schema = schema;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger;
  }
  static [entityKind] = "PostgresJsSession";
  logger;
  prepareQuery(query2, fields, name, customResultMapper) {
    return new PostgresJsPreparedQuery(this.client, query2.sql, query2.params, this.logger, fields, customResultMapper);
  }
  query(query2, params) {
    this.logger.logQuery(query2, params);
    return this.client.unsafe(query2, params).values();
  }
  queryObjects(query2, params) {
    return this.client.unsafe(query2, params);
  }
  transaction(transaction, config) {
    return this.client.begin(async (client) => {
      const session2 = new PostgresJsSession(client, this.dialect, this.schema, this.options);
      const tx = new PostgresJsTransaction(this.dialect, session2, this.schema);
      if (config) {
        await tx.setTransaction(config);
      }
      return transaction(tx);
    });
  }
}

class PostgresJsTransaction extends PgTransaction {
  constructor(dialect2, session2, schema, nestedIndex = 0) {
    super(dialect2, session2, schema, nestedIndex);
    this.session = session2;
  }
  static [entityKind] = "PostgresJsTransaction";
  transaction(transaction) {
    return this.session.client.savepoint((client) => {
      const session2 = new PostgresJsSession(client, this.dialect, this.schema, this.session.options);
      const tx = new PostgresJsTransaction(this.dialect, session2, this.schema);
      return transaction(tx);
    });
  }
}

// node_modules/drizzle-orm/postgres-js/driver.js
function drizzle(client, config = {}) {
  const dialect3 = new PgDialect;
  let logger3;
  if (config.logger === true) {
    logger3 = new DefaultLogger;
  } else if (config.logger !== false) {
    logger3 = config.logger;
  }
  let schema;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(config.schema, createTableRelationsHelpers);
    schema = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session3 = new PostgresJsSession(client, dialect3, schema, { logger: logger3 });
  return new PgDatabase(dialect3, session3, schema);
}

// node_modules/postgres/src/index.js
import os from "os";
import fs from "fs";

// node_modules/postgres/src/query.js
function cachedError(xs) {
  if (originCache.has(xs))
    return originCache.get(xs);
  const x = Error.stackTraceLimit;
  Error.stackTraceLimit = 4;
  originCache.set(xs, new Error);
  Error.stackTraceLimit = x;
  return originCache.get(xs);
}
var originCache = new Map;
var originStackCache = new Map;
var originError = Symbol("OriginError");
var CLOSE = {};

class Query extends Promise {
  constructor(strings, args, handler, canceller, options = {}) {
    let resolve, reject;
    super((a, b) => {
      resolve = a;
      reject = b;
    });
    this.tagged = Array.isArray(strings.raw);
    this.strings = strings;
    this.args = args;
    this.handler = handler;
    this.canceller = canceller;
    this.options = options;
    this.state = null;
    this.statement = null;
    this.resolve = (x) => (this.active = false, resolve(x));
    this.reject = (x) => (this.active = false, reject(x));
    this.active = false;
    this.cancelled = null;
    this.executed = false;
    this.signature = "";
    this[originError] = this.handler.debug ? new Error : this.tagged && cachedError(this.strings);
  }
  get origin() {
    return (this.handler.debug ? this[originError].stack : this.tagged && originStackCache.has(this.strings) ? originStackCache.get(this.strings) : originStackCache.set(this.strings, this[originError].stack).get(this.strings)) || "";
  }
  static get [Symbol.species]() {
    return Promise;
  }
  cancel() {
    return this.canceller && (this.canceller(this), this.canceller = null);
  }
  simple() {
    this.options.simple = true;
    this.options.prepare = false;
    return this;
  }
  async readable() {
    this.simple();
    this.streaming = true;
    return this;
  }
  async writable() {
    this.simple();
    this.streaming = true;
    return this;
  }
  cursor(rows = 1, fn) {
    this.options.simple = false;
    if (typeof rows === "function") {
      fn = rows;
      rows = 1;
    }
    this.cursorRows = rows;
    if (typeof fn === "function")
      return this.cursorFn = fn, this;
    let prev;
    return {
      [Symbol.asyncIterator]: () => ({
        next: () => {
          if (this.executed && !this.active)
            return { done: true };
          prev && prev();
          const promise = new Promise((resolve, reject) => {
            this.cursorFn = (value) => {
              resolve({ value, done: false });
              return new Promise((r) => prev = r);
            };
            this.resolve = () => (this.active = false, resolve({ done: true }));
            this.reject = (x) => (this.active = false, reject(x));
          });
          this.execute();
          return promise;
        },
        return() {
          prev && prev(CLOSE);
          return { done: true };
        }
      })
    };
  }
  describe() {
    this.options.simple = false;
    this.onlyDescribe = this.options.prepare = true;
    return this;
  }
  stream() {
    throw new Error(".stream has been renamed to .forEach");
  }
  forEach(fn) {
    this.forEachFn = fn;
    this.handle();
    return this;
  }
  raw() {
    this.isRaw = true;
    return this;
  }
  values() {
    this.isRaw = "values";
    return this;
  }
  async handle() {
    !this.executed && (this.executed = true) && await 1 && this.handler(this);
  }
  execute() {
    this.handle();
    return this;
  }
  then() {
    this.handle();
    return super.then.apply(this, arguments);
  }
  catch() {
    this.handle();
    return super.catch.apply(this, arguments);
  }
  finally() {
    this.handle();
    return super.finally.apply(this, arguments);
  }
}

// node_modules/postgres/src/errors.js
function connection(x, options, socket) {
  const { host, port } = socket || options;
  const error = Object.assign(new Error("write " + x + " " + (options.path || host + ":" + port)), {
    code: x,
    errno: x,
    address: options.path || host
  }, options.path ? {} : { port });
  Error.captureStackTrace(error, connection);
  return error;
}
function postgres(x) {
  const error = new PostgresError(x);
  Error.captureStackTrace(error, postgres);
  return error;
}
function generic(code, message) {
  const error = Object.assign(new Error(code + ": " + message), { code });
  Error.captureStackTrace(error, generic);
  return error;
}
function notSupported(x) {
  const error = Object.assign(new Error(x + " (B) is not supported"), {
    code: "MESSAGE_NOT_SUPPORTED",
    name: x
  });
  Error.captureStackTrace(error, notSupported);
  return error;
}

class PostgresError extends Error {
  constructor(x) {
    super(x.message);
    this.name = this.constructor.name;
    Object.assign(this, x);
  }
}
var Errors = {
  connection,
  postgres,
  generic,
  notSupported
};

// node_modules/postgres/src/types.js
function handleValue(x, parameters, types, options) {
  let value = x instanceof Parameter ? x.value : x;
  if (value === undefined) {
    x instanceof Parameter ? x.value = options.transform.undefined : value = x = options.transform.undefined;
    if (value === undefined)
      throw Errors.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
  }
  return "$" + types.push(x instanceof Parameter ? (parameters.push(x.value), x.array ? x.array[x.type || inferType(x.value)] || x.type || firstIsString(x.value) : x.type) : (parameters.push(x), inferType(x)));
}
function stringify(q, string, value, parameters, types, options) {
  for (let i = 1;i < q.strings.length; i++) {
    string += stringifyValue(string, value, parameters, types, options) + q.strings[i];
    value = q.args[i];
  }
  return string;
}
function stringifyValue(string, value, parameters, types, o) {
  return value instanceof Builder ? value.build(string, parameters, types, o) : value instanceof Query ? fragment(value, parameters, types, o) : value instanceof Identifier ? value.value : value && value[0] instanceof Query ? value.reduce((acc, x) => acc + " " + fragment(x, parameters, types, o), "") : handleValue(value, parameters, types, o);
}
function fragment(q, parameters, types, options) {
  q.fragment = true;
  return stringify(q, q.strings[0], q.args[0], parameters, types, options);
}
function valuesBuilder(first, parameters, types, columns2, options) {
  return first.map((row) => "(" + columns2.map((column9) => stringifyValue("values", row[column9], parameters, types, options)).join(",") + ")").join(",");
}
function values(first, rest, parameters, types, options) {
  const multi = Array.isArray(first[0]);
  const columns2 = rest.length ? rest.flat() : Object.keys(multi ? first[0] : first);
  return valuesBuilder(multi ? first : [first], parameters, types, columns2, options);
}
function select2(first, rest, parameters, types, options) {
  typeof first === "string" && (first = [first].concat(rest));
  if (Array.isArray(first))
    return escapeIdentifiers(first, options);
  let value;
  const columns2 = rest.length ? rest.flat() : Object.keys(first);
  return columns2.map((x) => {
    value = first[x];
    return (value instanceof Query ? fragment(value, parameters, types, options) : value instanceof Identifier ? value.value : handleValue(value, parameters, types, options)) + " as " + escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x);
  }).join(",");
}
function notTagged() {
  throw Errors.generic("NOT_TAGGED_CALL", "Query not called as a tagged template literal");
}
function firstIsString(x) {
  if (Array.isArray(x))
    return firstIsString(x[0]);
  return typeof x === "string" ? 1009 : 0;
}
function typeHandlers(types) {
  return Object.keys(types).reduce((acc, k) => {
    types[k].from && [].concat(types[k].from).forEach((x) => acc.parsers[x] = types[k].parse);
    if (types[k].serialize) {
      acc.serializers[types[k].to] = types[k].serialize;
      types[k].from && [].concat(types[k].from).forEach((x) => acc.serializers[x] = types[k].serialize);
    }
    return acc;
  }, { parsers: {}, serializers: {} });
}
function escapeIdentifiers(xs, { transform: { column: column9 } }) {
  return xs.map((x) => escapeIdentifier(column9.to ? column9.to(x) : x)).join(",");
}
function arrayEscape(x) {
  return x.replace(escapeBackslash, "\\\\").replace(escapeQuote, '\\"');
}
function arrayParserLoop(s, x, parser, typarray) {
  const xs = [];
  const delimiter = typarray === 1020 ? ";" : ",";
  for (;s.i < x.length; s.i++) {
    s.char = x[s.i];
    if (s.quoted) {
      if (s.char === "\\") {
        s.str += x[++s.i];
      } else if (s.char === '"') {
        xs.push(parser ? parser(s.str) : s.str);
        s.str = "";
        s.quoted = x[s.i + 1] === '"';
        s.last = s.i + 2;
      } else {
        s.str += s.char;
      }
    } else if (s.char === '"') {
      s.quoted = true;
    } else if (s.char === "{") {
      s.last = ++s.i;
      xs.push(arrayParserLoop(s, x, parser, typarray));
    } else if (s.char === "}") {
      s.quoted = false;
      s.last < s.i && xs.push(parser ? parser(x.slice(s.last, s.i)) : x.slice(s.last, s.i));
      s.last = s.i + 1;
      break;
    } else if (s.char === delimiter && s.p !== "}" && s.p !== '"') {
      xs.push(parser ? parser(x.slice(s.last, s.i)) : x.slice(s.last, s.i));
      s.last = s.i + 1;
    }
    s.p = s.char;
  }
  s.last < s.i && xs.push(parser ? parser(x.slice(s.last, s.i + 1)) : x.slice(s.last, s.i + 1));
  return xs;
}
function createJsonTransform(fn) {
  return function jsonTransform(x, column9) {
    return typeof x === "object" && x !== null && (column9.type === 114 || column9.type === 3802) ? Array.isArray(x) ? x.map((x2) => jsonTransform(x2, column9)) : Object.entries(x).reduce((acc, [k, v]) => Object.assign(acc, { [fn(k)]: jsonTransform(v, column9) }), {}) : x;
  };
}
var types = {
  string: {
    to: 25,
    from: null,
    serialize: (x) => "" + x
  },
  number: {
    to: 0,
    from: [21, 23, 26, 700, 701],
    serialize: (x) => "" + x,
    parse: (x) => +x
  },
  json: {
    to: 114,
    from: [114, 3802],
    serialize: (x) => JSON.stringify(x),
    parse: (x) => JSON.parse(x)
  },
  boolean: {
    to: 16,
    from: 16,
    serialize: (x) => x === true ? "t" : "f",
    parse: (x) => x === "t"
  },
  date: {
    to: 1184,
    from: [1082, 1114, 1184],
    serialize: (x) => (x instanceof Date ? x : new Date(x)).toISOString(),
    parse: (x) => new Date(x)
  },
  bytea: {
    to: 17,
    from: 17,
    serialize: (x) => "\\x" + Buffer.from(x).toString("hex"),
    parse: (x) => Buffer.from(x.slice(2), "hex")
  }
};

class NotTagged {
  then() {
    notTagged();
  }
  catch() {
    notTagged();
  }
  finally() {
    notTagged();
  }
}

class Identifier extends NotTagged {
  constructor(value) {
    super();
    this.value = escapeIdentifier(value);
  }
}

class Parameter extends NotTagged {
  constructor(value, type, array2) {
    super();
    this.value = value;
    this.type = type;
    this.array = array2;
  }
}

class Builder extends NotTagged {
  constructor(first, rest) {
    super();
    this.first = first;
    this.rest = rest;
  }
  build(before, parameters, types2, options) {
    const keyword = builders.map(([x, fn]) => ({ fn, i: before.search(x) })).sort((a, b) => a.i - b.i).pop();
    return keyword.i === -1 ? escapeIdentifiers(this.first, options) : keyword.fn(this.first, this.rest, parameters, types2, options);
  }
}
var defaultHandlers = typeHandlers(types);
var builders = Object.entries({
  values,
  in: (...xs) => {
    const x = values(...xs);
    return x === "()" ? "(null)" : x;
  },
  select: select2,
  as: select2,
  returning: select2,
  "\\(": select2,
  update(first, rest, parameters, types2, options) {
    return (rest.length ? rest.flat() : Object.keys(first)).map((x) => escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x) + "=" + stringifyValue("values", first[x], parameters, types2, options));
  },
  insert(first, rest, parameters, types2, options) {
    const columns2 = rest.length ? rest.flat() : Object.keys(Array.isArray(first) ? first[0] : first);
    return "(" + escapeIdentifiers(columns2, options) + ")values" + valuesBuilder(Array.isArray(first) ? first : [first], parameters, types2, columns2, options);
  }
}).map(([x, fn]) => [new RegExp("((?:^|[\\s(])" + x + "(?:$|[\\s(]))(?![\\s\\S]*\\1)", "i"), fn]);
var serializers = defaultHandlers.serializers;
var parsers = defaultHandlers.parsers;
var mergeUserTypes = function(types2) {
  const user = typeHandlers(types2 || {});
  return {
    serializers: Object.assign({}, serializers, user.serializers),
    parsers: Object.assign({}, parsers, user.parsers)
  };
};
var escapeIdentifier = function escape(str) {
  return '"' + str.replace(/"/g, '""').replace(/\./g, '"."') + '"';
};
var inferType = function inferType2(x) {
  return x instanceof Parameter ? x.type : x instanceof Date ? 1184 : x instanceof Uint8Array ? 17 : x === true || x === false ? 16 : typeof x === "bigint" ? 20 : Array.isArray(x) ? inferType2(x[0]) : 0;
};
var escapeBackslash = /\\/g;
var escapeQuote = /"/g;
var arraySerializer = function arraySerializer2(xs, serializer, options, typarray) {
  if (Array.isArray(xs) === false)
    return xs;
  if (!xs.length)
    return "{}";
  const first = xs[0];
  const delimiter = typarray === 1020 ? ";" : ",";
  if (Array.isArray(first) && !first.type)
    return "{" + xs.map((x) => arraySerializer2(x, serializer, options, typarray)).join(delimiter) + "}";
  return "{" + xs.map((x) => {
    if (x === undefined) {
      x = options.transform.undefined;
      if (x === undefined)
        throw Errors.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
    }
    return x === null ? "null" : '"' + arrayEscape(serializer ? serializer(x.type ? x.value : x) : "" + x) + '"';
  }).join(delimiter) + "}";
};
var arrayParserState = {
  i: 0,
  char: null,
  str: "",
  quoted: false,
  last: 0
};
var arrayParser = function arrayParser2(x, parser, typarray) {
  arrayParserState.i = arrayParserState.last = 0;
  return arrayParserLoop(arrayParserState, x, parser, typarray);
};
var toCamel = (x) => {
  let str = x[0];
  for (let i = 1;i < x.length; i++)
    str += x[i] === "_" ? x[++i].toUpperCase() : x[i];
  return str;
};
var toPascal = (x) => {
  let str = x[0].toUpperCase();
  for (let i = 1;i < x.length; i++)
    str += x[i] === "_" ? x[++i].toUpperCase() : x[i];
  return str;
};
var toKebab = (x) => x.replace(/_/g, "-");
var fromCamel = (x) => x.replace(/([A-Z])/g, "_$1").toLowerCase();
var fromPascal = (x) => (x.slice(0, 1) + x.slice(1).replace(/([A-Z])/g, "_$1")).toLowerCase();
var fromKebab = (x) => x.replace(/-/g, "_");
toCamel.column = { from: toCamel };
toCamel.value = { from: createJsonTransform(toCamel) };
fromCamel.column = { to: fromCamel };
var camel = { ...toCamel };
camel.column.to = fromCamel;
toPascal.column = { from: toPascal };
toPascal.value = { from: createJsonTransform(toPascal) };
fromPascal.column = { to: fromPascal };
var pascal = { ...toPascal };
pascal.column.to = fromPascal;
toKebab.column = { from: toKebab };
toKebab.value = { from: createJsonTransform(toKebab) };
fromKebab.column = { to: fromKebab };
var kebab = { ...toKebab };
kebab.column.to = fromKebab;

// node_modules/postgres/src/connection.js
import net from "net";
import tls from "tls";
import crypto2 from "crypto";
import Stream from "stream";
import {performance} from "perf_hooks";

// node_modules/postgres/src/result.js
class Result extends Array {
  constructor() {
    super();
    Object.defineProperties(this, {
      count: { value: null, writable: true },
      state: { value: null, writable: true },
      command: { value: null, writable: true },
      columns: { value: null, writable: true },
      statement: { value: null, writable: true }
    });
  }
  static get [Symbol.species]() {
    return Array;
  }
}

// node_modules/postgres/src/queue.js
function Queue(initial = []) {
  let xs = initial.slice();
  let index2 = 0;
  return {
    get length() {
      return xs.length - index2;
    },
    remove: (x) => {
      const index3 = xs.indexOf(x);
      return index3 === -1 ? null : (xs.splice(index3, 1), x);
    },
    push: (x) => (xs.push(x), x),
    shift: () => {
      const out = xs[index2++];
      if (index2 === xs.length) {
        index2 = 0;
        xs = [];
      } else {
        xs[index2 - 1] = undefined;
      }
      return out;
    }
  };
}
var queue_default = Queue;

// node_modules/postgres/src/bytes.js
function fit(x) {
  if (buffer.length - b.i < x) {
    const prev = buffer, length = prev.length;
    buffer = Buffer.allocUnsafe(length + (length >> 1) + x);
    prev.copy(buffer);
  }
}
function reset() {
  b.i = 0;
  return b;
}
var size = 256;
var buffer = Buffer.allocUnsafe(size);
var messages = "BCcDdEFfHPpQSX".split("").reduce((acc, x) => {
  const v = x.charCodeAt(0);
  acc[x] = () => {
    buffer[0] = v;
    b.i = 5;
    return b;
  };
  return acc;
}, {});
var b = Object.assign(reset, messages, {
  N: String.fromCharCode(0),
  i: 0,
  inc(x) {
    b.i += x;
    return b;
  },
  str(x) {
    const length = Buffer.byteLength(x);
    fit(length);
    b.i += buffer.write(x, b.i, length, "utf8");
    return b;
  },
  i16(x) {
    fit(2);
    buffer.writeUInt16BE(x, b.i);
    b.i += 2;
    return b;
  },
  i32(x, i) {
    if (i || i === 0) {
      buffer.writeUInt32BE(x, i);
      return b;
    }
    fit(4);
    buffer.writeUInt32BE(x, b.i);
    b.i += 4;
    return b;
  },
  z(x) {
    fit(x);
    buffer.fill(0, b.i, b.i + x);
    b.i += x;
    return b;
  },
  raw(x) {
    buffer = Buffer.concat([buffer.subarray(0, b.i), x]);
    b.i = buffer.length;
    return b;
  },
  end(at = 1) {
    buffer.writeUInt32BE(b.i - at, at);
    const out = buffer.subarray(0, b.i);
    b.i = 0;
    buffer = Buffer.allocUnsafe(size);
    return out;
  }
});
var bytes_default = b;

// node_modules/postgres/src/connection.js
function Connection(options, queues = {}, { onopen = noop, onend = noop, onclose = noop } = {}) {
  const {
    ssl,
    max,
    user,
    host,
    port,
    database,
    parsers: parsers2,
    transform,
    onnotice,
    onnotify,
    onparameter,
    max_pipeline,
    keep_alive,
    backoff,
    target_session_attrs
  } = options;
  const sent = queue_default(), id = uid++, backend = { pid: null, secret: null }, idleTimer = timer(end, options.idle_timeout), lifeTimer = timer(end, options.max_lifetime), connectTimer = timer(connectTimedOut, options.connect_timeout);
  let socket = null, cancelMessage, result2 = new Result, incoming = Buffer.alloc(0), needsTypes = options.fetch_types, backendParameters = {}, statements = {}, statementId = Math.random().toString(36).slice(2), statementCount = 1, closedDate = 0, remaining = 0, hostIndex = 0, retries = 0, length = 0, delay = 0, rows = 0, serverSignature = null, nextWriteTimer = null, terminated = false, incomings = null, results = null, initial = null, ending = null, stream = null, chunk = null, ended = null, nonce = null, query4 = null, final = null;
  const connection2 = {
    queue: queues.closed,
    idleTimer,
    connect(query5) {
      initial = query5 || true;
      reconnect();
    },
    terminate,
    execute,
    cancel,
    end,
    count: 0,
    id
  };
  queues.closed && queues.closed.push(connection2);
  return connection2;
  async function createSocket() {
    let x;
    try {
      x = options.socket ? await Promise.resolve(options.socket(options)) : new net.Socket;
    } catch (e) {
      error(e);
      return;
    }
    x.on("error", error);
    x.on("close", closed);
    x.on("drain", drain);
    return x;
  }
  async function cancel({ pid, secret }, resolve, reject) {
    try {
      cancelMessage = bytes_default().i32(16).i32(80877102).i32(pid).i32(secret).end(16);
      await connect();
      socket.once("error", reject);
      socket.once("close", resolve);
    } catch (error2) {
      reject(error2);
    }
  }
  function execute(q) {
    if (terminated)
      return queryError(q, Errors.connection("CONNECTION_DESTROYED", options));
    if (q.cancelled)
      return;
    try {
      q.state = backend;
      query4 ? sent.push(q) : (query4 = q, query4.active = true);
      build(q);
      return write(toBuffer(q)) && !q.describeFirst && !q.cursorFn && sent.length < max_pipeline && (!q.options.onexecute || q.options.onexecute(connection2));
    } catch (error2) {
      sent.length === 0 && write(Sync);
      errored(error2);
      return true;
    }
  }
  function toBuffer(q) {
    if (q.parameters.length >= 65534)
      throw Errors.generic("MAX_PARAMETERS_EXCEEDED", "Max number of parameters (65534) exceeded");
    return q.options.simple ? bytes_default().Q().str(q.statement.string + bytes_default.N).end() : q.describeFirst ? Buffer.concat([describe(q), Flush]) : q.prepare ? q.prepared ? prepared(q) : Buffer.concat([describe(q), prepared(q)]) : unnamed(q);
  }
  function describe(q) {
    return Buffer.concat([
      Parse(q.statement.string, q.parameters, q.statement.types, q.statement.name),
      Describe("S", q.statement.name)
    ]);
  }
  function prepared(q) {
    return Buffer.concat([
      Bind(q.parameters, q.statement.types, q.statement.name, q.cursorName),
      q.cursorFn ? Execute("", q.cursorRows) : ExecuteUnnamed
    ]);
  }
  function unnamed(q) {
    return Buffer.concat([
      Parse(q.statement.string, q.parameters, q.statement.types),
      DescribeUnnamed,
      prepared(q)
    ]);
  }
  function build(q) {
    const parameters = [], types3 = [];
    const string = stringify(q, q.strings[0], q.args[0], parameters, types3, options);
    !q.tagged && q.args.forEach((x) => handleValue(x, parameters, types3, options));
    q.prepare = options.prepare && ("prepare" in q.options ? q.options.prepare : true);
    q.string = string;
    q.signature = q.prepare && types3 + string;
    q.onlyDescribe && delete statements[q.signature];
    q.parameters = q.parameters || parameters;
    q.prepared = q.prepare && q.signature in statements;
    q.describeFirst = q.onlyDescribe || parameters.length && !q.prepared;
    q.statement = q.prepared ? statements[q.signature] : { string, types: types3, name: q.prepare ? statementId + statementCount++ : "" };
    typeof options.debug === "function" && options.debug(id, string, parameters, types3);
  }
  function write(x, fn) {
    chunk = chunk ? Buffer.concat([chunk, x]) : Buffer.from(x);
    if (fn || chunk.length >= 1024)
      return nextWrite(fn);
    nextWriteTimer === null && (nextWriteTimer = setImmediate(nextWrite));
    return true;
  }
  function nextWrite(fn) {
    const x = socket.write(chunk, fn);
    nextWriteTimer !== null && clearImmediate(nextWriteTimer);
    chunk = nextWriteTimer = null;
    return x;
  }
  function connectTimedOut() {
    errored(Errors.connection("CONNECT_TIMEOUT", options, socket));
    socket.destroy();
  }
  async function secure() {
    write(SSLRequest);
    const canSSL = await new Promise((r) => socket.once("data", (x) => r(x[0] === 83)));
    if (!canSSL && ssl === "prefer")
      return connected();
    socket.removeAllListeners();
    socket = tls.connect({
      socket,
      servername: net.isIP(socket.host) ? undefined : socket.host,
      ...ssl === "require" || ssl === "allow" || ssl === "prefer" ? { rejectUnauthorized: false } : ssl === "verify-full" ? {} : typeof ssl === "object" ? ssl : {}
    });
    socket.on("secureConnect", connected);
    socket.on("error", error);
    socket.on("close", closed);
    socket.on("drain", drain);
  }
  function drain() {
    !query4 && onopen(connection2);
  }
  function data(x) {
    if (incomings) {
      incomings.push(x);
      remaining -= x.length;
      if (remaining >= 0)
        return;
    }
    incoming = incomings ? Buffer.concat(incomings, length - remaining) : incoming.length === 0 ? x : Buffer.concat([incoming, x], incoming.length + x.length);
    while (incoming.length > 4) {
      length = incoming.readUInt32BE(1);
      if (length >= incoming.length) {
        remaining = length - incoming.length;
        incomings = [incoming];
        break;
      }
      try {
        handle(incoming.subarray(0, length + 1));
      } catch (e) {
        query4 && (query4.cursorFn || query4.describeFirst) && write(Sync);
        errored(e);
      }
      incoming = incoming.subarray(length + 1);
      remaining = 0;
      incomings = null;
    }
  }
  async function connect() {
    terminated = false;
    backendParameters = {};
    socket || (socket = await createSocket());
    if (!socket)
      return;
    connectTimer.start();
    if (options.socket)
      return ssl ? secure() : connected();
    socket.on("connect", ssl ? secure : connected);
    if (options.path)
      return socket.connect(options.path);
    socket.ssl = ssl;
    socket.connect(port[hostIndex], host[hostIndex]);
    socket.host = host[hostIndex];
    socket.port = port[hostIndex];
    hostIndex = (hostIndex + 1) % port.length;
  }
  function reconnect() {
    setTimeout(connect, closedDate ? closedDate + delay - performance.now() : 0);
  }
  function connected() {
    try {
      statements = {};
      needsTypes = options.fetch_types;
      statementId = Math.random().toString(36).slice(2);
      statementCount = 1;
      lifeTimer.start();
      socket.on("data", data);
      keep_alive && socket.setKeepAlive && socket.setKeepAlive(true, 1000 * keep_alive);
      const s = StartupMessage();
      write(s);
    } catch (err) {
      error(err);
    }
  }
  function error(err) {
    if (connection2.queue === queues.connecting && options.host[retries + 1])
      return;
    errored(err);
    while (sent.length)
      queryError(sent.shift(), err);
  }
  function errored(err) {
    stream && (stream.destroy(err), stream = null);
    query4 && queryError(query4, err);
    initial && (queryError(initial, err), initial = null);
  }
  function queryError(query5, err) {
    Object.defineProperties(err, {
      stack: { value: err.stack + query5.origin.replace(/.*\n/, "\n"), enumerable: options.debug },
      query: { value: query5.string, enumerable: options.debug },
      parameters: { value: query5.parameters, enumerable: options.debug },
      args: { value: query5.args, enumerable: options.debug },
      types: { value: query5.statement && query5.statement.types, enumerable: options.debug }
    });
    query5.reject(err);
  }
  function end() {
    return ending || (!connection2.reserved && onend(connection2), !connection2.reserved && !initial && !query4 && sent.length === 0 ? (terminate(), new Promise((r) => socket && socket.readyState !== "closed" ? socket.once("close", r) : r())) : ending = new Promise((r) => ended = r));
  }
  function terminate() {
    terminated = true;
    if (stream || query4 || initial || sent.length)
      error(Errors.connection("CONNECTION_DESTROYED", options));
    clearImmediate(nextWriteTimer);
    if (socket) {
      socket.removeListener("data", data);
      socket.removeListener("connect", connected);
      socket.readyState === "open" && socket.end(bytes_default().X().end());
    }
    ended && (ended(), ending = ended = null);
  }
  async function closed(hadError) {
    incoming = Buffer.alloc(0);
    remaining = 0;
    incomings = null;
    clearImmediate(nextWriteTimer);
    socket.removeListener("data", data);
    socket.removeListener("connect", connected);
    idleTimer.cancel();
    lifeTimer.cancel();
    connectTimer.cancel();
    if (socket.encrypted) {
      socket.removeAllListeners();
      socket = null;
    }
    if (initial)
      return reconnect();
    !hadError && (query4 || sent.length) && error(Errors.connection("CONNECTION_CLOSED", options, socket));
    closedDate = performance.now();
    hadError && options.shared.retries++;
    delay = (typeof backoff === "function" ? backoff(options.shared.retries) : backoff) * 1000;
    onclose(connection2, Errors.connection("CONNECTION_CLOSED", options, socket));
  }
  function handle(xs, x = xs[0]) {
    (x === 68 ? DataRow : x === 100 ? CopyData : x === 65 ? NotificationResponse : x === 83 ? ParameterStatus : x === 90 ? ReadyForQuery : x === 67 ? CommandComplete : x === 50 ? BindComplete : x === 49 ? ParseComplete : x === 116 ? ParameterDescription : x === 84 ? RowDescription : x === 82 ? Authentication : x === 110 ? NoData : x === 75 ? BackendKeyData : x === 69 ? ErrorResponse : x === 115 ? PortalSuspended : x === 51 ? CloseComplete : x === 71 ? CopyInResponse : x === 78 ? NoticeResponse : x === 72 ? CopyOutResponse : x === 99 ? CopyDone : x === 73 ? EmptyQueryResponse : x === 86 ? FunctionCallResponse : x === 118 ? NegotiateProtocolVersion : x === 87 ? CopyBothResponse : UnknownMessage)(xs);
  }
  function DataRow(x) {
    let index2 = 7;
    let length2;
    let column9;
    let value;
    const row = query4.isRaw ? new Array(query4.statement.columns.length) : {};
    for (let i = 0;i < query4.statement.columns.length; i++) {
      column9 = query4.statement.columns[i];
      length2 = x.readInt32BE(index2);
      index2 += 4;
      value = length2 === -1 ? null : query4.isRaw === true ? x.subarray(index2, index2 += length2) : column9.parser === undefined ? x.toString("utf8", index2, index2 += length2) : column9.parser.array === true ? column9.parser(x.toString("utf8", index2 + 1, index2 += length2)) : column9.parser(x.toString("utf8", index2, index2 += length2));
      query4.isRaw ? row[i] = query4.isRaw === true ? value : transform.value.from ? transform.value.from(value, column9) : value : row[column9.name] = transform.value.from ? transform.value.from(value, column9) : value;
    }
    query4.forEachFn ? query4.forEachFn(transform.row.from ? transform.row.from(row) : row, result2) : result2[rows++] = transform.row.from ? transform.row.from(row) : row;
  }
  function ParameterStatus(x) {
    const [k, v] = x.toString("utf8", 5, x.length - 1).split(bytes_default.N);
    backendParameters[k] = v;
    if (options.parameters[k] !== v) {
      options.parameters[k] = v;
      onparameter && onparameter(k, v);
    }
  }
  function ReadyForQuery(x) {
    query4 && query4.options.simple && query4.resolve(results || result2);
    query4 = results = null;
    result2 = new Result;
    connectTimer.cancel();
    if (initial) {
      if (target_session_attrs) {
        if (!backendParameters.in_hot_standby || !backendParameters.default_transaction_read_only)
          return fetchState();
        else if (tryNext(target_session_attrs, backendParameters))
          return terminate();
      }
      if (needsTypes) {
        initial === true && (initial = null);
        return fetchArrayTypes();
      }
      initial !== true && execute(initial);
      options.shared.retries = retries = 0;
      initial = null;
      return;
    }
    while (sent.length && (query4 = sent.shift()) && (query4.active = true, query4.cancelled))
      Connection(options).cancel(query4.state, query4.cancelled.resolve, query4.cancelled.reject);
    if (query4)
      return;
    connection2.reserved ? !connection2.reserved.release && x[5] === 73 ? ending ? terminate() : (connection2.reserved = null, onopen(connection2)) : connection2.reserved() : ending ? terminate() : onopen(connection2);
  }
  function CommandComplete(x) {
    rows = 0;
    for (let i = x.length - 1;i > 0; i--) {
      if (x[i] === 32 && x[i + 1] < 58 && result2.count === null)
        result2.count = +x.toString("utf8", i + 1, x.length - 1);
      if (x[i - 1] >= 65) {
        result2.command = x.toString("utf8", 5, i);
        result2.state = backend;
        break;
      }
    }
    final && (final(), final = null);
    if (result2.command === "BEGIN" && max !== 1 && !connection2.reserved)
      return errored(Errors.generic("UNSAFE_TRANSACTION", "Only use sql.begin, sql.reserved or max: 1"));
    if (query4.options.simple)
      return BindComplete();
    if (query4.cursorFn) {
      result2.count && query4.cursorFn(result2);
      write(Sync);
    }
    query4.resolve(result2);
  }
  function ParseComplete() {
    query4.parsing = false;
  }
  function BindComplete() {
    !result2.statement && (result2.statement = query4.statement);
    result2.columns = query4.statement.columns;
  }
  function ParameterDescription(x) {
    const length2 = x.readUInt16BE(5);
    for (let i = 0;i < length2; ++i)
      !query4.statement.types[i] && (query4.statement.types[i] = x.readUInt32BE(7 + i * 4));
    query4.prepare && (statements[query4.signature] = query4.statement);
    query4.describeFirst && !query4.onlyDescribe && (write(prepared(query4)), query4.describeFirst = false);
  }
  function RowDescription(x) {
    if (result2.command) {
      results = results || [result2];
      results.push(result2 = new Result);
      result2.count = null;
      query4.statement.columns = null;
    }
    const length2 = x.readUInt16BE(5);
    let index2 = 7;
    let start;
    query4.statement.columns = Array(length2);
    for (let i = 0;i < length2; ++i) {
      start = index2;
      while (x[index2++] !== 0)
        ;
      const table16 = x.readUInt32BE(index2);
      const number = x.readUInt16BE(index2 + 4);
      const type = x.readUInt32BE(index2 + 6);
      query4.statement.columns[i] = {
        name: transform.column.from ? transform.column.from(x.toString("utf8", start, index2 - 1)) : x.toString("utf8", start, index2 - 1),
        parser: parsers2[type],
        table: table16,
        number,
        type
      };
      index2 += 18;
    }
    result2.statement = query4.statement;
    if (query4.onlyDescribe)
      return query4.resolve(query4.statement), write(Sync);
  }
  async function Authentication(x, type = x.readUInt32BE(5)) {
    (type === 3 ? AuthenticationCleartextPassword : type === 5 ? AuthenticationMD5Password : type === 10 ? SASL : type === 11 ? SASLContinue : type === 12 ? SASLFinal : type !== 0 ? UnknownAuth : noop)(x, type);
  }
  async function AuthenticationCleartextPassword() {
    const payload = await Pass();
    write(bytes_default().p().str(payload).z(1).end());
  }
  async function AuthenticationMD5Password(x) {
    const payload = "md5" + await md5(Buffer.concat([
      Buffer.from(await md5(await Pass() + user)),
      x.subarray(9)
    ]));
    write(bytes_default().p().str(payload).z(1).end());
  }
  async function SASL() {
    nonce = (await crypto2.randomBytes(18)).toString("base64");
    bytes_default().p().str("SCRAM-SHA-256" + bytes_default.N);
    const i = bytes_default.i;
    write(bytes_default.inc(4).str("n,,n=*,r=" + nonce).i32(bytes_default.i - i - 4, i).end());
  }
  async function SASLContinue(x) {
    const res = x.toString("utf8", 9).split(",").reduce((acc, x2) => (acc[x2[0]] = x2.slice(2), acc), {});
    const saltedPassword = await crypto2.pbkdf2Sync(await Pass(), Buffer.from(res.s, "base64"), parseInt(res.i), 32, "sha256");
    const clientKey = await hmac(saltedPassword, "Client Key");
    const auth = "n=*,r=" + nonce + "," + "r=" + res.r + ",s=" + res.s + ",i=" + res.i + ",c=biws,r=" + res.r;
    serverSignature = (await hmac(await hmac(saltedPassword, "Server Key"), auth)).toString("base64");
    const payload = "c=biws,r=" + res.r + ",p=" + xor(clientKey, Buffer.from(await hmac(await sha256(clientKey), auth))).toString("base64");
    write(bytes_default().p().str(payload).end());
  }
  function SASLFinal(x) {
    if (x.toString("utf8", 9).split(bytes_default.N, 1)[0].slice(2) === serverSignature)
      return;
    errored(Errors.generic("SASL_SIGNATURE_MISMATCH", "The server did not return the correct signature"));
    socket.destroy();
  }
  function Pass() {
    return Promise.resolve(typeof options.pass === "function" ? options.pass() : options.pass);
  }
  function NoData() {
    result2.statement = query4.statement;
    result2.statement.columns = [];
    if (query4.onlyDescribe)
      return query4.resolve(query4.statement), write(Sync);
  }
  function BackendKeyData(x) {
    backend.pid = x.readUInt32BE(5);
    backend.secret = x.readUInt32BE(9);
  }
  async function fetchArrayTypes() {
    needsTypes = false;
    const types3 = await new Query([`
      select b.oid, b.typarray
      from pg_catalog.pg_type a
      left join pg_catalog.pg_type b on b.oid = a.typelem
      where a.typcategory = 'A'
      group by b.oid, b.typarray
      order by b.oid
    `], [], execute);
    types3.forEach(({ oid, typarray }) => addArrayType(oid, typarray));
  }
  function addArrayType(oid, typarray) {
    if (!!options.parsers[typarray] && !!options.serializers[typarray])
      return;
    const parser = options.parsers[oid];
    options.shared.typeArrayMap[oid] = typarray;
    options.parsers[typarray] = (xs) => arrayParser(xs, parser, typarray);
    options.parsers[typarray].array = true;
    options.serializers[typarray] = (xs) => arraySerializer(xs, options.serializers[oid], options, typarray);
  }
  function tryNext(x, xs) {
    return x === "read-write" && xs.default_transaction_read_only === "on" || x === "read-only" && xs.default_transaction_read_only === "off" || x === "primary" && xs.in_hot_standby === "on" || x === "standby" && xs.in_hot_standby === "off" || x === "prefer-standby" && xs.in_hot_standby === "off" && options.host[retries];
  }
  function fetchState() {
    const query5 = new Query([`
      show transaction_read_only;
      select pg_catalog.pg_is_in_recovery()
    `], [], execute, null, { simple: true });
    query5.resolve = ([[a], [b2]]) => {
      backendParameters.default_transaction_read_only = a.transaction_read_only;
      backendParameters.in_hot_standby = b2.pg_is_in_recovery ? "on" : "off";
    };
    query5.execute();
  }
  function ErrorResponse(x) {
    query4 && (query4.cursorFn || query4.describeFirst) && write(Sync);
    const error2 = Errors.postgres(parseError(x));
    query4 && query4.retried ? errored(query4.retried) : query4 && retryRoutines.has(error2.routine) ? retry(query4, error2) : errored(error2);
  }
  function retry(q, error2) {
    delete statements[q.signature];
    q.retried = error2;
    execute(q);
  }
  function NotificationResponse(x) {
    if (!onnotify)
      return;
    let index2 = 9;
    while (x[index2++] !== 0)
      ;
    onnotify(x.toString("utf8", 9, index2 - 1), x.toString("utf8", index2, x.length - 1));
  }
  async function PortalSuspended() {
    try {
      const x = await Promise.resolve(query4.cursorFn(result2));
      rows = 0;
      x === CLOSE ? write(Close(query4.portal)) : (result2 = new Result, write(Execute("", query4.cursorRows)));
    } catch (err) {
      write(Sync);
      query4.reject(err);
    }
  }
  function CloseComplete() {
    result2.count && query4.cursorFn(result2);
    query4.resolve(result2);
  }
  function CopyInResponse() {
    stream = new Stream.Writable({
      autoDestroy: true,
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error2, callback) {
        callback(error2);
        socket.write(bytes_default().f().str(error2 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query4.resolve(stream);
  }
  function CopyOutResponse() {
    stream = new Stream.Readable({
      read() {
        socket.resume();
      }
    });
    query4.resolve(stream);
  }
  function CopyBothResponse() {
    stream = new Stream.Duplex({
      autoDestroy: true,
      read() {
        socket.resume();
      },
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error2, callback) {
        callback(error2);
        socket.write(bytes_default().f().str(error2 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query4.resolve(stream);
  }
  function CopyData(x) {
    stream && (stream.push(x.subarray(5)) || socket.pause());
  }
  function CopyDone() {
    stream && stream.push(null);
    stream = null;
  }
  function NoticeResponse(x) {
    onnotice ? onnotice(parseError(x)) : console.log(parseError(x));
  }
  function EmptyQueryResponse() {
  }
  function FunctionCallResponse() {
    errored(Errors.notSupported("FunctionCallResponse"));
  }
  function NegotiateProtocolVersion() {
    errored(Errors.notSupported("NegotiateProtocolVersion"));
  }
  function UnknownMessage(x) {
    console.error("Postgres.js : Unknown Message:", x[0]);
  }
  function UnknownAuth(x, type) {
    console.error("Postgres.js : Unknown Auth:", type);
  }
  function Bind(parameters, types3, statement = "", portal = "") {
    let prev, type;
    bytes_default().B().str(portal + bytes_default.N).str(statement + bytes_default.N).i16(0).i16(parameters.length);
    parameters.forEach((x, i) => {
      if (x === null)
        return bytes_default.i32(4294967295);
      type = types3[i];
      parameters[i] = x = type in options.serializers ? options.serializers[type](x) : "" + x;
      prev = bytes_default.i;
      bytes_default.inc(4).str(x).i32(bytes_default.i - prev - 4, prev);
    });
    bytes_default.i16(0);
    return bytes_default.end();
  }
  function Parse(str, parameters, types3, name = "") {
    bytes_default().P().str(name + bytes_default.N).str(str + bytes_default.N).i16(parameters.length);
    parameters.forEach((x, i) => bytes_default.i32(types3[i] || 0));
    return bytes_default.end();
  }
  function Describe(x, name = "") {
    return bytes_default().D().str(x).str(name + bytes_default.N).end();
  }
  function Execute(portal = "", rows2 = 0) {
    return Buffer.concat([
      bytes_default().E().str(portal + bytes_default.N).i32(rows2).end(),
      Flush
    ]);
  }
  function Close(portal = "") {
    return Buffer.concat([
      bytes_default().C().str("P").str(portal + bytes_default.N).end(),
      bytes_default().S().end()
    ]);
  }
  function StartupMessage() {
    return cancelMessage || bytes_default().inc(4).i16(3).z(2).str(Object.entries(Object.assign({
      user,
      database,
      client_encoding: "UTF8"
    }, options.connection)).filter(([, v]) => v).map(([k, v]) => k + bytes_default.N + v).join(bytes_default.N)).z(2).end(0);
  }
}
function parseError(x) {
  const error = {};
  let start = 5;
  for (let i = 5;i < x.length - 1; i++) {
    if (x[i] === 0) {
      error[errorFields[x[start]]] = x.toString("utf8", start + 1, i);
      start = i + 1;
    }
  }
  return error;
}
function md5(x) {
  return crypto2.createHash("md5").update(x).digest("hex");
}
function hmac(key, x) {
  return crypto2.createHmac("sha256", key).update(x).digest();
}
function sha256(x) {
  return crypto2.createHash("sha256").update(x).digest();
}
function xor(a, b2) {
  const length = Math.max(a.length, b2.length);
  const buffer2 = Buffer.allocUnsafe(length);
  for (let i = 0;i < length; i++)
    buffer2[i] = a[i] ^ b2[i];
  return buffer2;
}
function timer(fn, seconds) {
  seconds = typeof seconds === "function" ? seconds() : seconds;
  if (!seconds)
    return { cancel: noop, start: noop };
  let timer2;
  return {
    cancel() {
      timer2 && (clearTimeout(timer2), timer2 = null);
    },
    start() {
      timer2 && clearTimeout(timer2);
      timer2 = setTimeout(done, seconds * 1000, arguments);
    }
  };
  function done(args) {
    fn.apply(null, args);
    timer2 = null;
  }
}
var connection_default = Connection;
var uid = 1;
var Sync = bytes_default().S().end();
var Flush = bytes_default().H().end();
var SSLRequest = bytes_default().i32(8).i32(80877103).end(8);
var ExecuteUnnamed = Buffer.concat([bytes_default().E().str(bytes_default.N).i32(0).end(), Sync]);
var DescribeUnnamed = bytes_default().D().str("S").str(bytes_default.N).end();
var noop = () => {
};
var retryRoutines = new Set([
  "FetchPreparedStatement",
  "RevalidateCachedQuery",
  "transformAssignedExpr"
]);
var errorFields = {
  83: "severity_local",
  86: "severity",
  67: "code",
  77: "message",
  68: "detail",
  72: "hint",
  80: "position",
  112: "internal_position",
  113: "internal_query",
  87: "where",
  115: "schema_name",
  116: "table_name",
  99: "column_name",
  100: "data type_name",
  110: "constraint_name",
  70: "file",
  76: "line",
  82: "routine"
};

// node_modules/postgres/src/subscribe.js
function Time(x) {
  return new Date(Date.UTC(2000, 0, 1) + Number(x / BigInt(1000)));
}
function parse(x, state, parsers2, handle, transform) {
  const char = (acc, [k, v]) => (acc[k.charCodeAt(0)] = v, acc);
  Object.entries({
    R: (x2) => {
      let i = 1;
      const r = state[x2.readUInt32BE(i)] = {
        schema: x2.toString("utf8", i += 4, i = x2.indexOf(0, i)) || "pg_catalog",
        table: x2.toString("utf8", i + 1, i = x2.indexOf(0, i + 1)),
        columns: Array(x2.readUInt16BE(i += 2)),
        keys: []
      };
      i += 2;
      let columnIndex = 0, column9;
      while (i < x2.length) {
        column9 = r.columns[columnIndex++] = {
          key: x2[i++],
          name: transform.column.from ? transform.column.from(x2.toString("utf8", i, i = x2.indexOf(0, i))) : x2.toString("utf8", i, i = x2.indexOf(0, i)),
          type: x2.readUInt32BE(i += 1),
          parser: parsers2[x2.readUInt32BE(i)],
          atttypmod: x2.readUInt32BE(i += 4)
        };
        column9.key && r.keys.push(column9);
        i += 4;
      }
    },
    Y: () => {
    },
    O: () => {
    },
    B: (x2) => {
      state.date = Time(x2.readBigInt64BE(9));
      state.lsn = x2.subarray(1, 9);
    },
    I: (x2) => {
      let i = 1;
      const relation = state[x2.readUInt32BE(i)];
      const { row } = tuples(x2, relation.columns, i += 7, transform);
      handle(row, {
        command: "insert",
        relation
      });
    },
    D: (x2) => {
      let i = 1;
      const relation = state[x2.readUInt32BE(i)];
      i += 4;
      const key = x2[i] === 75;
      handle(key || x2[i] === 79 ? tuples(x2, relation.columns, i += 3, transform).row : null, {
        command: "delete",
        relation,
        key
      });
    },
    U: (x2) => {
      let i = 1;
      const relation = state[x2.readUInt32BE(i)];
      i += 4;
      const key = x2[i] === 75;
      const xs = key || x2[i] === 79 ? tuples(x2, relation.columns, i += 3, transform) : null;
      xs && (i = xs.i);
      const { row } = tuples(x2, relation.columns, i + 3, transform);
      handle(row, {
        command: "update",
        relation,
        key,
        old: xs && xs.row
      });
    },
    T: () => {
    },
    C: () => {
    }
  }).reduce(char, {})[x[0]](x);
}
function tuples(x, columns2, xi, transform) {
  let type, column9, value;
  const row = transform.raw ? new Array(columns2.length) : {};
  for (let i = 0;i < columns2.length; i++) {
    type = x[xi++];
    column9 = columns2[i];
    value = type === 110 ? null : type === 117 ? undefined : column9.parser === undefined ? x.toString("utf8", xi + 4, xi += 4 + x.readUInt32BE(xi)) : column9.parser.array === true ? column9.parser(x.toString("utf8", xi + 5, xi += 4 + x.readUInt32BE(xi))) : column9.parser(x.toString("utf8", xi + 4, xi += 4 + x.readUInt32BE(xi)));
    transform.raw ? row[i] = transform.raw === true ? value : transform.value.from ? transform.value.from(value, column9) : value : row[column9.name] = transform.value.from ? transform.value.from(value, column9) : value;
  }
  return { i: xi, row: transform.row.from ? transform.row.from(row) : row };
}
function parseEvent(x) {
  const xs = x.match(/^(\*|insert|update|delete)?:?([^.]+?\.?[^=]+)?=?(.+)?/i) || [];
  if (!xs)
    throw new Error("Malformed subscribe pattern: " + x);
  const [, command, path, key] = xs;
  return (command || "*") + (path ? ":" + (path.indexOf(".") === -1 ? "public." + path : path) : "") + (key ? "=" + key : "");
}
var noop2 = () => {
};
function Subscribe(postgres2, options) {
  const subscribers = new Map, slot = "postgresjs_" + Math.random().toString(36).slice(2), state = {};
  let connection2, stream, ended = false;
  const sql17 = subscribe.sql = postgres2({
    ...options,
    transform: { column: {}, value: {}, row: {} },
    max: 1,
    fetch_types: false,
    idle_timeout: null,
    max_lifetime: null,
    connection: {
      ...options.connection,
      replication: "database"
    },
    onclose: async function() {
      if (ended)
        return;
      stream = null;
      state.pid = state.secret = undefined;
      connected(await init2(sql17, slot, options.publications));
      subscribers.forEach((event) => event.forEach(({ onsubscribe }) => onsubscribe()));
    },
    no_subscribe: true
  });
  const { end, close } = sql17;
  sql17.end = async () => {
    ended = true;
    stream && await new Promise((r) => (stream.once("close", r), stream.end()));
    return end();
  };
  sql17.close = async () => {
    stream && await new Promise((r) => (stream.once("close", r), stream.end()));
    return close();
  };
  return subscribe;
  async function subscribe(event, fn, onsubscribe = noop2) {
    event = parseEvent(event);
    if (!connection2)
      connection2 = init2(sql17, slot, options.publications);
    const subscriber = { fn, onsubscribe };
    const fns = subscribers.has(event) ? subscribers.get(event).add(subscriber) : subscribers.set(event, new Set([subscriber])).get(event);
    const unsubscribe = () => {
      fns.delete(subscriber);
      fns.size === 0 && subscribers.delete(event);
    };
    return connection2.then((x) => {
      connected(x);
      onsubscribe();
      return { unsubscribe, state, sql: sql17 };
    });
  }
  function connected(x) {
    stream = x.stream;
    state.pid = x.state.pid;
    state.secret = x.state.secret;
  }
  async function init2(sql18, slot2, publications) {
    if (!publications)
      throw new Error("Missing publication names");
    const xs = await sql18.unsafe(`CREATE_REPLICATION_SLOT ${slot2} TEMPORARY LOGICAL pgoutput NOEXPORT_SNAPSHOT`);
    const [x] = xs;
    const stream2 = await sql18.unsafe(`START_REPLICATION SLOT ${slot2} LOGICAL ${x.consistent_point} (proto_version '1', publication_names '${publications}')`).writable();
    const state2 = {
      lsn: Buffer.concat(x.consistent_point.split("/").map((x2) => Buffer.from(("00000000" + x2).slice(-8), "hex")))
    };
    stream2.on("data", data);
    stream2.on("error", error);
    stream2.on("close", sql18.close);
    return { stream: stream2, state: xs.state };
    function error(e) {
      console.error("Unexpected error during logical streaming - reconnecting", e);
    }
    function data(x2) {
      if (x2[0] === 119)
        parse(x2.subarray(25), state2, sql18.options.parsers, handle, options.transform);
      else if (x2[0] === 107 && x2[17])
        pong();
    }
    function handle(a, b2) {
      const path = b2.relation.schema + "." + b2.relation.table;
      call("*", a, b2);
      call("*:" + path, a, b2);
      b2.relation.keys.length && call("*:" + path + "=" + b2.relation.keys.map((x2) => a[x2.name]), a, b2);
      call(b2.command, a, b2);
      call(b2.command + ":" + path, a, b2);
      b2.relation.keys.length && call(b2.command + ":" + path + "=" + b2.relation.keys.map((x2) => a[x2.name]), a, b2);
    }
    function pong() {
      const x2 = Buffer.alloc(34);
      x2[0] = "r".charCodeAt(0);
      x2.fill(state2.lsn, 1);
      x2.writeBigInt64BE(BigInt(Date.now() - Date.UTC(2000, 0, 1)) * BigInt(1000), 25);
      stream2.write(x2);
    }
  }
  function call(x, a, b2) {
    subscribers.has(x) && subscribers.get(x).forEach(({ fn }) => fn(a, b2, x));
  }
}

// node_modules/postgres/src/large.js
import Stream2 from "stream";
function largeObject(sql17, oid, mode = 131072 | 262144) {
  return new Promise(async (resolve, reject) => {
    await sql17.begin(async (sql18) => {
      let finish;
      !oid && ([{ oid }] = await sql18`select lo_creat(-1) as oid`);
      const [{ fd }] = await sql18`select lo_open(${oid}, ${mode}) as fd`;
      const lo = {
        writable,
        readable,
        close: () => sql18`select lo_close(${fd})`.then(finish),
        tell: () => sql18`select lo_tell64(${fd})`,
        read: (x) => sql18`select loread(${fd}, ${x}) as data`,
        write: (x) => sql18`select lowrite(${fd}, ${x})`,
        truncate: (x) => sql18`select lo_truncate64(${fd}, ${x})`,
        seek: (x, whence = 0) => sql18`select lo_lseek64(${fd}, ${x}, ${whence})`,
        size: () => sql18`
          select
            lo_lseek64(${fd}, location, 0) as position,
            seek.size
          from (
            select
              lo_lseek64($1, 0, 2) as size,
              tell.location
            from (select lo_tell64($1) as location) tell
          ) seek
        `
      };
      resolve(lo);
      return new Promise(async (r) => finish = r);
      async function readable({
        highWaterMark = 2048 * 8,
        start = 0,
        end = Infinity
      } = {}) {
        let max = end - start;
        start && await lo.seek(start);
        return new Stream2.Readable({
          highWaterMark,
          async read(size2) {
            const l = size2 > max ? size2 - max : size2;
            max -= size2;
            const [{ data }] = await lo.read(l);
            this.push(data);
            if (data.length < size2)
              this.push(null);
          }
        });
      }
      async function writable({
        highWaterMark = 2048 * 8,
        start = 0
      } = {}) {
        start && await lo.seek(start);
        return new Stream2.Writable({
          highWaterMark,
          write(chunk, encoding, callback) {
            lo.write(chunk).then(() => callback(), callback);
          }
        });
      }
    }).catch(reject);
  });
}

// node_modules/postgres/src/index.js
function Postgres(a, b2) {
  const options = parseOptions(a, b2), subscribe2 = options.no_subscribe || Subscribe(Postgres, { ...options });
  let ending = false;
  const queries = queue_default(), connecting = queue_default(), reserved = queue_default(), closed = queue_default(), ended = queue_default(), open = queue_default(), busy = queue_default(), full = queue_default(), queues = { connecting, reserved, closed, ended, open, busy, full };
  const connections = [...Array(options.max)].map(() => connection_default(options, queues, { onopen, onend, onclose }));
  const sql17 = Sql(handler);
  Object.assign(sql17, {
    get parameters() {
      return options.parameters;
    },
    largeObject: largeObject.bind(null, sql17),
    subscribe: subscribe2,
    CLOSE,
    END: CLOSE,
    PostgresError,
    options,
    reserve,
    listen,
    begin,
    close,
    end
  });
  return sql17;
  function Sql(handler2) {
    handler2.debug = options.debug;
    Object.entries(options.types).reduce((acc, [name, type]) => {
      acc[name] = (x) => new Parameter(x, type.to);
      return acc;
    }, typed);
    Object.assign(sql18, {
      types: typed,
      typed,
      unsafe,
      notify,
      array: array2,
      json,
      file
    });
    return sql18;
    function typed(value, type) {
      return new Parameter(value, type);
    }
    function sql18(strings, ...args) {
      const query5 = strings && Array.isArray(strings.raw) ? new Query(strings, args, handler2, cancel) : typeof strings === "string" && !args.length ? new Identifier(options.transform.column.to ? options.transform.column.to(strings) : strings) : new Builder(strings, args);
      return query5;
    }
    function unsafe(string, args = [], options2 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options2 = args, args = []);
      const query5 = new Query([string], args, handler2, cancel, {
        prepare: false,
        ...options2,
        simple: "simple" in options2 ? options2.simple : args.length === 0
      });
      return query5;
    }
    function file(path, args = [], options2 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options2 = args, args = []);
      const query5 = new Query([], args, (query6) => {
        fs.readFile(path, "utf8", (err, string) => {
          if (err)
            return query6.reject(err);
          query6.strings = [string];
          handler2(query6);
        });
      }, cancel, {
        ...options2,
        simple: "simple" in options2 ? options2.simple : args.length === 0
      });
      return query5;
    }
  }
  async function listen(name, fn, onlisten) {
    const listener = { fn, onlisten };
    const sql18 = listen.sql || (listen.sql = Postgres({
      ...options,
      max: 1,
      idle_timeout: null,
      max_lifetime: null,
      fetch_types: false,
      onclose() {
        Object.entries(listen.channels).forEach(([name2, { listeners }]) => {
          delete listen.channels[name2];
          Promise.all(listeners.map((l) => listen(name2, l.fn, l.onlisten).catch(() => {
          })));
        });
      },
      onnotify(c, x) {
        c in listen.channels && listen.channels[c].listeners.forEach((l) => l.fn(x));
      }
    }));
    const channels = listen.channels || (listen.channels = {}), exists2 = name in channels;
    if (exists2) {
      channels[name].listeners.push(listener);
      const result3 = await channels[name].result;
      listener.onlisten && listener.onlisten();
      return { state: result3.state, unlisten };
    }
    channels[name] = { result: sql18`listen ${sql18.unsafe('"' + name.replace(/"/g, '""') + '"')}`, listeners: [listener] };
    const result2 = await channels[name].result;
    listener.onlisten && listener.onlisten();
    return { state: result2.state, unlisten };
    async function unlisten() {
      if (name in channels === false)
        return;
      channels[name].listeners = channels[name].listeners.filter((x) => x !== listener);
      if (channels[name].listeners.length)
        return;
      delete channels[name];
      return sql18`unlisten ${sql18.unsafe('"' + name.replace(/"/g, '""') + '"')}`;
    }
  }
  async function notify(channel, payload) {
    return await sql17`select pg_notify(${channel}, ${"" + payload})`;
  }
  async function reserve() {
    const queue3 = queue_default();
    const c = open.length ? open.shift() : await new Promise((r) => {
      queries.push({ reserve: r });
      closed.length && connect(closed.shift());
    });
    move(c, reserved);
    c.reserved = () => queue3.length ? c.execute(queue3.shift()) : move(c, reserved);
    c.reserved.release = true;
    const sql18 = Sql(handler2);
    sql18.release = () => {
      c.reserved = null;
      onopen(c);
    };
    return sql18;
    function handler2(q) {
      c.queue === full ? queue3.push(q) : c.execute(q) || move(c, full);
    }
  }
  async function begin(options2, fn) {
    !fn && (fn = options2, options2 = "");
    const queries2 = queue_default();
    let savepoints = 0, connection3, prepare = null;
    try {
      await sql17.unsafe("begin " + options2.replace(/[^a-z ]/ig, ""), [], { onexecute }).execute();
      return await Promise.race([
        scope(connection3, fn),
        new Promise((_, reject) => connection3.onclose = reject)
      ]);
    } catch (error) {
      throw error;
    }
    async function scope(c, fn2, name) {
      const sql18 = Sql(handler2);
      sql18.savepoint = savepoint;
      sql18.prepare = (x) => prepare = x.replace(/[^a-z0-9$-_. ]/gi);
      let uncaughtError, result2;
      name && await sql18`savepoint ${sql18(name)}`;
      try {
        result2 = await new Promise((resolve, reject) => {
          const x = fn2(sql18);
          Promise.resolve(Array.isArray(x) ? Promise.all(x) : x).then(resolve, reject);
        });
        if (uncaughtError)
          throw uncaughtError;
      } catch (e) {
        await (name ? sql18`rollback to ${sql18(name)}` : sql18`rollback`);
        throw e instanceof PostgresError && e.code === "25P02" && uncaughtError || e;
      }
      if (!name) {
        prepare ? await sql18`prepare transaction '${sql18.unsafe(prepare)}'` : await sql18`commit`;
      }
      return result2;
      function savepoint(name2, fn3) {
        if (name2 && Array.isArray(name2.raw))
          return savepoint((sql19) => sql19.apply(sql19, arguments));
        arguments.length === 1 && (fn3 = name2, name2 = null);
        return scope(c, fn3, "s" + savepoints++ + (name2 ? "_" + name2 : ""));
      }
      function handler2(q) {
        q.catch((e) => uncaughtError || (uncaughtError = e));
        c.queue === full ? queries2.push(q) : c.execute(q) || move(c, full);
      }
    }
    function onexecute(c) {
      connection3 = c;
      move(c, reserved);
      c.reserved = () => queries2.length ? c.execute(queries2.shift()) : move(c, reserved);
    }
  }
  function move(c, queue3) {
    c.queue.remove(c);
    queue3.push(c);
    c.queue = queue3;
    queue3 === open ? c.idleTimer.start() : c.idleTimer.cancel();
    return c;
  }
  function json(x) {
    return new Parameter(x, 3802);
  }
  function array2(x, type) {
    if (!Array.isArray(x))
      return array2(Array.from(arguments));
    return new Parameter(x, type || (x.length ? inferType(x) || 25 : 0), options.shared.typeArrayMap);
  }
  function handler(query5) {
    if (ending)
      return query5.reject(Errors.connection("CONNECTION_ENDED", options, options));
    if (open.length)
      return go(open.shift(), query5);
    if (closed.length)
      return connect(closed.shift(), query5);
    busy.length ? go(busy.shift(), query5) : queries.push(query5);
  }
  function go(c, query5) {
    return c.execute(query5) ? move(c, busy) : move(c, full);
  }
  function cancel(query5) {
    return new Promise((resolve, reject) => {
      query5.state ? query5.active ? connection_default(options).cancel(query5.state, resolve, reject) : query5.cancelled = { resolve, reject } : (queries.remove(query5), query5.cancelled = true, query5.reject(Errors.generic("57014", "canceling statement due to user request")), resolve());
    });
  }
  async function end({ timeout = null } = {}) {
    if (ending)
      return ending;
    await 1;
    let timer2;
    return ending = Promise.race([
      new Promise((r) => timeout !== null && (timer2 = setTimeout(destroy, timeout * 1000, r))),
      Promise.all(connections.map((c) => c.end()).concat(listen.sql ? listen.sql.end({ timeout: 0 }) : [], subscribe2.sql ? subscribe2.sql.end({ timeout: 0 }) : []))
    ]).then(() => clearTimeout(timer2));
  }
  async function close() {
    await Promise.all(connections.map((c) => c.end()));
  }
  async function destroy(resolve) {
    await Promise.all(connections.map((c) => c.terminate()));
    while (queries.length)
      queries.shift().reject(Errors.connection("CONNECTION_DESTROYED", options));
    resolve();
  }
  function connect(c, query5) {
    move(c, connecting);
    c.connect(query5);
    return c;
  }
  function onend(c) {
    move(c, ended);
  }
  function onopen(c) {
    if (queries.length === 0)
      return move(c, open);
    let max = Math.ceil(queries.length / (connecting.length + 1)), ready = true;
    while (ready && queries.length && max-- > 0) {
      const query5 = queries.shift();
      if (query5.reserve)
        return query5.reserve(c);
      ready = c.execute(query5);
    }
    ready ? move(c, busy) : move(c, full);
  }
  function onclose(c, e) {
    move(c, closed);
    c.reserved = null;
    c.onclose && (c.onclose(e), c.onclose = null);
    options.onclose && options.onclose(c.id);
    queries.length && connect(c, queries.shift());
  }
}
function parseOptions(a, b2) {
  if (a && a.shared)
    return a;
  const env = process.env, o = (!a || typeof a === "string" ? b2 : a) || {}, { url, multihost } = parseUrl(a), query5 = [...url.searchParams].reduce((a2, [b3, c]) => (a2[b3] = c, a2), {}), host = o.hostname || o.host || multihost || url.hostname || env.PGHOST || "localhost", port = o.port || url.port || env.PGPORT || 5432, user = o.user || o.username || url.username || env.PGUSERNAME || env.PGUSER || osUsername();
  o.no_prepare && (o.prepare = false);
  query5.sslmode && (query5.ssl = query5.sslmode, delete query5.sslmode);
  "timeout" in o && (console.log("The timeout option is deprecated, use idle_timeout instead"), o.idle_timeout = o.timeout);
  query5.sslrootcert === "system" && (query5.ssl = "verify-full");
  const ints = ["idle_timeout", "connect_timeout", "max_lifetime", "max_pipeline", "backoff", "keep_alive"];
  const defaults = {
    max: 10,
    ssl: false,
    idle_timeout: null,
    connect_timeout: 30,
    max_lifetime,
    max_pipeline: 100,
    backoff,
    keep_alive: 60,
    prepare: true,
    debug: false,
    fetch_types: true,
    publications: "alltables",
    target_session_attrs: null
  };
  return {
    host: Array.isArray(host) ? host : host.split(",").map((x) => x.split(":")[0]),
    port: Array.isArray(port) ? port : host.split(",").map((x) => parseInt(x.split(":")[1] || port)),
    path: o.path || host.indexOf("/") > -1 && host + "/.s.PGSQL." + port,
    database: o.database || o.db || (url.pathname || "").slice(1) || env.PGDATABASE || user,
    user,
    pass: o.pass || o.password || url.password || env.PGPASSWORD || "",
    ...Object.entries(defaults).reduce((acc, [k, d]) => {
      const value = k in o ? o[k] : (k in query5) ? query5[k] === "disable" || query5[k] === "false" ? false : query5[k] : env["PG" + k.toUpperCase()] || d;
      acc[k] = typeof value === "string" && ints.includes(k) ? +value : value;
      return acc;
    }, {}),
    connection: {
      application_name: "postgres.js",
      ...o.connection,
      ...Object.entries(query5).reduce((acc, [k, v]) => ((k in defaults) || (acc[k] = v), acc), {})
    },
    types: o.types || {},
    target_session_attrs: tsa(o, url, env),
    onnotice: o.onnotice,
    onnotify: o.onnotify,
    onclose: o.onclose,
    onparameter: o.onparameter,
    socket: o.socket,
    transform: parseTransform(o.transform || { undefined: undefined }),
    parameters: {},
    shared: { retries: 0, typeArrayMap: {} },
    ...mergeUserTypes(o.types)
  };
}
function tsa(o, url, env) {
  const x = o.target_session_attrs || url.searchParams.get("target_session_attrs") || env.PGTARGETSESSIONATTRS;
  if (!x || ["read-write", "read-only", "primary", "standby", "prefer-standby"].includes(x))
    return x;
  throw new Error("target_session_attrs " + x + " is not supported");
}
function backoff(retries) {
  return (0.5 + Math.random() / 2) * Math.min(3 ** retries / 100, 20);
}
function max_lifetime() {
  return 60 * (30 + Math.random() * 30);
}
function parseTransform(x) {
  return {
    undefined: x.undefined,
    column: {
      from: typeof x.column === "function" ? x.column : x.column && x.column.from,
      to: x.column && x.column.to
    },
    value: {
      from: typeof x.value === "function" ? x.value : x.value && x.value.from,
      to: x.value && x.value.to
    },
    row: {
      from: typeof x.row === "function" ? x.row : x.row && x.row.from,
      to: x.row && x.row.to
    }
  };
}
function parseUrl(url) {
  if (!url || typeof url !== "string")
    return { url: { searchParams: new Map } };
  let host = url;
  host = host.slice(host.indexOf("://") + 3).split(/[?/]/)[0];
  host = decodeURIComponent(host.slice(host.indexOf("@") + 1));
  const urlObj = new URL(url.replace(host, host.split(",")[0]));
  return {
    url: {
      username: decodeURIComponent(urlObj.username),
      password: decodeURIComponent(urlObj.password),
      host: urlObj.host,
      hostname: urlObj.hostname,
      port: urlObj.port,
      pathname: urlObj.pathname,
      searchParams: urlObj.searchParams
    },
    multihost: host.indexOf(",") > -1 && host
  };
}
function osUsername() {
  try {
    return os.userInfo().username;
  } catch (_) {
    return process.env.USERNAME || process.env.USER || process.env.LOGNAME;
  }
}
Object.assign(Postgres, {
  PostgresError,
  toPascal,
  pascal,
  toCamel,
  camel,
  toKebab,
  kebab,
  fromPascal,
  fromCamel,
  fromKebab,
  BigInt: {
    to: 20,
    from: [20],
    parse: (x) => BigInt(x),
    serialize: (x) => x.toString()
  }
});
var src_default = Postgres;

// node_modules/zod/lib/index.mjs
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap)
    return { errorMap, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== undefined ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== undefined ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
function isValidIP(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a, b2) {
  const aType = getParsedType(a);
  const bType = getParsedType(b2);
  if (a === b2) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0;index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b2[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b2) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values2, params) {
  return new ZodEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result2) => {
  if (isValid(result2)) {
    return { success: true, data: result2.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};

class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result2 = this._parse(input);
    if (isAsync(result2)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result2;
  }
  _parseAsync(input) {
    const result2 = this._parse(input);
    return Promise.resolve(result2);
  }
  parse(data, params) {
    const result2 = this.safeParse(data, params);
    if (result2.success)
      return result2.data;
    throw result2.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === undefined ? undefined : params.async) !== null && _a !== undefined ? _a : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result2 = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result2);
  }
  async parseAsync(data, params) {
    const result2 = await this.safeParseAsync(data, params);
    if (result2.success)
      return result2.data;
    throw result2.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result2 = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result2);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result2 = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result2 instanceof Promise) {
        return result2.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result2) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+\$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z\$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z\$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z\$`);
    }
  }
};

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      offset: (_a = options === null || options === undefined ? undefined : options.offset) !== null && _a !== undefined ? _a : false,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === undefined ? undefined : options.position,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result3) => {
        return ParseStatus.mergeArray(status, result3);
      });
    }
    const result2 = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result2);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === undefined ? undefined : _b.call(_a, issue, ctx).message) !== null && _c !== undefined ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result2 of results) {
        if (result2.result.status === "valid") {
          return result2.result;
        }
      }
      for (const result2 of results) {
        if (result2.result.status === "dirty") {
          ctx.common.issues.push(...result2.ctx.common.issues);
          return result2.result;
        }
      }
      const unionErrors = results.map((result2) => new ZodError(result2.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result2 = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result2.status === "valid") {
          return result2;
        } else if (result2.status === "dirty" && !dirty) {
          dirty = { result: result2, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types4, params) => {
  return new ZodUnion({
    options: types4,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result2 = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result2, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result2, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result2 = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result2, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result2, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values2) {
    return ZodEnum.create(values2);
  }
  exclude(values2) {
    return ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values2, params) => {
  return new ZodNativeEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result2 = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result2);
        }
        if (result2 instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result2 = effect.transform(base.value, checkCtx);
        if (result2 instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result2 };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result2) => ({ status: status.value, value: result2 }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};

class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result2 = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result2)) {
      return result2.then((result3) => {
        return {
          status: "valid",
          value: result3.status === "valid" ? result3.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result2.status === "valid" ? result2.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b2) {
    return new ZodPipeline({
      in: a,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result2 = this._def.innerType._parse(input);
    if (isValid(result2)) {
      result2.value = Object.freeze(result2.value);
    }
    return result2;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== undefined ? _a : fatal) !== null && _b !== undefined ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// src/env.ts
var envSchema = z.object({
  API_BASE_URL: z.string().url(),
  AUTH_REDIRECT_URL: z.string().url(),
  DB_URL: z.string().url().min(1),
  JWT_SECRET_KEY: z.string().min(1),
  RESEND_API_KEY: z.string().optional(),
  SMTP_HOST: z.string(),
  SMTP_PORT: z.coerce.number(),
  SMTP_USER: z.string().email(),
  SMTP_PASS: z.string()
});
var env = envSchema.parse(process.env);

// src/db/connection.ts
var client = src_default(env.DB_URL);
var db3 = drizzle(client, { schema: exports_schema });

// src/http/routes/register-restaurant.ts
var import_elysia = __toESM(require_cjs2(), 1);
var appa = new import_elysia.default();  
var registerRestaurant = appa.post("/restaurants", async ({ body, set }) => {
  const { restaurantName, managerName, email, phone } = body;
  const [manager] = await db3.insert(users).values({
    name: managerName,
    email,
    phone,
    role: "manager"
  }).returning();
  await db3.insert(restaurants).values({
    name: restaurantName,
    managerId: manager.id
  });
  set.status = 204;
}, {
  body: import_elysia.t.Object({
    restaurantName: import_elysia.t.String(),
    managerName: import_elysia.t.String(),
    phone: import_elysia.t.String(),
    email: import_elysia.t.String({ format: "email" })
  })
});

// src/http/routes/register-customer.ts
var import_elysia2 = __toESM(require_cjs2(), 1);
var registerCustomerBodySchema = z.object({
  name: z.string().min(1),
  phone: z.string(),
  email: z.string().email()
});
var registerCustomer = new import_elysia2.default().post("/customers", async ({ body, set }) => {
  const { name, phone, email } = registerCustomerBodySchema.parse(body);
  await db3.insert(users).values({
    name,
    email,
    phone
  });
  set.status = 401;
});

// src/http/routes/send-authentication-link.tsx
var import_elysia3 = __toESM(require_cjs2(), 1);

// src/http/routes/errors/unauthorized-error.ts
class UnauthorizedError extends Error {
  constructor() {
    super("Unauthorized.");
  }
}

// src/mail/client.ts
var import_nodemailer = __toESM(require_nodemailer(), 1);
var transporter = import_nodemailer.default.createTransport({
  host: process.env.SMTP_HOST,
  port: process.env.SMTP_PORT,
  secure: false,
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS
  },
  family: 4
});

// src/utils/time.ts
var minutes = (n) => n * 60 * 1000;

// node_modules/@react-email/render/dist/node/index.mjs
var import_react = __toESM(require_react(), 1);

// node_modules/@react-email/render/node_modules/prettier/plugins/html.mjs
var exports_html = {};
__export(exports_html, {
  printers: () => uu,
  parsers: () => tn,
  options: () => Us,
  languages: () => Hs,
  default: () => ym
});
function yi(t2) {
  if (typeof t2 == "string")
    return we;
  if (Array.isArray(t2))
    return ze;
  if (!t2)
    return;
  let { type: e } = t2;
  if (Dt.has(e))
    return e;
}
function bi(t2) {
  let e = t2 === null ? "null" : typeof t2;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (Fe(t2))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t2);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let n = wi([...Dt].map((s) => `'${s}'`));
  return `Unexpected doc.type '${t2.type}'.
Expected it to be ${n}.`;
}
function hr(t2, e) {
  if (typeof t2 == "string")
    return e(t2);
  let r = new Map;
  return n(t2);
  function n(i) {
    if (r.has(i))
      return r.get(i);
    let a = s(i);
    return r.set(i, a), a;
  }
  function s(i) {
    switch (Fe(i)) {
      case ze:
        return e(i.map(n));
      case ke:
        return e({ ...i, parts: i.parts.map(n) });
      case ce:
        return e({ ...i, breakContents: n(i.breakContents), flatContents: n(i.flatContents) });
      case xe: {
        let { expandedStates: a, contents: o } = i;
        return a ? (a = a.map(n), o = a[0]) : o = n(o), e({ ...i, contents: o, expandedStates: a });
      }
      case Te:
      case be:
      case Be:
      case Qe:
      case Ke:
        return e({ ...i, contents: n(i.contents) });
      case we:
      case Ye:
      case je:
      case Xe:
      case j:
      case Le:
        return e(i);
      default:
        throw new pr(i);
    }
  }
}
function B(t2, e = hn) {
  return hr(t2, (r) => typeof r == "string" ? H(e, r.split(`
`)) : r);
}
function k(t2) {
  return re(t2), { type: be, contents: t2 };
}
function fn(t2, e) {
  return re(e), { type: Te, contents: e, n: t2 };
}
function E(t2, e = {}) {
  return re(t2), fr(e.expandedStates, true), { type: xe, id: e.id, contents: t2, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function dn(t2) {
  return fn(Number.NEGATIVE_INFINITY, t2);
}
function gn(t2) {
  return fn({ type: "root" }, t2);
}
function vt(t2) {
  return mn(t2), { type: ke, parts: t2 };
}
function pe(t2, e = "", r = {}) {
  return re(t2), e !== "" && re(e), { type: ce, breakContents: t2, flatContents: e, groupId: r.groupId };
}
function Cn(t2, e) {
  return re(t2), { type: Be, contents: t2, groupId: e.groupId, negate: e.negate };
}
function H(t2, e) {
  re(t2), fr(e);
  let r = [];
  for (let n = 0;n < e.length; n++)
    n !== 0 && r.push(t2), r.push(e[n]);
  return r;
}
function Bi(t2, e) {
  let r = e === true || e === yt ? yt : Sn, n = r === yt ? Sn : yt, s = 0, i = 0;
  for (let a of t2)
    a === r ? s++ : a === n && i++;
  return s > i ? n : r;
}
function dr(t2) {
  if (typeof t2 != "string")
    throw new TypeError("Expected a string");
  return t2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Pi(t2) {
  return (t2 == null ? undefined : t2.type) === "front-matter";
}
function Dn(t2, e) {
  var r;
  if (t2.type === "text" || t2.type === "comment" || Pe(t2) || t2.type === "yaml" || t2.type === "toml")
    return null;
  if (t2.type === "attribute" && delete e.value, t2.type === "docType" && delete e.value, t2.type === "angularControlFlowBlock" && ((r = t2.parameters) != null && r.children))
    for (let n of e.parameters.children)
      Ii.has(t2.name) ? delete n.expression : n.expression = n.expression.trim();
  t2.type === "angularIcuExpression" && (e.switchValue = t2.switchValue.trim()), t2.type === "angularLetDeclarationInitializer" && delete e.value;
}
async function Ri(t2, e) {
  if (t2.language === "yaml") {
    let r = t2.value.trim(), n = r ? await e(r, { parser: "yaml" }) : "";
    return gn([t2.startDelimiter, t2.explicitLanguage, S, n, n ? S : "", t2.endDelimiter]);
  }
}
function he(t2, e = true) {
  return [k([v, t2]), e ? v : ""];
}
function X(t2, e) {
  let r = t2.type === "NGRoot" ? t2.node.type === "NGMicrosyntax" && t2.node.body.length === 1 && t2.node.body[0].type === "NGMicrosyntaxExpression" ? t2.node.body[0].expression : t2.node : t2.type === "JsExpressionRoot" ? t2.node : t2;
  return r && (r.type === "ObjectExpression" || r.type === "ArrayExpression" || (e.parser === "__vue_expression" || e.parser === "__vue_ts_expression") && (r.type === "TemplateLiteral" || r.type === "StringLiteral"));
}
async function T(t2, e, r, n) {
  r = { __isInHtmlAttribute: true, __embeddedInHtml: true, ...r };
  let s = true;
  n && (r.__onHtmlBindingRoot = (a, o) => {
    s = n(a, o);
  });
  let i = await e(t2, r, e);
  return s ? E(i) : he(i);
}
function $i(t2, e, r, n) {
  let { node: s } = r, i = n.originalText.slice(s.sourceSpan.start.offset, s.sourceSpan.end.offset);
  return /^\s*$/u.test(i) ? "" : T(i, t2, { parser: "__ng_directive", __isInHtmlAttribute: false }, X);
}
function Mi(t2) {
  return Array.isArray(t2) && t2.length > 0;
}
function Fn(t2) {
  if (t2 = t2 instanceof URL ? t2 : new URL(t2), t2.protocol !== "file:")
    throw new TypeError(`URL must be a file URL: received "${t2.protocol}"`);
  return t2;
}
function Hi(t2) {
  return t2 = Fn(t2), decodeURIComponent(t2.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function Vi(t2) {
  t2 = Fn(t2);
  let e = decodeURIComponent(t2.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  return t2.hostname !== "" && (e = `\\\\${t2.hostname}${e}`), e;
}
function Pn(t2) {
  return qi ? Vi(t2) : Hi(t2);
}
function In(t2, e) {
  if (!e)
    return;
  let r = Ui(e).toLowerCase();
  return t2.find(({ filenames: n }) => n == null ? undefined : n.some((s) => s.toLowerCase() === r)) ?? t2.find(({ extensions: n }) => n == null ? undefined : n.some((s) => r.endsWith(s)));
}
function Wi(t2, e) {
  if (e)
    return t2.find(({ name: r }) => r.toLowerCase() === e) ?? t2.find(({ aliases: r }) => r == null ? undefined : r.includes(e)) ?? t2.find(({ extensions: r }) => r == null ? undefined : r.includes(`.${e}`));
}
function Rn(t2, e) {
  if (e) {
    if (String(e).startsWith("file:"))
      try {
        e = Nn(e);
      } catch {
        return;
      }
    if (typeof e == "string")
      return t2.find(({ isSupported: r }) => r == null ? undefined : r({ filepath: e }));
  }
}
function Gi(t2, e) {
  let r = bn(false, t2.plugins).flatMap((s) => s.languages ?? []), n = Wi(r, e.language) ?? In(r, e.physicalFile) ?? In(r, e.file) ?? Rn(r, e.physicalFile) ?? Rn(r, e.file) ?? (e.physicalFile, undefined);
  return n == null ? undefined : n.parsers[0];
}
function zi(t2) {
  return t2.type === "element" && !t2.hasExplicitNamespace && !["html", "svg"].includes(t2.namespace);
}
function wt(t2, e) {
  return !!(t2.type === "ieConditionalComment" && t2.lastChild && !t2.lastChild.isSelfClosing && !t2.lastChild.endSourceSpan || t2.type === "ieConditionalComment" && !t2.complete || de(t2) && t2.children.some((r) => r.type !== "text" && r.type !== "interpolation") || xt(t2, e) && !W(t2, e) && t2.type !== "interpolation");
}
function ge(t2) {
  return t2.type === "attribute" || !t2.parent || !t2.prev ? false : ji(t2.prev);
}
function ji(t2) {
  return t2.type === "comment" && t2.value.trim() === "prettier-ignore";
}
function $(t2) {
  return t2.type === "text" || t2.type === "comment";
}
function W(t2, e) {
  return t2.type === "element" && (t2.fullName === "script" || t2.fullName === "style" || t2.fullName === "svg:style" || t2.fullName === "svg:script" || t2.fullName === "mj-style" && e.parser === "mjml" || fe(t2) && (t2.name === "script" || t2.name === "style"));
}
function qn(t2, e) {
  return t2.children && !W(t2, e);
}
function Hn(t2, e) {
  return W(t2, e) || t2.type === "interpolation" || Ar(t2);
}
function Ar(t2) {
  return Jn(t2).startsWith("pre");
}
function Vn(t2, e) {
  var s, i;
  let r = n();
  if (r && !t2.prev && ((i = (s = t2.parent) == null ? undefined : s.tagDefinition) != null && i.ignoreFirstLf))
    return t2.type === "interpolation";
  return r;
  function n() {
    return Pe(t2) || t2.type === "angularControlFlowBlock" ? false : (t2.type === "text" || t2.type === "interpolation") && t2.prev && (t2.prev.type === "text" || t2.prev.type === "interpolation") ? true : !t2.parent || t2.parent.cssDisplay === "none" ? false : de(t2.parent) ? true : !(!t2.prev && (t2.parent.type === "root" || de(t2) && t2.parent || W(t2.parent, e) || et(t2.parent, e) || !ea(t2.parent.cssDisplay)) || t2.prev && !na(t2.prev.cssDisplay));
  }
}
function Un(t2, e) {
  return Pe(t2) || t2.type === "angularControlFlowBlock" ? false : (t2.type === "text" || t2.type === "interpolation") && t2.next && (t2.next.type === "text" || t2.next.type === "interpolation") ? true : !t2.parent || t2.parent.cssDisplay === "none" ? false : de(t2.parent) ? true : !(!t2.next && (t2.parent.type === "root" || de(t2) && t2.parent || W(t2.parent, e) || et(t2.parent, e) || !ta(t2.parent.cssDisplay)) || t2.next && !ra(t2.next.cssDisplay));
}
function Wn(t2, e) {
  return sa(t2.cssDisplay) && !W(t2, e);
}
function Je(t2) {
  return Pe(t2) || t2.next && t2.sourceSpan.end && t2.sourceSpan.end.line + 1 < t2.next.sourceSpan.start.line;
}
function Gn(t2) {
  return Dr(t2) || t2.type === "element" && t2.children.length > 0 && (["body", "script", "style"].includes(t2.name) || t2.children.some((e) => Xi(e))) || t2.firstChild && t2.firstChild === t2.lastChild && t2.firstChild.type !== "text" && Yn(t2.firstChild) && (!t2.lastChild.isTrailingSpaceSensitive || jn(t2.lastChild));
}
function Dr(t2) {
  return t2.type === "element" && t2.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(t2.name) || t2.cssDisplay.startsWith("table") && t2.cssDisplay !== "table-cell");
}
function bt(t2) {
  return Kn(t2) || t2.prev && Ki(t2.prev) || zn(t2);
}
function Ki(t2) {
  return Kn(t2) || t2.type === "element" && t2.fullName === "br" || zn(t2);
}
function zn(t2) {
  return Yn(t2) && jn(t2);
}
function Yn(t2) {
  return t2.hasLeadingSpaces && (t2.prev ? t2.prev.sourceSpan.end.line < t2.sourceSpan.start.line : t2.parent.type === "root" || t2.parent.startSourceSpan.end.line < t2.sourceSpan.start.line);
}
function jn(t2) {
  return t2.hasTrailingSpaces && (t2.next ? t2.next.sourceSpan.start.line > t2.sourceSpan.end.line : t2.parent.type === "root" || t2.parent.endSourceSpan && t2.parent.endSourceSpan.start.line > t2.sourceSpan.end.line);
}
function Kn(t2) {
  switch (t2.type) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return true;
    case "element":
      return ["script", "select"].includes(t2.name);
  }
  return false;
}
function Tt(t2) {
  return t2.lastChild ? Tt(t2.lastChild) : t2;
}
function Xi(t2) {
  var e;
  return (e = t2.children) == null ? undefined : e.some((r) => r.type !== "text");
}
function Xn(t2) {
  if (t2)
    switch (t2) {
      case "module":
      case "text/javascript":
      case "text/babel":
      case "text/jsx":
      case "application/javascript":
        return "babel";
      case "application/x-typescript":
        return "typescript";
      case "text/markdown":
        return "markdown";
      case "text/html":
        return "html";
      case "text/x-handlebars-template":
        return "glimmer";
      default:
        if (t2.endsWith("json") || t2.endsWith("importmap") || t2 === "speculationrules")
          return "json";
    }
}
function Qi(t2, e) {
  let { name: r, attrMap: n } = t2;
  if (r !== "script" || Object.prototype.hasOwnProperty.call(n, "src"))
    return;
  let { type: s, lang: i } = t2.attrMap;
  return !i && !s ? "babel" : Ne(e, { language: i }) ?? Xn(s);
}
function Ji(t2, e) {
  if (!xt(t2, e))
    return;
  let { attrMap: r } = t2;
  if (Object.prototype.hasOwnProperty.call(r, "src"))
    return;
  let { type: n, lang: s } = r;
  return Ne(e, { language: s }) ?? Xn(n);
}
function Zi(t2, e) {
  if (t2.name === "style") {
    let { lang: r } = t2.attrMap;
    return r ? Ne(e, { language: r }) : "css";
  }
  if (t2.name === "mj-style" && e.parser === "mjml")
    return "css";
}
function vr(t2, e) {
  return Qi(t2, e) ?? Zi(t2, e) ?? Ji(t2, e);
}
function Ze(t2) {
  return t2 === "block" || t2 === "list-item" || t2.startsWith("table");
}
function ea(t2) {
  return !Ze(t2) && t2 !== "inline-block";
}
function ta(t2) {
  return !Ze(t2) && t2 !== "inline-block";
}
function ra(t2) {
  return !Ze(t2);
}
function na(t2) {
  return !Ze(t2);
}
function sa(t2) {
  return !Ze(t2) && t2 !== "inline-block";
}
function de(t2) {
  return Jn(t2).startsWith("pre");
}
function ia(t2, e) {
  let r = t2;
  for (;r; ) {
    if (e(r))
      return true;
    r = r.parent;
  }
  return false;
}
function Qn(t2, e) {
  var n;
  if (Ce(t2, e))
    return "block";
  if (((n = t2.prev) == null ? undefined : n.type) === "comment") {
    let s = t2.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/u);
    if (s)
      return s[1];
  }
  let r = false;
  if (t2.type === "element" && t2.namespace === "svg")
    if (ia(t2, (s) => s.fullName === "svg:foreignObject"))
      r = true;
    else
      return t2.name === "svg" ? "inline-block" : "block";
  switch (e.htmlWhitespaceSensitivity) {
    case "strict":
      return "inline";
    case "ignore":
      return "block";
    default:
      if (t2.type === "element" && (!t2.namespace || r || fe(t2)) && Object.prototype.hasOwnProperty.call(Sr, t2.name))
        return Sr[t2.name];
  }
  return $n;
}
function Jn(t2) {
  return t2.type === "element" && (!t2.namespace || fe(t2)) && Object.prototype.hasOwnProperty.call(_r, t2.name) ? _r[t2.name] : On;
}
function aa(t2) {
  let e = Number.POSITIVE_INFINITY;
  for (let r of t2.split(`
`)) {
    if (r.length === 0)
      continue;
    let n = O.getLeadingWhitespaceCount(r);
    if (n === 0)
      return 0;
    r.length !== n && n < e && (e = n);
  }
  return e === Number.POSITIVE_INFINITY ? 0 : e;
}
function yr(t2, e = aa(t2)) {
  return e === 0 ? t2 : t2.split(`
`).map((r) => r.slice(e)).join(`
`);
}
function wr(t2) {
  return w(false, w(false, t2, "&apos;", "'"), "&quot;", '"');
}
function P(t2) {
  return wr(t2.value);
}
function et(t2, e) {
  return Ce(t2, e) && !oa.has(t2.fullName);
}
function Ce(t2, e) {
  return e.parser === "vue" && t2.type === "element" && t2.parent.type === "root" && t2.fullName.toLowerCase() !== "html";
}
function xt(t2, e) {
  return Ce(t2, e) && (et(t2, e) || t2.attrMap.lang && t2.attrMap.lang !== "html");
}
function Zn(t2) {
  let e = t2.fullName;
  return e.charAt(0) === "#" || e === "slot-scope" || e === "v-slot" || e.startsWith("v-slot:");
}
function es(t2, e) {
  let r = t2.parent;
  if (!Ce(r, e))
    return false;
  let n = r.fullName, s = t2.fullName;
  return n === "script" && s === "setup" || n === "style" && s === "vars";
}
function kt(t2, e = t2.value) {
  return t2.parent.isWhitespaceSensitive ? t2.parent.isIndentationSensitive ? B(e) : B(yr(Er(e)), S) : H(_, O.split(e));
}
function Bt(t2, e) {
  return Ce(t2, e) && t2.name === "script";
}
async function ts(t2, e) {
  let r = [];
  for (let [n, s] of t2.split(br).entries())
    if (n % 2 === 0)
      r.push(B(s));
    else
      try {
        r.push(E(["{{", k([_, await T(s, e, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), _, "}}"]));
      } catch {
        r.push("{{", B(s), "}}");
      }
  return r;
}
function Tr({ parser: t2 }) {
  return (e, r, n) => T(P(n.node), e, { parser: t2 }, X);
}
function pa(t2, e) {
  if (e.parser !== "angular")
    return;
  let { node: r } = t2, n = r.fullName;
  if (n.startsWith("(") && n.endsWith(")") || n.startsWith("on-"))
    return ua;
  if (n.startsWith("[") && n.endsWith("]") || /^bind(?:on)?-/u.test(n) || /^ng-(?:if|show|hide|class|style)$/u.test(n))
    return la;
  if (n.startsWith("*"))
    return ca;
  let s = P(r);
  if (/^i18n(?:-.+)?$/u.test(n))
    return () => he(vt(kt(r, s.trim())), !s.includes("@@"));
  if (br.test(s))
    return (i) => ts(s, i);
}
function ha(t2, e) {
  let { node: r } = t2, n = P(r);
  if (r.fullName === "class" && !e.parentParser && !n.includes("{{"))
    return () => n.trim().split(/\s+/u).join(" ");
}
function ss(t2) {
  return t2 === "	" || t2 === `
` || t2 === "\f" || t2 === "\r" || t2 === " ";
}
function Sa(t2) {
  let e = t2.length, r, n, s, i, a, o = 0, u;
  function p(C) {
    let A, D = C.exec(t2.substring(o));
    if (D)
      return [A] = D, o += A.length, A;
  }
  let l = [];
  for (;; ) {
    if (p(fa), o >= e) {
      if (l.length === 0)
        throw new Error("Must contain one or more image candidate strings.");
      return l;
    }
    u = o, r = p(da), n = [], r.slice(-1) === "," ? (r = r.replace(ga, ""), f()) : m();
  }
  function m() {
    for (p(ma), s = "", i = "in descriptor";; ) {
      if (a = t2.charAt(o), i === "in descriptor")
        if (ss(a))
          s && (n.push(s), s = "", i = "after descriptor");
        else if (a === ",") {
          o += 1, s && n.push(s), f();
          return;
        } else if (a === "(")
          s += a, i = "in parens";
        else if (a === "") {
          s && n.push(s), f();
          return;
        } else
          s += a;
      else if (i === "in parens")
        if (a === ")")
          s += a, i = "in descriptor";
        else if (a === "") {
          n.push(s), f();
          return;
        } else
          s += a;
      else if (i === "after descriptor" && !ss(a))
        if (a === "") {
          f();
          return;
        } else
          i = "in descriptor", o -= 1;
      o += 1;
    }
  }
  function f() {
    let C = false, A, D, I, F, c = {}, g, y, q, x, U;
    for (F = 0;F < n.length; F++)
      g = n[F], y = g[g.length - 1], q = g.substring(0, g.length - 1), x = parseInt(q, 10), U = parseFloat(q), is2.test(q) && y === "w" ? ((A || D) && (C = true), x === 0 ? C = true : A = x) : Ca.test(q) && y === "x" ? ((A || D || I) && (C = true), U < 0 ? C = true : D = U) : is2.test(q) && y === "h" ? ((I || D) && (C = true), x === 0 ? C = true : I = x) : C = true;
    if (!C)
      c.source = { value: r, startOffset: u }, A && (c.width = { value: A }), D && (c.density = { value: D }), I && (c.height = { value: I }), l.push(c);
    else
      throw new Error(`Invalid srcset descriptor found in "${t2}" at "${g}".`);
  }
}
function _a(t2) {
  if (t2.node.fullName === "srcset" && (t2.parent.fullName === "img" || t2.parent.fullName === "source"))
    return () => Aa(P(t2.node));
}
function Aa(t2) {
  let e = as(t2), r = Ea.filter((l) => e.some((m) => Object.prototype.hasOwnProperty.call(m, l)));
  if (r.length > 1)
    throw new Error("Mixed descriptor in srcset is not supported");
  let [n] = r, s = os2[n], i = e.map((l) => l.source.value), a = Math.max(...i.map((l) => l.length)), o = e.map((l) => l[n] ? String(l[n].value) : ""), u = o.map((l) => {
    let m = l.indexOf(".");
    return m === -1 ? l.length : m;
  }), p = Math.max(...u);
  return he(H([",", _], i.map((l, m) => {
    let f = [l], C = o[m];
    if (C) {
      let A = a - l.length + 1, D = p - u[m], I = " ".repeat(A + D);
      f.push(pe(I, " "), C + s);
    }
    return f;
  })));
}
function ls(t2, e) {
  let { node: r } = t2, n = P(t2.node).trim();
  if (r.fullName === "style" && !e.parentParser && !n.includes("{{"))
    return async (s) => he(await s(n, { parser: "css", __isHTMLStyleAttribute: true }));
}
function Da(t2, e) {
  let { root: r } = t2;
  return xr.has(r) || xr.set(r, r.children.some((n) => Bt(n, e) && ["ts", "typescript"].includes(n.attrMap.lang))), xr.get(r);
}
function cs(t2, e, r) {
  let { node: n } = r, s = P(n);
  return T(`type T<${s}> = any`, t2, { parser: "babel-ts", __isEmbeddedTypescriptGenericParameters: true }, X);
}
function ps(t2, e, { parseWithTs: r }) {
  return T(`function _(${t2}) {}`, e, { parser: r ? "babel-ts" : "babel", __isVueBindings: true });
}
async function hs(t2, e, r, n) {
  let s = P(r.node), { left: i, operator: a, right: o } = va(s), u = Ie(r, n);
  return [E(await T(`function _(${i}) {}`, t2, { parser: u ? "babel-ts" : "babel", __isVueForBindingLeft: true })), " ", a, " ", await T(o, t2, { parser: u ? "__ts_expression" : "__js_expression" })];
}
function va(t2) {
  let e = /(.*?)\s+(in|of)\s+(.*)/su, r = /,([^,\]}]*)(?:,([^,\]}]*))?$/u, n = /^\(|\)$/gu, s = t2.match(e);
  if (!s)
    return;
  let i = {};
  if (i.for = s[3].trim(), !i.for)
    return;
  let a = w(false, s[1].trim(), n, ""), o = a.match(r);
  o ? (i.alias = a.replace(r, ""), i.iterator1 = o[1].trim(), o[2] && (i.iterator2 = o[2].trim())) : i.alias = a;
  let u = [i.alias, i.iterator1, i.iterator2];
  if (!u.some((p, l) => !p && (l === 0 || u.slice(l + 1).some(Boolean))))
    return { left: u.filter(Boolean).join(","), operator: s[2], right: i.for };
}
function ya(t2, e) {
  if (e.parser !== "vue")
    return;
  let { node: r } = t2, n = r.fullName;
  if (n === "v-for")
    return hs;
  if (n === "generic" && Bt(r.parent, e))
    return cs;
  let s = P(r), i = Ie(t2, e);
  if (Zn(r) || es(r, e))
    return (a) => ps(s, a, { parseWithTs: i });
  if (n.startsWith("@") || n.startsWith("v-on:"))
    return (a) => wa(s, a, { parseWithTs: i });
  if (n.startsWith(":") || n.startsWith(".") || n.startsWith("v-bind:"))
    return (a) => ba(s, a, { parseWithTs: i });
  if (n.startsWith("v-"))
    return (a) => ms(s, a, { parseWithTs: i });
}
async function wa(t2, e, { parseWithTs: r }) {
  var n;
  try {
    return await ms(t2, e, { parseWithTs: r });
  } catch (s) {
    if (((n = s.cause) == null ? undefined : n.code) !== "BABEL_PARSER_SYNTAX_ERROR")
      throw s;
  }
  return T(t2, e, { parser: r ? "__vue_ts_event_binding" : "__vue_event_binding" }, X);
}
function ba(t2, e, { parseWithTs: r }) {
  return T(t2, e, { parser: r ? "__vue_ts_expression" : "__vue_expression" }, X);
}
function ms(t2, e, { parseWithTs: r }) {
  return T(t2, e, { parser: r ? "__ts_expression" : "__js_expression" }, X);
}
function Ta(t2, e) {
  let { node: r } = t2;
  if (r.value) {
    if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(e.originalText.slice(r.valueSpan.start.offset, r.valueSpan.end.offset)) || e.parser === "lwc" && r.value.startsWith("{") && r.value.endsWith("}"))
      return [r.rawName, "=", r.value];
    for (let n of [us, ls, ns, fs2, rs]) {
      let s = n(t2, e);
      if (s)
        return xa(s);
    }
  }
}
function xa(t2) {
  return async (e, r, n, s) => {
    let i = await t2(e, r, n, s);
    if (i)
      return i = hr(i, (a) => typeof a == "string" ? w(false, a, '"', "&quot;") : a), [n.node.rawName, '="', E(i), '"'];
  };
}
function J(t2) {
  return t2.sourceSpan.start.offset;
}
function se(t2) {
  return t2.sourceSpan.end.offset;
}
function tt(t2, e) {
  return [t2.isSelfClosing ? "" : Ba(t2, e), Se(t2, e)];
}
function Ba(t2, e) {
  return t2.lastChild && Ae(t2.lastChild) ? "" : [La(t2, e), Lt(t2, e)];
}
function Se(t2, e) {
  return (t2.next ? Q(t2.next) : Ee(t2.parent)) ? "" : [_e(t2, e), G(t2, e)];
}
function La(t2, e) {
  return Ee(t2) ? _e(t2.lastChild, e) : "";
}
function G(t2, e) {
  return Ae(t2) ? Lt(t2.parent, e) : rt(t2) ? Ft(t2.next, e) : "";
}
function Lt(t2, e) {
  if (Cs(t2, e))
    return "";
  switch (t2.type) {
    case "ieConditionalComment":
      return "<!";
    case "element":
      if (t2.hasHtmComponentClosingTag)
        return "<//";
    default:
      return `</${t2.rawName}`;
  }
}
function _e(t2, e) {
  if (Cs(t2, e))
    return "";
  switch (t2.type) {
    case "ieConditionalComment":
    case "ieConditionalEndComment":
      return "[endif]-->";
    case "ieConditionalStartComment":
      return "]><!-->";
    case "interpolation":
      return "}}";
    case "angularIcuExpression":
      return "}";
    case "element":
      if (t2.isSelfClosing)
        return "/>";
    default:
      return ">";
  }
}
function Cs(t2, e) {
  return !t2.isSelfClosing && !t2.endSourceSpan && (ge(t2) || wt(t2.parent, e));
}
function Q(t2) {
  return t2.prev && t2.prev.type !== "docType" && t2.type !== "angularControlFlowBlock" && !$(t2.prev) && t2.isLeadingSpaceSensitive && !t2.hasLeadingSpaces;
}
function Ee(t2) {
  var e;
  return ((e = t2.lastChild) == null ? undefined : e.isTrailingSpaceSensitive) && !t2.lastChild.hasTrailingSpaces && !$(Tt(t2.lastChild)) && !de(t2);
}
function Ae(t2) {
  return !t2.next && !t2.hasTrailingSpaces && t2.isTrailingSpaceSensitive && $(Tt(t2));
}
function rt(t2) {
  return t2.next && !$(t2.next) && $(t2) && t2.isTrailingSpaceSensitive && !t2.hasTrailingSpaces;
}
function Fa(t2) {
  let e = t2.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/su);
  return e ? e[1] ? e[1].split(/\s+/u) : true : false;
}
function nt(t2) {
  return !t2.prev && t2.isLeadingSpaceSensitive && !t2.hasLeadingSpaces;
}
function Pa(t2, e, r) {
  var m;
  let { node: n } = t2;
  if (!me(n.attrs))
    return n.isSelfClosing ? " " : "";
  let s = ((m = n.prev) == null ? undefined : m.type) === "comment" && Fa(n.prev.value), i = typeof s == "boolean" ? () => s : Array.isArray(s) ? (f) => s.includes(f.rawName) : () => false, a = t2.map(({ node: f }) => i(f) ? B(e.originalText.slice(J(f), se(f))) : r(), "attrs"), o = n.type === "element" && n.fullName === "script" && n.attrs.length === 1 && n.attrs[0].fullName === "src" && n.children.length === 0, p = e.singleAttributePerLine && n.attrs.length > 1 && !Ce(n, e) ? S : _, l = [k([o ? " " : _, H(p, a)])];
  return n.firstChild && nt(n.firstChild) || n.isSelfClosing && Ee(n.parent) || o ? l.push(n.isSelfClosing ? " " : "") : l.push(e.bracketSameLine ? n.isSelfClosing ? " " : "" : n.isSelfClosing ? _ : v), l;
}
function Na(t2) {
  return t2.firstChild && nt(t2.firstChild) ? "" : Pt(t2);
}
function st(t2, e, r) {
  let { node: n } = t2;
  return [De(n, e), Pa(t2, e, r), n.isSelfClosing ? "" : Na(n)];
}
function De(t2, e) {
  return t2.prev && rt(t2.prev) ? "" : [z2(t2, e), Ft(t2, e)];
}
function z2(t2, e) {
  return nt(t2) ? Pt(t2.parent) : Q(t2) ? _e(t2.prev, e) : "";
}
function Ft(t2, e) {
  switch (t2.type) {
    case "ieConditionalComment":
    case "ieConditionalStartComment":
      return `<!--[if ${t2.condition}`;
    case "ieConditionalEndComment":
      return "<!--<!";
    case "interpolation":
      return "{{";
    case "docType": {
      if (t2.value === "html") {
        let { filepath: n } = e;
        if (n && /\.html?$/u.test(n))
          return gs;
      }
      let r = J(t2);
      return e.originalText.slice(r, r + gs.length);
    }
    case "angularIcuExpression":
      return "{";
    case "element":
      if (t2.condition)
        return `<!--[if ${t2.condition}]><!--><${t2.rawName}`;
    default:
      return `<${t2.rawName}`;
  }
}
function Pt(t2) {
  switch (t2.type) {
    case "ieConditionalComment":
      return "]>";
    case "element":
      if (t2.condition)
        return "><!--<![endif]-->";
    default:
      return ">";
  }
}
function Ia(t2, e) {
  if (!t2.endSourceSpan)
    return "";
  let r = t2.startSourceSpan.end.offset;
  t2.firstChild && nt(t2.firstChild) && (r -= Pt(t2).length);
  let n = t2.endSourceSpan.start.offset;
  return t2.lastChild && Ae(t2.lastChild) ? n += Lt(t2, e).length : Ee(t2) && (n -= _e(t2.lastChild, e).length), e.originalText.slice(r, n);
}
function $a(t2, e) {
  let { node: r } = t2;
  switch (r.type) {
    case "element":
      if (W(r, e) || r.type === "interpolation")
        return;
      if (!r.isSelfClosing && xt(r, e)) {
        let n = vr(r, e);
        return n ? async (s, i) => {
          let a = Nt(r, e), o = /^\s*$/u.test(a), u = "";
          return o || (u = await s(Er(a), { parser: n, __embeddedInHtml: true }), o = u === ""), [z2(r, e), E(st(t2, e, i)), o ? "" : S, u, o ? "" : S, tt(r, e), G(r, e)];
        } : undefined;
      }
      break;
    case "text":
      if (W(r.parent, e)) {
        let n = vr(r.parent, e);
        if (n)
          return async (s) => {
            let i = n === "markdown" ? yr(r.value.replace(/^[^\S\n]*\n/u, "")) : r.value, a = { parser: n, __embeddedInHtml: true };
            if (e.parser === "html" && n === "babel") {
              let o = "script", { attrMap: u } = r.parent;
              u && (u.type === "module" || (u.type === "text/babel" || u.type === "text/jsx") && u["data-type"] === "module") && (o = "module"), a.__babelSourceType = o;
            }
            return [ne2, z2(r, e), await s(i, a), G(r, e)];
          };
      } else if (r.parent.type === "interpolation")
        return async (n) => {
          let s = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
          return e.parser === "angular" ? s.parser = "__ng_interpolation" : e.parser === "vue" ? s.parser = Ie(t2, e) ? "__vue_ts_expression" : "__vue_expression" : s.parser = "__js_expression", [k([_, await n(r.value, s)]), r.parent.next && Q(r.parent.next) ? " " : _];
        };
      break;
    case "attribute":
      return ds(t2, e);
    case "front-matter":
      return (n) => yn(r, n);
    case "angularControlFlowBlockParameters":
      return Ra.has(t2.parent.name) ? wn : undefined;
    case "angularLetDeclarationInitializer":
      return (n) => T(r.value, n, { parser: "__ng_binding", __isInHtmlAttribute: false });
  }
}
function at(t2) {
  if (it !== null && typeof it.property) {
    let e = it;
    return it = at.prototype = null, e;
  }
  return it = at.prototype = t2 ?? Object.create(null), new at;
}
function kr(t2) {
  return at(t2);
}
function Ma(t2, e = "type") {
  kr(t2);
  function r(n) {
    let s = n[e], i = t2[s];
    if (!Array.isArray(i))
      throw Object.assign(new Error(`Missing visitor keys for '${s}'.`), { node: n });
    return i;
  }
  return r;
}
function ws(t2) {
  return ys.test(t2);
}
function bs(t2) {
  return vs.test(t2);
}
function Ts(t2) {
  return `<!-- @${Ds} -->

${t2}`;
}
function ks(t2) {
  let e = se(t2);
  return t2.type === "element" && !t2.endSourceSpan && me(t2.children) ? Math.max(e, ks(K(false, t2.children, -1))) : e;
}
function ot(t2, e, r) {
  let n = t2.node;
  if (ge(n)) {
    let s = ks(n);
    return [z2(n, e), B(O.trimEnd(e.originalText.slice(J(n) + (n.prev && rt(n.prev) ? Ft(n).length : 0), s - (n.next && Q(n.next) ? _e(n, e).length : 0)))), G(n, e)];
  }
  return r();
}
function It(t2, e) {
  return $(t2) && $(e) ? t2.isTrailingSpaceSensitive ? t2.hasTrailingSpaces ? bt(e) ? S : _ : "" : bt(e) ? S : v : rt(t2) && (ge(e) || e.firstChild || e.isSelfClosing || e.type === "element" && e.attrs.length > 0) || t2.type === "element" && t2.isSelfClosing && Q(e) ? "" : !e.isLeadingSpaceSensitive || bt(e) || Q(e) && t2.lastChild && Ae(t2.lastChild) && t2.lastChild.lastChild && Ae(t2.lastChild.lastChild) ? S : e.hasLeadingSpaces ? _ : v;
}
function Re(t2, e, r) {
  let { node: n } = t2;
  if (Dr(n))
    return [ne2, ...t2.map((i) => {
      let a = i.node, o = a.prev ? It(a.prev, a) : "";
      return [o ? [o, Je(a.prev) ? S : ""] : "", ot(i, e, r)];
    }, "children")];
  let s = n.children.map(() => Symbol(""));
  return t2.map((i, a) => {
    let o = i.node;
    if ($(o)) {
      if (o.prev && $(o.prev)) {
        let A = It(o.prev, o);
        if (A)
          return Je(o.prev) ? [S, S, ot(i, e, r)] : [A, ot(i, e, r)];
      }
      return ot(i, e, r);
    }
    let u = [], p = [], l = [], m = [], f = o.prev ? It(o.prev, o) : "", C = o.next ? It(o, o.next) : "";
    return f && (Je(o.prev) ? u.push(S, S) : f === S ? u.push(S) : $(o.prev) ? p.push(f) : p.push(pe("", v, { groupId: s[a - 1] }))), C && (Je(o) ? $(o.next) && m.push(S, S) : C === S ? $(o.next) && m.push(S) : l.push(C)), [...u, E([...p, E([ot(i, e, r), ...l], { id: s[a] })]), ...m];
  }, "children");
}
function Bs(t2, e, r) {
  let { node: n } = t2, s = [];
  Va(t2) && s.push("} "), s.push("@", n.name), n.parameters && s.push(" (", E(r("parameters")), ")"), s.push(" {");
  let i = Ls(n);
  return n.children.length > 0 ? (n.firstChild.hasLeadingSpaces = true, n.lastChild.hasTrailingSpaces = true, s.push(k([S, Re(t2, e, r)])), i && s.push(S, "}")) : i && s.push("}"), E(s, { shouldBreak: true });
}
function Ls(t2) {
  var e, r;
  return !(((e = t2.next) == null ? undefined : e.type) === "angularControlFlowBlock" && ((r = xs.get(t2.name)) != null && r.has(t2.next.name)));
}
function Va(t2) {
  let { previous: e } = t2;
  return (e == null ? undefined : e.type) === "angularControlFlowBlock" && !ge(e) && !Ls(e);
}
function Fs(t2, e, r) {
  return [k([v, H([";", _], t2.map(r, "children"))]), v];
}
function Ps(t2, e, r) {
  let { node: n } = t2;
  return [De(n, e), E([n.switchValue.trim(), ", ", n.clause, n.cases.length > 0 ? [",", k([_, H(_, t2.map(r, "cases"))])] : "", v]), Se(n, e)];
}
function Ns(t2, e, r) {
  let { node: n } = t2;
  return [n.value, " {", E([k([v, t2.map(({ node: s, isLast: i }) => {
    let a = [r()];
    return s.type === "text" && (s.hasLeadingSpaces && a.unshift(_), s.hasTrailingSpaces && !i && a.push(_)), a;
  }, "expression")]), v]), "}"];
}
function Is(t2, e, r) {
  let { node: n } = t2;
  if (wt(n, e))
    return [z2(n, e), E(st(t2, e, r)), B(Nt(n, e)), ...tt(n, e), G(n, e)];
  let s = n.children.length === 1 && (n.firstChild.type === "interpolation" || n.firstChild.type === "angularIcuExpression") && n.firstChild.isLeadingSpaceSensitive && !n.firstChild.hasLeadingSpaces && n.lastChild.isTrailingSpaceSensitive && !n.lastChild.hasTrailingSpaces, i = Symbol("element-attr-group-id"), a = (l) => E([E(st(t2, e, r), { id: i }), l, tt(n, e)]), o = (l) => s ? Cn(l, { groupId: i }) : (W(n, e) || et(n, e)) && n.parent.type === "root" && e.parser === "vue" && !e.vueIndentScriptAndStyle ? l : k(l), u = () => s ? pe(v, "", { groupId: i }) : n.firstChild.hasLeadingSpaces && n.firstChild.isLeadingSpaceSensitive ? _ : n.firstChild.type === "text" && n.isWhitespaceSensitive && n.isIndentationSensitive ? dn(v) : v, p = () => (n.next ? Q(n.next) : Ee(n.parent)) ? n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? " " : "" : s ? pe(v, "", { groupId: i }) : n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? _ : (n.lastChild.type === "comment" || n.lastChild.type === "text" && n.isWhitespaceSensitive && n.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${e.tabWidth * (t2.ancestors.length - 1)}}\$`, "u").test(n.lastChild.value) ? "" : v;
  return n.children.length === 0 ? a(n.hasDanglingSpaces && n.isDanglingSpaceSensitive ? _ : "") : a([Gn(n) ? ne2 : "", o([u(), Re(t2, e, r)]), p()]);
}
function ut(t2) {
  return t2 >= 9 && t2 <= 32 || t2 == 160;
}
function Rt(t2) {
  return 48 <= t2 && t2 <= 57;
}
function lt2(t2) {
  return t2 >= 97 && t2 <= 122 || t2 >= 65 && t2 <= 90;
}
function Rs(t2) {
  return t2 >= 97 && t2 <= 102 || t2 >= 65 && t2 <= 70 || Rt(t2);
}
function $t(t2) {
  return t2 === 10 || t2 === 13;
}
function Br(t2) {
  return 48 <= t2 && t2 <= 55;
}
function Ot(t2) {
  return t2 === 39 || t2 === 34 || t2 === 96;
}
function Os(t2) {
  return t2.replace(Ua, (...e) => e[1].toUpperCase());
}
function Ga(t2, e) {
  for (let r of Wa)
    r(t2, e);
  return t2;
}
function za(t2) {
  t2.walk((e) => {
    if (e.type === "element" && e.tagDefinition.ignoreFirstLf && e.children.length > 0 && e.children[0].type === "text" && e.children[0].value[0] === `
`) {
      let r = e.children[0];
      r.value.length === 1 ? e.removeChild(r) : r.value = r.value.slice(1);
    }
  });
}
function Ya(t2) {
  let e = (r) => {
    var n, s;
    return r.type === "element" && ((n = r.prev) == null ? undefined : n.type) === "ieConditionalStartComment" && r.prev.sourceSpan.end.offset === r.startSourceSpan.start.offset && ((s = r.firstChild) == null ? undefined : s.type) === "ieConditionalEndComment" && r.firstChild.sourceSpan.start.offset === r.startSourceSpan.end.offset;
  };
  t2.walk((r) => {
    if (r.children)
      for (let n = 0;n < r.children.length; n++) {
        let s = r.children[n];
        if (!e(s))
          continue;
        let { prev: i, firstChild: a } = s;
        r.removeChild(i), n--;
        let o = new h(i.sourceSpan.start, a.sourceSpan.end), u = new h(o.start, s.sourceSpan.end);
        s.condition = i.condition, s.sourceSpan = u, s.startSourceSpan = o, s.removeChild(a);
      }
  });
}
function ja(t2, e, r) {
  t2.walk((n) => {
    if (n.children)
      for (let s = 0;s < n.children.length; s++) {
        let i = n.children[s];
        if (i.type !== "text" && !e(i))
          continue;
        i.type !== "text" && (i.type = "text", i.value = r(i));
        let a = i.prev;
        !a || a.type !== "text" || (a.value += i.value, a.sourceSpan = new h(a.sourceSpan.start, i.sourceSpan.end), n.removeChild(i), s--);
      }
  });
}
function Ka(t2) {
  return ja(t2, (e) => e.type === "cdata", (e) => `<![CDATA[${e.value}]]>`);
}
function Xa(t2) {
  let e = (r) => {
    var n, s;
    return r.type === "element" && r.attrs.length === 0 && r.children.length === 1 && r.firstChild.type === "text" && !O.hasWhitespaceCharacter(r.children[0].value) && !r.firstChild.hasLeadingSpaces && !r.firstChild.hasTrailingSpaces && r.isLeadingSpaceSensitive && !r.hasLeadingSpaces && r.isTrailingSpaceSensitive && !r.hasTrailingSpaces && ((n = r.prev) == null ? undefined : n.type) === "text" && ((s = r.next) == null ? undefined : s.type) === "text";
  };
  t2.walk((r) => {
    if (r.children)
      for (let n = 0;n < r.children.length; n++) {
        let s = r.children[n];
        if (!e(s))
          continue;
        let { prev: i, next: a } = s;
        i.value += `<${s.rawName}>` + s.firstChild.value + `</${s.rawName}>` + a.value, i.sourceSpan = new h(i.sourceSpan.start, a.sourceSpan.end), i.isTrailingSpaceSensitive = a.isTrailingSpaceSensitive, i.hasTrailingSpaces = a.hasTrailingSpaces, r.removeChild(s), n--, r.removeChild(a);
      }
  });
}
function Qa(t2, e) {
  if (e.parser === "html")
    return;
  let r = /\{\{(.+?)\}\}/su;
  t2.walk((n) => {
    if (qn(n, e))
      for (let s of n.children) {
        if (s.type !== "text")
          continue;
        let i = s.sourceSpan.start, a = null, o = s.value.split(r);
        for (let u = 0;u < o.length; u++, i = a) {
          let p = o[u];
          if (u % 2 === 0) {
            a = i.moveBy(p.length), p.length > 0 && n.insertChildBefore(s, { type: "text", value: p, sourceSpan: new h(i, a) });
            continue;
          }
          a = i.moveBy(p.length + 4), n.insertChildBefore(s, { type: "interpolation", sourceSpan: new h(i, a), children: p.length === 0 ? [] : [{ type: "text", value: p, sourceSpan: new h(i.moveBy(2), a.moveBy(-2)) }] });
        }
        n.removeChild(s);
      }
  });
}
function Ja(t2, e) {
  t2.walk((r) => {
    let n = r.$children;
    if (!n)
      return;
    if (n.length === 0 || n.length === 1 && n[0].type === "text" && O.trim(n[0].value).length === 0) {
      r.hasDanglingSpaces = n.length > 0, r.$children = [];
      return;
    }
    let s = Hn(r, e), i = Ar(r);
    if (!s)
      for (let a = 0;a < n.length; a++) {
        let o = n[a];
        if (o.type !== "text")
          continue;
        let { leadingWhitespace: u, text: p, trailingWhitespace: l } = Mn(o.value), m = o.prev, f = o.next;
        p ? (o.value = p, o.sourceSpan = new h(o.sourceSpan.start.moveBy(u.length), o.sourceSpan.end.moveBy(-l.length)), u && (m && (m.hasTrailingSpaces = true), o.hasLeadingSpaces = true), l && (o.hasTrailingSpaces = true, f && (f.hasLeadingSpaces = true))) : (r.removeChild(o), a--, (u || l) && (m && (m.hasTrailingSpaces = true), f && (f.hasLeadingSpaces = true)));
      }
    r.isWhitespaceSensitive = s, r.isIndentationSensitive = i;
  });
}
function Za(t2) {
  t2.walk((e) => {
    e.isSelfClosing = !e.children || e.type === "element" && (e.tagDefinition.isVoid || e.endSourceSpan && e.startSourceSpan.start === e.endSourceSpan.start && e.startSourceSpan.end === e.endSourceSpan.end);
  });
}
function eo(t2, e) {
  t2.walk((r) => {
    r.type === "element" && (r.hasHtmComponentClosingTag = r.endSourceSpan && /^<\s*\/\s*\/\s*>$/u.test(e.originalText.slice(r.endSourceSpan.start.offset, r.endSourceSpan.end.offset)));
  });
}
function to(t2, e) {
  t2.walk((r) => {
    r.cssDisplay = Qn(r, e);
  });
}
function ro(t2, e) {
  t2.walk((r) => {
    let { children: n } = r;
    if (n) {
      if (n.length === 0) {
        r.isDanglingSpaceSensitive = Wn(r, e);
        return;
      }
      for (let s of n)
        s.isLeadingSpaceSensitive = Vn(s, e), s.isTrailingSpaceSensitive = Un(s, e);
      for (let s = 0;s < n.length; s++) {
        let i = n[s];
        i.isLeadingSpaceSensitive = (s === 0 || i.prev.isTrailingSpaceSensitive) && i.isLeadingSpaceSensitive, i.isTrailingSpaceSensitive = (s === n.length - 1 || i.next.isLeadingSpaceSensitive) && i.isTrailingSpaceSensitive;
      }
    }
  });
}
function no(t2, e, r) {
  let { node: n } = t2;
  switch (n.type) {
    case "front-matter":
      return B(n.raw);
    case "root":
      return e.__onHtmlRoot && e.__onHtmlRoot(n), [E(Re(t2, e, r)), S];
    case "element":
    case "ieConditionalComment":
      return Is(t2, e, r);
    case "angularControlFlowBlock":
      return Bs(t2, e, r);
    case "angularControlFlowBlockParameters":
      return Fs(t2, e, r);
    case "angularControlFlowBlockParameter":
      return O.trim(n.expression);
    case "angularLetDeclaration":
      return E(["@let ", E([n.id, " =", E(k([_, r("init")]))]), ";"]);
    case "angularLetDeclarationInitializer":
      return n.value;
    case "angularIcuExpression":
      return Ps(t2, e, r);
    case "angularIcuCase":
      return Ns(t2, e, r);
    case "ieConditionalStartComment":
    case "ieConditionalEndComment":
      return [De(n), Se(n)];
    case "interpolation":
      return [De(n, e), ...t2.map(r, "children"), Se(n, e)];
    case "text": {
      if (n.parent.type === "interpolation") {
        let o = /\n[^\S\n]*$/u, u = o.test(n.value), p = u ? n.value.replace(o, "") : n.value;
        return [B(p), u ? S : ""];
      }
      let s = z2(n, e), i = kt(n), a = G(n, e);
      return i[0] = [s, i[0]], i.push([i.pop(), a]), vt(i);
    }
    case "docType":
      return [E([De(n, e), " ", w(false, n.value.replace(/^html\b/iu, "html"), /\s+/gu, " ")]), Se(n, e)];
    case "comment":
      return [z2(n, e), B(e.originalText.slice(J(n), se(n))), G(n, e)];
    case "attribute": {
      if (n.value === null)
        return n.rawName;
      let s = wr(n.value), i = _n(s, '"');
      return [n.rawName, "=", i, B(i === '"' ? w(false, s, '"', "&quot;") : w(false, s, "'", "&apos;")), i];
    }
    case "cdata":
    default:
      throw new An(n, "HTML");
  }
}
function ct(t2, e = true) {
  if (t2[0] != ":")
    return [null, t2];
  let r = t2.indexOf(":", 1);
  if (r === -1) {
    if (e)
      throw new Error(`Unsupported format "${t2}" expecting ":namespace:name"`);
    return [null, t2];
  }
  return [t2.slice(1, r), t2.slice(r + 1)];
}
function Nr(t2) {
  return ct(t2)[1] === "ng-container";
}
function Ir(t2) {
  return ct(t2)[1] === "ng-content";
}
function Me(t2) {
  return t2 === null ? null : ct(t2)[0];
}
function qe(t2, e) {
  return t2 ? `:${t2}:${e}` : e;
}
function Rr() {
  return Ht || (Ht = {}, qt(Z.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), qt(Z.STYLE, ["*|style"]), qt(Z.URL, ["*|formAction", "area|href", "area|ping", "audio|src", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "form|action", "img|src", "input|src", "ins|cite", "q|cite", "source|src", "track|src", "video|poster", "video|src"]), qt(Z.RESOURCE_URL, ["applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])), Ht;
}
function qt(t2, e) {
  for (let r of e)
    Ht[r.toLowerCase()] = t2;
}
function ho(t2) {
  switch (t2) {
    case "width":
    case "height":
    case "minWidth":
    case "minHeight":
    case "maxWidth":
    case "maxHeight":
    case "left":
    case "top":
    case "bottom":
    case "right":
    case "fontSize":
    case "outlineWidth":
    case "outlineOffset":
    case "paddingTop":
    case "paddingLeft":
    case "paddingBottom":
    case "paddingRight":
    case "marginTop":
    case "marginLeft":
    case "marginBottom":
    case "marginRight":
    case "borderRadius":
    case "borderWidth":
    case "borderTopWidth":
    case "borderLeftWidth":
    case "borderRightWidth":
    case "borderBottomWidth":
    case "textIndent":
      return true;
    default:
      return false;
  }
}
function He(t2) {
  return pt || (Ks = new d({ canSelfClose: true }), pt = Object.assign(Object.create(null), { base: new d({ isVoid: true }), meta: new d({ isVoid: true }), area: new d({ isVoid: true }), embed: new d({ isVoid: true }), link: new d({ isVoid: true }), img: new d({ isVoid: true }), input: new d({ isVoid: true }), param: new d({ isVoid: true }), hr: new d({ isVoid: true }), br: new d({ isVoid: true }), source: new d({ isVoid: true }), track: new d({ isVoid: true }), wbr: new d({ isVoid: true }), p: new d({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: true }), thead: new d({ closedByChildren: ["tbody", "tfoot"] }), tbody: new d({ closedByChildren: ["tbody", "tfoot"], closedByParent: true }), tfoot: new d({ closedByChildren: ["tbody"], closedByParent: true }), tr: new d({ closedByChildren: ["tr"], closedByParent: true }), td: new d({ closedByChildren: ["td", "th"], closedByParent: true }), th: new d({ closedByChildren: ["td", "th"], closedByParent: true }), col: new d({ isVoid: true }), svg: new d({ implicitNamespacePrefix: "svg" }), foreignObject: new d({ implicitNamespacePrefix: "svg", preventNamespaceInheritance: true }), math: new d({ implicitNamespacePrefix: "math" }), li: new d({ closedByChildren: ["li"], closedByParent: true }), dt: new d({ closedByChildren: ["dt", "dd"] }), dd: new d({ closedByChildren: ["dt", "dd"], closedByParent: true }), rb: new d({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rt: new d({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rtc: new d({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: true }), rp: new d({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), optgroup: new d({ closedByChildren: ["optgroup"], closedByParent: true }), option: new d({ closedByChildren: ["option", "optgroup"], closedByParent: true }), pre: new d({ ignoreFirstLf: true }), listing: new d({ ignoreFirstLf: true }), style: new d({ contentType: N.RAW_TEXT }), script: new d({ contentType: N.RAW_TEXT }), title: new d({ contentType: { default: N.ESCAPABLE_RAW_TEXT, svg: N.PARSABLE_DATA } }), textarea: new d({ contentType: N.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }) }), new Ut().allKnownElementNames().forEach((e) => {
    !pt[e] && Me(e) === null && (pt[e] = new d({ canSelfClose: false }));
  })), pt[t2] ?? Ks;
}
function Qt(t2, e, r = null) {
  let n = [], s = t2.visit ? (i) => t2.visit(i, r) || i.visit(t2, r) : (i) => i.visit(t2, r);
  return e.forEach((i) => {
    let a = s(i);
    a && n.push(a);
  }), n;
}
function Xs(t2, e) {
  if (e != null && !(Array.isArray(e) && e.length == 2))
    throw new Error(`Expected '${t2}' to be an array, [start, end].`);
  if (e != null) {
    let r = e[0], n = e[1];
    go.forEach((s) => {
      if (s.test(r) || s.test(n))
        throw new Error(`['${r}', '${n}'] contains unusable interpolation symbol.`);
    });
  }
}
function li(t2, e, r, n = {}) {
  let s = new Wr(new ve(t2, e), r, n);
  return s.tokenize(), new Ur(Vo(s.tokens), s.errors, s.nonNormalizedIcuExpressions);
}
function Ue(t2) {
  return `Unexpected character "${t2 === 0 ? "EOF" : String.fromCharCode(t2)}"`;
}
function ti(t2) {
  return `Unknown entity "${t2}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
}
function Ro(t2, e) {
  return `Unable to parse entity "${e}" - ${t2} character reference entities must end with ";"`;
}
function b2(t2) {
  return !ut(t2) || t2 === 0;
}
function ri(t2) {
  return ut(t2) || t2 === 62 || t2 === 60 || t2 === 47 || t2 === 39 || t2 === 34 || t2 === 61 || t2 === 0;
}
function $o(t2) {
  return (t2 < 97 || 122 < t2) && (t2 < 65 || 90 < t2) && (t2 < 48 || t2 > 57);
}
function Oo(t2) {
  return t2 === 59 || t2 === 0 || !Rs(t2);
}
function Mo(t2) {
  return t2 === 59 || t2 === 0 || !lt2(t2);
}
function qo(t2) {
  return t2 !== 125;
}
function Ho(t2, e) {
  return ni(t2) === ni(e);
}
function ni(t2) {
  return t2 >= 97 && t2 <= 122 ? t2 - 97 + 65 : t2;
}
function si(t2) {
  return lt2(t2) || Rt(t2) || t2 === 95;
}
function ii(t2) {
  return t2 !== 59 && b2(t2);
}
function Vo(t2) {
  let e = [], r;
  for (let n = 0;n < t2.length; n++) {
    let s = t2[n];
    r && r.type === 5 && s.type === 5 || r && r.type === 16 && s.type === 16 ? (r.parts[0] += s.parts[0], r.sourceSpan.end = s.sourceSpan.end) : (r = s, e.push(r));
  }
  return e;
}
function ci(t2, e) {
  return t2.length > 0 && t2[t2.length - 1] === e;
}
function pi(t2, e) {
  return Ve[e] !== undefined ? Ve[e] || t2 : /^#x[a-f0-9]+$/i.test(e) ? String.fromCodePoint(parseInt(e.slice(2), 16)) : /^#\d+$/.test(e) ? String.fromCodePoint(parseInt(e.slice(1), 10)) : t2;
}
function Qr(t2, e = {}) {
  let { canSelfClose: r = false, allowHtmComponentClosingTags: n = false, isTagNameCaseSensitive: s = false, getTagContentType: i, tokenizeAngularBlocks: a = false, tokenizeAngularLetDeclaration: o = false } = e;
  return Uo().parse(t2, "angular-html-parser", { tokenizeExpansionForms: a, interpolationConfig: undefined, canSelfClose: r, allowHtmComponentClosingTags: n, tokenizeBlocks: a, tokenizeLet: o }, s, i);
}
function Wo(t2, e) {
  let r = new SyntaxError(t2 + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
function Go(t2) {
  let e = t2.slice(0, _t);
  if (e !== "---" && e !== "+++")
    return;
  let r = t2.indexOf(`
`, _t);
  if (r === -1)
    return;
  let n = t2.slice(_t, r).trim(), s = t2.indexOf(`
${e}`, r), i = n;
  if (i || (i = e === "+++" ? "toml" : "yaml"), s === -1 && e === "---" && i === "yaml" && (s = t2.indexOf(`
...`, r)), s === -1)
    return;
  let a = s + 1 + _t, o = t2.charAt(a + 1);
  if (!/\s?/u.test(o))
    return;
  let u = t2.slice(0, a);
  return { type: "front-matter", language: i, explicitLanguage: n, value: t2.slice(r + 1, s), startDelimiter: e, endDelimiter: u.slice(-_t), raw: u };
}
function zo(t2) {
  let e = Go(t2);
  if (!e)
    return { content: t2 };
  let { raw: r } = e;
  return { frontMatter: e, content: w(false, r, /[^\n]/gu, " ") + t2.slice(r.length) };
}
function Yo(t2, e) {
  let r = t2.map(e);
  return r.some((n, s) => n !== t2[s]) ? r : t2;
}
function di(t2, e) {
  if (t2.value)
    for (let { regex: r, parse: n } of jo) {
      let s = t2.value.match(r);
      if (s)
        return n(t2, e, s);
    }
  return null;
}
function Ko(t2, e, r) {
  let [, n, s, i] = r, a = 4 + n.length, o = t2.sourceSpan.start.moveBy(a), u = o.moveBy(i.length), [p, l] = (() => {
    try {
      return [true, e(i, o).children];
    } catch {
      return [false, [{ type: "text", value: i, sourceSpan: new h(o, u) }]];
    }
  })();
  return { type: "ieConditionalComment", complete: p, children: l, condition: w(false, s.trim(), /\s+/gu, " "), sourceSpan: t2.sourceSpan, startSourceSpan: new h(t2.sourceSpan.start, o), endSourceSpan: new h(u, t2.sourceSpan.end) };
}
function Xo(t2, e, r) {
  let [, n] = r;
  return { type: "ieConditionalStartComment", condition: w(false, n.trim(), /\s+/gu, " "), sourceSpan: t2.sourceSpan };
}
function Qo(t2) {
  return { type: "ieConditionalEndComment", sourceSpan: t2.sourceSpan };
}
function Jo(t2) {
  if (t2.type === "block") {
    if (t2.name = w(false, t2.name.toLowerCase(), /\s+/gu, " ").trim(), t2.type = "angularControlFlowBlock", !me(t2.parameters)) {
      delete t2.parameters;
      return;
    }
    for (let e of t2.parameters)
      e.type = "angularControlFlowBlockParameter";
    t2.parameters = { type: "angularControlFlowBlockParameters", children: t2.parameters, sourceSpan: new h(t2.parameters[0].sourceSpan.start, K(false, t2.parameters, -1).sourceSpan.end) };
  }
}
function Zo(t2) {
  t2.type === "letDeclaration" && (t2.type = "angularLetDeclaration", t2.id = t2.name, t2.init = { type: "angularLetDeclarationInitializer", sourceSpan: new h(t2.valueSpan.start, t2.valueSpan.end), value: t2.value }, delete t2.name, delete t2.value);
}
function eu(t2) {
  (t2.type === "plural" || t2.type === "select") && (t2.clause = t2.type, t2.type = "angularIcuExpression"), t2.type === "expansionCase" && (t2.type = "angularIcuCase");
}
function Si(t2, e, r) {
  let { name: n, canSelfClose: s = true, normalizeTagName: i = false, normalizeAttributeName: a = false, allowHtmComponentClosingTags: o = false, isTagNameCaseSensitive: u = false, shouldParseAsRawText: p } = e, { rootNodes: l, errors: m } = Qr(t2, { canSelfClose: s, allowHtmComponentClosingTags: o, isTagNameCaseSensitive: u, getTagContentType: p ? (...c) => p(...c) ? N.RAW_TEXT : undefined : undefined, tokenizeAngularBlocks: n === "angular" ? true : undefined, tokenizeAngularLetDeclaration: n === "angular" ? true : undefined });
  if (n === "vue") {
    if (l.some((x) => x.type === "docType" && x.value === "html" || x.type === "element" && x.name.toLowerCase() === "html"))
      return Si(t2, en, r);
    let g, y = () => g ?? (g = Qr(t2, { canSelfClose: s, allowHtmComponentClosingTags: o, isTagNameCaseSensitive: u })), q = (x) => y().rootNodes.find(({ startSourceSpan: U }) => U && U.start.offset === x.startSourceSpan.start.offset) ?? x;
    for (let [x, U] of l.entries()) {
      let { endSourceSpan: nn, startSourceSpan: Ei } = U;
      if (nn === null)
        m = y().errors, l[x] = q(U);
      else if (tu(U, r)) {
        let sn = y().errors.find((an) => an.span.start.offset > Ei.start.offset && an.span.start.offset < nn.end.offset);
        sn && Ci(sn), l[x] = q(U);
      }
    }
  }
  m.length > 0 && Ci(m[0]);
  let f = (c) => {
    let g = c.name.startsWith(":") ? c.name.slice(1).split(":")[0] : null, y = c.nameSpan.toString(), q = g !== null && y.startsWith(`${g}:`), x = q ? y.slice(g.length + 1) : y;
    c.name = x, c.namespace = g, c.hasExplicitNamespace = q;
  }, C = (c) => {
    switch (c.type) {
      case "element":
        f(c);
        for (let g of c.attrs)
          f(g), g.valueSpan ? (g.value = g.valueSpan.toString(), /["']/u.test(g.value[0]) && (g.value = g.value.slice(1, -1))) : g.value = null;
        break;
      case "comment":
        c.value = c.sourceSpan.toString().slice(4, -3);
        break;
      case "text":
        c.value = c.sourceSpan.toString();
        break;
    }
  }, A = (c, g) => {
    let y = c.toLowerCase();
    return g(y) ? y : c;
  }, D = (c) => {
    if (c.type === "element" && (i && (!c.namespace || c.namespace === c.tagDefinition.implicitNamespacePrefix || fe(c)) && (c.name = A(c.name, (g) => gi.has(g))), a))
      for (let g of c.attrs)
        g.namespace || (g.name = A(g.name, (y) => ur.has(c.name) && (ur.get("*").has(y) || ur.get(c.name).has(y))));
  }, I = (c) => {
    c.sourceSpan && c.endSourceSpan && (c.sourceSpan = new h(c.sourceSpan.start, c.endSourceSpan.end));
  }, F = (c) => {
    if (c.type === "element") {
      let g = He(u ? c.name : c.name.toLowerCase());
      !c.namespace || c.namespace === g.implicitNamespacePrefix || fe(c) ? c.tagDefinition = g : c.tagDefinition = He("");
    }
  };
  return Qt(new class extends ft {
    visitExpansionCase(c, g) {
      n === "angular" && this.visitChildren(g, (y) => {
        y(c.expression);
      });
    }
    visit(c) {
      C(c), F(c), D(c), I(c);
    }
  }, l), l;
}
function tu(t2, e) {
  var n;
  if (t2.type !== "element" || t2.name !== "template")
    return false;
  let r = (n = t2.attrs.find((s) => s.name === "lang")) == null ? undefined : n.value;
  return !r || Ne(e, { language: r }) === "html";
}
function Ci(t2) {
  let { msg: e, span: { start: r, end: n } } = t2;
  throw hi(e, { loc: { start: { line: r.line + 1, column: r.col + 1 }, end: { line: n.line + 1, column: n.col + 1 } }, cause: t2 });
}
function _i(t2, e, r = {}, n = true) {
  let { frontMatter: s, content: i } = n ? mi(t2) : { frontMatter: null, content: t2 }, a = new ve(t2, r.filepath), o = new ie(a, 0, 0, 0), u = o.moveBy(t2.length), p = { type: "root", sourceSpan: new h(o, u), children: Si(i, e, r) };
  if (s) {
    let f = new ie(a, 0, 0, 0), C = f.moveBy(s.raw.length);
    s.sourceSpan = new h(f, C), p.children.unshift(s);
  }
  let l = new or2(p), m = (f, C) => {
    let { offset: A } = C, D = w(false, t2.slice(0, A), /[^\n\r]/gu, " "), F = _i(D + f, e, r, false);
    F.sourceSpan = new h(C, K(false, F.children, -1).sourceSpan.end);
    let c = F.children[0];
    return c.length === A ? F.children.shift() : (c.sourceSpan = new h(c.sourceSpan.start.moveBy(A), c.sourceSpan.end), c.value = c.value.slice(A)), F;
  };
  return l.walk((f) => {
    if (f.type === "comment") {
      let C = di(f, m);
      C && f.parent.replaceChild(f, C);
    }
    Jo(f), Zo(f), eu(f);
  }), l;
}
function Et(t2) {
  return { parse: (e, r) => _i(e, t2, r), hasPragma: ws, hasIgnorePragma: bs, astFormat: "html", locStart: J, locEnd: se };
}
var on = Object.defineProperty;
var un = (t2) => {
  throw TypeError(t2);
};
var Ai = (t2, e, r) => (e in t2) ? on(t2, e, { enumerable: true, configurable: true, writable: true, value: r }) : t2[e] = r;
var ln = (t2, e) => {
  for (var r in e)
    on(t2, r, { get: e[r], enumerable: true });
};
var lr = (t2, e, r) => Ai(t2, typeof e != "symbol" ? e + "" : e, r);
var cn = (t2, e, r) => e.has(t2) || un("Cannot " + r);
var R = (t2, e, r) => (cn(t2, e, "read from private field"), r ? r.call(t2) : e.get(t2));
var At = (t2, e, r) => e.has(t2) ? un("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t2) : e.set(t2, r);
var pn = (t2, e, r, n) => (cn(t2, e, "write to private field"), n ? n.call(t2, r) : e.set(t2, r), r);
var rn = {};
ln(rn, { languages: () => Hs, options: () => Us, parsers: () => tn, printers: () => uu });
var Di = (t2, e, r, n) => {
  if (!(t2 && e == null))
    return e.replaceAll ? e.replaceAll(r, n) : r.global ? e.replace(r, n) : e.split(r).join(n);
};
var w = Di;
var we = "string";
var ze = "array";
var Ye = "cursor";
var be = "indent";
var Te = "align";
var je = "trim";
var xe = "group";
var ke = "fill";
var ce = "if-break";
var Be = "indent-if-break";
var Ke = "line-suffix";
var Xe = "line-suffix-boundary";
var j = "line";
var Qe = "label";
var Le = "break-parent";
var Dt = new Set([Ye, be, Te, je, xe, ke, ce, Be, Ke, Xe, j, Qe, Le]);
var vi = (t2, e, r) => {
  if (!(t2 && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
};
var K = vi;
var Fe = yi;
var wi = (t2) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t2);
var cr = class extends Error {
  name = "InvalidDocError";
  constructor(e) {
    super(bi(e)), this.doc = e;
  }
};
var pr = cr;
var mr = () => {
};
var re = mr;
var fr = mr;
var mn = mr;
var ne2 = { type: Le };
var xi = { type: j, hard: true };
var ki = { type: j, hard: true, literal: true };
var _ = { type: j };
var v = { type: j, soft: true };
var S = [xi, ne2];
var hn = [ki, ne2];
var yt = "'";
var Sn = '"';
var _n = Bi;
var V;
var gr = class {
  constructor(e) {
    At(this, V);
    pn(this, V, new Set(e));
  }
  getLeadingWhitespaceCount(e) {
    let r = R(this, V), n = 0;
    for (let s = 0;s < e.length && r.has(e.charAt(s)); s++)
      n++;
    return n;
  }
  getTrailingWhitespaceCount(e) {
    let r = R(this, V), n = 0;
    for (let s = e.length - 1;s >= 0 && r.has(e.charAt(s)); s--)
      n++;
    return n;
  }
  getLeadingWhitespace(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(0, r);
  }
  getTrailingWhitespace(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(e.length - r);
  }
  hasLeadingWhitespace(e) {
    return R(this, V).has(e.charAt(0));
  }
  hasTrailingWhitespace(e) {
    return R(this, V).has(K(false, e, -1));
  }
  trimStart(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(r);
  }
  trimEnd(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(0, e.length - r);
  }
  trim(e) {
    return this.trimEnd(this.trimStart(e));
  }
  split(e, r = false) {
    let n = `[${dr([...R(this, V)].join(""))}]+`, s = new RegExp(r ? `(${n})` : n, "u");
    return e.split(s);
  }
  hasWhitespaceCharacter(e) {
    let r = R(this, V);
    return Array.prototype.some.call(e, (n) => r.has(n));
  }
  hasNonWhitespaceCharacter(e) {
    let r = R(this, V);
    return Array.prototype.some.call(e, (n) => !r.has(n));
  }
  isWhitespaceOnly(e) {
    let r = R(this, V);
    return Array.prototype.every.call(e, (n) => r.has(n));
  }
};
V = new WeakMap;
var En = gr;
var Li = ["	", `
`, "\f", "\r", " "];
var Fi = new En(Li);
var O = Fi;
var Cr = class extends Error {
  name = "UnexpectedNodeError";
  constructor(e, r, n = "type") {
    super(`Unexpected ${r} node ${n}: ${JSON.stringify(e[n])}.`), this.node = e;
  }
};
var An = Cr;
var Pe = Pi;
var Ni = new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan", "keySpan", "tagDefinition", "tokens", "valueTokens", "switchValueSourceSpan", "expSourceSpan", "valueSourceSpan"]);
var Ii = new Set(["if", "else if", "for", "switch", "case"]);
Dn.ignoredProperties = Ni;
var vn = Dn;
var yn = Ri;
var wn = $i;
var Oi = (t2, e) => {
  if (!(t2 && e == null))
    return e.toReversed || !Array.isArray(e) ? e.toReversed() : [...e].reverse();
};
var bn = Oi;
var me = Mi;
var Tn;
var xn;
var kn;
var Bn;
var Ln;
var qi = ((Tn = globalThis.Deno) == null ? undefined : Tn.build.os) === "windows" || ((kn = (xn = globalThis.navigator) == null ? undefined : xn.platform) == null ? undefined : kn.startsWith("Win")) || ((Ln = (Bn = globalThis.process) == null ? undefined : Bn.platform) == null ? undefined : Ln.startsWith("win")) || false;
var Nn = Pn;
var Ui = (t2) => String(t2).split(/[/\\]/u).pop();
var Ne = Gi;
var $n = "inline";
var Sr = { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", style: "none", template: "inline", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", dialog: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", search: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", menu: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", input: "inline-block", button: "inline-block", fieldset: "block", details: "block", summary: "block", marquee: "inline-block", source: "block", track: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" };
var On = "normal";
var _r = { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" };
var fe = zi;
var Yi = (t2) => w(false, t2, /^[\t\f\r ]*\n/gu, "");
var Er = (t2) => Yi(O.trimEnd(t2));
var Mn = (t2) => {
  let e = t2, r = O.getLeadingWhitespace(e);
  r && (e = e.slice(r.length));
  let n = O.getTrailingWhitespace(e);
  return n && (e = e.slice(0, -n.length)), { leadingWhitespace: r, trailingWhitespace: n, text: e };
};
var oa = new Set(["template", "style", "script"]);
var br = /\{\{(.+?)\}\}/su;
var ua = Tr({ parser: "__ng_action" });
var la = Tr({ parser: "__ng_binding" });
var ca = Tr({ parser: "__ng_directive" });
var rs = pa;
var ns = ha;
var ma = /^[ \t\n\r\u000c]+/;
var fa = /^[, \t\n\r\u000c]+/;
var da = /^[^ \t\n\r\u000c]+/;
var ga = /[,]+$/;
var is2 = /^\d+$/;
var Ca = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
var as = Sa;
var os2 = { width: "w", height: "h", density: "x" };
var Ea = Object.keys(os2);
var us = _a;
var xr = new WeakMap;
var Ie = Da;
var fs2 = ya;
var ds = Ta;
var ka = new Proxy(() => {
}, { get: () => ka });
var gs = "<!doctype";
var Nt = Ia;
var Ra = new Set(["if", "else if", "for", "switch", "case"]);
var Ss = $a;
var it = null;
var Oa = 10;
for (let t2 = 0;t2 <= Oa; t2++)
  at();
var _s = Ma;
var qa = { "front-matter": [], root: ["children"], element: ["attrs", "children"], ieConditionalComment: ["children"], ieConditionalStartComment: [], ieConditionalEndComment: [], interpolation: ["children"], text: ["children"], docType: [], comment: [], attribute: [], cdata: [], angularControlFlowBlock: ["children", "parameters"], angularControlFlowBlockParameters: ["children"], angularControlFlowBlockParameter: [], angularLetDeclaration: ["init"], angularLetDeclarationInitializer: [], angularIcuExpression: ["cases"], angularIcuCase: ["expression"] };
var Es = qa;
var Ha = _s(Es);
var As = Ha;
var Ds = "format";
var vs = /^\s*<!--\s*@(?:noformat|noprettier)\s*-->/u;
var ys = /^\s*<!--\s*@(?:format|prettier)\s*-->/u;
var xs = new Map([["if", new Set(["else if", "else"])], ["else if", new Set(["else if", "else"])], ["for", new Set(["empty"])], ["defer", new Set(["placeholder", "error", "loading"])], ["placeholder", new Set(["placeholder", "error", "loading"])], ["error", new Set(["placeholder", "error", "loading"])], ["loading", new Set(["placeholder", "error", "loading"])]]);
var Ua = /-+([a-z0-9])/g;
var ie = class t2 {
  constructor(e, r, n, s) {
    this.file = e, this.offset = r, this.line = n, this.col = s;
  }
  toString() {
    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
  }
  moveBy(e) {
    let r = this.file.content, n = r.length, s = this.offset, i = this.line, a = this.col;
    for (;s > 0 && e < 0; )
      if (s--, e++, r.charCodeAt(s) == 10) {
        i--;
        let u = r.substring(0, s - 1).lastIndexOf(String.fromCharCode(10));
        a = u > 0 ? s - u : s;
      } else
        a--;
    for (;s < n && e > 0; ) {
      let o = r.charCodeAt(s);
      s++, e--, o == 10 ? (i++, a = 0) : a++;
    }
    return new t2(this.file, s, i, a);
  }
  getContext(e, r) {
    let n = this.file.content, s = this.offset;
    if (s != null) {
      s > n.length - 1 && (s = n.length - 1);
      let i = s, a = 0, o = 0;
      for (;a < e && s > 0 && (s--, a++, !(n[s] == `
` && ++o == r)); )
        ;
      for (a = 0, o = 0;a < e && i < n.length - 1 && (i++, a++, !(n[i] == `
` && ++o == r)); )
        ;
      return { before: n.substring(s, this.offset), after: n.substring(this.offset, i + 1) };
    }
    return null;
  }
};
var ve = class {
  constructor(e, r) {
    this.content = e, this.url = r;
  }
};
var h = class {
  constructor(e, r, n = e, s = null) {
    this.start = e, this.end = r, this.fullStart = n, this.details = s;
  }
  toString() {
    return this.start.file.content.substring(this.start.offset, this.end.offset);
  }
};
var Mt;
(function(t3) {
  t3[t3.WARNING = 0] = "WARNING", t3[t3.ERROR = 1] = "ERROR";
})(Mt || (Mt = {}));
var Oe = class {
  constructor(e, r, n = Mt.ERROR, s) {
    this.span = e, this.msg = r, this.level = n, this.relatedError = s;
  }
  contextualMessage() {
    let e = this.span.start.getContext(100, 3);
    return e ? `${this.msg} ("${e.before}[${Mt[this.level]} ->]${e.after}")` : this.msg;
  }
  toString() {
    let e = this.span.details ? `, ${this.span.details}` : "";
    return `${this.contextualMessage()}: ${this.span.start}${e}`;
  }
};
var Wa = [za, Ya, Ka, Qa, Ja, to, Za, eo, ro, Xa];
var Ms = Ga;
var so = { preprocess: Ms, print: no, insertPragma: Ts, massageAstNode: vn, embed: Ss, getVisitorKeys: As };
var qs = so;
var Hs = [{ name: "Angular", type: "markup", extensions: [".component.html"], tmScope: "text.html.basic", aceMode: "html", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["angular"], vscodeLanguageIds: ["html"], filenames: [], linguistLanguageId: 146 }, { name: "HTML", type: "markup", extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], tmScope: "text.html.basic", aceMode: "html", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["html"], vscodeLanguageIds: ["html"], linguistLanguageId: 146 }, { name: "Lightning Web Components", type: "markup", extensions: [], tmScope: "text.html.basic", aceMode: "html", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["lwc"], vscodeLanguageIds: ["html"], filenames: [], linguistLanguageId: 146 }, { name: "MJML", type: "markup", extensions: [".mjml"], tmScope: "text.mjml.basic", aceMode: "html", aliases: ["MJML", "mjml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["mjml"], filenames: [], vscodeLanguageIds: ["mjml"], linguistLanguageId: 146 }, { name: "Vue", type: "markup", extensions: [".vue"], tmScope: "source.vue", aceMode: "html", parsers: ["vue"], vscodeLanguageIds: ["vue"], linguistLanguageId: 391 }];
var Lr = { bracketSpacing: { category: "Common", type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, objectWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap object literals.", choices: [{ value: "preserve", description: "Keep as multi-line, if there is a newline between the opening brace and first property." }, { value: "collapse", description: "Fit to a single line when possible." }] }, singleQuote: { category: "Common", type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
var Vs = "HTML";
var io = { bracketSameLine: Lr.bracketSameLine, htmlWhitespaceSensitivity: { category: Vs, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: Lr.singleAttributePerLine, vueIndentScriptAndStyle: { category: Vs, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
var Us = io;
var tn = {};
ln(tn, { angular: () => iu, html: () => ru, lwc: () => ou, mjml: () => su, vue: () => au });
var ah = new RegExp(`(\\:not\\()|(([\\.\\#]?)[-\\w]+)|(?:\\[([-.\\w*\\\\\$]+)(?:=(["']?)([^\\]"']*)\\5)?\\])|(\\))|(\\s*,\\s*)`, "g");
var Ws;
(function(t3) {
  t3[t3.Emulated = 0] = "Emulated", t3[t3.None = 2] = "None", t3[t3.ShadowDom = 3] = "ShadowDom";
})(Ws || (Ws = {}));
var Gs;
(function(t3) {
  t3[t3.OnPush = 0] = "OnPush", t3[t3.Default = 1] = "Default";
})(Gs || (Gs = {}));
var zs;
(function(t3) {
  t3[t3.None = 0] = "None", t3[t3.SignalBased = 1] = "SignalBased", t3[t3.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform";
})(zs || (zs = {}));
var Fr = { name: "custom-elements" };
var Pr = { name: "no-errors-schema" };
var Z;
(function(t3) {
  t3[t3.NONE = 0] = "NONE", t3[t3.HTML = 1] = "HTML", t3[t3.STYLE = 2] = "STYLE", t3[t3.SCRIPT = 3] = "SCRIPT", t3[t3.URL = 4] = "URL", t3[t3.RESOURCE_URL = 5] = "RESOURCE_URL";
})(Z || (Z = {}));
var Ys;
(function(t3) {
  t3[t3.Error = 0] = "Error", t3[t3.Warning = 1] = "Warning", t3[t3.Ignore = 2] = "Ignore";
})(Ys || (Ys = {}));
var N;
(function(t3) {
  t3[t3.RAW_TEXT = 0] = "RAW_TEXT", t3[t3.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", t3[t3.PARSABLE_DATA = 2] = "PARSABLE_DATA";
})(N || (N = {}));
var Ht;
var Vt = class {
};
var ao = "boolean";
var oo = "number";
var uo = "string";
var lo = "object";
var co = ["[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored", "[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,!inert,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume", ":svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":svg:graphics^:svg:|", ":svg:animation^:svg:|*begin,*end,*repeat", ":svg:geometry^:svg:|", ":svg:componentTransferFunction^:svg:|", ":svg:gradient^:svg:|", ":svg:textContent^:svg:graphics|", ":svg:textPositioning^:svg:textContent|", "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username", "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username", "audio^media|", "br^[HTMLElement]|clear", "base^[HTMLElement]|href,target", "body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink", "button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value", "canvas^[HTMLElement]|#height,#width", "content^[HTMLElement]|select", "dl^[HTMLElement]|!compact", "data^[HTMLElement]|value", "datalist^[HTMLElement]|", "details^[HTMLElement]|!open", "dialog^[HTMLElement]|!open,returnValue", "dir^[HTMLElement]|!compact", "div^[HTMLElement]|align", "embed^[HTMLElement]|align,height,name,src,type,width", "fieldset^[HTMLElement]|!disabled,name", "font^[HTMLElement]|color,face,size", "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target", "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src", "frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows", "hr^[HTMLElement]|align,color,!noShade,size,width", "head^[HTMLElement]|", "h1,h2,h3,h4,h5,h6^[HTMLElement]|align", "html^[HTMLElement]|version", "iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width", "img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width", "input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width", "li^[HTMLElement]|type,#value", "label^[HTMLElement]|htmlFor", "legend^[HTMLElement]|align", "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type", "map^[HTMLElement]|name", "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width", "menu^[HTMLElement]|!compact", "meta^[HTMLElement]|content,httpEquiv,media,name,scheme", "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value", "ins,del^[HTMLElement]|cite,dateTime", "ol^[HTMLElement]|!compact,!reversed,#start,type", "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width", "optgroup^[HTMLElement]|!disabled,label", "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value", "output^[HTMLElement]|defaultValue,%htmlFor,name,value", "p^[HTMLElement]|align", "param^[HTMLElement]|name,type,value,valueType", "picture^[HTMLElement]|", "pre^[HTMLElement]|#width", "progress^[HTMLElement]|#max,#value", "q,blockquote,cite^[HTMLElement]|", "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type", "select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value", "slot^[HTMLElement]|name", "source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width", "span^[HTMLElement]|", "style^[HTMLElement]|!disabled,media,type", "caption^[HTMLElement]|align", "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width", "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width", "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width", "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign", "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign", "template^[HTMLElement]|", "textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap", "time^[HTMLElement]|dateTime", "title^[HTMLElement]|text", "track^[HTMLElement]|!default,kind,label,src,srclang", "ul^[HTMLElement]|!compact,type", "unknown^[HTMLElement]|", "video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width", ":svg:a^:svg:graphics|", ":svg:animate^:svg:animation|", ":svg:animateMotion^:svg:animation|", ":svg:animateTransform^:svg:animation|", ":svg:circle^:svg:geometry|", ":svg:clipPath^:svg:graphics|", ":svg:defs^:svg:graphics|", ":svg:desc^:svg:|", ":svg:discard^:svg:|", ":svg:ellipse^:svg:geometry|", ":svg:feBlend^:svg:|", ":svg:feColorMatrix^:svg:|", ":svg:feComponentTransfer^:svg:|", ":svg:feComposite^:svg:|", ":svg:feConvolveMatrix^:svg:|", ":svg:feDiffuseLighting^:svg:|", ":svg:feDisplacementMap^:svg:|", ":svg:feDistantLight^:svg:|", ":svg:feDropShadow^:svg:|", ":svg:feFlood^:svg:|", ":svg:feFuncA^:svg:componentTransferFunction|", ":svg:feFuncB^:svg:componentTransferFunction|", ":svg:feFuncG^:svg:componentTransferFunction|", ":svg:feFuncR^:svg:componentTransferFunction|", ":svg:feGaussianBlur^:svg:|", ":svg:feImage^:svg:|", ":svg:feMerge^:svg:|", ":svg:feMergeNode^:svg:|", ":svg:feMorphology^:svg:|", ":svg:feOffset^:svg:|", ":svg:fePointLight^:svg:|", ":svg:feSpecularLighting^:svg:|", ":svg:feSpotLight^:svg:|", ":svg:feTile^:svg:|", ":svg:feTurbulence^:svg:|", ":svg:filter^:svg:|", ":svg:foreignObject^:svg:graphics|", ":svg:g^:svg:graphics|", ":svg:image^:svg:graphics|decoding", ":svg:line^:svg:geometry|", ":svg:linearGradient^:svg:gradient|", ":svg:mpath^:svg:|", ":svg:marker^:svg:|", ":svg:mask^:svg:|", ":svg:metadata^:svg:|", ":svg:path^:svg:geometry|", ":svg:pattern^:svg:|", ":svg:polygon^:svg:geometry|", ":svg:polyline^:svg:geometry|", ":svg:radialGradient^:svg:gradient|", ":svg:rect^:svg:geometry|", ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan", ":svg:script^:svg:|type", ":svg:set^:svg:animation|", ":svg:stop^:svg:|", ":svg:style^:svg:|!disabled,media,title,type", ":svg:switch^:svg:graphics|", ":svg:symbol^:svg:|", ":svg:tspan^:svg:textPositioning|", ":svg:text^:svg:textPositioning|", ":svg:textPath^:svg:textContent|", ":svg:title^:svg:|", ":svg:use^:svg:graphics|", ":svg:view^:svg:|#zoomAndPan", "data^[HTMLElement]|value", "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name", "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default", "summary^[HTMLElement]|", "time^[HTMLElement]|dateTime", ":svg:cursor^:svg:|", ":math:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforeinput,*beforematch,*beforetoggle,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contentvisibilityautostatechange,*contextlost,*contextmenu,*contextrestored,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*scrollend,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":math:math^:math:|", ":math:maction^:math:|", ":math:menclose^:math:|", ":math:merror^:math:|", ":math:mfenced^:math:|", ":math:mfrac^:math:|", ":math:mi^:math:|", ":math:mmultiscripts^:math:|", ":math:mn^:math:|", ":math:mo^:math:|", ":math:mover^:math:|", ":math:mpadded^:math:|", ":math:mphantom^:math:|", ":math:mroot^:math:|", ":math:mrow^:math:|", ":math:ms^:math:|", ":math:mspace^:math:|", ":math:msqrt^:math:|", ":math:mstyle^:math:|", ":math:msub^:math:|", ":math:msubsup^:math:|", ":math:msup^:math:|", ":math:mtable^:math:|", ":math:mtd^:math:|", ":math:mtext^:math:|", ":math:mtr^:math:|", ":math:munder^:math:|", ":math:munderover^:math:|", ":math:semantics^:math:|"];
var js = new Map(Object.entries({ class: "className", for: "htmlFor", formaction: "formAction", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex" }));
var po = Array.from(js).reduce((t3, [e, r]) => (t3.set(e, r), t3), new Map);
var Ut = class extends Vt {
  constructor() {
    super(), this._schema = new Map, this._eventSchema = new Map, co.forEach((e) => {
      let r = new Map, n = new Set, [s, i] = e.split("|"), a = i.split(","), [o, u] = s.split("^");
      o.split(",").forEach((l) => {
        this._schema.set(l.toLowerCase(), r), this._eventSchema.set(l.toLowerCase(), n);
      });
      let p = u && this._schema.get(u.toLowerCase());
      if (p) {
        for (let [l, m] of p)
          r.set(l, m);
        for (let l of this._eventSchema.get(u.toLowerCase()))
          n.add(l);
      }
      a.forEach((l) => {
        if (l.length > 0)
          switch (l[0]) {
            case "*":
              n.add(l.substring(1));
              break;
            case "!":
              r.set(l.substring(1), ao);
              break;
            case "#":
              r.set(l.substring(1), oo);
              break;
            case "%":
              r.set(l.substring(1), lo);
              break;
            default:
              r.set(l, uo);
          }
      });
    });
  }
  hasProperty(e, r, n) {
    if (n.some((i) => i.name === Pr.name))
      return true;
    if (e.indexOf("-") > -1) {
      if (Nr(e) || Ir(e))
        return false;
      if (n.some((i) => i.name === Fr.name))
        return true;
    }
    return (this._schema.get(e.toLowerCase()) || this._schema.get("unknown")).has(r);
  }
  hasElement(e, r) {
    return r.some((n) => n.name === Pr.name) || e.indexOf("-") > -1 && (Nr(e) || Ir(e) || r.some((n) => n.name === Fr.name)) ? true : this._schema.has(e.toLowerCase());
  }
  securityContext(e, r, n) {
    n && (r = this.getMappedPropName(r)), e = e.toLowerCase(), r = r.toLowerCase();
    let s = Rr()[e + "|" + r];
    return s || (s = Rr()["*|" + r], s || Z.NONE);
  }
  getMappedPropName(e) {
    return js.get(e) ?? e;
  }
  getDefaultComponentElementName() {
    return "ng-component";
  }
  validateProperty(e) {
    return e.toLowerCase().startsWith("on") ? { error: true, msg: `Binding to event property '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...
If '${e}' is a directive input, make sure the directive is imported by the current module.` } : { error: false };
  }
  validateAttribute(e) {
    return e.toLowerCase().startsWith("on") ? { error: true, msg: `Binding to event attribute '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...` } : { error: false };
  }
  allKnownElementNames() {
    return Array.from(this._schema.keys());
  }
  allKnownAttributesOfElement(e) {
    let r = this._schema.get(e.toLowerCase()) || this._schema.get("unknown");
    return Array.from(r.keys()).map((n) => po.get(n) ?? n);
  }
  allKnownEventsOfElement(e) {
    return Array.from(this._eventSchema.get(e.toLowerCase()) ?? []);
  }
  normalizeAnimationStyleProperty(e) {
    return Os(e);
  }
  normalizeAnimationStyleValue(e, r, n) {
    let s = "", i = n.toString().trim(), a = null;
    if (ho(e) && n !== 0 && n !== "0")
      if (typeof n == "number")
        s = "px";
      else {
        let o = n.match(/^[+-]?[\d\.]+([a-z]*)$/);
        o && o[1].length == 0 && (a = `Please provide a CSS unit value for ${r}:${n}`);
      }
    return { error: a, value: i + s };
  }
};
var d = class {
  constructor({ closedByChildren: e, implicitNamespacePrefix: r, contentType: n = N.PARSABLE_DATA, closedByParent: s = false, isVoid: i = false, ignoreFirstLf: a = false, preventNamespaceInheritance: o = false, canSelfClose: u = false } = {}) {
    this.closedByChildren = {}, this.closedByParent = false, e && e.length > 0 && e.forEach((p) => this.closedByChildren[p] = true), this.isVoid = i, this.closedByParent = s || i, this.implicitNamespacePrefix = r || null, this.contentType = n, this.ignoreFirstLf = a, this.preventNamespaceInheritance = o, this.canSelfClose = u ?? i;
  }
  isClosedByChild(e) {
    return this.isVoid || e.toLowerCase() in this.closedByChildren;
  }
  getContentType(e) {
    return typeof this.contentType == "object" ? (e === undefined ? undefined : this.contentType[e]) ?? this.contentType.default : this.contentType;
  }
};
var Ks;
var pt;
var ae = class {
  constructor(e, r) {
    this.sourceSpan = e, this.i18n = r;
  }
};
var Wt = class extends ae {
  constructor(e, r, n, s) {
    super(r, s), this.value = e, this.tokens = n, this.type = "text";
  }
  visit(e, r) {
    return e.visitText(this, r);
  }
};
var Gt = class extends ae {
  constructor(e, r, n, s) {
    super(r, s), this.value = e, this.tokens = n, this.type = "cdata";
  }
  visit(e, r) {
    return e.visitCdata(this, r);
  }
};
var zt = class extends ae {
  constructor(e, r, n, s, i, a) {
    super(s, a), this.switchValue = e, this.type = r, this.cases = n, this.switchValueSourceSpan = i;
  }
  visit(e, r) {
    return e.visitExpansion(this, r);
  }
};
var Yt = class {
  constructor(e, r, n, s, i) {
    this.value = e, this.expression = r, this.sourceSpan = n, this.valueSourceSpan = s, this.expSourceSpan = i, this.type = "expansionCase";
  }
  visit(e, r) {
    return e.visitExpansionCase(this, r);
  }
};
var jt = class extends ae {
  constructor(e, r, n, s, i, a, o) {
    super(n, o), this.name = e, this.value = r, this.keySpan = s, this.valueSpan = i, this.valueTokens = a, this.type = "attribute";
  }
  visit(e, r) {
    return e.visitAttribute(this, r);
  }
  get nameSpan() {
    return this.keySpan;
  }
};
var Y = class extends ae {
  constructor(e, r, n, s, i, a = null, o = null, u) {
    super(s, u), this.name = e, this.attrs = r, this.children = n, this.startSourceSpan = i, this.endSourceSpan = a, this.nameSpan = o, this.type = "element";
  }
  visit(e, r) {
    return e.visitElement(this, r);
  }
};
var Kt = class {
  constructor(e, r) {
    this.value = e, this.sourceSpan = r, this.type = "comment";
  }
  visit(e, r) {
    return e.visitComment(this, r);
  }
};
var Xt = class {
  constructor(e, r) {
    this.value = e, this.sourceSpan = r, this.type = "docType";
  }
  visit(e, r) {
    return e.visitDocType(this, r);
  }
};
var ee = class extends ae {
  constructor(e, r, n, s, i, a, o = null, u) {
    super(s, u), this.name = e, this.parameters = r, this.children = n, this.nameSpan = i, this.startSourceSpan = a, this.endSourceSpan = o, this.type = "block";
  }
  visit(e, r) {
    return e.visitBlock(this, r);
  }
};
var ht = class {
  constructor(e, r) {
    this.expression = e, this.sourceSpan = r, this.type = "blockParameter", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e, r) {
    return e.visitBlockParameter(this, r);
  }
};
var mt = class {
  constructor(e, r, n, s, i) {
    this.name = e, this.value = r, this.sourceSpan = n, this.nameSpan = s, this.valueSpan = i, this.type = "letDeclaration", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e, r) {
    return e.visitLetDeclaration(this, r);
  }
};
var ft = class {
  constructor() {
  }
  visitElement(e, r) {
    this.visitChildren(r, (n) => {
      n(e.attrs), n(e.children);
    });
  }
  visitAttribute(e, r) {
  }
  visitText(e, r) {
  }
  visitCdata(e, r) {
  }
  visitComment(e, r) {
  }
  visitDocType(e, r) {
  }
  visitExpansion(e, r) {
    return this.visitChildren(r, (n) => {
      n(e.cases);
    });
  }
  visitExpansionCase(e, r) {
  }
  visitBlock(e, r) {
    this.visitChildren(r, (n) => {
      n(e.parameters), n(e.children);
    });
  }
  visitBlockParameter(e, r) {
  }
  visitLetDeclaration(e, r) {
  }
  visitChildren(e, r) {
    let n = [], s = this;
    function i(a) {
      a && n.push(Qt(s, a, e));
    }
    return r(i), Array.prototype.concat.apply([], n);
  }
};
var Ve = { AElig: "\xC6", AMP: "&", amp: "&", Aacute: "\xC1", Abreve: "\u0102", Acirc: "\xC2", Acy: "\u0410", Afr: "\uD835\uDD04", Agrave: "\xC0", Alpha: "\u0391", Amacr: "\u0100", And: "\u2A53", Aogon: "\u0104", Aopf: "\uD835\uDD38", ApplyFunction: "\u2061", af: "\u2061", Aring: "\xC5", angst: "\xC5", Ascr: "\uD835\uDC9C", Assign: "\u2254", colone: "\u2254", coloneq: "\u2254", Atilde: "\xC3", Auml: "\xC4", Backslash: "\u2216", setminus: "\u2216", setmn: "\u2216", smallsetminus: "\u2216", ssetmn: "\u2216", Barv: "\u2AE7", Barwed: "\u2306", doublebarwedge: "\u2306", Bcy: "\u0411", Because: "\u2235", becaus: "\u2235", because: "\u2235", Bernoullis: "\u212C", Bscr: "\u212C", bernou: "\u212C", Beta: "\u0392", Bfr: "\uD835\uDD05", Bopf: "\uD835\uDD39", Breve: "\u02D8", breve: "\u02D8", Bumpeq: "\u224E", HumpDownHump: "\u224E", bump: "\u224E", CHcy: "\u0427", COPY: "\xA9", copy: "\xA9", Cacute: "\u0106", Cap: "\u22D2", CapitalDifferentialD: "\u2145", DD: "\u2145", Cayleys: "\u212D", Cfr: "\u212D", Ccaron: "\u010C", Ccedil: "\xC7", Ccirc: "\u0108", Cconint: "\u2230", Cdot: "\u010A", Cedilla: "\xB8", cedil: "\xB8", CenterDot: "\xB7", centerdot: "\xB7", middot: "\xB7", Chi: "\u03A7", CircleDot: "\u2299", odot: "\u2299", CircleMinus: "\u2296", ominus: "\u2296", CirclePlus: "\u2295", oplus: "\u2295", CircleTimes: "\u2297", otimes: "\u2297", ClockwiseContourIntegral: "\u2232", cwconint: "\u2232", CloseCurlyDoubleQuote: "\u201D", rdquo: "\u201D", rdquor: "\u201D", CloseCurlyQuote: "\u2019", rsquo: "\u2019", rsquor: "\u2019", Colon: "\u2237", Proportion: "\u2237", Colone: "\u2A74", Congruent: "\u2261", equiv: "\u2261", Conint: "\u222F", DoubleContourIntegral: "\u222F", ContourIntegral: "\u222E", conint: "\u222E", oint: "\u222E", Copf: "\u2102", complexes: "\u2102", Coproduct: "\u2210", coprod: "\u2210", CounterClockwiseContourIntegral: "\u2233", awconint: "\u2233", Cross: "\u2A2F", Cscr: "\uD835\uDC9E", Cup: "\u22D3", CupCap: "\u224D", asympeq: "\u224D", DDotrahd: "\u2911", DJcy: "\u0402", DScy: "\u0405", DZcy: "\u040F", Dagger: "\u2021", ddagger: "\u2021", Darr: "\u21A1", Dashv: "\u2AE4", DoubleLeftTee: "\u2AE4", Dcaron: "\u010E", Dcy: "\u0414", Del: "\u2207", nabla: "\u2207", Delta: "\u0394", Dfr: "\uD835\uDD07", DiacriticalAcute: "\xB4", acute: "\xB4", DiacriticalDot: "\u02D9", dot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", dblac: "\u02DD", DiacriticalGrave: "`", grave: "`", DiacriticalTilde: "\u02DC", tilde: "\u02DC", Diamond: "\u22C4", diam: "\u22C4", diamond: "\u22C4", DifferentialD: "\u2146", dd: "\u2146", Dopf: "\uD835\uDD3B", Dot: "\xA8", DoubleDot: "\xA8", die: "\xA8", uml: "\xA8", DotDot: "\u20DC", DotEqual: "\u2250", doteq: "\u2250", esdot: "\u2250", DoubleDownArrow: "\u21D3", Downarrow: "\u21D3", dArr: "\u21D3", DoubleLeftArrow: "\u21D0", Leftarrow: "\u21D0", lArr: "\u21D0", DoubleLeftRightArrow: "\u21D4", Leftrightarrow: "\u21D4", hArr: "\u21D4", iff: "\u21D4", DoubleLongLeftArrow: "\u27F8", Longleftarrow: "\u27F8", xlArr: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", Longleftrightarrow: "\u27FA", xhArr: "\u27FA", DoubleLongRightArrow: "\u27F9", Longrightarrow: "\u27F9", xrArr: "\u27F9", DoubleRightArrow: "\u21D2", Implies: "\u21D2", Rightarrow: "\u21D2", rArr: "\u21D2", DoubleRightTee: "\u22A8", vDash: "\u22A8", DoubleUpArrow: "\u21D1", Uparrow: "\u21D1", uArr: "\u21D1", DoubleUpDownArrow: "\u21D5", Updownarrow: "\u21D5", vArr: "\u21D5", DoubleVerticalBar: "\u2225", par: "\u2225", parallel: "\u2225", shortparallel: "\u2225", spar: "\u2225", DownArrow: "\u2193", ShortDownArrow: "\u2193", darr: "\u2193", downarrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", duarr: "\u21F5", DownBreve: "\u0311", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", leftharpoondown: "\u21BD", lhard: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", rhard: "\u21C1", rightharpoondown: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", top: "\u22A4", DownTeeArrow: "\u21A7", mapstodown: "\u21A7", Dscr: "\uD835\uDC9F", Dstrok: "\u0110", ENG: "\u014A", ETH: "\xD0", Eacute: "\xC9", Ecaron: "\u011A", Ecirc: "\xCA", Ecy: "\u042D", Edot: "\u0116", Efr: "\uD835\uDD08", Egrave: "\xC8", Element: "\u2208", in: "\u2208", isin: "\u2208", isinv: "\u2208", Emacr: "\u0112", EmptySmallSquare: "\u25FB", EmptyVerySmallSquare: "\u25AB", Eogon: "\u0118", Eopf: "\uD835\uDD3C", Epsilon: "\u0395", Equal: "\u2A75", EqualTilde: "\u2242", eqsim: "\u2242", esim: "\u2242", Equilibrium: "\u21CC", rightleftharpoons: "\u21CC", rlhar: "\u21CC", Escr: "\u2130", expectation: "\u2130", Esim: "\u2A73", Eta: "\u0397", Euml: "\xCB", Exists: "\u2203", exist: "\u2203", ExponentialE: "\u2147", ee: "\u2147", exponentiale: "\u2147", Fcy: "\u0424", Ffr: "\uD835\uDD09", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", blacksquare: "\u25AA", squarf: "\u25AA", squf: "\u25AA", Fopf: "\uD835\uDD3D", ForAll: "\u2200", forall: "\u2200", Fouriertrf: "\u2131", Fscr: "\u2131", GJcy: "\u0403", GT: ">", gt: ">", Gamma: "\u0393", Gammad: "\u03DC", Gbreve: "\u011E", Gcedil: "\u0122", Gcirc: "\u011C", Gcy: "\u0413", Gdot: "\u0120", Gfr: "\uD835\uDD0A", Gg: "\u22D9", ggg: "\u22D9", Gopf: "\uD835\uDD3E", GreaterEqual: "\u2265", ge: "\u2265", geq: "\u2265", GreaterEqualLess: "\u22DB", gel: "\u22DB", gtreqless: "\u22DB", GreaterFullEqual: "\u2267", gE: "\u2267", geqq: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", gl: "\u2277", gtrless: "\u2277", GreaterSlantEqual: "\u2A7E", geqslant: "\u2A7E", ges: "\u2A7E", GreaterTilde: "\u2273", gsim: "\u2273", gtrsim: "\u2273", Gscr: "\uD835\uDCA2", Gt: "\u226B", NestedGreaterGreater: "\u226B", gg: "\u226B", HARDcy: "\u042A", Hacek: "\u02C7", caron: "\u02C7", Hat: "^", Hcirc: "\u0124", Hfr: "\u210C", Poincareplane: "\u210C", HilbertSpace: "\u210B", Hscr: "\u210B", hamilt: "\u210B", Hopf: "\u210D", quaternions: "\u210D", HorizontalLine: "\u2500", boxh: "\u2500", Hstrok: "\u0126", HumpEqual: "\u224F", bumpe: "\u224F", bumpeq: "\u224F", IEcy: "\u0415", IJlig: "\u0132", IOcy: "\u0401", Iacute: "\xCD", Icirc: "\xCE", Icy: "\u0418", Idot: "\u0130", Ifr: "\u2111", Im: "\u2111", image: "\u2111", imagpart: "\u2111", Igrave: "\xCC", Imacr: "\u012A", ImaginaryI: "\u2148", ii: "\u2148", Int: "\u222C", Integral: "\u222B", int: "\u222B", Intersection: "\u22C2", bigcap: "\u22C2", xcap: "\u22C2", InvisibleComma: "\u2063", ic: "\u2063", InvisibleTimes: "\u2062", it: "\u2062", Iogon: "\u012E", Iopf: "\uD835\uDD40", Iota: "\u0399", Iscr: "\u2110", imagline: "\u2110", Itilde: "\u0128", Iukcy: "\u0406", Iuml: "\xCF", Jcirc: "\u0134", Jcy: "\u0419", Jfr: "\uD835\uDD0D", Jopf: "\uD835\uDD41", Jscr: "\uD835\uDCA5", Jsercy: "\u0408", Jukcy: "\u0404", KHcy: "\u0425", KJcy: "\u040C", Kappa: "\u039A", Kcedil: "\u0136", Kcy: "\u041A", Kfr: "\uD835\uDD0E", Kopf: "\uD835\uDD42", Kscr: "\uD835\uDCA6", LJcy: "\u0409", LT: "<", lt: "<", Lacute: "\u0139", Lambda: "\u039B", Lang: "\u27EA", Laplacetrf: "\u2112", Lscr: "\u2112", lagran: "\u2112", Larr: "\u219E", twoheadleftarrow: "\u219E", Lcaron: "\u013D", Lcedil: "\u013B", Lcy: "\u041B", LeftAngleBracket: "\u27E8", lang: "\u27E8", langle: "\u27E8", LeftArrow: "\u2190", ShortLeftArrow: "\u2190", larr: "\u2190", leftarrow: "\u2190", slarr: "\u2190", LeftArrowBar: "\u21E4", larrb: "\u21E4", LeftArrowRightArrow: "\u21C6", leftrightarrows: "\u21C6", lrarr: "\u21C6", LeftCeiling: "\u2308", lceil: "\u2308", LeftDoubleBracket: "\u27E6", lobrk: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", dharl: "\u21C3", downharpoonleft: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", lfloor: "\u230A", LeftRightArrow: "\u2194", harr: "\u2194", leftrightarrow: "\u2194", LeftRightVector: "\u294E", LeftTee: "\u22A3", dashv: "\u22A3", LeftTeeArrow: "\u21A4", mapstoleft: "\u21A4", LeftTeeVector: "\u295A", LeftTriangle: "\u22B2", vartriangleleft: "\u22B2", vltri: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", ltrie: "\u22B4", trianglelefteq: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", uharl: "\u21BF", upharpoonleft: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", leftharpoonup: "\u21BC", lharu: "\u21BC", LeftVectorBar: "\u2952", LessEqualGreater: "\u22DA", leg: "\u22DA", lesseqgtr: "\u22DA", LessFullEqual: "\u2266", lE: "\u2266", leqq: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", lg: "\u2276", LessLess: "\u2AA1", LessSlantEqual: "\u2A7D", leqslant: "\u2A7D", les: "\u2A7D", LessTilde: "\u2272", lesssim: "\u2272", lsim: "\u2272", Lfr: "\uD835\uDD0F", Ll: "\u22D8", Lleftarrow: "\u21DA", lAarr: "\u21DA", Lmidot: "\u013F", LongLeftArrow: "\u27F5", longleftarrow: "\u27F5", xlarr: "\u27F5", LongLeftRightArrow: "\u27F7", longleftrightarrow: "\u27F7", xharr: "\u27F7", LongRightArrow: "\u27F6", longrightarrow: "\u27F6", xrarr: "\u27F6", Lopf: "\uD835\uDD43", LowerLeftArrow: "\u2199", swarr: "\u2199", swarrow: "\u2199", LowerRightArrow: "\u2198", searr: "\u2198", searrow: "\u2198", Lsh: "\u21B0", lsh: "\u21B0", Lstrok: "\u0141", Lt: "\u226A", NestedLessLess: "\u226A", ll: "\u226A", Map: "\u2905", Mcy: "\u041C", MediumSpace: "\u205F", Mellintrf: "\u2133", Mscr: "\u2133", phmmat: "\u2133", Mfr: "\uD835\uDD10", MinusPlus: "\u2213", mnplus: "\u2213", mp: "\u2213", Mopf: "\uD835\uDD44", Mu: "\u039C", NJcy: "\u040A", Nacute: "\u0143", Ncaron: "\u0147", Ncedil: "\u0145", Ncy: "\u041D", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", ZeroWidthSpace: "\u200B", NewLine: `
`, Nfr: "\uD835\uDD11", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nbsp: "\xA0", Nopf: "\u2115", naturals: "\u2115", Not: "\u2AEC", NotCongruent: "\u2262", nequiv: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", npar: "\u2226", nparallel: "\u2226", nshortparallel: "\u2226", nspar: "\u2226", NotElement: "\u2209", notin: "\u2209", notinva: "\u2209", NotEqual: "\u2260", ne: "\u2260", NotEqualTilde: "\u2242\u0338", nesim: "\u2242\u0338", NotExists: "\u2204", nexist: "\u2204", nexists: "\u2204", NotGreater: "\u226F", ngt: "\u226F", ngtr: "\u226F", NotGreaterEqual: "\u2271", nge: "\u2271", ngeq: "\u2271", NotGreaterFullEqual: "\u2267\u0338", ngE: "\u2267\u0338", ngeqq: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", nGtv: "\u226B\u0338", NotGreaterLess: "\u2279", ntgl: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", NotGreaterTilde: "\u2275", ngsim: "\u2275", NotHumpDownHump: "\u224E\u0338", nbump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", nbumpe: "\u224F\u0338", NotLeftTriangle: "\u22EA", nltri: "\u22EA", ntriangleleft: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", nltrie: "\u22EC", ntrianglelefteq: "\u22EC", NotLess: "\u226E", nless: "\u226E", nlt: "\u226E", NotLessEqual: "\u2270", nle: "\u2270", nleq: "\u2270", NotLessGreater: "\u2278", ntlg: "\u2278", NotLessLess: "\u226A\u0338", nLtv: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", NotLessTilde: "\u2274", nlsim: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", NotPrecedes: "\u2280", npr: "\u2280", nprec: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", npre: "\u2AAF\u0338", npreceq: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", nprcue: "\u22E0", NotReverseElement: "\u220C", notni: "\u220C", notniva: "\u220C", NotRightTriangle: "\u22EB", nrtri: "\u22EB", ntriangleright: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", nrtrie: "\u22ED", ntrianglerighteq: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", nsqsube: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", nsqsupe: "\u22E3", NotSubset: "\u2282\u20D2", nsubset: "\u2282\u20D2", vnsub: "\u2282\u20D2", NotSubsetEqual: "\u2288", nsube: "\u2288", nsubseteq: "\u2288", NotSucceeds: "\u2281", nsc: "\u2281", nsucc: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", nsce: "\u2AB0\u0338", nsucceq: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", nsccue: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", nsupset: "\u2283\u20D2", vnsup: "\u2283\u20D2", NotSupersetEqual: "\u2289", nsupe: "\u2289", nsupseteq: "\u2289", NotTilde: "\u2241", nsim: "\u2241", NotTildeEqual: "\u2244", nsime: "\u2244", nsimeq: "\u2244", NotTildeFullEqual: "\u2247", ncong: "\u2247", NotTildeTilde: "\u2249", nap: "\u2249", napprox: "\u2249", NotVerticalBar: "\u2224", nmid: "\u2224", nshortmid: "\u2224", nsmid: "\u2224", Nscr: "\uD835\uDCA9", Ntilde: "\xD1", Nu: "\u039D", OElig: "\u0152", Oacute: "\xD3", Ocirc: "\xD4", Ocy: "\u041E", Odblac: "\u0150", Ofr: "\uD835\uDD12", Ograve: "\xD2", Omacr: "\u014C", Omega: "\u03A9", ohm: "\u03A9", Omicron: "\u039F", Oopf: "\uD835\uDD46", OpenCurlyDoubleQuote: "\u201C", ldquo: "\u201C", OpenCurlyQuote: "\u2018", lsquo: "\u2018", Or: "\u2A54", Oscr: "\uD835\uDCAA", Oslash: "\xD8", Otilde: "\xD5", Otimes: "\u2A37", Ouml: "\xD6", OverBar: "\u203E", oline: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", tbrk: "\u23B4", OverParenthesis: "\u23DC", PartialD: "\u2202", part: "\u2202", Pcy: "\u041F", Pfr: "\uD835\uDD13", Phi: "\u03A6", Pi: "\u03A0", PlusMinus: "\xB1", plusmn: "\xB1", pm: "\xB1", Popf: "\u2119", primes: "\u2119", Pr: "\u2ABB", Precedes: "\u227A", pr: "\u227A", prec: "\u227A", PrecedesEqual: "\u2AAF", pre: "\u2AAF", preceq: "\u2AAF", PrecedesSlantEqual: "\u227C", prcue: "\u227C", preccurlyeq: "\u227C", PrecedesTilde: "\u227E", precsim: "\u227E", prsim: "\u227E", Prime: "\u2033", Product: "\u220F", prod: "\u220F", Proportional: "\u221D", prop: "\u221D", propto: "\u221D", varpropto: "\u221D", vprop: "\u221D", Pscr: "\uD835\uDCAB", Psi: "\u03A8", QUOT: '"', quot: '"', Qfr: "\uD835\uDD14", Qopf: "\u211A", rationals: "\u211A", Qscr: "\uD835\uDCAC", RBarr: "\u2910", drbkarow: "\u2910", REG: "\xAE", circledR: "\xAE", reg: "\xAE", Racute: "\u0154", Rang: "\u27EB", Rarr: "\u21A0", twoheadrightarrow: "\u21A0", Rarrtl: "\u2916", Rcaron: "\u0158", Rcedil: "\u0156", Rcy: "\u0420", Re: "\u211C", Rfr: "\u211C", real: "\u211C", realpart: "\u211C", ReverseElement: "\u220B", SuchThat: "\u220B", ni: "\u220B", niv: "\u220B", ReverseEquilibrium: "\u21CB", leftrightharpoons: "\u21CB", lrhar: "\u21CB", ReverseUpEquilibrium: "\u296F", duhar: "\u296F", Rho: "\u03A1", RightAngleBracket: "\u27E9", rang: "\u27E9", rangle: "\u27E9", RightArrow: "\u2192", ShortRightArrow: "\u2192", rarr: "\u2192", rightarrow: "\u2192", srarr: "\u2192", RightArrowBar: "\u21E5", rarrb: "\u21E5", RightArrowLeftArrow: "\u21C4", rightleftarrows: "\u21C4", rlarr: "\u21C4", RightCeiling: "\u2309", rceil: "\u2309", RightDoubleBracket: "\u27E7", robrk: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", dharr: "\u21C2", downharpoonright: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", rfloor: "\u230B", RightTee: "\u22A2", vdash: "\u22A2", RightTeeArrow: "\u21A6", map: "\u21A6", mapsto: "\u21A6", RightTeeVector: "\u295B", RightTriangle: "\u22B3", vartriangleright: "\u22B3", vrtri: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", rtrie: "\u22B5", trianglerighteq: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", uharr: "\u21BE", upharpoonright: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", rharu: "\u21C0", rightharpoonup: "\u21C0", RightVectorBar: "\u2953", Ropf: "\u211D", reals: "\u211D", RoundImplies: "\u2970", Rrightarrow: "\u21DB", rAarr: "\u21DB", Rscr: "\u211B", realine: "\u211B", Rsh: "\u21B1", rsh: "\u21B1", RuleDelayed: "\u29F4", SHCHcy: "\u0429", SHcy: "\u0428", SOFTcy: "\u042C", Sacute: "\u015A", Sc: "\u2ABC", Scaron: "\u0160", Scedil: "\u015E", Scirc: "\u015C", Scy: "\u0421", Sfr: "\uD835\uDD16", ShortUpArrow: "\u2191", UpArrow: "\u2191", uarr: "\u2191", uparrow: "\u2191", Sigma: "\u03A3", SmallCircle: "\u2218", compfn: "\u2218", Sopf: "\uD835\uDD4A", Sqrt: "\u221A", radic: "\u221A", Square: "\u25A1", squ: "\u25A1", square: "\u25A1", SquareIntersection: "\u2293", sqcap: "\u2293", SquareSubset: "\u228F", sqsub: "\u228F", sqsubset: "\u228F", SquareSubsetEqual: "\u2291", sqsube: "\u2291", sqsubseteq: "\u2291", SquareSuperset: "\u2290", sqsup: "\u2290", sqsupset: "\u2290", SquareSupersetEqual: "\u2292", sqsupe: "\u2292", sqsupseteq: "\u2292", SquareUnion: "\u2294", sqcup: "\u2294", Sscr: "\uD835\uDCAE", Star: "\u22C6", sstarf: "\u22C6", Sub: "\u22D0", Subset: "\u22D0", SubsetEqual: "\u2286", sube: "\u2286", subseteq: "\u2286", Succeeds: "\u227B", sc: "\u227B", succ: "\u227B", SucceedsEqual: "\u2AB0", sce: "\u2AB0", succeq: "\u2AB0", SucceedsSlantEqual: "\u227D", sccue: "\u227D", succcurlyeq: "\u227D", SucceedsTilde: "\u227F", scsim: "\u227F", succsim: "\u227F", Sum: "\u2211", sum: "\u2211", Sup: "\u22D1", Supset: "\u22D1", Superset: "\u2283", sup: "\u2283", supset: "\u2283", SupersetEqual: "\u2287", supe: "\u2287", supseteq: "\u2287", THORN: "\xDE", TRADE: "\u2122", trade: "\u2122", TSHcy: "\u040B", TScy: "\u0426", Tab: "	", Tau: "\u03A4", Tcaron: "\u0164", Tcedil: "\u0162", Tcy: "\u0422", Tfr: "\uD835\uDD17", Therefore: "\u2234", there4: "\u2234", therefore: "\u2234", Theta: "\u0398", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", Tilde: "\u223C", sim: "\u223C", thicksim: "\u223C", thksim: "\u223C", TildeEqual: "\u2243", sime: "\u2243", simeq: "\u2243", TildeFullEqual: "\u2245", cong: "\u2245", TildeTilde: "\u2248", ap: "\u2248", approx: "\u2248", asymp: "\u2248", thickapprox: "\u2248", thkap: "\u2248", Topf: "\uD835\uDD4B", TripleDot: "\u20DB", tdot: "\u20DB", Tscr: "\uD835\uDCAF", Tstrok: "\u0166", Uacute: "\xDA", Uarr: "\u219F", Uarrocir: "\u2949", Ubrcy: "\u040E", Ubreve: "\u016C", Ucirc: "\xDB", Ucy: "\u0423", Udblac: "\u0170", Ufr: "\uD835\uDD18", Ugrave: "\xD9", Umacr: "\u016A", UnderBar: "_", lowbar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", bbrk: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", bigcup: "\u22C3", xcup: "\u22C3", UnionPlus: "\u228E", uplus: "\u228E", Uogon: "\u0172", Uopf: "\uD835\uDD4C", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", udarr: "\u21C5", UpDownArrow: "\u2195", updownarrow: "\u2195", varr: "\u2195", UpEquilibrium: "\u296E", udhar: "\u296E", UpTee: "\u22A5", bot: "\u22A5", bottom: "\u22A5", perp: "\u22A5", UpTeeArrow: "\u21A5", mapstoup: "\u21A5", UpperLeftArrow: "\u2196", nwarr: "\u2196", nwarrow: "\u2196", UpperRightArrow: "\u2197", nearr: "\u2197", nearrow: "\u2197", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", Uring: "\u016E", Uscr: "\uD835\uDCB0", Utilde: "\u0168", Uuml: "\xDC", VDash: "\u22AB", Vbar: "\u2AEB", Vcy: "\u0412", Vdash: "\u22A9", Vdashl: "\u2AE6", Vee: "\u22C1", bigvee: "\u22C1", xvee: "\u22C1", Verbar: "\u2016", Vert: "\u2016", VerticalBar: "\u2223", mid: "\u2223", shortmid: "\u2223", smid: "\u2223", VerticalLine: "|", verbar: "|", vert: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", wr: "\u2240", wreath: "\u2240", VeryThinSpace: "\u200A", hairsp: "\u200A", Vfr: "\uD835\uDD19", Vopf: "\uD835\uDD4D", Vscr: "\uD835\uDCB1", Vvdash: "\u22AA", Wcirc: "\u0174", Wedge: "\u22C0", bigwedge: "\u22C0", xwedge: "\u22C0", Wfr: "\uD835\uDD1A", Wopf: "\uD835\uDD4E", Wscr: "\uD835\uDCB2", Xfr: "\uD835\uDD1B", Xi: "\u039E", Xopf: "\uD835\uDD4F", Xscr: "\uD835\uDCB3", YAcy: "\u042F", YIcy: "\u0407", YUcy: "\u042E", Yacute: "\xDD", Ycirc: "\u0176", Ycy: "\u042B", Yfr: "\uD835\uDD1C", Yopf: "\uD835\uDD50", Yscr: "\uD835\uDCB4", Yuml: "\u0178", ZHcy: "\u0416", Zacute: "\u0179", Zcaron: "\u017D", Zcy: "\u0417", Zdot: "\u017B", Zeta: "\u0396", Zfr: "\u2128", zeetrf: "\u2128", Zopf: "\u2124", integers: "\u2124", Zscr: "\uD835\uDCB5", aacute: "\xE1", abreve: "\u0103", ac: "\u223E", mstpos: "\u223E", acE: "\u223E\u0333", acd: "\u223F", acirc: "\xE2", acy: "\u0430", aelig: "\xE6", afr: "\uD835\uDD1E", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", alpha: "\u03B1", amacr: "\u0101", amalg: "\u2A3F", and: "\u2227", wedge: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", angle: "\u2220", ange: "\u29A4", angmsd: "\u2221", measuredangle: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angzarr: "\u237C", aogon: "\u0105", aopf: "\uD835\uDD52", apE: "\u2A70", apacir: "\u2A6F", ape: "\u224A", approxeq: "\u224A", apid: "\u224B", apos: "'", aring: "\xE5", ascr: "\uD835\uDCB6", ast: "*", midast: "*", atilde: "\xE3", auml: "\xE4", awint: "\u2A11", bNot: "\u2AED", backcong: "\u224C", bcong: "\u224C", backepsilon: "\u03F6", bepsi: "\u03F6", backprime: "\u2035", bprime: "\u2035", backsim: "\u223D", bsim: "\u223D", backsimeq: "\u22CD", bsime: "\u22CD", barvee: "\u22BD", barwed: "\u2305", barwedge: "\u2305", bbrktbrk: "\u23B6", bcy: "\u0431", bdquo: "\u201E", ldquor: "\u201E", bemptyv: "\u29B0", beta: "\u03B2", beth: "\u2136", between: "\u226C", twixt: "\u226C", bfr: "\uD835\uDD1F", bigcirc: "\u25EF", xcirc: "\u25EF", bigodot: "\u2A00", xodot: "\u2A00", bigoplus: "\u2A01", xoplus: "\u2A01", bigotimes: "\u2A02", xotime: "\u2A02", bigsqcup: "\u2A06", xsqcup: "\u2A06", bigstar: "\u2605", starf: "\u2605", bigtriangledown: "\u25BD", xdtri: "\u25BD", bigtriangleup: "\u25B3", xutri: "\u25B3", biguplus: "\u2A04", xuplus: "\u2A04", bkarow: "\u290D", rbarr: "\u290D", blacklozenge: "\u29EB", lozf: "\u29EB", blacktriangle: "\u25B4", utrif: "\u25B4", blacktriangledown: "\u25BE", dtrif: "\u25BE", blacktriangleleft: "\u25C2", ltrif: "\u25C2", blacktriangleright: "\u25B8", rtrif: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bnot: "\u2310", bopf: "\uD835\uDD53", bowtie: "\u22C8", boxDL: "\u2557", boxDR: "\u2554", boxDl: "\u2556", boxDr: "\u2553", boxH: "\u2550", boxHD: "\u2566", boxHU: "\u2569", boxHd: "\u2564", boxHu: "\u2567", boxUL: "\u255D", boxUR: "\u255A", boxUl: "\u255C", boxUr: "\u2559", boxV: "\u2551", boxVH: "\u256C", boxVL: "\u2563", boxVR: "\u2560", boxVh: "\u256B", boxVl: "\u2562", boxVr: "\u255F", boxbox: "\u29C9", boxdL: "\u2555", boxdR: "\u2552", boxdl: "\u2510", boxdr: "\u250C", boxhD: "\u2565", boxhU: "\u2568", boxhd: "\u252C", boxhu: "\u2534", boxminus: "\u229F", minusb: "\u229F", boxplus: "\u229E", plusb: "\u229E", boxtimes: "\u22A0", timesb: "\u22A0", boxuL: "\u255B", boxuR: "\u2558", boxul: "\u2518", boxur: "\u2514", boxv: "\u2502", boxvH: "\u256A", boxvL: "\u2561", boxvR: "\u255E", boxvh: "\u253C", boxvl: "\u2524", boxvr: "\u251C", brvbar: "\xA6", bscr: "\uD835\uDCB7", bsemi: "\u204F", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bumpE: "\u2AAE", cacute: "\u0107", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", caps: "\u2229\uFE00", caret: "\u2041", ccaps: "\u2A4D", ccaron: "\u010D", ccedil: "\xE7", ccirc: "\u0109", ccups: "\u2A4C", ccupssm: "\u2A50", cdot: "\u010B", cemptyv: "\u29B2", cent: "\xA2", cfr: "\uD835\uDD20", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", chi: "\u03C7", cir: "\u25CB", cirE: "\u29C3", circ: "\u02C6", circeq: "\u2257", cire: "\u2257", circlearrowleft: "\u21BA", olarr: "\u21BA", circlearrowright: "\u21BB", orarr: "\u21BB", circledS: "\u24C8", oS: "\u24C8", circledast: "\u229B", oast: "\u229B", circledcirc: "\u229A", ocir: "\u229A", circleddash: "\u229D", odash: "\u229D", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", clubs: "\u2663", clubsuit: "\u2663", colon: ":", comma: ",", commat: "@", comp: "\u2201", complement: "\u2201", congdot: "\u2A6D", copf: "\uD835\uDD54", copysr: "\u2117", crarr: "\u21B5", cross: "\u2717", cscr: "\uD835\uDCB8", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", curlyeqprec: "\u22DE", cuesc: "\u22DF", curlyeqsucc: "\u22DF", cularr: "\u21B6", curvearrowleft: "\u21B6", cularrp: "\u293D", cup: "\u222A", cupbrcap: "\u2A48", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curvearrowright: "\u21B7", curarrm: "\u293C", curlyvee: "\u22CE", cuvee: "\u22CE", curlywedge: "\u22CF", cuwed: "\u22CF", curren: "\xA4", cwint: "\u2231", cylcty: "\u232D", dHar: "\u2965", dagger: "\u2020", daleth: "\u2138", dash: "\u2010", hyphen: "\u2010", dbkarow: "\u290F", rBarr: "\u290F", dcaron: "\u010F", dcy: "\u0434", ddarr: "\u21CA", downdownarrows: "\u21CA", ddotseq: "\u2A77", eDDot: "\u2A77", deg: "\xB0", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", dfr: "\uD835\uDD21", diamondsuit: "\u2666", diams: "\u2666", digamma: "\u03DD", gammad: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", djcy: "\u0452", dlcorn: "\u231E", llcorner: "\u231E", dlcrop: "\u230D", dollar: "$", dopf: "\uD835\uDD55", doteqdot: "\u2251", eDot: "\u2251", dotminus: "\u2238", minusd: "\u2238", dotplus: "\u2214", plusdo: "\u2214", dotsquare: "\u22A1", sdotb: "\u22A1", drcorn: "\u231F", lrcorner: "\u231F", drcrop: "\u230C", dscr: "\uD835\uDCB9", dscy: "\u0455", dsol: "\u29F6", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", triangledown: "\u25BF", dwangle: "\u29A6", dzcy: "\u045F", dzigrarr: "\u27FF", eacute: "\xE9", easter: "\u2A6E", ecaron: "\u011B", ecir: "\u2256", eqcirc: "\u2256", ecirc: "\xEA", ecolon: "\u2255", eqcolon: "\u2255", ecy: "\u044D", edot: "\u0117", efDot: "\u2252", fallingdotseq: "\u2252", efr: "\uD835\uDD22", eg: "\u2A9A", egrave: "\xE8", egs: "\u2A96", eqslantgtr: "\u2A96", egsdot: "\u2A98", el: "\u2A99", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", eqslantless: "\u2A95", elsdot: "\u2A97", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", emptyv: "\u2205", varnothing: "\u2205", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", eng: "\u014B", ensp: "\u2002", eogon: "\u0119", eopf: "\uD835\uDD56", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", epsilon: "\u03B5", epsiv: "\u03F5", straightepsilon: "\u03F5", varepsilon: "\u03F5", equals: "=", equest: "\u225F", questeq: "\u225F", equivDD: "\u2A78", eqvparsl: "\u29E5", erDot: "\u2253", risingdotseq: "\u2253", erarr: "\u2971", escr: "\u212F", eta: "\u03B7", eth: "\xF0", euml: "\xEB", euro: "\u20AC", excl: "!", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", ffr: "\uD835\uDD23", filig: "\uFB01", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", fopf: "\uD835\uDD57", fork: "\u22D4", pitchfork: "\u22D4", forkv: "\u2AD9", fpartint: "\u2A0D", frac12: "\xBD", half: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", sfrown: "\u2322", fscr: "\uD835\uDCBB", gEl: "\u2A8C", gtreqqless: "\u2A8C", gacute: "\u01F5", gamma: "\u03B3", gap: "\u2A86", gtrapprox: "\u2A86", gbreve: "\u011F", gcirc: "\u011D", gcy: "\u0433", gdot: "\u0121", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", gfr: "\uD835\uDD24", gimel: "\u2137", gjcy: "\u0453", glE: "\u2A92", gla: "\u2AA5", glj: "\u2AA4", gnE: "\u2269", gneqq: "\u2269", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gneq: "\u2A88", gnsim: "\u22E7", gopf: "\uD835\uDD58", gscr: "\u210A", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtrdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrarr: "\u2978", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", hardcy: "\u044A", harrcir: "\u2948", harrw: "\u21AD", leftrightsquigarrow: "\u21AD", hbar: "\u210F", hslash: "\u210F", planck: "\u210F", plankv: "\u210F", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", mldr: "\u2026", hercon: "\u22B9", hfr: "\uD835\uDD25", hksearow: "\u2925", searhk: "\u2925", hkswarow: "\u2926", swarhk: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", larrhk: "\u21A9", hookrightarrow: "\u21AA", rarrhk: "\u21AA", hopf: "\uD835\uDD59", horbar: "\u2015", hscr: "\uD835\uDCBD", hstrok: "\u0127", hybull: "\u2043", iacute: "\xED", icirc: "\xEE", icy: "\u0438", iecy: "\u0435", iexcl: "\xA1", ifr: "\uD835\uDD26", igrave: "\xEC", iiiint: "\u2A0C", qint: "\u2A0C", iiint: "\u222D", tint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", ijlig: "\u0133", imacr: "\u012B", imath: "\u0131", inodot: "\u0131", imof: "\u22B7", imped: "\u01B5", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", intcal: "\u22BA", intercal: "\u22BA", intlarhk: "\u2A17", intprod: "\u2A3C", iprod: "\u2A3C", iocy: "\u0451", iogon: "\u012F", iopf: "\uD835\uDD5A", iota: "\u03B9", iquest: "\xBF", iscr: "\uD835\uDCBE", isinE: "\u22F9", isindot: "\u22F5", isins: "\u22F4", isinsv: "\u22F3", itilde: "\u0129", iukcy: "\u0456", iuml: "\xEF", jcirc: "\u0135", jcy: "\u0439", jfr: "\uD835\uDD27", jmath: "\u0237", jopf: "\uD835\uDD5B", jscr: "\uD835\uDCBF", jsercy: "\u0458", jukcy: "\u0454", kappa: "\u03BA", kappav: "\u03F0", varkappa: "\u03F0", kcedil: "\u0137", kcy: "\u043A", kfr: "\uD835\uDD28", kgreen: "\u0138", khcy: "\u0445", kjcy: "\u045C", kopf: "\uD835\uDD5C", kscr: "\uD835\uDCC0", lAtail: "\u291B", lBarr: "\u290E", lEg: "\u2A8B", lesseqqgtr: "\u2A8B", lHar: "\u2962", lacute: "\u013A", laemptyv: "\u29B4", lambda: "\u03BB", langd: "\u2991", lap: "\u2A85", lessapprox: "\u2A85", laquo: "\xAB", larrbfs: "\u291F", larrfs: "\u291D", larrlp: "\u21AB", looparrowleft: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", leftarrowtail: "\u21A2", lat: "\u2AAB", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lcub: "{", lbrack: "[", lsqb: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", lcaron: "\u013E", lcedil: "\u013C", lcy: "\u043B", ldca: "\u2936", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", leq: "\u2264", leftleftarrows: "\u21C7", llarr: "\u21C7", leftthreetimes: "\u22CB", lthree: "\u22CB", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessdot: "\u22D6", ltdot: "\u22D6", lfisht: "\u297C", lfr: "\uD835\uDD29", lgE: "\u2A91", lharul: "\u296A", lhblk: "\u2584", ljcy: "\u0459", llhard: "\u296B", lltri: "\u25FA", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnE: "\u2268", lneqq: "\u2268", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lneq: "\u2A87", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", longmapsto: "\u27FC", xmap: "\u27FC", looparrowright: "\u21AC", rarrlp: "\u21AC", lopar: "\u2985", lopf: "\uD835\uDD5D", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", loz: "\u25CA", lozenge: "\u25CA", lpar: "(", lparlt: "\u2993", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\uD835\uDCC1", lsime: "\u2A8D", lsimg: "\u2A8F", lsquor: "\u201A", sbquo: "\u201A", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltrPar: "\u2996", ltri: "\u25C3", triangleleft: "\u25C3", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", mDDot: "\u223A", macr: "\xAF", strns: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", marker: "\u25AE", mcomma: "\u2A29", mcy: "\u043C", mdash: "\u2014", mfr: "\uD835\uDD2A", mho: "\u2127", micro: "\xB5", midcir: "\u2AF0", minus: "\u2212", minusdu: "\u2A2A", mlcp: "\u2ADB", models: "\u22A7", mopf: "\uD835\uDD5E", mscr: "\uD835\uDCC2", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nGg: "\u22D9\u0338", nGt: "\u226B\u20D2", nLeftarrow: "\u21CD", nlArr: "\u21CD", nLeftrightarrow: "\u21CE", nhArr: "\u21CE", nLl: "\u22D8\u0338", nLt: "\u226A\u20D2", nRightarrow: "\u21CF", nrArr: "\u21CF", nVDash: "\u22AF", nVdash: "\u22AE", nacute: "\u0144", nang: "\u2220\u20D2", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", natur: "\u266E", natural: "\u266E", ncap: "\u2A43", ncaron: "\u0148", ncedil: "\u0146", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", ncy: "\u043D", ndash: "\u2013", neArr: "\u21D7", nearhk: "\u2924", nedot: "\u2250\u0338", nesear: "\u2928", toea: "\u2928", nfr: "\uD835\uDD2B", nharr: "\u21AE", nleftrightarrow: "\u21AE", nhpar: "\u2AF2", nis: "\u22FC", nisd: "\u22FA", njcy: "\u045A", nlE: "\u2266\u0338", nleqq: "\u2266\u0338", nlarr: "\u219A", nleftarrow: "\u219A", nldr: "\u2025", nopf: "\uD835\uDD5F", not: "\xAC", notinE: "\u22F9\u0338", notindot: "\u22F5\u0338", notinvb: "\u22F7", notinvc: "\u22F6", notnivb: "\u22FE", notnivc: "\u22FD", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", nrarr: "\u219B", nrightarrow: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nscr: "\uD835\uDCC3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsubseteqq: "\u2AC5\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupseteqq: "\u2AC6\u0338", ntilde: "\xF1", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvDash: "\u22AD", nvHarr: "\u2904", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwArr: "\u21D6", nwarhk: "\u2923", nwnear: "\u2927", oacute: "\xF3", ocirc: "\xF4", ocy: "\u043E", odblac: "\u0151", odiv: "\u2A38", odsold: "\u29BC", oelig: "\u0153", ofcir: "\u29BF", ofr: "\uD835\uDD2C", ogon: "\u02DB", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", olcir: "\u29BE", olcross: "\u29BB", olt: "\u29C0", omacr: "\u014D", omega: "\u03C9", omicron: "\u03BF", omid: "\u29B6", oopf: "\uD835\uDD60", opar: "\u29B7", operp: "\u29B9", or: "\u2228", vee: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", oscr: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oslash: "\xF8", osol: "\u2298", otilde: "\xF5", otimesas: "\u2A36", ouml: "\xF6", ovbar: "\u233D", para: "\xB6", parsim: "\u2AF3", parsl: "\u2AFD", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", pertenk: "\u2031", pfr: "\uD835\uDD2D", phi: "\u03C6", phiv: "\u03D5", straightphi: "\u03D5", varphi: "\u03D5", phone: "\u260E", pi: "\u03C0", piv: "\u03D6", varpi: "\u03D6", planckh: "\u210E", plus: "+", plusacir: "\u2A23", pluscir: "\u2A22", plusdu: "\u2A25", pluse: "\u2A72", plussim: "\u2A26", plustwo: "\u2A27", pointint: "\u2A15", popf: "\uD835\uDD61", pound: "\xA3", prE: "\u2AB3", prap: "\u2AB7", precapprox: "\u2AB7", precnapprox: "\u2AB9", prnap: "\u2AB9", precneqq: "\u2AB5", prnE: "\u2AB5", precnsim: "\u22E8", prnsim: "\u22E8", prime: "\u2032", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prurel: "\u22B0", pscr: "\uD835\uDCC5", psi: "\u03C8", puncsp: "\u2008", qfr: "\uD835\uDD2E", qopf: "\uD835\uDD62", qprime: "\u2057", qscr: "\uD835\uDCC6", quatint: "\u2A16", quest: "?", rAtail: "\u291C", rHar: "\u2964", race: "\u223D\u0331", racute: "\u0155", raemptyv: "\u29B3", rangd: "\u2992", range: "\u29A5", raquo: "\xBB", rarrap: "\u2975", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrpl: "\u2945", rarrsim: "\u2974", rarrtl: "\u21A3", rightarrowtail: "\u21A3", rarrw: "\u219D", rightsquigarrow: "\u219D", ratail: "\u291A", ratio: "\u2236", rbbrk: "\u2773", rbrace: "}", rcub: "}", rbrack: "]", rsqb: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", rcaron: "\u0159", rcedil: "\u0157", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdsh: "\u21B3", rect: "\u25AD", rfisht: "\u297D", rfr: "\uD835\uDD2F", rharul: "\u296C", rho: "\u03C1", rhov: "\u03F1", varrho: "\u03F1", rightrightarrows: "\u21C9", rrarr: "\u21C9", rightthreetimes: "\u22CC", rthree: "\u22CC", ring: "\u02DA", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", ropar: "\u2986", ropf: "\uD835\uDD63", roplus: "\u2A2E", rotimes: "\u2A35", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rsaquo: "\u203A", rscr: "\uD835\uDCC7", rtimes: "\u22CA", rtri: "\u25B9", triangleright: "\u25B9", rtriltri: "\u29CE", ruluhar: "\u2968", rx: "\u211E", sacute: "\u015B", scE: "\u2AB4", scap: "\u2AB8", succapprox: "\u2AB8", scaron: "\u0161", scedil: "\u015F", scirc: "\u015D", scnE: "\u2AB6", succneqq: "\u2AB6", scnap: "\u2ABA", succnapprox: "\u2ABA", scnsim: "\u22E9", succnsim: "\u22E9", scpolint: "\u2A13", scy: "\u0441", sdot: "\u22C5", sdote: "\u2A66", seArr: "\u21D8", sect: "\xA7", semi: ";", seswar: "\u2929", tosa: "\u2929", sext: "\u2736", sfr: "\uD835\uDD30", sharp: "\u266F", shchcy: "\u0449", shcy: "\u0448", shy: "\xAD", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", varsigma: "\u03C2", simdot: "\u2A6A", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", smashp: "\u2A33", smeparsl: "\u29E4", smile: "\u2323", ssmile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", sopf: "\uD835\uDD64", spades: "\u2660", spadesuit: "\u2660", sqcaps: "\u2293\uFE00", sqcups: "\u2294\uFE00", sscr: "\uD835\uDCC8", star: "\u2606", sub: "\u2282", subset: "\u2282", subE: "\u2AC5", subseteqq: "\u2AC5", subdot: "\u2ABD", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subsetneqq: "\u2ACB", subne: "\u228A", subsetneq: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supE: "\u2AC6", supseteqq: "\u2AC6", supdot: "\u2ABE", supdsub: "\u2AD8", supedot: "\u2AC4", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supsetneqq: "\u2ACC", supne: "\u228B", supsetneq: "\u228B", supplus: "\u2AC0", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swArr: "\u21D9", swnwar: "\u292A", szlig: "\xDF", target: "\u2316", tau: "\u03C4", tcaron: "\u0165", tcedil: "\u0163", tcy: "\u0442", telrec: "\u2315", tfr: "\uD835\uDD31", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", vartheta: "\u03D1", thorn: "\xFE", times: "\xD7", timesbar: "\u2A31", timesd: "\u2A30", topbot: "\u2336", topcir: "\u2AF1", topf: "\uD835\uDD65", topfork: "\u2ADA", tprime: "\u2034", triangle: "\u25B5", utri: "\u25B5", triangleq: "\u225C", trie: "\u225C", tridot: "\u25EC", triminus: "\u2A3A", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", tscr: "\uD835\uDCC9", tscy: "\u0446", tshcy: "\u045B", tstrok: "\u0167", uHar: "\u2963", uacute: "\xFA", ubrcy: "\u045E", ubreve: "\u016D", ucirc: "\xFB", ucy: "\u0443", udblac: "\u0171", ufisht: "\u297E", ufr: "\uD835\uDD32", ugrave: "\xF9", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", umacr: "\u016B", uogon: "\u0173", uopf: "\uD835\uDD66", upsi: "\u03C5", upsilon: "\u03C5", upuparrows: "\u21C8", uuarr: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", uring: "\u016F", urtri: "\u25F9", uscr: "\uD835\uDCCA", utdot: "\u22F0", utilde: "\u0169", uuml: "\xFC", uwangle: "\u29A7", vBar: "\u2AE8", vBarv: "\u2AE9", vangrt: "\u299C", varsubsetneq: "\u228A\uFE00", vsubne: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", vsubnE: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", vsupne: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vsupnE: "\u2ACC\uFE00", vcy: "\u0432", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", vfr: "\uD835\uDD33", vopf: "\uD835\uDD67", vscr: "\uD835\uDCCB", vzigzag: "\u299A", wcirc: "\u0175", wedbar: "\u2A5F", wedgeq: "\u2259", weierp: "\u2118", wp: "\u2118", wfr: "\uD835\uDD34", wopf: "\uD835\uDD68", wscr: "\uD835\uDCCC", xfr: "\uD835\uDD35", xi: "\u03BE", xnis: "\u22FB", xopf: "\uD835\uDD69", xscr: "\uD835\uDCCD", yacute: "\xFD", yacy: "\u044F", ycirc: "\u0177", ycy: "\u044B", yen: "\xA5", yfr: "\uD835\uDD36", yicy: "\u0457", yopf: "\uD835\uDD6A", yscr: "\uD835\uDCCE", yucy: "\u044E", yuml: "\xFF", zacute: "\u017A", zcaron: "\u017E", zcy: "\u0437", zdot: "\u017C", zeta: "\u03B6", zfr: "\uD835\uDD37", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\uD835\uDD6B", zscr: "\uD835\uDCCF", zwj: "\u200D", zwnj: "\u200C" };
var fo = "\uE500";
Ve.ngsp = fo;
var go = [/@/, /^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
var $r = class t3 {
  static fromArray(e) {
    return e ? (Xs("interpolation", e), new t3(e[0], e[1])) : Or;
  }
  constructor(e, r) {
    this.start = e, this.end = r;
  }
};
var Or = new $r("{{", "}}");
var gt2 = class extends Oe {
  constructor(e, r, n) {
    super(n, e), this.tokenType = r;
  }
};
var Ur = class {
  constructor(e, r, n) {
    this.tokens = e, this.errors = r, this.nonNormalizedIcuExpressions = n;
  }
};
var Io = /\r\n?/g;
var rr;
(function(t4) {
  t4.HEX = "hexadecimal", t4.DEC = "decimal";
})(rr || (rr = {}));
var Ct = class {
  constructor(e) {
    this.error = e;
  }
};
var Wr = class {
  constructor(e, r, n) {
    this._getTagContentType = r, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = false, this._fullNameStack = [], this.tokens = [], this.errors = [], this.nonNormalizedIcuExpressions = [], this._tokenizeIcu = n.tokenizeExpansionForms || false, this._interpolationConfig = n.interpolationConfig || Or, this._leadingTriviaCodePoints = n.leadingTriviaChars && n.leadingTriviaChars.map((i) => i.codePointAt(0) || 0), this._canSelfClose = n.canSelfClose || false, this._allowHtmComponentClosingTags = n.allowHtmComponentClosingTags || false;
    let s = n.range || { endPos: e.content.length, startPos: 0, startLine: 0, startCol: 0 };
    this._cursor = n.escapedString ? new Gr(e, s) : new nr(e, s), this._preserveLineEndings = n.preserveLineEndings || false, this._i18nNormalizeLineEndingsInICUs = n.i18nNormalizeLineEndingsInICUs || false, this._tokenizeBlocks = n.tokenizeBlocks ?? true, this._tokenizeLet = n.tokenizeLet ?? true;
    try {
      this._cursor.init();
    } catch (i) {
      this.handleError(i);
    }
  }
  _processCarriageReturns(e) {
    return this._preserveLineEndings ? e : e.replace(Io, `
`);
  }
  tokenize() {
    for (;this._cursor.peek() !== 0; ) {
      let e = this._cursor.clone();
      try {
        if (this._attemptCharCode(60))
          if (this._attemptCharCode(33))
            this._attemptStr("[CDATA[") ? this._consumeCdata(e) : this._attemptStr("--") ? this._consumeComment(e) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e) : this._consumeBogusComment(e);
          else if (this._attemptCharCode(47))
            this._consumeTagClose(e);
          else {
            let r = this._cursor.clone();
            this._attemptCharCode(63) ? (this._cursor = r, this._consumeBogusComment(e)) : this._consumeTagOpen(e);
          }
        else
          this._tokenizeLet && this._cursor.peek() === 64 && !this._inInterpolation && this._attemptStr("@let") ? this._consumeLetDeclaration(e) : this._tokenizeBlocks && this._attemptCharCode(64) ? this._consumeBlockStart(e) : this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode(125) ? this._consumeBlockEnd(e) : this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());
      } catch (r) {
        this.handleError(r);
      }
    }
    this._beginToken(34), this._endToken([]);
  }
  _getBlockName() {
    let e = false, r = this._cursor.clone();
    return this._attemptCharCodeUntilFn((n) => ut(n) ? !e : si(n) ? (e = true, false) : true), this._cursor.getChars(r).trim();
  }
  _consumeBlockStart(e) {
    this._beginToken(25, e);
    let r = this._endToken([this._getBlockName()]);
    if (this._cursor.peek() === 40)
      if (this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(b2), this._attemptCharCode(41))
        this._attemptCharCodeUntilFn(b2);
      else {
        r.type = 29;
        return;
      }
    this._attemptCharCode(123) ? (this._beginToken(26), this._endToken([])) : r.type = 29;
  }
  _consumeBlockEnd(e) {
    this._beginToken(27, e), this._endToken([]);
  }
  _consumeBlockParameters() {
    for (this._attemptCharCodeUntilFn(ii);this._cursor.peek() !== 41 && this._cursor.peek() !== 0; ) {
      this._beginToken(28);
      let e = this._cursor.clone(), r = null, n = 0;
      for (;this._cursor.peek() !== 59 && this._cursor.peek() !== 0 || r !== null; ) {
        let s = this._cursor.peek();
        if (s === 92)
          this._cursor.advance();
        else if (s === r)
          r = null;
        else if (r === null && Ot(s))
          r = s;
        else if (s === 40 && r === null)
          n++;
        else if (s === 41 && r === null) {
          if (n === 0)
            break;
          n > 0 && n--;
        }
        this._cursor.advance();
      }
      this._endToken([this._cursor.getChars(e)]), this._attemptCharCodeUntilFn(ii);
    }
  }
  _consumeLetDeclaration(e) {
    if (this._beginToken(30, e), ut(this._cursor.peek()))
      this._attemptCharCodeUntilFn(b2);
    else {
      let s = this._endToken([this._cursor.getChars(e)]);
      s.type = 33;
      return;
    }
    let r = this._endToken([this._getLetDeclarationName()]);
    if (this._attemptCharCodeUntilFn(b2), !this._attemptCharCode(61)) {
      r.type = 33;
      return;
    }
    this._attemptCharCodeUntilFn((s) => b2(s) && !$t(s)), this._consumeLetDeclarationValue(), this._cursor.peek() === 59 ? (this._beginToken(32), this._endToken([]), this._cursor.advance()) : (r.type = 33, r.sourceSpan = this._cursor.getSpan(e));
  }
  _getLetDeclarationName() {
    let e = this._cursor.clone(), r = false;
    return this._attemptCharCodeUntilFn((n) => lt2(n) || n === 36 || n === 95 || r && Rt(n) ? (r = true, false) : true), this._cursor.getChars(e).trim();
  }
  _consumeLetDeclarationValue() {
    let e = this._cursor.clone();
    for (this._beginToken(31, e);this._cursor.peek() !== 0; ) {
      let r = this._cursor.peek();
      if (r === 59)
        break;
      Ot(r) && (this._cursor.advance(), this._attemptCharCodeUntilFn((n) => n === 92 ? (this._cursor.advance(), false) : n === r)), this._cursor.advance();
    }
    this._endToken([this._cursor.getChars(e)]);
  }
  _tokenizeExpansionForm() {
    if (this.isExpansionFormStart())
      return this._consumeExpansionFormStart(), true;
    if (qo(this._cursor.peek()) && this._isInExpansionForm())
      return this._consumeExpansionCaseStart(), true;
    if (this._cursor.peek() === 125) {
      if (this._isInExpansionCase())
        return this._consumeExpansionCaseEnd(), true;
      if (this._isInExpansionForm())
        return this._consumeExpansionFormEnd(), true;
    }
    return false;
  }
  _beginToken(e, r = this._cursor.clone()) {
    this._currentTokenStart = r, this._currentTokenType = e;
  }
  _endToken(e, r) {
    if (this._currentTokenStart === null)
      throw new gt2("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(r));
    if (this._currentTokenType === null)
      throw new gt2("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
    let n = { type: this._currentTokenType, parts: e, sourceSpan: (r ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints) };
    return this.tokens.push(n), this._currentTokenStart = null, this._currentTokenType = null, n;
  }
  _createError(e, r) {
    this._isInExpansionForm() && (e += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
    let n = new gt2(e, this._currentTokenType, r);
    return this._currentTokenStart = null, this._currentTokenType = null, new Ct(n);
  }
  handleError(e) {
    if (e instanceof St && (e = this._createError(e.msg, this._cursor.getSpan(e.cursor))), e instanceof Ct)
      this.errors.push(e.error);
    else
      throw e;
  }
  _attemptCharCode(e) {
    return this._cursor.peek() === e ? (this._cursor.advance(), true) : false;
  }
  _attemptCharCodeCaseInsensitive(e) {
    return Ho(this._cursor.peek(), e) ? (this._cursor.advance(), true) : false;
  }
  _requireCharCode(e) {
    let r = this._cursor.clone();
    if (!this._attemptCharCode(e))
      throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _attemptStr(e) {
    let r = e.length;
    if (this._cursor.charsLeft() < r)
      return false;
    let n = this._cursor.clone();
    for (let s = 0;s < r; s++)
      if (!this._attemptCharCode(e.charCodeAt(s)))
        return this._cursor = n, false;
    return true;
  }
  _attemptStrCaseInsensitive(e) {
    for (let r = 0;r < e.length; r++)
      if (!this._attemptCharCodeCaseInsensitive(e.charCodeAt(r)))
        return false;
    return true;
  }
  _requireStr(e) {
    let r = this._cursor.clone();
    if (!this._attemptStr(e))
      throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _requireStrCaseInsensitive(e) {
    let r = this._cursor.clone();
    if (!this._attemptStrCaseInsensitive(e))
      throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _attemptCharCodeUntilFn(e) {
    for (;!e(this._cursor.peek()); )
      this._cursor.advance();
  }
  _requireCharCodeUntilFn(e, r) {
    let n = this._cursor.clone();
    if (this._attemptCharCodeUntilFn(e), this._cursor.diff(n) < r)
      throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(n));
  }
  _attemptUntilChar(e) {
    for (;this._cursor.peek() !== e; )
      this._cursor.advance();
  }
  _readChar() {
    let e = String.fromCodePoint(this._cursor.peek());
    return this._cursor.advance(), e;
  }
  _consumeEntity(e) {
    this._beginToken(9);
    let r = this._cursor.clone();
    if (this._cursor.advance(), this._attemptCharCode(35)) {
      let n = this._attemptCharCode(120) || this._attemptCharCode(88), s = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(Oo), this._cursor.peek() != 59) {
        this._cursor.advance();
        let a = n ? rr.HEX : rr.DEC;
        throw this._createError(Ro(a, this._cursor.getChars(r)), this._cursor.getSpan());
      }
      let i = this._cursor.getChars(s);
      this._cursor.advance();
      try {
        let a = parseInt(i, n ? 16 : 10);
        this._endToken([String.fromCharCode(a), this._cursor.getChars(r)]);
      } catch {
        throw this._createError(ti(this._cursor.getChars(r)), this._cursor.getSpan());
      }
    } else {
      let n = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(Mo), this._cursor.peek() != 59)
        this._beginToken(e, r), this._cursor = n, this._endToken(["&"]);
      else {
        let s = this._cursor.getChars(n);
        this._cursor.advance();
        let i = Ve[s];
        if (!i)
          throw this._createError(ti(s), this._cursor.getSpan(r));
        this._endToken([i, `&${s};`]);
      }
    }
  }
  _consumeRawText(e, r) {
    this._beginToken(e ? 6 : 7);
    let n = [];
    for (;; ) {
      let s = this._cursor.clone(), i = r();
      if (this._cursor = s, i)
        break;
      e && this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(n.join(""))]), n.length = 0, this._consumeEntity(6), this._beginToken(6)) : n.push(this._readChar());
    }
    this._endToken([this._processCarriageReturns(n.join(""))]);
  }
  _consumeComment(e) {
    this._beginToken(10, e), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("-->")), this._beginToken(11), this._requireStr("-->"), this._endToken([]);
  }
  _consumeBogusComment(e) {
    this._beginToken(10, e), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === 62), this._beginToken(11), this._cursor.advance(), this._endToken([]);
  }
  _consumeCdata(e) {
    this._beginToken(12, e), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("]]>")), this._beginToken(13), this._requireStr("]]>"), this._endToken([]);
  }
  _consumeDocType(e) {
    this._beginToken(18, e), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === 62), this._beginToken(19), this._cursor.advance(), this._endToken([]);
  }
  _consumePrefixAndName() {
    let e = this._cursor.clone(), r = "";
    for (;this._cursor.peek() !== 58 && !$o(this._cursor.peek()); )
      this._cursor.advance();
    let n;
    this._cursor.peek() === 58 ? (r = this._cursor.getChars(e), this._cursor.advance(), n = this._cursor.clone()) : n = e, this._requireCharCodeUntilFn(ri, r === "" ? 0 : 1);
    let s = this._cursor.getChars(n);
    return [r, s];
  }
  _consumeTagOpen(e) {
    let r, n, s, i = [];
    try {
      if (!lt2(this._cursor.peek()))
        throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(e));
      for (s = this._consumeTagOpenStart(e), n = s.parts[0], r = s.parts[1], this._attemptCharCodeUntilFn(b2);this._cursor.peek() !== 47 && this._cursor.peek() !== 62 && this._cursor.peek() !== 60 && this._cursor.peek() !== 0; ) {
        let [o, u] = this._consumeAttributeName();
        if (this._attemptCharCodeUntilFn(b2), this._attemptCharCode(61)) {
          this._attemptCharCodeUntilFn(b2);
          let p = this._consumeAttributeValue();
          i.push({ prefix: o, name: u, value: p });
        } else
          i.push({ prefix: o, name: u });
        this._attemptCharCodeUntilFn(b2);
      }
      this._consumeTagOpenEnd();
    } catch (o) {
      if (o instanceof Ct) {
        s ? s.type = 4 : (this._beginToken(5, e), this._endToken(["<"]));
        return;
      }
      throw o;
    }
    if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === 2)
      return;
    let a = this._getTagContentType(r, n, this._fullNameStack.length > 0, i);
    this._handleFullNameStackForTagOpen(n, r), a === N.RAW_TEXT ? this._consumeRawTextWithTagClose(n, r, false) : a === N.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(n, r, true);
  }
  _consumeRawTextWithTagClose(e, r, n) {
    this._consumeRawText(n, () => !this._attemptCharCode(60) || !this._attemptCharCode(47) || (this._attemptCharCodeUntilFn(b2), !this._attemptStrCaseInsensitive(e ? `${e}:${r}` : r)) ? false : (this._attemptCharCodeUntilFn(b2), this._attemptCharCode(62))), this._beginToken(3), this._requireCharCodeUntilFn((s) => s === 62, 3), this._cursor.advance(), this._endToken([e, r]), this._handleFullNameStackForTagClose(e, r);
  }
  _consumeTagOpenStart(e) {
    this._beginToken(0, e);
    let r = this._consumePrefixAndName();
    return this._endToken(r);
  }
  _consumeAttributeName() {
    let e = this._cursor.peek();
    if (e === 39 || e === 34)
      throw this._createError(Ue(e), this._cursor.getSpan());
    this._beginToken(14);
    let r = this._consumePrefixAndName();
    return this._endToken(r), r;
  }
  _consumeAttributeValue() {
    let e;
    if (this._cursor.peek() === 39 || this._cursor.peek() === 34) {
      let r = this._cursor.peek();
      this._consumeQuote(r);
      let n = () => this._cursor.peek() === r;
      e = this._consumeWithInterpolation(16, 17, n, n), this._consumeQuote(r);
    } else {
      let r = () => ri(this._cursor.peek());
      e = this._consumeWithInterpolation(16, 17, r, r);
    }
    return e;
  }
  _consumeQuote(e) {
    this._beginToken(15), this._requireCharCode(e), this._endToken([String.fromCodePoint(e)]);
  }
  _consumeTagOpenEnd() {
    let e = this._attemptCharCode(47) ? 2 : 1;
    this._beginToken(e), this._requireCharCode(62), this._endToken([]);
  }
  _consumeTagClose(e) {
    if (this._beginToken(3, e), this._attemptCharCodeUntilFn(b2), this._allowHtmComponentClosingTags && this._attemptCharCode(47))
      this._attemptCharCodeUntilFn(b2), this._requireCharCode(62), this._endToken([]);
    else {
      let [r, n] = this._consumePrefixAndName();
      this._attemptCharCodeUntilFn(b2), this._requireCharCode(62), this._endToken([r, n]), this._handleFullNameStackForTagClose(r, n);
    }
  }
  _consumeExpansionFormStart() {
    this._beginToken(20), this._requireCharCode(123), this._endToken([]), this._expansionCaseStack.push(20), this._beginToken(7);
    let e = this._readUntil(44), r = this._processCarriageReturns(e);
    if (this._i18nNormalizeLineEndingsInICUs)
      this._endToken([r]);
    else {
      let s = this._endToken([e]);
      r !== e && this.nonNormalizedIcuExpressions.push(s);
    }
    this._requireCharCode(44), this._attemptCharCodeUntilFn(b2), this._beginToken(7);
    let n = this._readUntil(44);
    this._endToken([n]), this._requireCharCode(44), this._attemptCharCodeUntilFn(b2);
  }
  _consumeExpansionCaseStart() {
    this._beginToken(21);
    let e = this._readUntil(123).trim();
    this._endToken([e]), this._attemptCharCodeUntilFn(b2), this._beginToken(22), this._requireCharCode(123), this._endToken([]), this._attemptCharCodeUntilFn(b2), this._expansionCaseStack.push(22);
  }
  _consumeExpansionCaseEnd() {
    this._beginToken(23), this._requireCharCode(125), this._endToken([]), this._attemptCharCodeUntilFn(b2), this._expansionCaseStack.pop();
  }
  _consumeExpansionFormEnd() {
    this._beginToken(24), this._requireCharCode(125), this._endToken([]), this._expansionCaseStack.pop();
  }
  _consumeWithInterpolation(e, r, n, s) {
    this._beginToken(e);
    let i = [];
    for (;!n(); ) {
      let o = this._cursor.clone();
      this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (this._endToken([this._processCarriageReturns(i.join(""))], o), i.length = 0, this._consumeInterpolation(r, o, s), this._beginToken(e)) : this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(i.join(""))]), i.length = 0, this._consumeEntity(e), this._beginToken(e)) : i.push(this._readChar());
    }
    this._inInterpolation = false;
    let a = this._processCarriageReturns(i.join(""));
    return this._endToken([a]), a;
  }
  _consumeInterpolation(e, r, n) {
    let s = [];
    this._beginToken(e, r), s.push(this._interpolationConfig.start);
    let i = this._cursor.clone(), a = null, o = false;
    for (;this._cursor.peek() !== 0 && (n === null || !n()); ) {
      let u = this._cursor.clone();
      if (this._isTagStart()) {
        this._cursor = u, s.push(this._getProcessedChars(i, u)), this._endToken(s);
        return;
      }
      if (a === null)
        if (this._attemptStr(this._interpolationConfig.end)) {
          s.push(this._getProcessedChars(i, u)), s.push(this._interpolationConfig.end), this._endToken(s);
          return;
        } else
          this._attemptStr("//") && (o = true);
      let p = this._cursor.peek();
      this._cursor.advance(), p === 92 ? this._cursor.advance() : p === a ? a = null : !o && a === null && Ot(p) && (a = p);
    }
    s.push(this._getProcessedChars(i, this._cursor)), this._endToken(s);
  }
  _getProcessedChars(e, r) {
    return this._processCarriageReturns(r.getChars(e));
  }
  _isTextEnd() {
    return !!(this._isTagStart() || this._cursor.peek() === 0 || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === 125 && this._isInExpansionCase()) || this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || this._cursor.peek() === 64 || this._cursor.peek() === 125));
  }
  _isTagStart() {
    if (this._cursor.peek() === 60) {
      let e = this._cursor.clone();
      e.advance();
      let r = e.peek();
      if (97 <= r && r <= 122 || 65 <= r && r <= 90 || r === 47 || r === 33)
        return true;
    }
    return false;
  }
  _isBlockStart() {
    if (this._tokenizeBlocks && this._cursor.peek() === 64) {
      let e = this._cursor.clone();
      if (e.advance(), si(e.peek()))
        return true;
    }
    return false;
  }
  _readUntil(e) {
    let r = this._cursor.clone();
    return this._attemptUntilChar(e), this._cursor.getChars(r);
  }
  _isInExpansion() {
    return this._isInExpansionCase() || this._isInExpansionForm();
  }
  _isInExpansionCase() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 22;
  }
  _isInExpansionForm() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 20;
  }
  isExpansionFormStart() {
    if (this._cursor.peek() !== 123)
      return false;
    if (this._interpolationConfig) {
      let e = this._cursor.clone(), r = this._attemptStr(this._interpolationConfig.start);
      return this._cursor = e, !r;
    }
    return true;
  }
  _handleFullNameStackForTagOpen(e, r) {
    let n = qe(e, r);
    (this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === n) && this._fullNameStack.push(n);
  }
  _handleFullNameStackForTagClose(e, r) {
    let n = qe(e, r);
    this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === n && this._fullNameStack.pop();
  }
};
var nr = class t4 {
  constructor(e, r) {
    if (e instanceof t4) {
      this.file = e.file, this.input = e.input, this.end = e.end;
      let n = e.state;
      this.state = { peek: n.peek, offset: n.offset, line: n.line, column: n.column };
    } else {
      if (!r)
        throw new Error("Programming error: the range argument must be provided with a file argument.");
      this.file = e, this.input = e.content, this.end = r.endPos, this.state = { peek: -1, offset: r.startPos, line: r.startLine, column: r.startCol };
    }
  }
  clone() {
    return new t4(this);
  }
  peek() {
    return this.state.peek;
  }
  charsLeft() {
    return this.end - this.state.offset;
  }
  diff(e) {
    return this.state.offset - e.state.offset;
  }
  advance() {
    this.advanceState(this.state);
  }
  init() {
    this.updatePeek(this.state);
  }
  getSpan(e, r) {
    e = e || this;
    let n = e;
    if (r)
      for (;this.diff(e) > 0 && r.indexOf(e.peek()) !== -1; )
        n === e && (e = e.clone()), e.advance();
    let s = this.locationFromCursor(e), i = this.locationFromCursor(this), a = n !== e ? this.locationFromCursor(n) : s;
    return new h(s, i, a);
  }
  getChars(e) {
    return this.input.substring(e.state.offset, this.state.offset);
  }
  charAt(e) {
    return this.input.charCodeAt(e);
  }
  advanceState(e) {
    if (e.offset >= this.end)
      throw this.state = e, new St('Unexpected character "EOF"', this);
    let r = this.charAt(e.offset);
    r === 10 ? (e.line++, e.column = 0) : $t(r) || e.column++, e.offset++, this.updatePeek(e);
  }
  updatePeek(e) {
    e.peek = e.offset >= this.end ? 0 : this.charAt(e.offset);
  }
  locationFromCursor(e) {
    return new ie(e.file, e.state.offset, e.state.line, e.state.column);
  }
};
var Gr = class t5 extends nr {
  constructor(e, r) {
    e instanceof t5 ? (super(e), this.internalState = { ...e.internalState }) : (super(e, r), this.internalState = this.state);
  }
  advance() {
    this.state = this.internalState, super.advance(), this.processEscapeSequence();
  }
  init() {
    super.init(), this.processEscapeSequence();
  }
  clone() {
    return new t5(this);
  }
  getChars(e) {
    let r = e.clone(), n = "";
    for (;r.internalState.offset < this.internalState.offset; )
      n += String.fromCodePoint(r.peek()), r.advance();
    return n;
  }
  processEscapeSequence() {
    let e = () => this.internalState.peek;
    if (e() === 92)
      if (this.internalState = { ...this.state }, this.advanceState(this.internalState), e() === 110)
        this.state.peek = 10;
      else if (e() === 114)
        this.state.peek = 13;
      else if (e() === 118)
        this.state.peek = 11;
      else if (e() === 116)
        this.state.peek = 9;
      else if (e() === 98)
        this.state.peek = 8;
      else if (e() === 102)
        this.state.peek = 12;
      else if (e() === 117)
        if (this.advanceState(this.internalState), e() === 123) {
          this.advanceState(this.internalState);
          let r = this.clone(), n = 0;
          for (;e() !== 125; )
            this.advanceState(this.internalState), n++;
          this.state.peek = this.decodeHexDigits(r, n);
        } else {
          let r = this.clone();
          this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 4);
        }
      else if (e() === 120) {
        this.advanceState(this.internalState);
        let r = this.clone();
        this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 2);
      } else if (Br(e())) {
        let r = "", n = 0, s = this.clone();
        for (;Br(e()) && n < 3; )
          s = this.clone(), r += String.fromCodePoint(e()), this.advanceState(this.internalState), n++;
        this.state.peek = parseInt(r, 8), this.internalState = s.internalState;
      } else
        $t(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
  }
  decodeHexDigits(e, r) {
    let n = this.input.slice(e.internalState.offset, e.internalState.offset + r), s = parseInt(n, 16);
    if (isNaN(s))
      throw e.state = e.internalState, new St("Invalid hexadecimal escape sequence", e);
    return s;
  }
};
var St = class {
  constructor(e, r) {
    this.msg = e, this.cursor = r;
  }
};
var L = class t6 extends Oe {
  static create(e, r, n) {
    return new t6(e, r, n);
  }
  constructor(e, r, n) {
    super(r, n), this.elementName = e;
  }
};
var jr = class {
  constructor(e, r) {
    this.rootNodes = e, this.errors = r;
  }
};
var sr = class {
  constructor(e) {
    this.getTagDefinition = e;
  }
  parse(e, r, n, s = false, i) {
    let a = (D) => (I, ...F) => D(I.toLowerCase(), ...F), o = s ? this.getTagDefinition : a(this.getTagDefinition), u = (D) => o(D).getContentType(), p = s ? i : a(i), m = li(e, r, i ? (D, I, F, c) => {
      let g = p(D, I, F, c);
      return g !== undefined ? g : u(D);
    } : u, n), f = n && n.canSelfClose || false, C = n && n.allowHtmComponentClosingTags || false, A = new Kr(m.tokens, o, f, C, s);
    return A.build(), new jr(A.rootNodes, m.errors.concat(A.errors));
  }
};
var Kr = class t7 {
  constructor(e, r, n, s, i) {
    this.tokens = e, this.getTagDefinition = r, this.canSelfClose = n, this.allowHtmComponentClosingTags = s, this.isTagNameCaseSensitive = i, this._index = -1, this._containerStack = [], this.rootNodes = [], this.errors = [], this._advance();
  }
  build() {
    for (;this._peek.type !== 34; )
      this._peek.type === 0 || this._peek.type === 4 ? this._consumeStartTag(this._advance()) : this._peek.type === 3 ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === 12 ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === 10 ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6 ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === 20 ? this._consumeExpansion(this._advance()) : this._peek.type === 25 ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : this._peek.type === 27 ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : this._peek.type === 29 ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : this._peek.type === 30 ? (this._closeVoidElement(), this._consumeLet(this._advance())) : this._peek.type === 18 ? this._consumeDocType(this._advance()) : this._peek.type === 33 ? (this._closeVoidElement(), this._consumeIncompleteLet(this._advance())) : this._advance();
    for (let e of this._containerStack)
      e instanceof ee && this.errors.push(L.create(e.name, e.sourceSpan, `Unclosed block "${e.name}"`));
  }
  _advance() {
    let e = this._peek;
    return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e;
  }
  _advanceIf(e) {
    return this._peek.type === e ? this._advance() : null;
  }
  _consumeCdata(e) {
    let r = this._advance(), n = this._getText(r), s = this._advanceIf(13);
    this._addToParent(new Gt(n, new h(e.sourceSpan.start, (s || r).sourceSpan.end), [r]));
  }
  _consumeComment(e) {
    let r = this._advanceIf(7), n = this._advanceIf(11), s = r != null ? r.parts[0].trim() : null, i = n == null ? e.sourceSpan : new h(e.sourceSpan.start, n.sourceSpan.end, e.sourceSpan.fullStart);
    this._addToParent(new Kt(s, i));
  }
  _consumeDocType(e) {
    let r = this._advanceIf(7), n = this._advanceIf(19), s = r != null ? r.parts[0].trim() : null, i = new h(e.sourceSpan.start, (n || r || e).sourceSpan.end);
    this._addToParent(new Xt(s, i));
  }
  _consumeExpansion(e) {
    let r = this._advance(), n = this._advance(), s = [];
    for (;this._peek.type === 21; ) {
      let a = this._parseExpansionCase();
      if (!a)
        return;
      s.push(a);
    }
    if (this._peek.type !== 24) {
      this.errors.push(L.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
      return;
    }
    let i = new h(e.sourceSpan.start, this._peek.sourceSpan.end, e.sourceSpan.fullStart);
    this._addToParent(new zt(r.parts[0], n.parts[0], s, i, r.sourceSpan)), this._advance();
  }
  _parseExpansionCase() {
    let e = this._advance();
    if (this._peek.type !== 22)
      return this.errors.push(L.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
    let r = this._advance(), n = this._collectExpansionExpTokens(r);
    if (!n)
      return null;
    let s = this._advance();
    n.push({ type: 34, parts: [], sourceSpan: s.sourceSpan });
    let i = new t7(n, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive);
    if (i.build(), i.errors.length > 0)
      return this.errors = this.errors.concat(i.errors), null;
    let a = new h(e.sourceSpan.start, s.sourceSpan.end, e.sourceSpan.fullStart), o = new h(r.sourceSpan.start, s.sourceSpan.end, r.sourceSpan.fullStart);
    return new Yt(e.parts[0], i.rootNodes, a, e.sourceSpan, o);
  }
  _collectExpansionExpTokens(e) {
    let r = [], n = [22];
    for (;; ) {
      if ((this._peek.type === 20 || this._peek.type === 22) && n.push(this._peek.type), this._peek.type === 23)
        if (ci(n, 22)) {
          if (n.pop(), n.length === 0)
            return r;
        } else
          return this.errors.push(L.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 24)
        if (ci(n, 20))
          n.pop();
        else
          return this.errors.push(L.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 34)
        return this.errors.push(L.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      r.push(this._advance());
    }
  }
  _getText(e) {
    let r = e.parts[0];
    if (r.length > 0 && r[0] == `
`) {
      let n = this._getClosestParentElement();
      n != null && n.children.length == 0 && this.getTagDefinition(n.name).ignoreFirstLf && (r = r.substring(1));
    }
    return r;
  }
  _consumeText(e) {
    let r = [e], n = e.sourceSpan, s = e.parts[0];
    if (s.length > 0 && s[0] === `
`) {
      let i = this._getContainer();
      i != null && i.children.length === 0 && this.getTagDefinition(i.name).ignoreFirstLf && (s = s.substring(1), r[0] = { type: e.type, sourceSpan: e.sourceSpan, parts: [s] });
    }
    for (;this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9; )
      e = this._advance(), r.push(e), e.type === 8 ? s += e.parts.join("").replace(/&([^;]+);/g, pi) : e.type === 9 ? s += e.parts[0] : s += e.parts.join("");
    if (s.length > 0) {
      let i = e.sourceSpan;
      this._addToParent(new Wt(s, new h(n.start, i.end, n.fullStart, n.details), r));
    }
  }
  _closeVoidElement() {
    let e = this._getContainer();
    e instanceof Y && this.getTagDefinition(e.name).isVoid && this._containerStack.pop();
  }
  _consumeStartTag(e) {
    let [r, n] = e.parts, s = [];
    for (;this._peek.type === 14; )
      s.push(this._consumeAttr(this._advance()));
    let i = this._getElementFullName(r, n, this._getClosestParentElement()), a = false;
    if (this._peek.type === 2) {
      this._advance(), a = true;
      let C = this.getTagDefinition(i);
      this.canSelfClose || C.canSelfClose || Me(i) !== null || C.isVoid || this.errors.push(L.create(i, e.sourceSpan, `Only void, custom and foreign elements can be self closed "${e.parts[1]}"`));
    } else
      this._peek.type === 1 && (this._advance(), a = false);
    let o = this._peek.sourceSpan.fullStart, u = new h(e.sourceSpan.start, o, e.sourceSpan.fullStart), p = new h(e.sourceSpan.start, o, e.sourceSpan.fullStart), l = new h(e.sourceSpan.start.moveBy(1), e.sourceSpan.end), m = new Y(i, s, [], u, p, undefined, l), f = this._getContainer();
    this._pushContainer(m, f instanceof Y && this.getTagDefinition(f.name).isClosedByChild(m.name)), a ? this._popContainer(i, Y, u) : e.type === 4 && (this._popContainer(i, Y, null), this.errors.push(L.create(i, u, `Opening tag "${i}" not terminated.`)));
  }
  _pushContainer(e, r) {
    r && this._containerStack.pop(), this._addToParent(e), this._containerStack.push(e);
  }
  _consumeEndTag(e) {
    let r = this.allowHtmComponentClosingTags && e.parts.length === 0 ? null : this._getElementFullName(e.parts[0], e.parts[1], this._getClosestParentElement());
    if (r && this.getTagDefinition(r).isVoid)
      this.errors.push(L.create(r, e.sourceSpan, `Void elements do not have end tags "${e.parts[1]}"`));
    else if (!this._popContainer(r, Y, e.sourceSpan)) {
      let n = `Unexpected closing tag "${r}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
      this.errors.push(L.create(r, e.sourceSpan, n));
    }
  }
  _popContainer(e, r, n) {
    let s = false;
    for (let i = this._containerStack.length - 1;i >= 0; i--) {
      let a = this._containerStack[i];
      if (Me(a.name) ? a.name === e : (e == null || a.name.toLowerCase() === e.toLowerCase()) && a instanceof r)
        return a.endSourceSpan = n, a.sourceSpan.end = n !== null ? n.end : a.sourceSpan.end, this._containerStack.splice(i, this._containerStack.length - i), !s;
      (a instanceof ee || a instanceof Y && !this.getTagDefinition(a.name).closedByParent) && (s = true);
    }
    return false;
  }
  _consumeAttr(e) {
    let r = qe(e.parts[0], e.parts[1]), n = e.sourceSpan.end, s;
    this._peek.type === 15 && (s = this._advance());
    let i = "", a = [], o, u;
    if (this._peek.type === 16)
      for (o = this._peek.sourceSpan, u = this._peek.sourceSpan.end;this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9; ) {
        let m = this._advance();
        a.push(m), m.type === 17 ? i += m.parts.join("").replace(/&([^;]+);/g, pi) : m.type === 9 ? i += m.parts[0] : i += m.parts.join(""), u = n = m.sourceSpan.end;
      }
    this._peek.type === 15 && (u = n = this._advance().sourceSpan.end);
    let l = o && u && new h((s == null ? undefined : s.sourceSpan.start) ?? o.start, u, (s == null ? undefined : s.sourceSpan.fullStart) ?? o.fullStart);
    return new jt(r, i, new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), e.sourceSpan, l, a.length > 0 ? a : undefined, undefined);
  }
  _consumeBlockOpen(e) {
    let r = [];
    for (;this._peek.type === 28; ) {
      let o = this._advance();
      r.push(new ht(o.parts[0], o.sourceSpan));
    }
    this._peek.type === 26 && this._advance();
    let n = this._peek.sourceSpan.fullStart, s = new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), i = new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), a = new ee(e.parts[0], r, [], s, e.sourceSpan, i);
    this._pushContainer(a, false);
  }
  _consumeBlockClose(e) {
    this._popContainer(null, ee, e.sourceSpan) || this.errors.push(L.create(null, e.sourceSpan, 'Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the "&#125;" HTML entity instead.'));
  }
  _consumeIncompleteBlock(e) {
    let r = [];
    for (;this._peek.type === 28; ) {
      let o = this._advance();
      r.push(new ht(o.parts[0], o.sourceSpan));
    }
    let n = this._peek.sourceSpan.fullStart, s = new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), i = new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), a = new ee(e.parts[0], r, [], s, e.sourceSpan, i);
    this._pushContainer(a, false), this._popContainer(null, ee, null), this.errors.push(L.create(e.parts[0], s, `Incomplete block "${e.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`));
  }
  _consumeLet(e) {
    let r = e.parts[0], n, s;
    if (this._peek.type !== 31) {
      this.errors.push(L.create(e.parts[0], e.sourceSpan, `Invalid @let declaration "${r}". Declaration must have a value.`));
      return;
    } else
      n = this._advance();
    if (this._peek.type !== 32) {
      this.errors.push(L.create(e.parts[0], e.sourceSpan, `Unterminated @let declaration "${r}". Declaration must be terminated with a semicolon.`));
      return;
    } else
      s = this._advance();
    let i = s.sourceSpan.fullStart, a = new h(e.sourceSpan.start, i, e.sourceSpan.fullStart), o = e.sourceSpan.toString().lastIndexOf(r), u = e.sourceSpan.start.moveBy(o), p = new h(u, e.sourceSpan.end), l = new mt(r, n.parts[0], a, p, n.sourceSpan);
    this._addToParent(l);
  }
  _consumeIncompleteLet(e) {
    let r = e.parts[0] ?? "", n = r ? ` "${r}"` : "";
    if (r.length > 0) {
      let s = e.sourceSpan.toString().lastIndexOf(r), i = e.sourceSpan.start.moveBy(s), a = new h(i, e.sourceSpan.end), o = new h(e.sourceSpan.start, e.sourceSpan.start.moveBy(0)), u = new mt(r, "", e.sourceSpan, a, o);
      this._addToParent(u);
    }
    this.errors.push(L.create(e.parts[0], e.sourceSpan, `Incomplete @let declaration${n}. @let declarations must be written as \`@let <name> = <value>;\``));
  }
  _getContainer() {
    return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;
  }
  _getClosestParentElement() {
    for (let e = this._containerStack.length - 1;e > -1; e--)
      if (this._containerStack[e] instanceof Y)
        return this._containerStack[e];
    return null;
  }
  _addToParent(e) {
    let r = this._getContainer();
    r === null ? this.rootNodes.push(e) : r.children.push(e);
  }
  _getElementFullName(e, r, n) {
    if (e === "" && (e = this.getTagDefinition(r).implicitNamespacePrefix || "", e === "" && n != null)) {
      let s = ct(n.name)[1];
      this.getTagDefinition(s).preventNamespaceInheritance || (e = Me(n.name));
    }
    return qe(e, r);
  }
};
var ir = class extends sr {
  constructor() {
    super(He);
  }
  parse(e, r, n, s = false, i) {
    return super.parse(e, r, n, s, i);
  }
};
var Xr = null;
var Uo = () => (Xr || (Xr = new ir), Xr);
var hi = Wo;
var _t = 3;
var mi = zo;
var ar = { attrs: true, children: true, cases: true, expression: true };
var fi = new Set(["parent"]);
var le;
var Jr;
var Zr;
var Ge = class Ge2 {
  constructor(e = {}) {
    At(this, le);
    lr(this, "type");
    lr(this, "parent");
    for (let r of new Set([...fi, ...Object.keys(e)]))
      this.setProperty(r, e[r]);
  }
  setProperty(e, r) {
    if (this[e] !== r) {
      if (e in ar && (r = r.map((n) => this.createChild(n))), !fi.has(e)) {
        this[e] = r;
        return;
      }
      Object.defineProperty(this, e, { value: r, enumerable: false, configurable: true });
    }
  }
  map(e) {
    let r;
    for (let n in ar) {
      let s = this[n];
      if (s) {
        let i = Yo(s, (a) => a.map(e));
        r !== s && (r || (r = new Ge2({ parent: this.parent })), r.setProperty(n, i));
      }
    }
    if (r)
      for (let n in this)
        n in ar || (r[n] = this[n]);
    return e(r || this);
  }
  walk(e) {
    for (let r in ar) {
      let n = this[r];
      if (n)
        for (let s = 0;s < n.length; s++)
          n[s].walk(e);
    }
    e(this);
  }
  createChild(e) {
    let r = e instanceof Ge2 ? e.clone() : new Ge2(e);
    return r.setProperty("parent", this), r;
  }
  insertChildBefore(e, r) {
    let n = this.$children;
    n.splice(n.indexOf(e), 0, this.createChild(r));
  }
  removeChild(e) {
    let r = this.$children;
    r.splice(r.indexOf(e), 1);
  }
  replaceChild(e, r) {
    let n = this.$children;
    n[n.indexOf(e)] = this.createChild(r);
  }
  clone() {
    return new Ge2(this);
  }
  get $children() {
    return this[R(this, le, Jr)];
  }
  set $children(e) {
    this[R(this, le, Jr)] = e;
  }
  get firstChild() {
    var e;
    return (e = this.$children) == null ? undefined : e[0];
  }
  get lastChild() {
    return K(true, this.$children, -1);
  }
  get prev() {
    let e = R(this, le, Zr);
    return e[e.indexOf(this) - 1];
  }
  get next() {
    let e = R(this, le, Zr);
    return e[e.indexOf(this) + 1];
  }
  get rawName() {
    return this.hasExplicitNamespace ? this.fullName : this.name;
  }
  get fullName() {
    return this.namespace ? this.namespace + ":" + this.name : this.name;
  }
  get attrMap() {
    return Object.fromEntries(this.attrs.map((e) => [e.fullName, e.value]));
  }
};
le = new WeakSet, Jr = function() {
  return this.type === "angularIcuCase" ? "expression" : this.type === "angularIcuExpression" ? "cases" : "children";
}, Zr = function() {
  var e;
  return ((e = this.parent) == null ? undefined : e.$children) ?? [];
};
var or2 = Ge;
var jo = [{ regex: /^(\[if([^\]]*)\]>)(.*?)<!\s*\[endif\]$/su, parse: Ko }, { regex: /^\[if([^\]]*)\]><!$/u, parse: Xo }, { regex: /^<!\s*\[endif\]$/u, parse: Qo }];
var ur = new Map([["*", new Set(["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inert", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "popover", "slot", "spellcheck", "style", "tabindex", "title", "translate", "writingsuggestions"])], ["a", new Set(["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"])], ["applet", new Set(["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"])], ["area", new Set(["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"])], ["audio", new Set(["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"])], ["base", new Set(["href", "target"])], ["basefont", new Set(["color", "face", "size"])], ["blockquote", new Set(["cite"])], ["body", new Set(["alink", "background", "bgcolor", "link", "text", "vlink"])], ["br", new Set(["clear"])], ["button", new Set(["disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "popovertarget", "popovertargetaction", "type", "value"])], ["canvas", new Set(["height", "width"])], ["caption", new Set(["align"])], ["col", new Set(["align", "char", "charoff", "span", "valign", "width"])], ["colgroup", new Set(["align", "char", "charoff", "span", "valign", "width"])], ["data", new Set(["value"])], ["del", new Set(["cite", "datetime"])], ["details", new Set(["name", "open"])], ["dialog", new Set(["open"])], ["dir", new Set(["compact"])], ["div", new Set(["align"])], ["dl", new Set(["compact"])], ["embed", new Set(["height", "src", "type", "width"])], ["fieldset", new Set(["disabled", "form", "name"])], ["font", new Set(["color", "face", "size"])], ["form", new Set(["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"])], ["frame", new Set(["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"])], ["frameset", new Set(["cols", "rows"])], ["h1", new Set(["align"])], ["h2", new Set(["align"])], ["h3", new Set(["align"])], ["h4", new Set(["align"])], ["h5", new Set(["align"])], ["h6", new Set(["align"])], ["head", new Set(["profile"])], ["hr", new Set(["align", "noshade", "size", "width"])], ["html", new Set(["manifest", "version"])], ["iframe", new Set(["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"])], ["img", new Set(["align", "alt", "border", "crossorigin", "decoding", "fetchpriority", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"])], ["input", new Set(["accept", "align", "alt", "autocomplete", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "popovertarget", "popovertargetaction", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"])], ["ins", new Set(["cite", "datetime"])], ["isindex", new Set(["prompt"])], ["label", new Set(["for", "form"])], ["legend", new Set(["align"])], ["li", new Set(["type", "value"])], ["link", new Set(["as", "blocking", "charset", "color", "crossorigin", "disabled", "fetchpriority", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"])], ["map", new Set(["name"])], ["menu", new Set(["compact"])], ["meta", new Set(["charset", "content", "http-equiv", "media", "name", "scheme"])], ["meter", new Set(["high", "low", "max", "min", "optimum", "value"])], ["object", new Set(["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"])], ["ol", new Set(["compact", "reversed", "start", "type"])], ["optgroup", new Set(["disabled", "label"])], ["option", new Set(["disabled", "label", "selected", "value"])], ["output", new Set(["for", "form", "name"])], ["p", new Set(["align"])], ["param", new Set(["name", "type", "value", "valuetype"])], ["pre", new Set(["width"])], ["progress", new Set(["max", "value"])], ["q", new Set(["cite"])], ["script", new Set(["async", "blocking", "charset", "crossorigin", "defer", "fetchpriority", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"])], ["select", new Set(["autocomplete", "disabled", "form", "multiple", "name", "required", "size"])], ["slot", new Set(["name"])], ["source", new Set(["height", "media", "sizes", "src", "srcset", "type", "width"])], ["style", new Set(["blocking", "media", "type"])], ["table", new Set(["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"])], ["tbody", new Set(["align", "char", "charoff", "valign"])], ["td", new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["template", new Set(["shadowrootclonable", "shadowrootdelegatesfocus", "shadowrootmode"])], ["textarea", new Set(["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"])], ["tfoot", new Set(["align", "char", "charoff", "valign"])], ["th", new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["thead", new Set(["align", "char", "charoff", "valign"])], ["time", new Set(["datetime"])], ["tr", new Set(["align", "bgcolor", "char", "charoff", "valign"])], ["track", new Set(["default", "kind", "label", "src", "srclang"])], ["ul", new Set(["compact", "type"])], ["video", new Set(["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"])]]);
var gi = new Set(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]);
var en = { name: "html", normalizeTagName: true, normalizeAttributeName: true, allowHtmComponentClosingTags: true };
var ru = Et(en);
var nu = new Set(["mj-style", "mj-raw"]);
var su = Et({ ...en, name: "mjml", shouldParseAsRawText: (t8) => nu.has(t8) });
var iu = Et({ name: "angular" });
var au = Et({ name: "vue", isTagNameCaseSensitive: true, shouldParseAsRawText(t8, e, r, n) {
  return t8.toLowerCase() !== "html" && !r && (t8 !== "template" || n.some(({ name: s, value: i }) => s === "lang" && i !== "html" && i !== "" && i !== undefined));
} });
var ou = Et({ name: "lwc", canSelfClose: false });
var uu = { html: qs };
var ym = rn;

// node_modules/@react-email/render/node_modules/prettier/standalone.mjs
function Et2(e, t8, r) {
  return rr2.diff(e, t8, r);
}
function nr2(e) {
  let t8 = e.indexOf("\r");
  return t8 !== -1 ? e.charAt(t8 + 1) === `
` ? "crlf" : "cr" : "lf";
}
function xe2(e) {
  switch (e) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
function Ct2(e, t8) {
  let r;
  switch (t8) {
    case `
`:
      r = /\n/gu;
      break;
    case "\r":
      r = /\r/gu;
      break;
    case `\r
`:
      r = /\r\n/gu;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(t8)}.`);
  }
  let n = e.match(r);
  return n ? n.length : 0;
}
function ur2(e) {
  return te(false, e, /\r\n?/gu, `
`);
}
function or3(e) {
  let t8 = e.length;
  for (;t8 > 0 && (e[t8 - 1] === "\r" || e[t8 - 1] === `
`); )
    t8--;
  return t8 < e.length ? e.slice(0, t8) : e;
}
function _u(e) {
  if (typeof e == "string")
    return W2;
  if (Array.isArray(e))
    return Y2;
  if (!e)
    return;
  let { type: t8 } = e;
  if (Ue2.has(t8))
    return t8;
}
function wu(e) {
  let t8 = e === null ? "null" : typeof e;
  if (t8 !== "string" && t8 !== "object")
    return `Unexpected doc '${t8}', 
Expected it to be 'string' or 'object'.`;
  if (M(e))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(e);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let n = xu([...Ue2].map((u) => `'${u}'`));
  return `Unexpected doc.type '${e.type}'.
Expected it to be ${n}.`;
}
function bu(e, t8, r, n) {
  let u = [e];
  for (;u.length > 0; ) {
    let o = u.pop();
    if (o === ir2) {
      r(u.pop());
      continue;
    }
    r && u.push(o, ir2);
    let i = M(o);
    if (!i)
      throw new q(o);
    if ((t8 == null ? undefined : t8(o)) !== false)
      switch (i) {
        case Y2:
        case k2: {
          let s = i === Y2 ? o : o.parts;
          for (let a = s.length, c = a - 1;c >= 0; --c)
            u.push(s[c]);
          break;
        }
        case _2:
          u.push(o.flatContents, o.breakContents);
          break;
        case B2:
          if (n && o.expandedStates)
            for (let s = o.expandedStates.length, a = s - 1;a >= 0; --a)
              u.push(o.expandedStates[a]);
          else
            u.push(o.contents);
          break;
        case O2:
        case N2:
        case v2:
        case S2:
        case L2:
          u.push(o.contents);
          break;
        case W2:
        case j2:
        case P2:
        case I:
        case g:
        case w2:
          break;
        default:
          throw new q(o);
      }
  }
}
function be2(e, t8) {
  if (typeof e == "string")
    return t8(e);
  let r = new Map;
  return n(e);
  function n(o) {
    if (r.has(o))
      return r.get(o);
    let i = u(o);
    return r.set(o, i), i;
  }
  function u(o) {
    switch (M(o)) {
      case Y2:
        return t8(o.map(n));
      case k2:
        return t8({ ...o, parts: o.parts.map(n) });
      case _2:
        return t8({ ...o, breakContents: n(o.breakContents), flatContents: n(o.flatContents) });
      case B2: {
        let { expandedStates: i, contents: s } = o;
        return i ? (i = i.map(n), s = i[0]) : s = n(s), t8({ ...o, contents: s, expandedStates: i });
      }
      case O2:
      case N2:
      case v2:
      case S2:
      case L2:
        return t8({ ...o, contents: n(o.contents) });
      case W2:
      case j2:
      case P2:
      case I:
      case g:
      case w2:
        return t8(o);
      default:
        throw new q(o);
    }
  }
}
function Ve2(e, t8, r) {
  let n = r, u = false;
  function o(i) {
    if (u)
      return false;
    let s = t8(i);
    s !== undefined && (u = true, n = s);
  }
  return le2(e, o), n;
}
function ku(e) {
  if (e.type === B2 && e.break || e.type === g && e.hard || e.type === w2)
    return true;
}
function Dr2(e) {
  return Ve2(e, ku, false);
}
function sr2(e) {
  if (e.length > 0) {
    let t8 = y(false, e, -1);
    !t8.expandedStates && !t8.break && (t8.break = "propagated");
  }
  return null;
}
function cr2(e) {
  let t8 = new Set, r = [];
  function n(o) {
    if (o.type === w2 && sr2(r), o.type === B2) {
      if (r.push(o), t8.has(o))
        return false;
      t8.add(o);
    }
  }
  function u(o) {
    o.type === B2 && r.pop().break && sr2(r);
  }
  le2(e, n, u, true);
}
function Su(e) {
  return e.type === g && !e.hard ? e.soft ? "" : " " : e.type === _2 ? e.flatContents : e;
}
function fr2(e) {
  return be2(e, Su);
}
function ar2(e) {
  for (e = [...e];e.length >= 2 && y(false, e, -2).type === g && y(false, e, -1).type === w2; )
    e.length -= 2;
  if (e.length > 0) {
    let t8 = we2(y(false, e, -1));
    e[e.length - 1] = t8;
  }
  return e;
}
function we2(e) {
  switch (M(e)) {
    case N2:
    case v2:
    case B2:
    case L2:
    case S2: {
      let t8 = we2(e.contents);
      return { ...e, contents: t8 };
    }
    case _2:
      return { ...e, breakContents: we2(e.breakContents), flatContents: we2(e.flatContents) };
    case k2:
      return { ...e, parts: ar2(e.parts) };
    case Y2:
      return ar2(e);
    case W2:
      return or3(e);
    case O2:
    case j2:
    case P2:
    case I:
    case g:
    case w2:
      break;
    default:
      throw new q(e);
  }
  return e;
}
function $e(e) {
  return we2(Nu(e));
}
function Tu(e) {
  switch (M(e)) {
    case k2:
      if (e.parts.every((t8) => t8 === ""))
        return "";
      break;
    case B2:
      if (!e.contents && !e.id && !e.break && !e.expandedStates)
        return "";
      if (e.contents.type === B2 && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates)
        return e.contents;
      break;
    case O2:
    case N2:
    case v2:
    case L2:
      if (!e.contents)
        return "";
      break;
    case _2:
      if (!e.flatContents && !e.breakContents)
        return "";
      break;
    case Y2: {
      let t8 = [];
      for (let r of e) {
        if (!r)
          continue;
        let [n, ...u] = Array.isArray(r) ? r : [r];
        typeof n == "string" && typeof y(false, t8, -1) == "string" ? t8[t8.length - 1] += n : t8.push(n), t8.push(...u);
      }
      return t8.length === 0 ? "" : t8.length === 1 ? t8[0] : t8;
    }
    case W2:
    case j2:
    case P2:
    case I:
    case g:
    case S2:
    case w2:
      break;
    default:
      throw new q(e);
  }
  return e;
}
function Nu(e) {
  return be2(e, (t8) => Tu(t8));
}
function lr2(e, t8 = We) {
  return be2(e, (r) => typeof r == "string" ? ke2(t8, r.split(`
`)) : r);
}
function Ou(e) {
  if (e.type === g)
    return true;
}
function Fr2(e) {
  return Ve2(e, Ou, false);
}
function Fe2(e, t8) {
  return e.type === S2 ? { ...e, contents: t8(e.contents) } : t8(e);
}
function ie2(e) {
  return K2(e), { type: N2, contents: e };
}
function oe(e, t8) {
  return K2(t8), { type: O2, contents: t8, n: e };
}
function At2(e, t8 = {}) {
  return K2(e), yt2(t8.expandedStates, true), { type: B2, id: t8.id, contents: e, break: !!t8.shouldBreak, expandedStates: t8.expandedStates };
}
function dr2(e) {
  return oe(Number.NEGATIVE_INFINITY, e);
}
function mr2(e) {
  return oe({ type: "root" }, e);
}
function Er2(e) {
  return oe(-1, e);
}
function Cr2(e, t8) {
  return At2(e[0], { ...t8, expandedStates: e });
}
function hr2(e) {
  return pr2(e), { type: k2, parts: e };
}
function gr2(e, t8 = "", r = {}) {
  return K2(e), t8 !== "" && K2(t8), { type: _2, breakContents: e, flatContents: t8, groupId: r.groupId };
}
function yr2(e, t8) {
  return K2(e), { type: v2, contents: e, groupId: t8.groupId, negate: t8.negate };
}
function Se2(e) {
  return K2(e), { type: L2, contents: e };
}
function ke2(e, t8) {
  K2(e), yt2(t8);
  let r = [];
  for (let n = 0;n < t8.length; n++)
    n !== 0 && r.push(e), r.push(t8[n]);
  return r;
}
function Ge3(e, t8, r) {
  K2(e);
  let n = e;
  if (t8 > 0) {
    for (let u = 0;u < Math.floor(t8 / r); ++u)
      n = ie2(n);
    n = oe(t8 % r, n), n = oe(Number.NEGATIVE_INFINITY, n);
  }
  return n;
}
function xr2(e, t8) {
  return K2(t8), e ? { type: S2, label: e, contents: t8 } : t8;
}
function Q2(e) {
  var t8;
  if (!e)
    return "";
  if (Array.isArray(e)) {
    let r = [];
    for (let n of e)
      if (Array.isArray(n))
        r.push(...Q2(n));
      else {
        let u = Q2(n);
        u !== "" && r.push(u);
      }
    return r;
  }
  return e.type === _2 ? { ...e, breakContents: Q2(e.breakContents), flatContents: Q2(e.flatContents) } : e.type === B2 ? { ...e, contents: Q2(e.contents), expandedStates: (t8 = e.expandedStates) == null ? undefined : t8.map(Q2) } : e.type === k2 ? { type: "fill", parts: e.parts.map(Q2) } : e.contents ? { ...e, contents: Q2(e.contents) } : e;
}
function wr2(e) {
  let t8 = Object.create(null), r = new Set;
  return n(Q2(e));
  function n(o, i, s) {
    var a, c;
    if (typeof o == "string")
      return JSON.stringify(o);
    if (Array.isArray(o)) {
      let D = o.map(n).filter(Boolean);
      return D.length === 1 ? D[0] : `[${D.join(", ")}]`;
    }
    if (o.type === g) {
      let D = ((a = s == null ? undefined : s[i + 1]) == null ? undefined : a.type) === w2;
      return o.literal ? D ? "literalline" : "literallineWithoutBreakParent" : o.hard ? D ? "hardline" : "hardlineWithoutBreakParent" : o.soft ? "softline" : "line";
    }
    if (o.type === w2)
      return ((c = s == null ? undefined : s[i - 1]) == null ? undefined : c.type) === g && s[i - 1].hard ? undefined : "breakParent";
    if (o.type === P2)
      return "trim";
    if (o.type === N2)
      return "indent(" + n(o.contents) + ")";
    if (o.type === O2)
      return o.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + n(o.contents) + ")" : o.n < 0 ? "dedent(" + n(o.contents) + ")" : o.n.type === "root" ? "markAsRoot(" + n(o.contents) + ")" : "align(" + JSON.stringify(o.n) + ", " + n(o.contents) + ")";
    if (o.type === _2)
      return "ifBreak(" + n(o.breakContents) + (o.flatContents ? ", " + n(o.flatContents) : "") + (o.groupId ? (o.flatContents ? "" : ', ""') + `, { groupId: ${u(o.groupId)} }` : "") + ")";
    if (o.type === v2) {
      let D = [];
      o.negate && D.push("negate: true"), o.groupId && D.push(`groupId: ${u(o.groupId)}`);
      let p = D.length > 0 ? `, { ${D.join(", ")} }` : "";
      return `indentIfBreak(${n(o.contents)}${p})`;
    }
    if (o.type === B2) {
      let D = [];
      o.break && o.break !== "propagated" && D.push("shouldBreak: true"), o.id && D.push(`id: ${u(o.id)}`);
      let p = D.length > 0 ? `, { ${D.join(", ")} }` : "";
      return o.expandedStates ? `conditionalGroup([${o.expandedStates.map((l) => n(l)).join(",")}]${p})` : `group(${n(o.contents)}${p})`;
    }
    if (o.type === k2)
      return `fill([${o.parts.map((D) => n(D)).join(", ")}])`;
    if (o.type === L2)
      return "lineSuffix(" + n(o.contents) + ")";
    if (o.type === I)
      return "lineSuffixBoundary";
    if (o.type === S2)
      return `label(${JSON.stringify(o.label)}, ${n(o.contents)})`;
    if (o.type === j2)
      return "cursor";
    throw new Error("Unknown doc type " + o.type);
  }
  function u(o) {
    if (typeof o != "symbol")
      return JSON.stringify(String(o));
    if (o in t8)
      return t8[o];
    let i = o.description || "symbol";
    for (let s = 0;; s++) {
      let a = i + (s > 0 ? ` #${s}` : "");
      if (!r.has(a))
        return r.add(a), t8[o] = `Symbol.for(${JSON.stringify(a)})`;
    }
  }
}
function kr2(e) {
  return e === 12288 || e >= 65281 && e <= 65376 || e >= 65504 && e <= 65510;
}
function Sr2(e) {
  return e >= 4352 && e <= 4447 || e === 8986 || e === 8987 || e === 9001 || e === 9002 || e >= 9193 && e <= 9196 || e === 9200 || e === 9203 || e === 9725 || e === 9726 || e === 9748 || e === 9749 || e >= 9776 && e <= 9783 || e >= 9800 && e <= 9811 || e === 9855 || e >= 9866 && e <= 9871 || e === 9875 || e === 9889 || e === 9898 || e === 9899 || e === 9917 || e === 9918 || e === 9924 || e === 9925 || e === 9934 || e === 9940 || e === 9962 || e === 9970 || e === 9971 || e === 9973 || e === 9978 || e === 9981 || e === 9989 || e === 9994 || e === 9995 || e === 10024 || e === 10060 || e === 10062 || e >= 10067 && e <= 10069 || e === 10071 || e >= 10133 && e <= 10135 || e === 10160 || e === 10175 || e === 11035 || e === 11036 || e === 11088 || e === 11093 || e >= 11904 && e <= 11929 || e >= 11931 && e <= 12019 || e >= 12032 && e <= 12245 || e >= 12272 && e <= 12287 || e >= 12289 && e <= 12350 || e >= 12353 && e <= 12438 || e >= 12441 && e <= 12543 || e >= 12549 && e <= 12591 || e >= 12593 && e <= 12686 || e >= 12688 && e <= 12773 || e >= 12783 && e <= 12830 || e >= 12832 && e <= 12871 || e >= 12880 && e <= 42124 || e >= 42128 && e <= 42182 || e >= 43360 && e <= 43388 || e >= 44032 && e <= 55203 || e >= 63744 && e <= 64255 || e >= 65040 && e <= 65049 || e >= 65072 && e <= 65106 || e >= 65108 && e <= 65126 || e >= 65128 && e <= 65131 || e >= 94176 && e <= 94180 || e === 94192 || e === 94193 || e >= 94208 && e <= 100343 || e >= 100352 && e <= 101589 || e >= 101631 && e <= 101640 || e >= 110576 && e <= 110579 || e >= 110581 && e <= 110587 || e === 110589 || e === 110590 || e >= 110592 && e <= 110882 || e === 110898 || e >= 110928 && e <= 110930 || e === 110933 || e >= 110948 && e <= 110951 || e >= 110960 && e <= 111355 || e >= 119552 && e <= 119638 || e >= 119648 && e <= 119670 || e === 126980 || e === 127183 || e === 127374 || e >= 127377 && e <= 127386 || e >= 127488 && e <= 127490 || e >= 127504 && e <= 127547 || e >= 127552 && e <= 127560 || e === 127568 || e === 127569 || e >= 127584 && e <= 127589 || e >= 127744 && e <= 127776 || e >= 127789 && e <= 127797 || e >= 127799 && e <= 127868 || e >= 127870 && e <= 127891 || e >= 127904 && e <= 127946 || e >= 127951 && e <= 127955 || e >= 127968 && e <= 127984 || e === 127988 || e >= 127992 && e <= 128062 || e === 128064 || e >= 128066 && e <= 128252 || e >= 128255 && e <= 128317 || e >= 128331 && e <= 128334 || e >= 128336 && e <= 128359 || e === 128378 || e === 128405 || e === 128406 || e === 128420 || e >= 128507 && e <= 128591 || e >= 128640 && e <= 128709 || e === 128716 || e >= 128720 && e <= 128722 || e >= 128725 && e <= 128727 || e >= 128732 && e <= 128735 || e === 128747 || e === 128748 || e >= 128756 && e <= 128764 || e >= 128992 && e <= 129003 || e === 129008 || e >= 129292 && e <= 129338 || e >= 129340 && e <= 129349 || e >= 129351 && e <= 129535 || e >= 129648 && e <= 129660 || e >= 129664 && e <= 129673 || e >= 129679 && e <= 129734 || e >= 129742 && e <= 129756 || e >= 129759 && e <= 129769 || e >= 129776 && e <= 129784 || e >= 131072 && e <= 196605 || e >= 196608 && e <= 262141;
}
function vu(e) {
  if (!e)
    return 0;
  if (!Pu.test(e))
    return e.length;
  e = e.replace(br2(), "  ");
  let t8 = 0;
  for (let r of e) {
    let n = r.codePointAt(0);
    n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (t8 += Tr2(n) ? 1 : 2);
  }
  return t8;
}
function Nr2() {
  return { value: "", length: 0, queue: [] };
}
function Lu(e, t8) {
  return xt2(e, { type: "indent" }, t8);
}
function Iu(e, t8, r) {
  return t8 === Number.NEGATIVE_INFINITY ? e.root || Nr2() : t8 < 0 ? xt2(e, { type: "dedent" }, r) : t8 ? t8.type === "root" ? { ...e, root: e } : xt2(e, { type: typeof t8 == "string" ? "stringAlign" : "numberAlign", n: t8 }, r) : e;
}
function xt2(e, t8, r) {
  let n = t8.type === "dedent" ? e.queue.slice(0, -1) : [...e.queue, t8], u = "", o = 0, i = 0, s = 0;
  for (let f of n)
    switch (f.type) {
      case "indent":
        D(), r.useTabs ? a(1) : c(r.tabWidth);
        break;
      case "stringAlign":
        D(), u += f.n, o += f.n.length;
        break;
      case "numberAlign":
        i += 1, s += f.n;
        break;
      default:
        throw new Error(`Unexpected type '${f.type}'`);
    }
  return l(), { ...e, value: u, length: o, queue: n };
  function a(f) {
    u += "	".repeat(f), o += r.tabWidth * f;
  }
  function c(f) {
    u += " ".repeat(f), o += f;
  }
  function D() {
    r.useTabs ? p() : l();
  }
  function p() {
    i > 0 && a(i), F();
  }
  function l() {
    s > 0 && c(s), F();
  }
  function F() {
    i = 0, s = 0;
  }
}
function wt2(e) {
  let t8 = 0, r = 0, n = e.length;
  e:
    for (;n--; ) {
      let u = e[n];
      if (u === de2) {
        r++;
        continue;
      }
      for (let o = u.length - 1;o >= 0; o--) {
        let i = u[o];
        if (i === " " || i === "	")
          t8++;
        else {
          e[n] = u.slice(0, o + 1);
          break e;
        }
      }
    }
  if (t8 > 0 || r > 0)
    for (e.length = n + 1;r-- > 0; )
      e.push(de2);
  return t8;
}
function Ke2(e, t8, r, n, u, o) {
  if (r === Number.POSITIVE_INFINITY)
    return true;
  let i = t8.length, s = [e], a = [];
  for (;r >= 0; ) {
    if (s.length === 0) {
      if (i === 0)
        return true;
      s.push(t8[--i]);
      continue;
    }
    let { mode: c, doc: D } = s.pop(), p = M(D);
    switch (p) {
      case W2:
        a.push(D), r -= Ne2(D);
        break;
      case Y2:
      case k2: {
        let l = p === Y2 ? D : D.parts, F = D[_t2] ?? 0;
        for (let f = l.length - 1;f >= F; f--)
          s.push({ mode: c, doc: l[f] });
        break;
      }
      case N2:
      case O2:
      case v2:
      case S2:
        s.push({ mode: c, doc: D.contents });
        break;
      case P2:
        r += wt2(a);
        break;
      case B2: {
        if (o && D.break)
          return false;
        let l = D.break ? R2 : c, F = D.expandedStates && l === R2 ? y(false, D.expandedStates, -1) : D.contents;
        s.push({ mode: l, doc: F });
        break;
      }
      case _2: {
        let F = (D.groupId ? u[D.groupId] || H2 : c) === R2 ? D.breakContents : D.flatContents;
        F && s.push({ mode: c, doc: F });
        break;
      }
      case g:
        if (c === R2 || D.hard)
          return true;
        D.soft || (a.push(" "), r--);
        break;
      case L2:
        n = true;
        break;
      case I:
        if (n)
          return false;
        break;
    }
  }
  return false;
}
function me2(e, t8) {
  let r = {}, n = t8.printWidth, u = xe2(t8.endOfLine), o = 0, i = [{ ind: Nr2(), mode: R2, doc: e }], s = [], a = false, c = [], D = 0;
  for (cr2(e);i.length > 0; ) {
    let { ind: l, mode: F, doc: f } = i.pop();
    switch (M(f)) {
      case W2: {
        let d2 = u !== `
` ? te(false, f, `
`, u) : f;
        s.push(d2), i.length > 0 && (o += Ne2(d2));
        break;
      }
      case Y2:
        for (let d2 = f.length - 1;d2 >= 0; d2--)
          i.push({ ind: l, mode: F, doc: f[d2] });
        break;
      case j2:
        if (D >= 2)
          throw new Error("There are too many 'cursor' in doc.");
        s.push(de2), D++;
        break;
      case N2:
        i.push({ ind: Lu(l, t8), mode: F, doc: f.contents });
        break;
      case O2:
        i.push({ ind: Iu(l, f.n, t8), mode: F, doc: f.contents });
        break;
      case P2:
        o -= wt2(s);
        break;
      case B2:
        switch (F) {
          case H2:
            if (!a) {
              i.push({ ind: l, mode: f.break ? R2 : H2, doc: f.contents });
              break;
            }
          case R2: {
            a = false;
            let d2 = { ind: l, mode: H2, doc: f.contents }, m = n - o, C = c.length > 0;
            if (!f.break && Ke2(d2, i, m, C, r))
              i.push(d2);
            else if (f.expandedStates) {
              let E2 = y(false, f.expandedStates, -1);
              if (f.break) {
                i.push({ ind: l, mode: R2, doc: E2 });
                break;
              } else
                for (let h2 = 1;h2 < f.expandedStates.length + 1; h2++)
                  if (h2 >= f.expandedStates.length) {
                    i.push({ ind: l, mode: R2, doc: E2 });
                    break;
                  } else {
                    let x = f.expandedStates[h2], A = { ind: l, mode: H2, doc: x };
                    if (Ke2(A, i, m, C, r)) {
                      i.push(A);
                      break;
                    }
                  }
            } else
              i.push({ ind: l, mode: R2, doc: f.contents });
            break;
          }
        }
        f.id && (r[f.id] = y(false, i, -1).mode);
        break;
      case k2: {
        let d2 = n - o, m = f[_t2] ?? 0, { parts: C } = f, E2 = C.length - m;
        if (E2 === 0)
          break;
        let h2 = C[m + 0], x = C[m + 1], A = { ind: l, mode: H2, doc: h2 }, $2 = { ind: l, mode: R2, doc: h2 }, ue = Ke2(A, [], d2, c.length > 0, r, true);
        if (E2 === 1) {
          ue ? i.push(A) : i.push($2);
          break;
        }
        let Be2 = { ind: l, mode: H2, doc: x }, lt3 = { ind: l, mode: R2, doc: x };
        if (E2 === 2) {
          ue ? i.push(Be2, A) : i.push(lt3, $2);
          break;
        }
        let lu = C[m + 2], Ft2 = { ind: l, mode: F, doc: { ...f, [_t2]: m + 2 } };
        Ke2({ ind: l, mode: H2, doc: [h2, x, lu] }, [], d2, c.length > 0, r, true) ? i.push(Ft2, Be2, A) : ue ? i.push(Ft2, lt3, A) : i.push(Ft2, lt3, $2);
        break;
      }
      case _2:
      case v2: {
        let d2 = f.groupId ? r[f.groupId] : F;
        if (d2 === R2) {
          let m = f.type === _2 ? f.breakContents : f.negate ? f.contents : ie2(f.contents);
          m && i.push({ ind: l, mode: F, doc: m });
        }
        if (d2 === H2) {
          let m = f.type === _2 ? f.flatContents : f.negate ? ie2(f.contents) : f.contents;
          m && i.push({ ind: l, mode: F, doc: m });
        }
        break;
      }
      case L2:
        c.push({ ind: l, mode: F, doc: f.contents });
        break;
      case I:
        c.length > 0 && i.push({ ind: l, mode: F, doc: Te2 });
        break;
      case g:
        switch (F) {
          case H2:
            if (f.hard)
              a = true;
            else {
              f.soft || (s.push(" "), o += 1);
              break;
            }
          case R2:
            if (c.length > 0) {
              i.push({ ind: l, mode: F, doc: f }, ...c.reverse()), c.length = 0;
              break;
            }
            f.literal ? l.root ? (s.push(u, l.root.value), o = l.root.length) : (s.push(u), o = 0) : (o -= wt2(s), s.push(u + l.value), o = l.length);
            break;
        }
        break;
      case S2:
        i.push({ ind: l, mode: F, doc: f.contents });
        break;
      case w2:
        break;
      default:
        throw new q(f);
    }
    i.length === 0 && c.length > 0 && (i.push(...c.reverse()), c.length = 0);
  }
  let p = s.indexOf(de2);
  if (p !== -1) {
    let l = s.indexOf(de2, p + 1);
    if (l === -1)
      return { formatted: s.filter((m) => m !== de2).join("") };
    let F = s.slice(0, p).join(""), f = s.slice(p + 1, l).join(""), d2 = s.slice(l + 1).join("");
    return { formatted: F + f + d2, cursorNodeStart: F.length, cursorNodeText: f };
  }
  return { formatted: s.join("") };
}
function Ru(e, t8, r = 0) {
  let n = 0;
  for (let u = r;u < e.length; ++u)
    e[u] === "	" ? n = n + t8 - n % t8 : n++;
  return n;
}
function Yu(e) {
  return e !== null && typeof e == "object";
}
function* Ce2(e, t8) {
  let { getVisitorKeys: r, filter: n = () => true } = t8, u = (o) => vr2(o) && n(o);
  for (let o of r(e)) {
    let i = e[o];
    if (Array.isArray(i))
      for (let s of i)
        u(s) && (yield s);
    else
      u(i) && (yield i);
  }
}
function* Lr2(e, t8) {
  let r = [e];
  for (let n = 0;n < r.length; n++) {
    let u = r[n];
    for (let o of Ce2(u, t8))
      yield o, r.push(o);
  }
}
function Ir2(e, t8) {
  return Ce2(e, t8).next().done;
}
function he2(e) {
  return (t8, r, n) => {
    let u = !!(n != null && n.backwards);
    if (r === false)
      return false;
    let { length: o } = t8, i = r;
    for (;i >= 0 && i < o; ) {
      let s = t8.charAt(i);
      if (e instanceof RegExp) {
        if (!e.test(s))
          return i;
      } else if (!e.includes(s))
        return i;
      u ? i-- : i++;
    }
    return i === -1 || i === o ? i : false;
  };
}
function ju(e, t8, r) {
  let n = !!(r != null && r.backwards);
  if (t8 === false)
    return false;
  let u = e.charAt(t8);
  if (n) {
    if (e.charAt(t8 - 1) === "\r" && u === `
`)
      return t8 - 2;
    if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029")
      return t8 - 1;
  } else {
    if (u === "\r" && e.charAt(t8 + 1) === `
`)
      return t8 + 2;
    if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029")
      return t8 + 1;
  }
  return t8;
}
function Uu(e, t8, r = {}) {
  let n = T2(e, r.backwards ? t8 - 1 : t8, r), u = U(e, n, r);
  return n !== u;
}
function Vu(e) {
  return Array.isArray(e) && e.length > 0;
}
function Wu(e) {
  return e ? (t8) => e(t8, Yr) : $u;
}
function Mu(e) {
  let t8 = e.type || e.kind || "(unknown type)", r = String(e.name || e.id && (typeof e.id == "object" ? e.id.name : e.id) || e.key && (typeof e.key == "object" ? e.key.name : e.key) || e.value && (typeof e.value == "object" ? "" : String(e.value)) || e.operator || "");
  return r.length > 20 && (r = r.slice(0, 19) + "\u2026"), t8 + (r ? " " + r : "");
}
function St2(e, t8) {
  (e.comments ?? (e.comments = [])).push(t8), t8.printed = false, t8.nodeDescription = Mu(e);
}
function se2(e, t8) {
  t8.leading = true, t8.trailing = false, St2(e, t8);
}
function ee2(e, t8, r) {
  t8.leading = false, t8.trailing = false, r && (t8.marker = r), St2(e, t8);
}
function ae2(e, t8) {
  t8.leading = false, t8.trailing = true, St2(e, t8);
}
function Xe2(e, t8) {
  if (Tt2.has(e))
    return Tt2.get(e);
  let { printer: { getCommentChildNodes: r, canAttachComment: n, getVisitorKeys: u }, locStart: o, locEnd: i } = t8;
  if (!n)
    return [];
  let s = ((r == null ? undefined : r(e, t8)) ?? [...Ce2(e, { getVisitorKeys: J2(u) })]).flatMap((a) => n(a) ? [a] : Xe2(a, t8));
  return s.sort((a, c) => o(a) - o(c) || i(a) - i(c)), Tt2.set(e, s), s;
}
function Ur2(e, t8, r, n) {
  let { locStart: u, locEnd: o } = r, i = u(t8), s = o(t8), a = Xe2(e, r), c, D, p = 0, l = a.length;
  for (;p < l; ) {
    let F = p + l >> 1, f = a[F], d2 = u(f), m = o(f);
    if (d2 <= i && s <= m)
      return Ur2(f, t8, r, f);
    if (m <= i) {
      c = f, p = F + 1;
      continue;
    }
    if (s <= d2) {
      D = f, l = F;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((n == null ? undefined : n.type) === "TemplateLiteral") {
    let { quasis: F } = n, f = Ot2(F, t8, r);
    c && Ot2(F, c, r) !== f && (c = null), D && Ot2(F, D, r) !== f && (D = null);
  }
  return { enclosingNode: n, precedingNode: c, followingNode: D };
}
function Vr(e, t8) {
  let { comments: r } = e;
  if (delete e.comments, !qe2(r) || !t8.printer.canAttachComment)
    return;
  let n = [], { printer: { experimentalFeatures: { avoidAstMutation: u = false } = {}, handleComments: o = {} }, originalText: i } = t8, { ownLine: s = Nt2, endOfLine: a = Nt2, remaining: c = Nt2 } = o, D = r.map((p, l) => ({ ...Ur2(e, p, t8), comment: p, text: i, options: t8, ast: e, isLastComment: r.length - 1 === l }));
  for (let [p, l] of D.entries()) {
    let { comment: F, precedingNode: f, enclosingNode: d2, followingNode: m, text: C, options: E2, ast: h2, isLastComment: x } = l, A;
    if (u ? A = [l] : (F.enclosingNode = d2, F.precedingNode = f, F.followingNode = m, A = [F, C, E2, h2, x]), Gu(C, E2, D, p))
      F.placement = "ownLine", s(...A) || (m ? se2(m, F) : f ? ae2(f, F) : d2 ? ee2(d2, F) : ee2(h2, F));
    else if (Ku(C, E2, D, p))
      F.placement = "endOfLine", a(...A) || (f ? ae2(f, F) : m ? se2(m, F) : d2 ? ee2(d2, F) : ee2(h2, F));
    else if (F.placement = "remaining", !c(...A))
      if (f && m) {
        let $2 = n.length;
        $2 > 0 && n[$2 - 1].followingNode !== m && jr2(n, E2), n.push(l);
      } else
        f ? ae2(f, F) : m ? se2(m, F) : d2 ? ee2(d2, F) : ee2(h2, F);
  }
  if (jr2(n, t8), !u)
    for (let p of r)
      delete p.precedingNode, delete p.enclosingNode, delete p.followingNode;
}
function Gu(e, t8, r, n) {
  let { comment: u, precedingNode: o } = r[n], { locStart: i, locEnd: s } = t8, a = i(u);
  if (o)
    for (let c = n - 1;c >= 0; c--) {
      let { comment: D, precedingNode: p } = r[c];
      if (p !== o || !$r2(e.slice(s(D), a)))
        break;
      a = i(D);
    }
  return G2(e, a, { backwards: true });
}
function Ku(e, t8, r, n) {
  let { comment: u, followingNode: o } = r[n], { locStart: i, locEnd: s } = t8, a = s(u);
  if (o)
    for (let c = n + 1;c < r.length; c++) {
      let { comment: D, followingNode: p } = r[c];
      if (p !== o || !$r2(e.slice(a, i(D))))
        break;
      a = s(D);
    }
  return G2(e, a);
}
function jr2(e, t8) {
  var s, a;
  let r = e.length;
  if (r === 0)
    return;
  let { precedingNode: n, followingNode: u } = e[0], o = t8.locStart(u), i;
  for (i = r;i > 0; --i) {
    let { comment: c, precedingNode: D, followingNode: p } = e[i - 1];
    Oe2.strictEqual(D, n), Oe2.strictEqual(p, u);
    let l = t8.originalText.slice(t8.locEnd(c), o);
    if (((a = (s = t8.printer).isGap) == null ? undefined : a.call(s, l, t8)) ?? /^[\s(]*$/u.test(l))
      o = t8.locStart(c);
    else
      break;
  }
  for (let [c, { comment: D }] of e.entries())
    c < i ? ae2(n, D) : se2(u, D);
  for (let c of [n, u])
    c.comments && c.comments.length > 1 && c.comments.sort((D, p) => t8.locStart(D) - t8.locStart(p));
  e.length = 0;
}
function Ot2(e, t8, r) {
  let n = r.locStart(t8) - 1;
  for (let u = 1;u < e.length; ++u)
    if (n < r.locStart(e[u]))
      return u - 1;
  return 0;
}
function zu(e, t8) {
  let r = t8 - 1;
  r = T2(e, r, { backwards: true }), r = U(e, r, { backwards: true }), r = T2(e, r, { backwards: true });
  let n = U(e, r, { backwards: true });
  return r !== n;
}
function Wr2(e, t8) {
  let r = e.node;
  return r.printed = true, t8.printer.printComment(e, t8);
}
function Hu(e, t8) {
  var D;
  let r = e.node, n = [Wr2(e, t8)], { printer: u, originalText: o, locStart: i, locEnd: s } = t8;
  if ((D = u.isBlockComment) == null ? undefined : D.call(u, r)) {
    let p = G2(o, s(r)) ? G2(o, i(r), { backwards: true }) ? z3 : Me2 : " ";
    n.push(p);
  } else
    n.push(z3);
  let c = U(o, T2(o, s(r)));
  return c !== false && G2(o, c) && n.push(z3), n;
}
function Ju(e, t8, r) {
  var c;
  let n = e.node, u = Wr2(e, t8), { printer: o, originalText: i, locStart: s } = t8, a = (c = o.isBlockComment) == null ? undefined : c.call(o, n);
  if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || G2(i, s(n), { backwards: true })) {
    let D = Pe2(i, s(n));
    return { doc: Se2([z3, D ? z3 : "", u]), isBlock: a, hasLineSuffix: true };
  }
  return !a || r != null && r.hasLineSuffix ? { doc: [Se2([" ", u]), pe2], isBlock: a, hasLineSuffix: true } : { doc: [" ", u], isBlock: a, hasLineSuffix: false };
}
function qu(e, t8) {
  let r = e.node;
  if (!r)
    return {};
  let n = t8[Symbol.for("printedComments")];
  if ((r.comments || []).filter((a) => !n.has(a)).length === 0)
    return { leading: "", trailing: "" };
  let o = [], i = [], s;
  return e.each(() => {
    let a = e.node;
    if (n != null && n.has(a))
      return;
    let { leading: c, trailing: D } = a;
    c ? o.push(Hu(e, t8)) : D && (s = Ju(e, t8, s), i.push(s.doc));
  }, "comments"), { leading: o, trailing: i };
}
function Mr(e, t8, r) {
  let { leading: n, trailing: u } = qu(e, r);
  return !n && !u ? t8 : Fe2(t8, (o) => [n, o, u]);
}
function Gr2(e) {
  let { [Symbol.for("comments")]: t8, [Symbol.for("printedComments")]: r } = e;
  for (let n of t8) {
    if (!n.printed && !r.has(n))
      throw new Error('Comment "' + n.value.trim() + '" was not printed. Please report this error!');
    delete n.printed;
  }
}
function Xu(e) {
  return () => {
  };
}
function Qe2({ plugins: e = [], showDeprecated: t8 = false } = {}) {
  let r = e.flatMap((u) => u.languages ?? []), n = [];
  for (let u of Zu(Object.assign({}, ...e.map(({ options: o }) => o), zr)))
    !t8 && u.deprecated || (Array.isArray(u.choices) && (t8 || (u.choices = u.choices.filter((o) => !o.deprecated)), u.name === "parser" && (u.choices = [...u.choices, ...Qu(u.choices, r, e)])), u.pluginDefaults = Object.fromEntries(e.filter((o) => {
      var i;
      return ((i = o.defaultOptions) == null ? undefined : i[u.name]) !== undefined;
    }).map((o) => [o.name, o.defaultOptions[u.name]])), n.push(u));
  return { languages: r, options: n };
}
function* Qu(e, t8, r) {
  let n = new Set(e.map((u) => u.value));
  for (let u of t8)
    if (u.parsers) {
      for (let o of u.parsers)
        if (!n.has(o)) {
          n.add(o);
          let i = r.find((a) => a.parsers && Object.prototype.hasOwnProperty.call(a.parsers, o)), s = u.name;
          i != null && i.name && (s += ` (plugin: ${i.name})`), yield { value: o, description: s };
        }
    }
}
function Zu(e) {
  let t8 = [];
  for (let [r, n] of Object.entries(e)) {
    let u = { name: r, ...n };
    Array.isArray(u.default) && (u.default = y(false, u.default, -1).value), t8.push(u);
  }
  return t8;
}
function en2(e) {
  if (e = e instanceof URL ? e : new URL(e), e.protocol !== "file:")
    throw new TypeError(`URL must be a file URL: received "${e.protocol}"`);
  return e;
}
function ro2(e) {
  return e = en2(e), decodeURIComponent(e.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function no2(e) {
  e = en2(e);
  let t8 = decodeURIComponent(e.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  return e.hostname !== "" && (t8 = `\\\\${e.hostname}${t8}`), t8;
}
function tn2(e) {
  return to2 ? no2(e) : ro2(e);
}
function nn(e, t8) {
  if (!t8)
    return;
  let r = uo2(t8).toLowerCase();
  return e.find(({ filenames: n }) => n == null ? undefined : n.some((u) => u.toLowerCase() === r)) ?? e.find(({ extensions: n }) => n == null ? undefined : n.some((u) => r.endsWith(u)));
}
function oo2(e, t8) {
  if (t8)
    return e.find(({ name: r }) => r.toLowerCase() === t8) ?? e.find(({ aliases: r }) => r == null ? undefined : r.includes(t8)) ?? e.find(({ extensions: r }) => r == null ? undefined : r.includes(`.${t8}`));
}
function un2(e, t8) {
  if (t8) {
    if (String(t8).startsWith("file:"))
      try {
        t8 = rn2(t8);
      } catch {
        return;
      }
    if (typeof t8 == "string")
      return e.find(({ isSupported: r }) => r == null ? undefined : r({ filepath: t8 }));
  }
}
function io2(e, t8) {
  let r = Hr(false, e.plugins).flatMap((u) => u.languages ?? []), n = oo2(r, t8.language) ?? nn(r, t8.physicalFile) ?? nn(r, t8.file) ?? un2(r, t8.physicalFile) ?? un2(r, t8.file) ?? (t8.physicalFile, undefined);
  return n == null ? undefined : n.parsers[0];
}
function cn2(e, t8, r, n) {
  return [`Invalid ${V2.red(n.key(e))} value.`, `Expected ${V2.blue(r)},`, `but received ${t8 === Ze2 ? V2.gray("nothing") : V2.red(n.value(t8))}.`].join(" ");
}
function ln2({ text: e, list: t8 }, r) {
  let n = [];
  return e && n.push(`- ${V2.blue(e)}`), t8 && n.push([`- ${V2.blue(t8.title)}:`].concat(t8.values.map((u) => ln2(u, r - Dn2.length).replace(/^|\n/g, `\$&${Dn2}`))).join(`
`)), Fn2(n, r);
}
function Fn2(e, t8) {
  if (e.length === 1)
    return e[0];
  let [r, n] = e, [u, o] = e.map((i) => i.split(`
`, 1)[0].length);
  return u > t8 && u > o ? n : r;
}
function vt2(e, t8) {
  if (e === t8)
    return 0;
  let r = e;
  e.length > t8.length && (e = t8, t8 = r);
  let n = e.length, u = t8.length;
  for (;n > 0 && e.charCodeAt(~-n) === t8.charCodeAt(~-u); )
    n--, u--;
  let o = 0;
  for (;o < n && e.charCodeAt(o) === t8.charCodeAt(o); )
    o++;
  if (n -= o, u -= o, n === 0)
    return u;
  let i, s, a, c, D = 0, p = 0;
  for (;D < n; )
    pn2[D] = e.charCodeAt(o + D), Pt2[D] = ++D;
  for (;p < u; )
    for (i = t8.charCodeAt(o + p), a = p++, s = p, D = 0;D < n; D++)
      c = i === pn2[D] ? a : a + 1, a = Pt2[D], s = Pt2[D] = a > s ? c > s ? s + 1 : c : c > a ? a + 1 : c;
  return s;
}
function ao2(e, t8) {
  let r = new e(t8), n = Object.create(r);
  for (let u of so2)
    u in t8 && (n[u] = Do(t8[u], r, b3.prototype[u].length));
  return n;
}
function Do(e, t8, r) {
  return typeof e == "function" ? (...n) => e(...n.slice(0, r - 1), t8, ...n.slice(r - 1)) : () => e;
}
function dn2({ from: e, to: t8 }) {
  return { from: [e], to: t8 };
}
function En2(e, t8) {
  let r = Object.create(null);
  for (let n of e) {
    let u = n[t8];
    if (r[u])
      throw new Error(`Duplicate ${t8} ${JSON.stringify(u)}`);
    r[u] = n;
  }
  return r;
}
function Cn2(e, t8) {
  let r = new Map;
  for (let n of e) {
    let u = n[t8];
    if (r.has(u))
      throw new Error(`Duplicate ${t8} ${JSON.stringify(u)}`);
    r.set(u, n);
  }
  return r;
}
function hn2() {
  let e = Object.create(null);
  return (t8) => {
    let r = JSON.stringify(t8);
    return e[r] ? true : (e[r] = true, false);
  };
}
function gn2(e, t8) {
  let r = [], n = [];
  for (let u of e)
    t8(u) ? r.push(u) : n.push(u);
  return [r, n];
}
function yn2(e) {
  return e === Math.floor(e);
}
function An2(e, t8) {
  if (e === t8)
    return 0;
  let r = typeof e, n = typeof t8, u = ["undefined", "object", "boolean", "number", "string"];
  return r !== n ? u.indexOf(r) - u.indexOf(n) : r !== "string" ? Number(e) - Number(t8) : e.localeCompare(t8);
}
function Bn2(e) {
  return (...t8) => {
    let r = e(...t8);
    return typeof r == "string" ? new Error(r) : r;
  };
}
function Lt2(e) {
  return e === undefined ? {} : e;
}
function It2(e) {
  if (typeof e == "string")
    return { text: e };
  let { text: t8, list: r } = e;
  return co2((t8 || r) !== undefined, "Unexpected `expected` result, there should be at least one field."), r ? { text: t8, list: { title: r.title, values: r.values.map(It2) } } : { text: t8 };
}
function Rt2(e, t8) {
  return e === true ? true : e === false ? { value: t8 } : e;
}
function Yt2(e, t8, r = false) {
  return e === false ? false : e === true ? r ? true : [{ value: t8 }] : ("value" in e) ? [e] : e.length === 0 ? false : e;
}
function mn2(e, t8) {
  return typeof e == "string" || "key" in e ? { from: t8, to: e } : ("from" in e) ? { from: e.from, to: e.to } : { from: t8, to: e.to };
}
function ot2(e, t8) {
  return e === undefined ? [] : Array.isArray(e) ? e.map((r) => mn2(r, t8)) : [mn2(e, t8)];
}
function jt2(e, t8) {
  let r = ot2(typeof e == "object" && "redirect" in e ? e.redirect : e, t8);
  return r.length === 0 ? { remain: t8, redirect: r } : typeof e == "object" && ("remain" in e) ? { remain: e.remain, redirect: r } : { redirect: r };
}
function co2(e, t8) {
  if (!e)
    throw new Error(t8);
}
function lo2(e, t8, { logger: r = false, isCLI: n = false, passThrough: u = false, FlagSchema: o, descriptor: i } = {}) {
  if (n) {
    if (!o)
      throw new Error("'FlagSchema' option is required.");
    if (!i)
      throw new Error("'descriptor' option is required.");
  } else
    i = re2;
  let s = u ? Array.isArray(u) ? (l, F) => u.includes(l) ? { [l]: F } : undefined : (l, F) => ({ [l]: F }) : (l, F, f) => {
    let { _: d2, ...m } = f.schemas;
    return et2(l, F, { ...f, schemas: m });
  }, a = Fo(t8, { isCLI: n, FlagSchema: o }), c = new Dt2(a, { logger: r, unknown: s, descriptor: i }), D = r !== false;
  D && Ut2 && (c._hasDeprecationWarned = Ut2);
  let p = c.normalize(e);
  return D && (Ut2 = c._hasDeprecationWarned), p;
}
function Fo(e, { isCLI: t8, FlagSchema: r }) {
  let n = [];
  t8 && n.push(rt2.create({ name: "_" }));
  for (let u of e)
    n.push(po2(u, { isCLI: t8, optionInfos: e, FlagSchema: r })), u.alias && t8 && n.push(tt2.create({ name: u.alias, sourceName: u.name }));
  return n;
}
function po2(e, { isCLI: t8, optionInfos: r, FlagSchema: n }) {
  let { name: u } = e, o = { name: u }, i, s = {};
  switch (e.type) {
    case "int":
      i = at2, t8 && (o.preprocess = Number);
      break;
    case "string":
      i = Ie2;
      break;
    case "choice":
      i = it2, o.choices = e.choices.map((a) => a != null && a.redirect ? { ...a, redirect: { to: { key: e.name, value: a.redirect } } } : a);
      break;
    case "boolean":
      i = ut2;
      break;
    case "flag":
      i = n, o.flags = r.flatMap((a) => [a.alias, a.description && a.name, a.oppositeDescription && `no-${a.name}`].filter(Boolean));
      break;
    case "path":
      i = Ie2;
      break;
    default:
      throw new Error(`Unexpected type ${e.type}`);
  }
  if (e.exception ? o.validate = (a, c, D) => e.exception(a) || c.validate(a, D) : o.validate = (a, c, D) => a === undefined || c.validate(a, D), e.redirect && (s.redirect = (a) => a ? { to: typeof e.redirect == "string" ? e.redirect : { key: e.redirect.option, value: e.redirect.value } } : undefined), e.deprecated && (s.deprecated = true), t8 && !e.array) {
    let a = o.preprocess || ((c) => c);
    o.preprocess = (c, D, p) => D.preprocess(a(Array.isArray(c) ? y(false, c, -1) : c), p);
  }
  return e.array ? nt2.create({ ...t8 ? { preprocess: (a) => Array.isArray(a) ? a : [a] } : {}, ...s, valueSchema: i.create(o) }) : i.create({ ...o, ...s });
}
function $t2(e, t8) {
  if (!t8)
    throw new Error("parserName is required.");
  let r = Vt2(false, e, (u) => u.parsers && Object.prototype.hasOwnProperty.call(u.parsers, t8));
  if (r)
    return r;
  let n = `Couldn't resolve parser "${t8}".`;
  throw n += " Plugins must be explicitly added to the standalone bundle.", new ve2(n);
}
function Sn2(e, t8) {
  if (!t8)
    throw new Error("astFormat is required.");
  let r = Vt2(false, e, (u) => u.printers && Object.prototype.hasOwnProperty.call(u.printers, t8));
  if (r)
    return r;
  let n = `Couldn't find plugin for AST format "${t8}".`;
  throw n += " Plugins must be explicitly added to the standalone bundle.", new ve2(n);
}
function Re2({ plugins: e, parser: t8 }) {
  let r = $t2(e, t8);
  return Wt2(r, t8);
}
function Wt2(e, t8) {
  let r = e.parsers[t8];
  return typeof r == "function" ? r() : r;
}
function Tn2(e, t8) {
  let r = e.printers[t8];
  return typeof r == "function" ? r() : r;
}
async function Eo(e, t8 = {}) {
  var p;
  let r = { ...e };
  if (!r.parser)
    if (r.filepath) {
      if (r.parser = on2(r, { physicalFile: r.filepath }), !r.parser)
        throw new Le2(`No parser could be inferred for file "${r.filepath}".`);
    } else
      throw new Le2("No parser and no file path given, couldn't infer a parser.");
  let n = Qe2({ plugins: e.plugins, showDeprecated: true }).options, u = { ...Nn2, ...Object.fromEntries(n.filter((l) => l.default !== undefined).map((l) => [l.name, l.default])) }, o = $t2(r.plugins, r.parser), i = await Wt2(o, r.parser);
  r.astFormat = i.astFormat, r.locEnd = i.locEnd, r.locStart = i.locStart;
  let s = (p = o.printers) != null && p[i.astFormat] ? o : Sn2(r.plugins, i.astFormat), a = await Tn2(s, i.astFormat);
  r.printer = a;
  let c = s.defaultOptions ? Object.fromEntries(Object.entries(s.defaultOptions).filter(([, l]) => l !== undefined)) : {}, D = { ...u, ...c };
  for (let [l, F] of Object.entries(D))
    (r[l] === null || r[l] === undefined) && (r[l] = F);
  return r.parser === "json" && (r.trailingComma = "none"), kn2(r, n, { passThrough: Object.keys(Nn2), ...t8 });
}
async function yo(e, t8) {
  let r = await Re2(t8), n = r.preprocess ? r.preprocess(e, t8) : e;
  t8.originalText = n;
  let u;
  try {
    u = await r.parse(n, t8, t8);
  } catch (o) {
    Ao(o, e);
  }
  return { text: n, ast: u };
}
function Ao(e, t8) {
  let { loc: r } = e;
  if (r) {
    let n = (0, vn2.codeFrameColumns)(t8, r, { highlightCode: true });
    throw e.message += `
` + n, e.codeFrame = n, e;
  }
  throw e;
}
async function Ln2(e, t8, r, n, u) {
  let { embeddedLanguageFormatting: o, printer: { embed: i, hasPrettierIgnore: s = () => false, getVisitorKeys: a } } = r;
  if (!i || o !== "auto")
    return;
  if (i.length > 2)
    throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/plugins#optional-embed");
  let c = J2(i.getVisitorKeys ?? a), D = [];
  F();
  let p = e.stack;
  for (let { print: f, node: d2, pathStack: m } of D)
    try {
      e.stack = m;
      let C = await f(l, t8, e, r);
      C && u.set(d2, C);
    } catch (C) {
      if (globalThis.PRETTIER_DEBUG)
        throw C;
    }
  e.stack = p;
  function l(f, d2) {
    return Bo(f, d2, r, n);
  }
  function F() {
    let { node: f } = e;
    if (f === null || typeof f != "object" || s(e))
      return;
    for (let m of c(f))
      Array.isArray(f[m]) ? e.each(F, m) : e.call(F, m);
    let d2 = i(e, r);
    if (d2) {
      if (typeof d2 == "function") {
        D.push({ print: d2, node: f, pathStack: [...e.stack] });
        return;
      }
      u.set(f, d2);
    }
  }
}
async function Bo(e, t8, r, n) {
  let u = await ne3({ ...r, ...t8, parentParser: r.parser, originalText: e, cursorOffset: undefined, rangeStart: undefined, rangeEnd: undefined }, { passThrough: true }), { ast: o } = await De2(e, u), i = await n(o, u);
  return $e(i);
}
function _o(e, t8) {
  let { originalText: r, [Symbol.for("comments")]: n, locStart: u, locEnd: o, [Symbol.for("printedComments")]: i } = t8, { node: s } = e, a = u(s), c = o(s);
  for (let D of n)
    u(D) >= a && o(D) <= c && i.add(D);
  return r.slice(a, c);
}
async function Ye2(e, t8) {
  ({ ast: e } = await Gt2(e, t8));
  let r = new Map, n = new Or2(e), u = Kr2(t8), o = new Map;
  await Ln2(n, s, t8, Ye2, o);
  let i = await Rn2(n, t8, s, undefined, o);
  if (Gr2(t8), t8.cursorOffset >= 0) {
    if (t8.nodeAfterCursor && !t8.nodeBeforeCursor)
      return [X2, i];
    if (t8.nodeBeforeCursor && !t8.nodeAfterCursor)
      return [i, X2];
  }
  return i;
  function s(c, D) {
    return c === undefined || c === n ? a(D) : Array.isArray(c) ? n.call(() => a(D), ...c) : n.call(() => a(D), c);
  }
  function a(c) {
    u(n);
    let D = n.node;
    if (D == null)
      return "";
    let p = D && typeof D == "object" && c === undefined;
    if (p && r.has(D))
      return r.get(D);
    let l = Rn2(n, t8, s, c, o);
    return p && r.set(D, l), l;
  }
}
function Rn2(e, t8, r, n, u) {
  var a;
  let { node: o } = e, { printer: i } = t8, s;
  switch ((a = i.hasPrettierIgnore) != null && a.call(i, e) ? s = In2(e, t8) : u.has(o) ? s = u.get(o) : s = i.print(e, t8, r, n), o) {
    case t8.cursorNode:
      s = Fe2(s, (c) => [X2, c, X2]);
      break;
    case t8.nodeBeforeCursor:
      s = Fe2(s, (c) => [c, X2]);
      break;
    case t8.nodeAfterCursor:
      s = Fe2(s, (c) => [X2, c]);
      break;
  }
  return i.printComment && (!i.willPrintOwnComments || !i.willPrintOwnComments(e, t8)) && (s = Mr(e, s, t8)), s;
}
async function Gt2(e, t8) {
  let r = e.comments ?? [];
  t8[Symbol.for("comments")] = r, t8[Symbol.for("printedComments")] = new Set, Vr(e, t8);
  let { printer: { preprocess: n } } = t8;
  return e = n ? await n(e, t8) : e, { ast: e, comments: r };
}
function xo(e, t8) {
  let { cursorOffset: r, locStart: n, locEnd: u } = t8, o = J2(t8.printer.getVisitorKeys), i = (F) => n(F) <= r && u(F) >= r, s = e, a = [e];
  for (let F of Lr2(e, { getVisitorKeys: o, filter: i }))
    a.push(F), s = F;
  if (Ir2(s, { getVisitorKeys: o }))
    return { cursorNode: s };
  let c, D, p = -1, l = Number.POSITIVE_INFINITY;
  for (;a.length > 0 && (c === undefined || D === undefined); ) {
    s = a.pop();
    let F = c !== undefined, f = D !== undefined;
    for (let d2 of Ce2(s, { getVisitorKeys: o })) {
      if (!F) {
        let m = u(d2);
        m <= r && m > p && (c = d2, p = m);
      }
      if (!f) {
        let m = n(d2);
        m >= r && m < l && (D = d2, l = m);
      }
    }
  }
  return { nodeBeforeCursor: c, nodeAfterCursor: D };
}
function wo(e, t8) {
  let { printer: { massageAstNode: r, getVisitorKeys: n } } = t8;
  if (!r)
    return e;
  let u = J2(n), o = r.ignoredProperties ?? new Set;
  return i(e);
  function i(s, a) {
    if (!(s !== null && typeof s == "object"))
      return s;
    if (Array.isArray(s))
      return s.map((l) => i(l, a)).filter(Boolean);
    let c = {}, D = new Set(u(s));
    for (let l in s)
      !Object.prototype.hasOwnProperty.call(s, l) || o.has(l) || (D.has(l) ? c[l] = i(s[l], s) : c[l] = s[l]);
    let p = r(s, c, a);
    if (p !== null)
      return p ?? c;
  }
}
function So(e, t8) {
  let r = [e.node, ...e.parentNodes], n = new Set([t8.node, ...t8.parentNodes]);
  return r.find((u) => $n2.has(u.type) && n.has(u));
}
function Un2(e) {
  let t8 = jn2(false, e, (r) => r.type !== "Program" && r.type !== "File");
  return t8 === -1 ? e : e.slice(0, t8 + 1);
}
function To(e, t8, { locStart: r, locEnd: n }) {
  let u = e.node, o = t8.node;
  if (u === o)
    return { startNode: u, endNode: o };
  let i = r(e.node);
  for (let a of Un2(t8.parentNodes))
    if (r(a) >= i)
      o = a;
    else
      break;
  let s = n(t8.node);
  for (let a of Un2(e.parentNodes)) {
    if (n(a) <= s)
      u = a;
    else
      break;
    if (u === o)
      break;
  }
  return { startNode: u, endNode: o };
}
function zt2(e, t8, r, n, u = [], o) {
  let { locStart: i, locEnd: s } = r, a = i(e), c = s(e);
  if (!(t8 > c || t8 < a || o === "rangeEnd" && t8 === a || o === "rangeStart" && t8 === c)) {
    for (let D of Xe2(e, r)) {
      let p = zt2(D, t8, r, n, [e, ...u], o);
      if (p)
        return p;
    }
    if (!n || n(e, u[0]))
      return { node: e, parentNodes: u };
  }
}
function No(e, t8) {
  return t8 !== "DeclareExportDeclaration" && e !== "TypeParameterDeclaration" && (e === "Directive" || e === "TypeAlias" || e === "TSExportAssignment" || e.startsWith("Declare") || e.startsWith("TSDeclare") || e.endsWith("Statement") || e.endsWith("Declaration"));
}
function Vn2(e, t8, r) {
  if (!t8)
    return false;
  switch (e.parser) {
    case "flow":
    case "hermes":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "oxc":
    case "oxc-ts":
    case "__babel_estree":
      return No(t8.type, r == null ? undefined : r.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return $n2.has(t8.type);
    case "graphql":
      return Oo2.has(t8.kind);
    case "vue":
      return t8.tag !== "root";
  }
  return false;
}
function Wn2(e, t8, r) {
  let { rangeStart: n, rangeEnd: u, locStart: o, locEnd: i } = t8;
  Oe2.ok(u > n);
  let s = e.slice(n, u).search(/\S/u), a = s === -1;
  if (!a)
    for (n += s;u > n && !/\S/u.test(e[u - 1]); --u)
      ;
  let c = zt2(r, n, t8, (F, f) => Vn2(t8, F, f), [], "rangeStart"), D = a ? c : zt2(r, u, t8, (F) => Vn2(t8, F), [], "rangeEnd");
  if (!c || !D)
    return { rangeStart: 0, rangeEnd: 0 };
  let p, l;
  if (ko(t8)) {
    let F = So(c, D);
    p = F, l = F;
  } else
    ({ startNode: p, endNode: l } = To(c, D, t8));
  return { rangeStart: Math.min(o(p), o(l)), rangeEnd: Math.max(i(p), i(l)) };
}
async function Hn2(e, t8, r = 0) {
  if (!e || e.trim().length === 0)
    return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: n, text: u } = await De2(e, t8);
  t8.cursorOffset >= 0 && (t8 = { ...t8, ...Kt2(n, t8) });
  let o = await Ye2(n, t8, r);
  r > 0 && (o = Ge3([z3, o], r, t8.tabWidth));
  let i = me2(o, t8);
  if (r > 0) {
    let a = i.formatted.trim();
    i.cursorNodeStart !== undefined && (i.cursorNodeStart -= i.formatted.indexOf(a), i.cursorNodeStart < 0 && (i.cursorNodeStart = 0, i.cursorNodeText = i.cursorNodeText.trimStart()), i.cursorNodeStart + i.cursorNodeText.length > a.length && (i.cursorNodeText = i.cursorNodeText.trimEnd())), i.formatted = a + xe2(t8.endOfLine);
  }
  let s = t8[Symbol.for("comments")];
  if (t8.cursorOffset >= 0) {
    let a, c, D, p;
    if ((t8.cursorNode || t8.nodeBeforeCursor || t8.nodeAfterCursor) && i.cursorNodeText)
      if (D = i.cursorNodeStart, p = i.cursorNodeText, t8.cursorNode)
        a = t8.locStart(t8.cursorNode), c = u.slice(a, t8.locEnd(t8.cursorNode));
      else {
        if (!t8.nodeBeforeCursor && !t8.nodeAfterCursor)
          throw new Error("Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor");
        a = t8.nodeBeforeCursor ? t8.locEnd(t8.nodeBeforeCursor) : 0;
        let C = t8.nodeAfterCursor ? t8.locStart(t8.nodeAfterCursor) : u.length;
        c = u.slice(a, C);
      }
    else
      a = 0, c = u, D = 0, p = i.formatted;
    let l = t8.cursorOffset - a;
    if (c === p)
      return { formatted: i.formatted, cursorOffset: D + l, comments: s };
    let F = c.split("");
    F.splice(l, 0, Mn2);
    let f = p.split(""), d2 = Et2(F, f), m = D;
    for (let C of d2)
      if (C.removed) {
        if (C.value.includes(Mn2))
          break;
      } else
        m += C.count;
    return { formatted: i.formatted, cursorOffset: m, comments: s };
  }
  return { formatted: i.formatted, cursorOffset: -1, comments: s };
}
async function Po(e, t8) {
  let { ast: r, text: n } = await De2(e, t8), { rangeStart: u, rangeEnd: o } = Wn2(n, t8, r), i = n.slice(u, o), s = Math.min(u, n.lastIndexOf(`
`, u) + 1), a = n.slice(s, u).match(/^\s*/u)[0], c = Ee2(a, t8.tabWidth), D = await Hn2(i, { ...t8, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t8.cursorOffset > u && t8.cursorOffset <= o ? t8.cursorOffset - u : -1, endOfLine: "lf" }, c), p = D.formatted.trimEnd(), { cursorOffset: l } = t8;
  l > o ? l += p.length - i.length : D.cursorOffset >= 0 && (l = D.cursorOffset + u);
  let F = n.slice(0, u) + p + n.slice(o);
  if (t8.endOfLine !== "lf") {
    let f = xe2(t8.endOfLine);
    l >= 0 && f === `\r
` && (l += Ct2(F.slice(0, l), `
`)), F = te(false, F, `
`, f);
  }
  return { formatted: F, cursorOffset: l, comments: D.comments };
}
function Ht2(e, t8, r) {
  return typeof t8 != "number" || Number.isNaN(t8) || t8 < 0 || t8 > e.length ? r : t8;
}
function Gn2(e, t8) {
  let { cursorOffset: r, rangeStart: n, rangeEnd: u } = t8;
  return r = Ht2(e, r, -1), n = Ht2(e, n, 0), u = Ht2(e, u, e.length), { ...t8, cursorOffset: r, rangeStart: n, rangeEnd: u };
}
function Jn2(e, t8) {
  let { cursorOffset: r, rangeStart: n, rangeEnd: u, endOfLine: o } = Gn2(e, t8), i = e.charAt(0) === zn2;
  if (i && (e = e.slice(1), r--, n--, u--), o === "auto" && (o = nr2(e)), e.includes("\r")) {
    let s = (a) => Ct2(e.slice(0, Math.max(a, 0)), `\r
`);
    r -= s(r), n -= s(n), u -= s(u), e = ur2(e);
  }
  return { hasBOM: i, text: e, options: Gn2(e, { ...t8, cursorOffset: r, rangeStart: n, rangeEnd: u, endOfLine: o }) };
}
async function Kn2(e, t8) {
  let r = await Re2(t8);
  return !r.hasPragma || r.hasPragma(e);
}
async function vo(e, t8) {
  var n;
  let r = await Re2(t8);
  return (n = r.hasIgnorePragma) == null ? undefined : n.call(r, e);
}
async function Jt(e, t8) {
  let { hasBOM: r, text: n, options: u } = Jn2(e, await ne3(t8));
  if (u.rangeStart >= u.rangeEnd && n !== "" || u.requirePragma && !await Kn2(n, u) || u.checkIgnorePragma && await vo(n, u))
    return { formatted: e, cursorOffset: t8.cursorOffset, comments: [] };
  let o;
  return u.rangeStart > 0 || u.rangeEnd < n.length ? o = await Po(n, u) : (!u.requirePragma && u.insertPragma && u.printer.insertPragma && !await Kn2(n, u) && (n = u.printer.insertPragma(n)), o = await Hn2(n, u)), r && (o.formatted = zn2 + o.formatted, o.cursorOffset >= 0 && o.cursorOffset++), o;
}
async function qn2(e, t8, r) {
  let { text: n, options: u } = Jn2(e, await ne3(t8)), o = await De2(n, u);
  return r && (r.preprocessForPrint && (o.ast = await Gt2(o.ast, u)), r.massage && (o.ast = Yn2(o.ast, u))), o;
}
async function Xn2(e, t8) {
  t8 = await ne3(t8);
  let r = await Ye2(e, t8);
  return me2(r, t8);
}
async function Qn2(e, t8) {
  let r = wr2(e), { formatted: n } = await Jt(r, { ...t8, parser: "__js_expression" });
  return n;
}
async function Zn2(e, t8) {
  t8 = await ne3(t8);
  let { ast: r } = await De2(e, t8);
  return t8.cursorOffset >= 0 && (t8 = { ...t8, ...Kt2(r, t8) }), Ye2(r, t8);
}
async function eu2(e, t8) {
  return me2(e, await ne3(t8));
}
function jo2(e, t8) {
  if (t8 === false)
    return false;
  if (e.charAt(t8) === "/" && e.charAt(t8 + 1) === "*") {
    for (let r = t8 + 2;r < e.length; ++r)
      if (e.charAt(r) === "*" && e.charAt(r + 1) === "/")
        return r + 2;
  }
  return t8;
}
function Uo2(e, t8) {
  return t8 === false ? false : e.charAt(t8) === "/" && e.charAt(t8 + 1) === "/" ? Je2(e, t8) : t8;
}
function Vo2(e, t8) {
  let r = null, n = t8;
  for (;n !== r; )
    r = n, n = T2(e, n), n = ye(e, n), n = Ae2(e, n), n = U(e, n);
  return n;
}
function $o2(e, t8) {
  let r = null, n = t8;
  for (;n !== r; )
    r = n, n = He2(e, n), n = ye(e, n), n = T2(e, n);
  return n = Ae2(e, n), n = U(e, n), n !== false && G2(e, n);
}
function Wo2(e, t8) {
  let r = e.lastIndexOf(`
`);
  return r === -1 ? 0 : Ee2(e.slice(r + 1).match(/^[\t ]*/u)[0], t8);
}
function Xt2(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Mo2(e, t8) {
  let r = e.match(new RegExp(`(${Xt2(t8)})+`, "gu"));
  return r === null ? 0 : r.reduce((n, u) => Math.max(n, u.length / t8.length), 0);
}
function Go2(e, t8) {
  let r = je2(e, t8);
  return r === false ? "" : e.charAt(r);
}
function Ko2(e, t8) {
  let r = t8 === true || t8 === ft2 ? ft2 : ou2, n = r === ft2 ? ou2 : ft2, u = 0, o = 0;
  for (let i of e)
    i === r ? u++ : i === n && o++;
  return u > o ? n : r;
}
function zo2(e, t8, r) {
  for (let n = t8;n < r; ++n)
    if (e.charAt(n) === `
`)
      return true;
  return false;
}
function Ho2(e, t8, r = {}) {
  return T2(e, r.backwards ? t8 - 1 : t8, r) !== t8;
}
function Jo2(e, t8, r) {
  let n = t8 === '"' ? "'" : '"', o = te(false, e, /\\(.)|(["'])/gsu, (i, s, a) => s === n ? s : a === t8 ? "\\" + a : a || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s) ? s : "\\" + s));
  return t8 + o + t8;
}
function qo2(e, t8, r) {
  return je2(e, r(t8));
}
function Xo2(e, t8) {
  return arguments.length === 2 || typeof t8 == "number" ? je2(e, t8) : qo2(...arguments);
}
function Qo2(e, t8, r) {
  return Pe2(e, r(t8));
}
function Zo2(e, t8) {
  return arguments.length === 2 || typeof t8 == "number" ? Pe2(e, t8) : Qo2(...arguments);
}
function ei(e, t8, r) {
  return ct2(e, r(t8));
}
function ti2(e, t8) {
  return arguments.length === 2 || typeof t8 == "number" ? ct2(e, t8) : ei(...arguments);
}
function ce2(e, t8 = 1) {
  return async (...r) => {
    let n = r[t8] ?? {}, u = n.plugins ?? [];
    return r[t8] = { ...n, plugins: Array.isArray(u) ? u : Object.values(u) }, e(...r);
  };
}
async function fu(e, t8) {
  let { formatted: r } = await cu(e, { ...t8, cursorOffset: -1 });
  return r;
}
async function ri2(e, t8) {
  return await fu(e, t8) === e;
}
var Fu = Object.create;
var pt2 = Object.defineProperty;
var pu = Object.getOwnPropertyDescriptor;
var du = Object.getOwnPropertyNames;
var mu = Object.getPrototypeOf;
var Eu = Object.prototype.hasOwnProperty;
var er = (e) => {
  throw TypeError(e);
};
var Cu = (e, t8) => () => (t8 || e((t8 = { exports: {} }).exports, t8), t8.exports);
var dt = (e, t8) => {
  for (var r in t8)
    pt2(e, r, { get: t8[r], enumerable: true });
};
var hu = (e, t8, r, n) => {
  if (t8 && typeof t8 == "object" || typeof t8 == "function")
    for (let u of du(t8))
      !Eu.call(e, u) && u !== r && pt2(e, u, { get: () => t8[u], enumerable: !(n = pu(t8, u)) || n.enumerable });
  return e;
};
var gu = (e, t8, r) => (r = e != null ? Fu(mu(e)) : {}, hu(t8 || !e || !e.__esModule ? pt2(r, "default", { value: e, enumerable: true }) : r, e));
var yu = (e, t8, r) => t8.has(e) || er("Cannot " + r);
var tr = (e, t8, r) => t8.has(e) ? er("Cannot add the same private member more than once") : t8 instanceof WeakSet ? t8.add(e) : t8.set(e, r);
var fe2 = (e, t8, r) => (yu(e, t8, "access private method"), r);
var Pn2 = Cu((Mt2) => {
  Object.defineProperty(Mt2, "__esModule", { value: true });
  function Co() {
    return new Proxy({}, { get: () => (e) => e });
  }
  var On2 = /\r\n|[\n\r\u2028\u2029]/;
  function ho2(e, t8, r) {
    let n = Object.assign({ column: 0, line: -1 }, e.start), u = Object.assign({}, n, e.end), { linesAbove: o = 2, linesBelow: i = 3 } = r || {}, s = n.line, a = n.column, c = u.line, D = u.column, p = Math.max(s - (o + 1), 0), l = Math.min(t8.length, c + i);
    s === -1 && (p = 0), c === -1 && (l = t8.length);
    let F = c - s, f = {};
    if (F)
      for (let d2 = 0;d2 <= F; d2++) {
        let m = d2 + s;
        if (!a)
          f[m] = true;
        else if (d2 === 0) {
          let C = t8[m - 1].length;
          f[m] = [a, C - a + 1];
        } else if (d2 === F)
          f[m] = [0, D];
        else {
          let C = t8[m - d2].length;
          f[m] = [0, C];
        }
      }
    else
      a === D ? a ? f[s] = [a, 0] : f[s] = true : f[s] = [a, D - a];
    return { start: p, end: l, markerLines: f };
  }
  function go2(e, t8, r = {}) {
    let u = Co(false), o = e.split(On2), { start: i, end: s, markerLines: a } = ho2(t8, o, r), c = t8.start && typeof t8.start.column == "number", D = String(s).length, l = e.split(On2, s).slice(i, s).map((F, f) => {
      let d2 = i + 1 + f, C = ` ${` ${d2}`.slice(-D)} |`, E2 = a[d2], h2 = !a[d2 + 1];
      if (E2) {
        let x = "";
        if (Array.isArray(E2)) {
          let A = F.slice(0, Math.max(E2[0] - 1, 0)).replace(/[^\t]/g, " "), $2 = E2[1] || 1;
          x = [`
 `, u.gutter(C.replace(/\d/g, " ")), " ", A, u.marker("^").repeat($2)].join(""), h2 && r.message && (x += " " + u.message(r.message));
        }
        return [u.marker(">"), u.gutter(C), F.length > 0 ? ` ${F}` : "", x].join("");
      } else
        return ` ${u.gutter(C)}${F.length > 0 ? ` ${F}` : ""}`;
    }).join(`
`);
    return r.message && !c && (l = `${" ".repeat(D + 1)}${r.message}
${l}`), l;
  }
  Mt2.codeFrameColumns = go2;
});
var Zt = {};
dt(Zt, { __debug: () => ui, check: () => ri2, doc: () => qt2, format: () => fu, formatWithCursor: () => cu, getSupportInfo: () => ni2, util: () => Qt2, version: () => tu2 });
var Au = (e, t8, r, n) => {
  if (!(e && t8 == null))
    return t8.replaceAll ? t8.replaceAll(r, n) : r.global ? t8.replace(r, n) : t8.split(r).join(n);
};
var te = Au;
var _e2 = class {
  diff(t8, r, n = {}) {
    let u;
    typeof n == "function" ? (u = n, n = {}) : ("callback" in n) && (u = n.callback);
    let o = this.castInput(t8, n), i = this.castInput(r, n), s = this.removeEmpty(this.tokenize(o, n)), a = this.removeEmpty(this.tokenize(i, n));
    return this.diffWithOptionsObj(s, a, n, u);
  }
  diffWithOptionsObj(t8, r, n, u) {
    var o;
    let i = (E2) => {
      if (E2 = this.postProcess(E2, n), u) {
        setTimeout(function() {
          u(E2);
        }, 0);
        return;
      } else
        return E2;
    }, s = r.length, a = t8.length, c = 1, D = s + a;
    n.maxEditLength != null && (D = Math.min(D, n.maxEditLength));
    let p = (o = n.timeout) !== null && o !== undefined ? o : 1 / 0, l = Date.now() + p, F = [{ oldPos: -1, lastComponent: undefined }], f = this.extractCommon(F[0], r, t8, 0, n);
    if (F[0].oldPos + 1 >= a && f + 1 >= s)
      return i(this.buildValues(F[0].lastComponent, r, t8));
    let d2 = -1 / 0, m = 1 / 0, C = () => {
      for (let E2 = Math.max(d2, -c);E2 <= Math.min(m, c); E2 += 2) {
        let h2, x = F[E2 - 1], A = F[E2 + 1];
        x && (F[E2 - 1] = undefined);
        let $2 = false;
        if (A) {
          let Be2 = A.oldPos - E2;
          $2 = A && 0 <= Be2 && Be2 < s;
        }
        let ue = x && x.oldPos + 1 < a;
        if (!$2 && !ue) {
          F[E2] = undefined;
          continue;
        }
        if (!ue || $2 && x.oldPos < A.oldPos ? h2 = this.addToPath(A, true, false, 0, n) : h2 = this.addToPath(x, false, true, 1, n), f = this.extractCommon(h2, r, t8, E2, n), h2.oldPos + 1 >= a && f + 1 >= s)
          return i(this.buildValues(h2.lastComponent, r, t8)) || true;
        F[E2] = h2, h2.oldPos + 1 >= a && (m = Math.min(m, E2 - 1)), f + 1 >= s && (d2 = Math.max(d2, E2 + 1));
      }
      c++;
    };
    if (u)
      (function E() {
        setTimeout(function() {
          if (c > D || Date.now() > l)
            return u(undefined);
          C() || E();
        }, 0);
      })();
    else
      for (;c <= D && Date.now() <= l; ) {
        let E2 = C();
        if (E2)
          return E2;
      }
  }
  addToPath(t8, r, n, u, o) {
    let i = t8.lastComponent;
    return i && !o.oneChangePerToken && i.added === r && i.removed === n ? { oldPos: t8.oldPos + u, lastComponent: { count: i.count + 1, added: r, removed: n, previousComponent: i.previousComponent } } : { oldPos: t8.oldPos + u, lastComponent: { count: 1, added: r, removed: n, previousComponent: i } };
  }
  extractCommon(t8, r, n, u, o) {
    let i = r.length, s = n.length, a = t8.oldPos, c = a - u, D = 0;
    for (;c + 1 < i && a + 1 < s && this.equals(n[a + 1], r[c + 1], o); )
      c++, a++, D++, o.oneChangePerToken && (t8.lastComponent = { count: 1, previousComponent: t8.lastComponent, added: false, removed: false });
    return D && !o.oneChangePerToken && (t8.lastComponent = { count: D, previousComponent: t8.lastComponent, added: false, removed: false }), t8.oldPos = a, c;
  }
  equals(t8, r, n) {
    return n.comparator ? n.comparator(t8, r) : t8 === r || !!n.ignoreCase && t8.toLowerCase() === r.toLowerCase();
  }
  removeEmpty(t8) {
    let r = [];
    for (let n = 0;n < t8.length; n++)
      t8[n] && r.push(t8[n]);
    return r;
  }
  castInput(t8, r) {
    return t8;
  }
  tokenize(t8, r) {
    return Array.from(t8);
  }
  join(t8) {
    return t8.join("");
  }
  postProcess(t8, r) {
    return t8;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(t8, r, n) {
    let u = [], o;
    for (;t8; )
      u.push(t8), o = t8.previousComponent, delete t8.previousComponent, t8 = o;
    u.reverse();
    let i = u.length, s = 0, a = 0, c = 0;
    for (;s < i; s++) {
      let D = u[s];
      if (D.removed)
        D.value = this.join(n.slice(c, c + D.count)), c += D.count;
      else {
        if (!D.added && this.useLongestToken) {
          let p = r.slice(a, a + D.count);
          p = p.map(function(l, F) {
            let f = n[c + F];
            return f.length > l.length ? f : l;
          }), D.value = this.join(p);
        } else
          D.value = this.join(r.slice(a, a + D.count));
        a += D.count, D.added || (c += D.count);
      }
    }
    return u;
  }
};
var mt2 = class extends _e2 {
  tokenize(t8) {
    return t8.slice();
  }
  join(t8) {
    return t8;
  }
  removeEmpty(t8) {
    return t8;
  }
};
var rr2 = new mt2;
var W2 = "string";
var Y2 = "array";
var j2 = "cursor";
var N2 = "indent";
var O2 = "align";
var P2 = "trim";
var B2 = "group";
var k2 = "fill";
var _2 = "if-break";
var v2 = "indent-if-break";
var L2 = "line-suffix";
var I = "line-suffix-boundary";
var g = "line";
var S2 = "label";
var w2 = "break-parent";
var Ue2 = new Set([j2, N2, O2, P2, B2, k2, _2, v2, L2, I, g, S2, w2]);
var Bu = (e, t8, r) => {
  if (!(e && t8 == null))
    return Array.isArray(t8) || typeof t8 == "string" ? t8[r < 0 ? t8.length + r : r] : t8.at(r);
};
var y = Bu;
var M = _u;
var xu = (e) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e);
var ht2 = class extends Error {
  name = "InvalidDocError";
  constructor(t8) {
    super(wu(t8)), this.doc = t8;
  }
};
var q = ht2;
var ir2 = {};
var le2 = bu;
var gt3 = () => {
};
var K2 = gt3;
var yt2 = gt3;
var pr2 = gt3;
var Ar2 = { type: I };
var pe2 = { type: w2 };
var Br2 = { type: P2 };
var Te2 = { type: g, hard: true };
var Bt2 = { type: g, hard: true, literal: true };
var Me2 = { type: g };
var _r2 = { type: g, soft: true };
var z3 = [Te2, pe2];
var We = [Bt2, pe2];
var X2 = { type: j2 };
var br2 = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
var Tr2 = (e) => !(kr2(e) || Sr2(e));
var Pu = /[^\x20-\x7F]/u;
var Ne2 = vu;
var R2 = Symbol("MODE_BREAK");
var H2 = Symbol("MODE_FLAT");
var de2 = Symbol("cursor");
var _t2 = Symbol("DOC_FILL_PRINTED_LENGTH");
var Ee2 = Ru;
var Z2;
var kt2;
var ze2;
var bt2 = class {
  constructor(t8) {
    tr(this, Z2);
    this.stack = [t8];
  }
  get key() {
    let { stack: t8, siblings: r } = this;
    return y(false, t8, r === null ? -2 : -4) ?? null;
  }
  get index() {
    return this.siblings === null ? null : y(false, this.stack, -2);
  }
  get node() {
    return y(false, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: t8 } = this, r = y(false, t8, -3);
    return Array.isArray(r) ? r : null;
  }
  get next() {
    let { siblings: t8 } = this;
    return t8 === null ? null : t8[this.index + 1];
  }
  get previous() {
    let { siblings: t8 } = this;
    return t8 === null ? null : t8[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: t8, index: r } = this;
    return t8 !== null && r === t8.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...fe2(this, Z2, ze2).call(this)];
  }
  getName() {
    let { stack: t8 } = this, { length: r } = t8;
    return r > 1 ? y(false, t8, -2) : null;
  }
  getValue() {
    return y(false, this.stack, -1);
  }
  getNode(t8 = 0) {
    let r = fe2(this, Z2, kt2).call(this, t8);
    return r === -1 ? null : this.stack[r];
  }
  getParentNode(t8 = 0) {
    return this.getNode(t8 + 1);
  }
  call(t8, ...r) {
    let { stack: n } = this, { length: u } = n, o = y(false, n, -1);
    for (let i of r)
      o = o[i], n.push(i, o);
    try {
      return t8(this);
    } finally {
      n.length = u;
    }
  }
  callParent(t8, r = 0) {
    let n = fe2(this, Z2, kt2).call(this, r + 1), u = this.stack.splice(n + 1);
    try {
      return t8(this);
    } finally {
      this.stack.push(...u);
    }
  }
  each(t8, ...r) {
    let { stack: n } = this, { length: u } = n, o = y(false, n, -1);
    for (let i of r)
      o = o[i], n.push(i, o);
    try {
      for (let i = 0;i < o.length; ++i)
        n.push(i, o[i]), t8(this, i, o), n.length -= 2;
    } finally {
      n.length = u;
    }
  }
  map(t8, ...r) {
    let n = [];
    return this.each((u, o, i) => {
      n[o] = t8(u, o, i);
    }, ...r), n;
  }
  match(...t8) {
    let r = this.stack.length - 1, n = null, u = this.stack[r--];
    for (let o of t8) {
      if (u === undefined)
        return false;
      let i = null;
      if (typeof n == "number" && (i = n, n = this.stack[r--], u = this.stack[r--]), o && !o(u, n, i))
        return false;
      n = this.stack[r--], u = this.stack[r--];
    }
    return true;
  }
  findAncestor(t8) {
    for (let r of fe2(this, Z2, ze2).call(this))
      if (t8(r))
        return r;
  }
  hasAncestor(t8) {
    for (let r of fe2(this, Z2, ze2).call(this))
      if (t8(r))
        return true;
    return false;
  }
};
Z2 = new WeakSet, kt2 = function(t8) {
  let { stack: r } = this;
  for (let n = r.length - 1;n >= 0; n -= 2)
    if (!Array.isArray(r[n]) && --t8 < 0)
      return n;
  return -1;
}, ze2 = function* () {
  let { stack: t8 } = this;
  for (let r = t8.length - 3;r >= 0; r -= 2) {
    let n = t8[r];
    Array.isArray(n) || (yield n);
  }
};
var Or2 = bt2;
var Pr2 = new Proxy(() => {
}, { get: () => Pr2 });
var Oe2 = Pr2;
var vr2 = Yu;
var Rr2 = he2(/\s/u);
var T2 = he2(" 	");
var He2 = he2(",; 	");
var Je2 = he2(/[^\n\r]/u);
var U = ju;
var G2 = Uu;
var qe2 = Vu;
var Yr = new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]);
var $u = (e) => Object.keys(e).filter((t8) => !Yr.has(t8));
var J2 = Wu;
var Tt2 = new WeakMap;
var Nt2 = () => false;
var $r2 = (e) => !/[\S\n\u2028\u2029]/u.test(e);
var Pe2 = zu;
var Kr2 = Xu;
var ve2 = class extends Error {
  name = "ConfigError";
};
var Le2 = class extends Error {
  name = "UndefinedParserError";
};
var zr = { checkIgnorePragma: { category: "Special", type: "boolean", default: false, description: "Check whether the file's first docblock comment contains '@noprettier' or '@noformat' to determine if it should be formatted.", cliCategory: "Other" }, cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: undefined, description: "Which parser to use.", exception: (e) => typeof e == "string" || typeof e == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }, { value: "mjml", description: "MJML" }] }, plugins: { type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e) => typeof e == "string" || typeof e == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: false, description: "Require either '@prettier' or '@format' to be present in the file's first docblock comment in order for it to be formatted.", cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
var eo2 = (e, t8) => {
  if (!(e && t8 == null))
    return t8.toReversed || !Array.isArray(t8) ? t8.toReversed() : [...t8].reverse();
};
var Hr = eo2;
var Jr2;
var qr;
var Xr2;
var Qr2;
var Zr2;
var to2 = ((Jr2 = globalThis.Deno) == null ? undefined : Jr2.build.os) === "windows" || ((Xr2 = (qr = globalThis.navigator) == null ? undefined : qr.platform) == null ? undefined : Xr2.startsWith("Win")) || ((Zr2 = (Qr2 = globalThis.process) == null ? undefined : Qr2.platform) == null ? undefined : Zr2.startsWith("win")) || false;
var rn2 = tn2;
var uo2 = (e) => String(e).split(/[/\\]/u).pop();
var on2 = io2;
var re2 = { key: (e) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e), value(e) {
  if (e === null || typeof e != "object")
    return JSON.stringify(e);
  if (Array.isArray(e))
    return `[${e.map((r) => re2.value(r)).join(", ")}]`;
  let t8 = Object.keys(e);
  return t8.length === 0 ? "{}" : `{ ${t8.map((r) => `${re2.key(r)}: ${re2.value(e[r])}`).join(", ")} }`;
}, pair: ({ key: e, value: t8 }) => re2.value({ [e]: t8 }) };
var sn = new Proxy(String, { get: () => sn });
var V2 = sn;
var an = (e, t8, { descriptor: r }) => {
  let n = [`${V2.yellow(typeof e == "string" ? r.key(e) : r.pair(e))} is deprecated`];
  return t8 && n.push(`we now treat it as ${V2.blue(typeof t8 == "string" ? r.key(t8) : r.pair(t8))}`), n.join("; ") + ".";
};
var Ze2 = Symbol.for("vnopts.VALUE_NOT_EXIST");
var ge2 = Symbol.for("vnopts.VALUE_UNCHANGED");
var Dn2 = " ".repeat(2);
var fn2 = (e, t8, r) => {
  let { text: n, list: u } = r.normalizeExpectedResult(r.schemas[e].expected(r)), o = [];
  return n && o.push(cn2(e, t8, n, r.descriptor)), u && o.push([cn2(e, t8, u.title, r.descriptor)].concat(u.values.map((i) => ln2(i, r.loggerPrintWidth))).join(`
`)), Fn2(o, r.loggerPrintWidth);
};
var Pt2 = [];
var pn2 = [];
var et2 = (e, t8, { descriptor: r, logger: n, schemas: u }) => {
  let o = [`Ignored unknown option ${V2.yellow(r.pair({ key: e, value: t8 }))}.`], i = Object.keys(u).sort().find((s) => vt2(e, s) < 3);
  i && o.push(`Did you mean ${V2.blue(r.key(i))}?`), n.warn(o.join(" "));
};
var so2 = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
var b3 = class {
  static create(t8) {
    return ao2(this, t8);
  }
  constructor(t8) {
    this.name = t8.name;
  }
  default(t8) {
  }
  expected(t8) {
    return "nothing";
  }
  validate(t8, r) {
    return false;
  }
  deprecated(t8, r) {
    return false;
  }
  forward(t8, r) {
  }
  redirect(t8, r) {
  }
  overlap(t8, r, n) {
    return t8;
  }
  preprocess(t8, r) {
    return t8;
  }
  postprocess(t8, r) {
    return ge2;
  }
};
var tt2 = class extends b3 {
  constructor(t8) {
    super(t8), this._sourceName = t8.sourceName;
  }
  expected(t8) {
    return t8.schemas[this._sourceName].expected(t8);
  }
  validate(t8, r) {
    return r.schemas[this._sourceName].validate(t8, r);
  }
  redirect(t8, r) {
    return this._sourceName;
  }
};
var rt2 = class extends b3 {
  expected() {
    return "anything";
  }
  validate() {
    return true;
  }
};
var nt2 = class extends b3 {
  constructor({ valueSchema: t8, name: r = t8.name, ...n }) {
    super({ ...n, name: r }), this._valueSchema = t8;
  }
  expected(t8) {
    let { text: r, list: n } = t8.normalizeExpectedResult(this._valueSchema.expected(t8));
    return { text: r && `an array of ${r}`, list: n && { title: "an array of the following values", values: [{ list: n }] } };
  }
  validate(t8, r) {
    if (!Array.isArray(t8))
      return false;
    let n = [];
    for (let u of t8) {
      let o = r.normalizeValidateResult(this._valueSchema.validate(u, r), u);
      o !== true && n.push(o.value);
    }
    return n.length === 0 ? true : { value: n };
  }
  deprecated(t8, r) {
    let n = [];
    for (let u of t8) {
      let o = r.normalizeDeprecatedResult(this._valueSchema.deprecated(u, r), u);
      o !== false && n.push(...o.map(({ value: i }) => ({ value: [i] })));
    }
    return n;
  }
  forward(t8, r) {
    let n = [];
    for (let u of t8) {
      let o = r.normalizeForwardResult(this._valueSchema.forward(u, r), u);
      n.push(...o.map(dn2));
    }
    return n;
  }
  redirect(t8, r) {
    let n = [], u = [];
    for (let o of t8) {
      let i = r.normalizeRedirectResult(this._valueSchema.redirect(o, r), o);
      "remain" in i && n.push(i.remain), u.push(...i.redirect.map(dn2));
    }
    return n.length === 0 ? { redirect: u } : { redirect: u, remain: n };
  }
  overlap(t8, r) {
    return t8.concat(r);
  }
};
var ut2 = class extends b3 {
  expected() {
    return "true or false";
  }
  validate(t8) {
    return typeof t8 == "boolean";
  }
};
var it2 = class extends b3 {
  constructor(t8) {
    super(t8), this._choices = Cn2(t8.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
  }
  expected({ descriptor: t8 }) {
    let r = Array.from(this._choices.keys()).map((i) => this._choices.get(i)).filter(({ hidden: i }) => !i).map((i) => i.value).sort(An2).map(t8.value), n = r.slice(0, -2), u = r.slice(-2);
    return { text: n.concat(u.join(" or ")).join(", "), list: { title: "one of the following values", values: r } };
  }
  validate(t8) {
    return this._choices.has(t8);
  }
  deprecated(t8) {
    let r = this._choices.get(t8);
    return r && r.deprecated ? { value: t8 } : false;
  }
  forward(t8) {
    let r = this._choices.get(t8);
    return r ? r.forward : undefined;
  }
  redirect(t8) {
    let r = this._choices.get(t8);
    return r ? r.redirect : undefined;
  }
};
var st2 = class extends b3 {
  expected() {
    return "a number";
  }
  validate(t8, r) {
    return typeof t8 == "number";
  }
};
var at2 = class extends st2 {
  expected() {
    return "an integer";
  }
  validate(t8, r) {
    return r.normalizeValidateResult(super.validate(t8, r), t8) === true && yn2(t8);
  }
};
var Ie2 = class extends b3 {
  expected() {
    return "a string";
  }
  validate(t8) {
    return typeof t8 == "string";
  }
};
var _n2 = re2;
var xn2 = et2;
var wn2 = fn2;
var bn2 = an;
var Dt2 = class {
  constructor(t8, r) {
    let { logger: n = console, loggerPrintWidth: u = 80, descriptor: o = _n2, unknown: i = xn2, invalid: s = wn2, deprecated: a = bn2, missing: c = () => false, required: D = () => false, preprocess: p = (F) => F, postprocess: l = () => ge2 } = r || {};
    this._utils = { descriptor: o, logger: n || { warn: () => {
    } }, loggerPrintWidth: u, schemas: En2(t8, "name"), normalizeDefaultResult: Lt2, normalizeExpectedResult: It2, normalizeDeprecatedResult: Yt2, normalizeForwardResult: ot2, normalizeRedirectResult: jt2, normalizeValidateResult: Rt2 }, this._unknownHandler = i, this._invalidHandler = Bn2(s), this._deprecatedHandler = a, this._identifyMissing = (F, f) => !(F in f) || c(F, f), this._identifyRequired = D, this._preprocess = p, this._postprocess = l, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = hn2();
  }
  normalize(t8) {
    let r = {}, u = [this._preprocess(t8, this._utils)], o = () => {
      for (;u.length !== 0; ) {
        let i = u.shift(), s = this._applyNormalization(i, r);
        u.push(...s);
      }
    };
    o();
    for (let i of Object.keys(this._utils.schemas)) {
      let s = this._utils.schemas[i];
      if (!(i in r)) {
        let a = Lt2(s.default(this._utils));
        "value" in a && u.push({ [i]: a.value });
      }
    }
    o();
    for (let i of Object.keys(this._utils.schemas)) {
      if (!(i in r))
        continue;
      let s = this._utils.schemas[i], a = r[i], c = s.postprocess(a, this._utils);
      c !== ge2 && (this._applyValidation(c, i, s), r[i] = c);
    }
    return this._applyPostprocess(r), this._applyRequiredCheck(r), r;
  }
  _applyNormalization(t8, r) {
    let n = [], { knownKeys: u, unknownKeys: o } = this._partitionOptionKeys(t8);
    for (let i of u) {
      let s = this._utils.schemas[i], a = s.preprocess(t8[i], this._utils);
      this._applyValidation(a, i, s);
      let c = ({ from: F, to: f }) => {
        n.push(typeof f == "string" ? { [f]: F } : { [f.key]: f.value });
      }, D = ({ value: F, redirectTo: f }) => {
        let d2 = Yt2(s.deprecated(F, this._utils), a, true);
        if (d2 !== false)
          if (d2 === true)
            this._hasDeprecationWarned(i) || this._utils.logger.warn(this._deprecatedHandler(i, f, this._utils));
          else
            for (let { value: m } of d2) {
              let C = { key: i, value: m };
              if (!this._hasDeprecationWarned(C)) {
                let E2 = typeof f == "string" ? { key: f, value: m } : f;
                this._utils.logger.warn(this._deprecatedHandler(C, E2, this._utils));
              }
            }
      };
      ot2(s.forward(a, this._utils), a).forEach(c);
      let l = jt2(s.redirect(a, this._utils), a);
      if (l.redirect.forEach(c), "remain" in l) {
        let F = l.remain;
        r[i] = i in r ? s.overlap(r[i], F, this._utils) : F, D({ value: F });
      }
      for (let { from: F, to: f } of l.redirect)
        D({ value: F, redirectTo: f });
    }
    for (let i of o) {
      let s = t8[i];
      this._applyUnknownHandler(i, s, r, (a, c) => {
        n.push({ [a]: c });
      });
    }
    return n;
  }
  _applyRequiredCheck(t8) {
    for (let r of Object.keys(this._utils.schemas))
      if (this._identifyMissing(r, t8) && this._identifyRequired(r))
        throw this._invalidHandler(r, Ze2, this._utils);
  }
  _partitionOptionKeys(t8) {
    let [r, n] = gn2(Object.keys(t8).filter((u) => !this._identifyMissing(u, t8)), (u) => (u in this._utils.schemas));
    return { knownKeys: r, unknownKeys: n };
  }
  _applyValidation(t8, r, n) {
    let u = Rt2(n.validate(t8, this._utils), t8);
    if (u !== true)
      throw this._invalidHandler(r, u.value, this._utils);
  }
  _applyUnknownHandler(t8, r, n, u) {
    let o = this._unknownHandler(t8, r, this._utils);
    if (o)
      for (let i of Object.keys(o)) {
        if (this._identifyMissing(i, o))
          continue;
        let s = o[i];
        i in this._utils.schemas ? u(i, s) : n[i] = s;
      }
  }
  _applyPostprocess(t8) {
    let r = this._postprocess(t8, this._utils);
    if (r !== ge2) {
      if (r.delete)
        for (let n of r.delete)
          delete t8[n];
      if (r.override) {
        let { knownKeys: n, unknownKeys: u } = this._partitionOptionKeys(r.override);
        for (let o of n) {
          let i = r.override[o];
          this._applyValidation(i, o, this._utils.schemas[o]), t8[o] = i;
        }
        for (let o of u) {
          let i = r.override[o];
          this._applyUnknownHandler(o, i, t8, (s, a) => {
            let c = this._utils.schemas[s];
            this._applyValidation(a, s, c), t8[s] = a;
          });
        }
      }
    }
  }
};
var Ut2;
var kn2 = lo2;
var mo = (e, t8, r) => {
  if (!(e && t8 == null)) {
    if (t8.findLast)
      return t8.findLast(r);
    for (let n = t8.length - 1;n >= 0; n--) {
      let u = t8[n];
      if (r(u, n, t8))
        return u;
    }
  }
};
var Vt2 = mo;
var Nn2 = { astFormat: "estree", printer: {}, originalText: undefined, locStart: null, locEnd: null };
var ne3 = Eo;
var vn2 = gu(Pn2(), 1);
var De2 = yo;
var In2 = _o;
var Kt2 = xo;
var Yn2 = wo;
var bo = (e, t8, r) => {
  if (!(e && t8 == null)) {
    if (t8.findLastIndex)
      return t8.findLastIndex(r);
    for (let n = t8.length - 1;n >= 0; n--) {
      let u = t8[n];
      if (r(u, n, t8))
        return n;
    }
    return -1;
  }
};
var jn2 = bo;
var ko = ({ parser: e }) => e === "json" || e === "json5" || e === "jsonc" || e === "json-stringify";
var $n2 = new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]);
var Oo2 = new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
var zn2 = "\uFEFF";
var Mn2 = Symbol("cursor");
var qt2 = {};
dt(qt2, { builders: () => Io2, printer: () => Ro2, utils: () => Yo2 });
var Io2 = { join: ke2, line: Me2, softline: _r2, hardline: z3, literalline: We, group: At2, conditionalGroup: Cr2, fill: hr2, lineSuffix: Se2, lineSuffixBoundary: Ar2, cursor: X2, breakParent: pe2, ifBreak: gr2, trim: Br2, indent: ie2, indentIfBreak: yr2, align: oe, addAlignmentToDoc: Ge3, markAsRoot: mr2, dedentToRoot: dr2, dedent: Er2, hardlineWithoutBreakParent: Te2, literallineWithoutBreakParent: Bt2, label: xr2, concat: (e) => e };
var Ro2 = { printDocToString: me2 };
var Yo2 = { willBreak: Dr2, traverseDoc: le2, findInDoc: Ve2, mapDoc: be2, removeLines: fr2, stripTrailingHardline: $e, replaceEndOfLine: lr2, canBreak: Fr2 };
var tu2 = "3.6.2";
var Qt2 = {};
dt(Qt2, { addDanglingComment: () => ee2, addLeadingComment: () => se2, addTrailingComment: () => ae2, getAlignmentSize: () => Ee2, getIndentSize: () => ru2, getMaxContinuousCount: () => nu2, getNextNonSpaceNonCommentCharacter: () => uu2, getNextNonSpaceNonCommentCharacterIndex: () => Xo2, getPreferredQuote: () => iu2, getStringWidth: () => Ne2, hasNewline: () => G2, hasNewlineInRange: () => su2, hasSpaces: () => au2, isNextLineEmpty: () => ti2, isNextLineEmptyAfterIndex: () => ct2, isPreviousLineEmpty: () => Zo2, makeString: () => Du, skip: () => he2, skipEverythingButNewLine: () => Je2, skipInlineComment: () => ye, skipNewline: () => U, skipSpaces: () => T2, skipToLineEnd: () => He2, skipTrailingComment: () => Ae2, skipWhitespace: () => Rr2 });
var ye = jo2;
var Ae2 = Uo2;
var je2 = Vo2;
var ct2 = $o2;
var ru2 = Wo2;
var nu2 = Mo2;
var uu2 = Go2;
var ft2 = "'";
var ou2 = '"';
var iu2 = Ko2;
var su2 = zo2;
var au2 = Ho2;
var Du = Jo2;
var cu = ce2(Jt);
var ni2 = ce2(Qe2, 0);
var ui = { parse: ce2(qn2), formatAST: ce2(Xn2), formatDoc: ce2(Qn2), printToDoc: ce2(Zn2), printDocToString: ce2(eu2) };

// node_modules/@react-email/render/dist/node/index.mjs
function recursivelyMapDoc(doc, callback) {
  if (Array.isArray(doc)) {
    return doc.map((innerDoc) => recursivelyMapDoc(innerDoc, callback));
  }
  if (typeof doc === "object") {
    if (doc.type === "group") {
      return __spreadProps(__spreadValues({}, doc), {
        contents: recursivelyMapDoc(doc.contents, callback),
        expandedStates: recursivelyMapDoc(doc.expandedStates, callback)
      });
    }
    if ("contents" in doc) {
      return __spreadProps(__spreadValues({}, doc), {
        contents: recursivelyMapDoc(doc.contents, callback)
      });
    }
    if ("parts" in doc) {
      return __spreadProps(__spreadValues({}, doc), {
        parts: recursivelyMapDoc(doc.parts, callback)
      });
    }
    if (doc.type === "if-break") {
      return __spreadProps(__spreadValues({}, doc), {
        breakContents: recursivelyMapDoc(doc.breakContents, callback),
        flatContents: recursivelyMapDoc(doc.flatContents, callback)
      });
    }
  }
  return callback(doc);
}

// node_modules/domelementtype/lib/esm/index.js
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
var Root = ElementType.Root;
var Text = ElementType.Text;
var Directive = ElementType.Directive;
var Comment = ElementType.Comment;
var Script = ElementType.Script;
var Style = ElementType.Style;
var Tag = ElementType.Tag;
var CDATA = ElementType.CDATA;
var Doctype = ElementType.Doctype;

// node_modules/domhandler/lib/esm/node.js
function isTag2(node) {
  return isTag(node);
}
function isCDATA(node) {
  return node.type === ElementType.CDATA;
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}
function isDirective(node) {
  return node.type === ElementType.Directive;
}
function isDocument(node) {
  return node.type === ElementType.Root;
}
function cloneNode(node, recursive = false) {
  let result2;
  if (isText(node)) {
    result2 = new Text2(node.data);
  } else if (isComment(node)) {
    result2 = new Comment2(node.data);
  } else if (isTag2(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Element(node.name, { ...node.attribs }, children);
    children.forEach((child) => child.parent = clone);
    if (node.namespace != null) {
      clone.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
    }
    if (node["x-attribsPrefix"]) {
      clone["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
    }
    result2 = clone;
  } else if (isCDATA(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new CDATA2(children);
    children.forEach((child) => child.parent = clone);
    result2 = clone;
  } else if (isDocument(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Document(children);
    children.forEach((child) => child.parent = clone);
    if (node["x-mode"]) {
      clone["x-mode"] = node["x-mode"];
    }
    result2 = clone;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result2 = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result2.startIndex = node.startIndex;
  result2.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result2.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result2;
}
function cloneChildren(childs) {
  const children = childs.map((child) => cloneNode(child, true));
  for (let i = 1;i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}

class Node {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent) {
    this.parent = parent;
  }
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev) {
    this.prev = prev;
  }
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next) {
    this.next = next;
  }
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
}

class DataNode extends Node {
  constructor(data) {
    super();
    this.data = data;
  }
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data) {
    this.data = data;
  }
}

class Text2 extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
}

class Comment2 extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
}

class ProcessingInstruction extends DataNode {
  constructor(name, data) {
    super(data);
    this.name = name;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
}

class NodeWithChildren extends Node {
  constructor(children) {
    super();
    this.children = children;
  }
  get firstChild() {
    var _a2;
    return (_a2 = this.children[0]) !== null && _a2 !== undefined ? _a2 : null;
  }
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  get childNodes() {
    return this.children;
  }
  set childNodes(children) {
    this.children = children;
  }
}

class CDATA2 extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
}

class Document extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
}

class Element extends NodeWithChildren {
  constructor(name, attribs, children = [], type = name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag) {
    super(children);
    this.name = name;
    this.attribs = attribs;
    this.type = type;
  }
  get nodeType() {
    return 1;
  }
  get tagName() {
    return this.name;
  }
  set tagName(name) {
    this.name = name;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name) => {
      var _a2, _b;
      return {
        name,
        value: this.attribs[name],
        namespace: (_a2 = this["x-attribsNamespace"]) === null || _a2 === undefined ? undefined : _a2[name],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === undefined ? undefined : _b[name]
      };
    });
  }
}

// node_modules/domhandler/lib/esm/index.js
var defaultOpts = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};

class DomHandler {
  constructor(callback, options, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = undefined;
    }
    this.callback = callback !== null && callback !== undefined ? callback : null;
    this.options = options !== null && options !== undefined ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== undefined ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error) {
    this.handleCallback(error);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name, attribs) {
    const type = this.options.xmlMode ? ElementType.Tag : undefined;
    const element = new Element(name, attribs, undefined, type);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node3 = new Text2(data);
      this.addNode(node3);
      this.lastNode = node3;
    }
  }
  oncomment(data) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }
    const node3 = new Comment2(data);
    this.addNode(node3);
    this.lastNode = node3;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text2 = new Text2("");
    const node3 = new CDATA2([text2]);
    this.addNode(node3);
    text2.parent = node3;
    this.lastNode = text2;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name, data) {
    const node3 = new ProcessingInstruction(name, data);
    this.addNode(node3);
  }
  handleCallback(error) {
    if (typeof this.callback === "function") {
      this.callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  }
  addNode(node3) {
    const parent = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node3.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node3.endIndex = this.parser.endIndex;
    }
    parent.children.push(node3);
    if (previousSibling) {
      node3.prev = previousSibling;
      previousSibling.next = node3;
    }
    node3.parent = parent;
    this.lastNode = null;
  }
}

// node_modules/leac/lib/leac.mjs
function n(n2) {
  const o = [...n2.matchAll(e)].map((e) => e.index || 0);
  o.unshift(-1);
  const s = t8(o, 0, o.length);
  return (e) => r(s, e);
}
function t8(e, n2, r) {
  if (r - n2 == 1)
    return { offset: e[n2], index: n2 + 1 };
  const o = Math.ceil((n2 + r) / 2), s = t8(e, n2, o), l = t8(e, o, r);
  return { offset: s.offset, low: s, high: l };
}
function r(e, n2) {
  return function(e2) {
    return Object.prototype.hasOwnProperty.call(e2, "index");
  }(e) ? { line: e.index, column: n2 - e.offset } : r(e.high.offset < n2 ? e.high : e.low, n2);
}
function o(e, t9 = "", r2 = {}) {
  const o2 = typeof t9 != "string" ? t9 : r2, l = typeof t9 == "string" ? t9 : "", c = e.map(s), f = !!o2.lineNumbers;
  return function(e2, t10 = 0) {
    const r3 = f ? n(e2) : () => ({ line: 0, column: 0 });
    let o3 = t10;
    const s = [];
    e:
      for (;o3 < e2.length; ) {
        let n2 = false;
        for (const t11 of c) {
          t11.regex.lastIndex = o3;
          const c2 = t11.regex.exec(e2);
          if (c2 && c2[0].length > 0) {
            if (!t11.discard) {
              const e3 = r3(o3), n3 = typeof t11.replace == "string" ? c2[0].replace(new RegExp(t11.regex.source, t11.regex.flags), t11.replace) : c2[0];
              s.push({ state: l, name: t11.name, text: n3, offset: o3, len: c2[0].length, line: e3.line, column: e3.column });
            }
            if (o3 = t11.regex.lastIndex, n2 = true, t11.push) {
              const n3 = t11.push(e2, o3);
              s.push(...n3.tokens), o3 = n3.offset;
            }
            if (t11.pop)
              break e;
            break;
          }
        }
        if (!n2)
          break;
      }
    return { tokens: s, offset: o3, complete: e2.length <= o3 };
  };
}
function s(e, n2) {
  return { ...e, regex: l(e, n2) };
}
function l(e, n2) {
  if (e.name.length === 0)
    throw new Error(`Rule #${n2} has empty name, which is not allowed.`);
  if (function(e2) {
    return Object.prototype.hasOwnProperty.call(e2, "regex");
  }(e))
    return function(e2) {
      if (e2.global)
        throw new Error(`Regular expression /${e2.source}/${e2.flags} contains the global flag, which is not allowed.`);
      return e2.sticky ? e2 : new RegExp(e2.source, e2.flags + "y");
    }(e.regex);
  if (function(e2) {
    return Object.prototype.hasOwnProperty.call(e2, "str");
  }(e)) {
    if (e.str.length === 0)
      throw new Error(`Rule #${n2} ("${e.name}") has empty "str" property, which is not allowed.`);
    return new RegExp(c(e.str), "y");
  }
  return new RegExp(c(e.name), "y");
}
function c(e) {
  return e.replace(/[-[\]{}()*+!<=:?./\\^$|#\s,]/g, "\\$&");
}
var e = /\n/g;

// node_modules/peberminta/lib/core.mjs
function token(onToken, onEnd) {
  return (data, i) => {
    let position = i;
    let value = undefined;
    if (i < data.tokens.length) {
      value = onToken(data.tokens[i], data, i);
      if (value !== undefined) {
        position++;
      }
    } else {
      onEnd?.(data, i);
    }
    return value === undefined ? { matched: false } : {
      matched: true,
      position,
      value
    };
  };
}
function mapInner(r2, f) {
  return r2.matched ? {
    matched: true,
    position: r2.position,
    value: f(r2.value, r2.position)
  } : r2;
}
function mapOuter(r2, f) {
  return r2.matched ? f(r2) : r2;
}
function map(p, mapper) {
  return (data, i) => mapInner(p(data, i), (v3, j3) => mapper(v3, data, i, j3));
}
function option(p, def) {
  return (data, i) => {
    const r2 = p(data, i);
    return r2.matched ? r2 : {
      matched: true,
      position: i,
      value: def
    };
  };
}
function choice(...ps2) {
  return (data, i) => {
    for (const p of ps2) {
      const result2 = p(data, i);
      if (result2.matched) {
        return result2;
      }
    }
    return { matched: false };
  };
}
function otherwise(pa2, pb) {
  return (data, i) => {
    const r1 = pa2(data, i);
    return r1.matched ? r1 : pb(data, i);
  };
}
function takeWhile(p, test) {
  return (data, i) => {
    const values2 = [];
    let success = true;
    do {
      const r2 = p(data, i);
      if (r2.matched && test(r2.value, values2.length + 1, data, i, r2.position)) {
        values2.push(r2.value);
        i = r2.position;
      } else {
        success = false;
      }
    } while (success);
    return {
      matched: true,
      position: i,
      value: values2
    };
  };
}
function many(p) {
  return takeWhile(p, () => true);
}
function many1(p) {
  return ab(p, many(p), (head, tail) => [head, ...tail]);
}
function ab(pa2, pb, join) {
  return (data, i) => mapOuter(pa2(data, i), (ma2) => mapInner(pb(data, ma2.position), (vb, j3) => join(ma2.value, vb, data, i, j3)));
}
function left(pa2, pb) {
  return ab(pa2, pb, (va2) => va2);
}
function right(pa2, pb) {
  return ab(pa2, pb, (va2, vb) => vb);
}
function abc(pa2, pb, pc, join) {
  return (data, i) => mapOuter(pa2(data, i), (ma2) => mapOuter(pb(data, ma2.position), (mb) => mapInner(pc(data, mb.position), (vc, j3) => join(ma2.value, mb.value, vc, data, i, j3))));
}
function middle(pa2, pb, pc) {
  return abc(pa2, pb, pc, (ra2, rb) => rb);
}
function all(...ps2) {
  return (data, i) => {
    const result2 = [];
    let position = i;
    for (const p of ps2) {
      const r1 = p(data, position);
      if (r1.matched) {
        result2.push(r1.value);
        position = r1.position;
      } else {
        return { matched: false };
      }
    }
    return {
      matched: true,
      position,
      value: result2
    };
  };
}
function flatten(...ps2) {
  return flatten1(all(...ps2));
}
function flatten1(p) {
  return map(p, (vs2) => vs2.flatMap((v3) => v3));
}
function chainReduce(acc, f) {
  return (data, i) => {
    let loop = true;
    let acc1 = acc;
    let pos = i;
    do {
      const r2 = f(acc1, data, pos)(data, pos);
      if (r2.matched) {
        acc1 = r2.value;
        pos = r2.position;
      } else {
        loop = false;
      }
    } while (loop);
    return {
      matched: true,
      position: pos,
      value: acc1
    };
  };
}
function reduceLeft(acc, p, reducer) {
  return chainReduce(acc, (acc2) => map(p, (v3, data, i, j3) => reducer(acc2, v3, data, i, j3)));
}
function leftAssoc2(pLeft, pOper, pRight) {
  return chain(pLeft, (v0) => reduceLeft(v0, ab(pOper, pRight, (f, y2) => [f, y2]), (acc, [f, y2]) => f(acc, y2)));
}
function chain(p, f) {
  return (data, i) => mapOuter(p(data, i), (m1) => f(m1.value, data, i, m1.position)(data, m1.position));
}

// node_modules/parseley/lib/parseley.mjs
function sumSpec([a0, a1, a2], [b0, b1, b22]) {
  return [a0 + b0, a1 + b1, a2 + b22];
}
function sumAllSpec(ss2) {
  return ss2.reduce(sumSpec, [0, 0, 0]);
}
function unescape2(escapedString) {
  const lexerResult = lexEscapedString(escapedString);
  const result2 = escapedString_({ tokens: lexerResult.tokens, options: undefined }, 0);
  return result2.value;
}
function literal(name) {
  return token((t9) => t9.name === name ? true : undefined);
}
function optionallySpaced(parser) {
  return middle(optionalWhitespace_, parser, optionalWhitespace_);
}
function parse_(parser, str) {
  if (!(typeof str === "string" || str instanceof String)) {
    throw new Error("Expected a selector string. Actual input is not a string!");
  }
  const lexerResult = lexSelector(str);
  if (!lexerResult.complete) {
    throw new Error(`The input "${str}" was only partially tokenized, stopped at offset ${lexerResult.offset}!\n` + prettyPrintPosition(str, lexerResult.offset));
  }
  const result2 = optionallySpaced(parser)({ tokens: lexerResult.tokens, options: undefined }, 0);
  if (!result2.matched) {
    throw new Error(`No match for "${str}" input!`);
  }
  if (result2.position < lexerResult.tokens.length) {
    const token2 = lexerResult.tokens[result2.position];
    throw new Error(`The input "${str}" was only partially parsed, stopped at offset ${token2.offset}!\n` + prettyPrintPosition(str, token2.offset, token2.len));
  }
  return result2.value;
}
function prettyPrintPosition(str, offset, len = 1) {
  return `${str.replace(/(\t)|(\r)|(\n)/g, (m, t9, r2) => t9 ? "\u2409" : r2 ? "\u240D" : "\u240A")}\n${"".padEnd(offset)}${"^".repeat(len)}`;
}
function parse1(str) {
  return parse_(complexSelector_, str);
}
function serialize(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "universal":
      return _serNs(selector.namespace) + "*";
    case "tag":
      return _serNs(selector.namespace) + _serIdent(selector.name);
    case "class":
      return "." + _serIdent(selector.name);
    case "id":
      return "#" + _serIdent(selector.name);
    case "attrPresence":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}]`;
    case "attrValue":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}${selector.matcher}"${_serStr(selector.value)}"${selector.modifier ? selector.modifier : ""}]`;
    case "combinator":
      return serialize(selector.left) + selector.combinator;
    case "compound":
      return selector.list.reduce((acc, node3) => {
        if (node3.type === "combinator") {
          return serialize(node3) + acc;
        } else {
          return acc + serialize(node3);
        }
      }, "");
    case "list":
      return selector.list.map(serialize).join(",");
  }
}
function _serNs(ns2) {
  return ns2 || ns2 === "" ? _serIdent(ns2) + "|" : "";
}
function _codePoint(char) {
  return `\\${char.codePointAt(0).toString(16)} `;
}
function _serIdent(str) {
  return str.replace(/(^[0-9])|(^-[0-9])|(^-$)|([-0-9a-zA-Z_]|[^\x00-\x7F])|(\x00)|([\x01-\x1f]|\x7f)|([\s\S])/g, (m, d1, d2, hy, safe, nl, ctrl, other) => d1 ? _codePoint(d1) : d2 ? "-" + _codePoint(d2.slice(1)) : hy ? "\\-" : safe ? safe : nl ? "\uFFFD" : ctrl ? _codePoint(ctrl) : "\\" + other);
}
function _serStr(str) {
  return str.replace(/(")|(\\)|(\x00)|([\x01-\x1f]|\x7f)/g, (m, dq, bs2, nl, ctrl) => dq ? '\\"' : bs2 ? "\\\\" : nl ? "\uFFFD" : _codePoint(ctrl));
}
function normalize(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "compound": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b4) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b4)));
      break;
    }
    case "combinator": {
      normalize(selector.left);
      break;
    }
    case "list": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b4) => serialize(a) < serialize(b4) ? -1 : 1);
      break;
    }
  }
  return selector;
}
function _getSelectorPriority(selector) {
  switch (selector.type) {
    case "universal":
      return [1];
    case "tag":
      return [1];
    case "id":
      return [2];
    case "class":
      return [3, selector.name];
    case "attrPresence":
      return [4, serialize(selector)];
    case "attrValue":
      return [5, serialize(selector)];
    case "combinator":
      return [15, serialize(selector)];
  }
}
function compareSpecificity(a, b4) {
  return _compareArrays(a, b4);
}
function _compareArrays(a, b4) {
  if (!Array.isArray(a) || !Array.isArray(b4)) {
    throw new Error("Arguments must be arrays.");
  }
  const shorter = a.length < b4.length ? a.length : b4.length;
  for (let i = 0;i < shorter; i++) {
    if (a[i] === b4[i]) {
      continue;
    }
    return a[i] < b4[i] ? -1 : 1;
  }
  return a.length - b4.length;
}
var ws2 = `(?:[ \\t\\r\\n\\f]*)`;
var nl = `(?:\\n|\\r\\n|\\r|\\f)`;
var nonascii = `[^\\x00-\\x7F]`;
var unicode = `(?:\\\\[0-9a-f]{1,6}(?:\\r\\n|[ \\n\\r\\t\\f])?)`;
var escape2 = `(?:\\\\[^\\n\\r\\f0-9a-f])`;
var nmstart = `(?:[_a-z]|${nonascii}|${unicode}|${escape2})`;
var nmchar = `(?:[_a-z0-9-]|${nonascii}|${unicode}|${escape2})`;
var name = `(?:${nmchar}+)`;
var ident = `(?:[-]?${nmstart}${nmchar}*)`;
var string1 = `'([^\\n\\r\\f\\\\']|\\\\${nl}|${nonascii}|${unicode}|${escape2})*'`;
var string2 = `"([^\\n\\r\\f\\\\"]|\\\\${nl}|${nonascii}|${unicode}|${escape2})*"`;
var lexSelector = o([
  { name: "ws", regex: new RegExp(ws2) },
  { name: "hash", regex: new RegExp(`#${name}`, "i") },
  { name: "ident", regex: new RegExp(ident, "i") },
  { name: "str1", regex: new RegExp(string1, "i") },
  { name: "str2", regex: new RegExp(string2, "i") },
  { name: "*" },
  { name: "." },
  { name: "," },
  { name: "[" },
  { name: "]" },
  { name: "=" },
  { name: ">" },
  { name: "|" },
  { name: "+" },
  { name: "~" },
  { name: "^" },
  { name: "$" }
]);
var lexEscapedString = o([
  { name: "unicode", regex: new RegExp(unicode, "i") },
  { name: "escape", regex: new RegExp(escape2, "i") },
  { name: "any", regex: new RegExp("[\\s\\S]", "i") }
]);
var unicodeEscapedSequence_ = token((t9) => t9.name === "unicode" ? String.fromCodePoint(parseInt(t9.text.slice(1), 16)) : undefined);
var escapedSequence_ = token((t9) => t9.name === "escape" ? t9.text.slice(1) : undefined);
var anyChar_ = token((t9) => t9.name === "any" ? t9.text : undefined);
var escapedString_ = map(many(choice(unicodeEscapedSequence_, escapedSequence_, anyChar_)), (cs2) => cs2.join(""));
var whitespace_ = token((t9) => t9.name === "ws" ? null : undefined);
var optionalWhitespace_ = option(whitespace_, null);
var identifier_ = token((t9) => t9.name === "ident" ? unescape2(t9.text) : undefined);
var hashId_ = token((t9) => t9.name === "hash" ? unescape2(t9.text.slice(1)) : undefined);
var string_ = token((t9) => t9.name.startsWith("str") ? unescape2(t9.text.slice(1, -1)) : undefined);
var namespace_ = left(option(identifier_, ""), literal("|"));
var qualifiedName_ = otherwise(ab(namespace_, identifier_, (ns2, name2) => ({ name: name2, namespace: ns2 })), map(identifier_, (name2) => ({ name: name2, namespace: null })));
var uniSelector_ = otherwise(ab(namespace_, literal("*"), (ns2) => ({ type: "universal", namespace: ns2, specificity: [0, 0, 0] })), map(literal("*"), () => ({ type: "universal", namespace: null, specificity: [0, 0, 0] })));
var tagSelector_ = map(qualifiedName_, ({ name: name2, namespace }) => ({
  type: "tag",
  name: name2,
  namespace,
  specificity: [0, 0, 1]
}));
var classSelector_ = ab(literal("."), identifier_, (fullstop, name2) => ({
  type: "class",
  name: name2,
  specificity: [0, 1, 0]
}));
var idSelector_ = map(hashId_, (name2) => ({
  type: "id",
  name: name2,
  specificity: [1, 0, 0]
}));
var attrModifier_ = token((t9) => {
  if (t9.name === "ident") {
    if (t9.text === "i" || t9.text === "I") {
      return "i";
    }
    if (t9.text === "s" || t9.text === "S") {
      return "s";
    }
  }
  return;
});
var attrValue_ = otherwise(ab(string_, option(right(optionalWhitespace_, attrModifier_), null), (v3, mod) => ({ value: v3, modifier: mod })), ab(identifier_, option(right(whitespace_, attrModifier_), null), (v3, mod) => ({ value: v3, modifier: mod })));
var attrMatcher_ = choice(map(literal("="), () => "="), ab(literal("~"), literal("="), () => "~="), ab(literal("|"), literal("="), () => "|="), ab(literal("^"), literal("="), () => "^="), ab(literal("$"), literal("="), () => "$="), ab(literal("*"), literal("="), () => "*="));
var attrPresenceSelector_ = abc(literal("["), optionallySpaced(qualifiedName_), literal("]"), (lbr, { name: name2, namespace }) => ({
  type: "attrPresence",
  name: name2,
  namespace,
  specificity: [0, 1, 0]
}));
var attrValueSelector_ = middle(literal("["), abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name: name2, namespace }, matcher, { value, modifier }) => ({
  type: "attrValue",
  name: name2,
  namespace,
  matcher,
  value,
  modifier,
  specificity: [0, 1, 0]
})), literal("]"));
var attrSelector_ = otherwise(attrPresenceSelector_, attrValueSelector_);
var typeSelector_ = otherwise(uniSelector_, tagSelector_);
var subclassSelector_ = choice(idSelector_, classSelector_, attrSelector_);
var compoundSelector_ = map(otherwise(flatten(typeSelector_, many(subclassSelector_)), many1(subclassSelector_)), (ss2) => {
  return {
    type: "compound",
    list: ss2,
    specificity: sumAllSpec(ss2.map((s2) => s2.specificity))
  };
});
var combinator_ = choice(map(literal(">"), () => ">"), map(literal("+"), () => "+"), map(literal("~"), () => "~"), ab(literal("|"), literal("|"), () => "||"));
var combinatorSeparator_ = otherwise(optionallySpaced(combinator_), map(whitespace_, () => " "));
var complexSelector_ = leftAssoc2(compoundSelector_, map(combinatorSeparator_, (c2) => (left2, right2) => ({
  type: "compound",
  list: [...right2.list, { type: "combinator", combinator: c2, left: left2, specificity: left2.specificity }],
  specificity: sumSpec(left2.specificity, right2.specificity)
})), compoundSelector_);
var listSelector_ = leftAssoc2(map(complexSelector_, (s2) => ({ type: "list", list: [s2] })), map(optionallySpaced(literal(",")), () => (acc, next) => ({ type: "list", list: [...acc.list, next] })), complexSelector_);

// node_modules/selderee/lib/selderee.mjs
function toAstTerminalPairs(array2) {
  const len = array2.length;
  const results = new Array(len);
  for (let i = 0;i < len; i++) {
    const [selectorString, val] = array2[i];
    const ast = preprocess(parse1(selectorString));
    results[i] = {
      ast,
      terminal: {
        type: "terminal",
        valueContainer: { index: i, value: val, specificity: ast.specificity }
      }
    };
  }
  return results;
}
function preprocess(ast) {
  reduceSelectorVariants(ast);
  normalize(ast);
  return ast;
}
function reduceSelectorVariants(ast) {
  const newList = [];
  ast.list.forEach((sel) => {
    switch (sel.type) {
      case "class":
        newList.push({
          matcher: "~=",
          modifier: null,
          name: "class",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "id":
        newList.push({
          matcher: "=",
          modifier: null,
          name: "id",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "combinator":
        reduceSelectorVariants(sel.left);
        newList.push(sel);
        break;
      case "universal":
        break;
      default:
        newList.push(sel);
        break;
    }
  });
  ast.list = newList;
}
function weave(items) {
  const branches = [];
  while (items.length) {
    const topKind = findTopKey(items, (sel) => true, getSelectorKind);
    const { matches, nonmatches, empty } = breakByKind(items, topKind);
    items = nonmatches;
    if (matches.length) {
      branches.push(branchOfKind(topKind, matches));
    }
    if (empty.length) {
      branches.push(...terminate(empty));
    }
  }
  return branches;
}
function terminate(items) {
  const results = [];
  for (const item of items) {
    const terminal = item.terminal;
    if (terminal.type === "terminal") {
      results.push(terminal);
    } else {
      const { matches, rest } = partition(terminal.cont, (node3) => node3.type === "terminal");
      matches.forEach((node3) => results.push(node3));
      if (rest.length) {
        terminal.cont = rest;
        results.push(terminal);
      }
    }
  }
  return results;
}
function breakByKind(items, selectedKind) {
  const matches = [];
  const nonmatches = [];
  const empty = [];
  for (const item of items) {
    const simpsels = item.ast.list;
    if (simpsels.length) {
      const isMatch = simpsels.some((node3) => getSelectorKind(node3) === selectedKind);
      (isMatch ? matches : nonmatches).push(item);
    } else {
      empty.push(item);
    }
  }
  return { matches, nonmatches, empty };
}
function getSelectorKind(sel) {
  switch (sel.type) {
    case "attrPresence":
      return `attrPresence ${sel.name}`;
    case "attrValue":
      return `attrValue ${sel.name}`;
    case "combinator":
      return `combinator ${sel.combinator}`;
    default:
      return sel.type;
  }
}
function branchOfKind(kind, items) {
  if (kind === "tag") {
    return tagNameBranch(items);
  }
  if (kind.startsWith("attrValue ")) {
    return attrValueBranch(kind.substring(10), items);
  }
  if (kind.startsWith("attrPresence ")) {
    return attrPresenceBranch(kind.substring(13), items);
  }
  if (kind === "combinator >") {
    return combinatorBranch(">", items);
  }
  if (kind === "combinator +") {
    return combinatorBranch("+", items);
  }
  throw new Error(`Unsupported selector kind: ${kind}`);
}
function tagNameBranch(items) {
  const groups = spliceAndGroup(items, (x) => x.type === "tag", (x) => x.name);
  const variants = Object.entries(groups).map(([name2, group]) => ({
    type: "variant",
    value: name2,
    cont: weave(group.items)
  }));
  return {
    type: "tagName",
    variants
  };
}
function attrPresenceBranch(name2, items) {
  for (const item of items) {
    spliceSimpleSelector(item, (x) => x.type === "attrPresence" && x.name === name2);
  }
  return {
    type: "attrPresence",
    name: name2,
    cont: weave(items)
  };
}
function attrValueBranch(name2, items) {
  const groups = spliceAndGroup(items, (x) => x.type === "attrValue" && x.name === name2, (x) => `${x.matcher} ${x.modifier || ""} ${x.value}`);
  const matchers = [];
  for (const group of Object.values(groups)) {
    const sel = group.oneSimpleSelector;
    const predicate = getAttrPredicate(sel);
    const continuation = weave(group.items);
    matchers.push({
      type: "matcher",
      matcher: sel.matcher,
      modifier: sel.modifier,
      value: sel.value,
      predicate,
      cont: continuation
    });
  }
  return {
    type: "attrValue",
    name: name2,
    matchers
  };
}
function getAttrPredicate(sel) {
  if (sel.modifier === "i") {
    const expected = sel.value.toLowerCase();
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual.toLowerCase();
      case "~=":
        return (actual) => actual.toLowerCase().split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.toLowerCase().startsWith(expected);
      case "$=":
        return (actual) => actual.toLowerCase().endsWith(expected);
      case "*=":
        return (actual) => actual.toLowerCase().includes(expected);
      case "|=":
        return (actual) => {
          const lower = actual.toLowerCase();
          return expected === lower || lower.startsWith(expected) && lower[expected.length] === "-";
        };
    }
  } else {
    const expected = sel.value;
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual;
      case "~=":
        return (actual) => actual.split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.startsWith(expected);
      case "$=":
        return (actual) => actual.endsWith(expected);
      case "*=":
        return (actual) => actual.includes(expected);
      case "|=":
        return (actual) => expected === actual || actual.startsWith(expected) && actual[expected.length] === "-";
    }
  }
}
function combinatorBranch(combinator, items) {
  const groups = spliceAndGroup(items, (x) => x.type === "combinator" && x.combinator === combinator, (x) => serialize(x.left));
  const leftItems = [];
  for (const group of Object.values(groups)) {
    const rightCont = weave(group.items);
    const leftAst = group.oneSimpleSelector.left;
    leftItems.push({
      ast: leftAst,
      terminal: { type: "popElement", cont: rightCont }
    });
  }
  return {
    type: "pushElement",
    combinator,
    cont: weave(leftItems)
  };
}
function spliceAndGroup(items, predicate, keyCallback) {
  const groups = {};
  while (items.length) {
    const bestKey = findTopKey(items, predicate, keyCallback);
    const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;
    const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);
    const { matches, rest } = partition1(items, hasBestKeyPredicate);
    let oneSimpleSelector = null;
    for (const item of matches) {
      const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
      if (!oneSimpleSelector) {
        oneSimpleSelector = splicedNode;
      }
    }
    if (oneSimpleSelector == null) {
      throw new Error("No simple selector is found.");
    }
    groups[bestKey] = { oneSimpleSelector, items: matches };
    items = rest;
  }
  return groups;
}
function spliceSimpleSelector(item, predicate) {
  const simpsels = item.ast.list;
  const matches = new Array(simpsels.length);
  let firstIndex = -1;
  for (let i = simpsels.length;i-- > 0; ) {
    if (predicate(simpsels[i])) {
      matches[i] = true;
      firstIndex = i;
    }
  }
  if (firstIndex == -1) {
    throw new Error(`Couldn't find the required simple selector.`);
  }
  const result2 = simpsels[firstIndex];
  item.ast.list = simpsels.filter((sel, i) => !matches[i]);
  return result2;
}
function findTopKey(items, predicate, keyCallback) {
  const candidates = {};
  for (const item of items) {
    const candidates1 = {};
    for (const node3 of item.ast.list.filter(predicate)) {
      candidates1[keyCallback(node3)] = true;
    }
    for (const key of Object.keys(candidates1)) {
      if (candidates[key]) {
        candidates[key]++;
      } else {
        candidates[key] = 1;
      }
    }
  }
  let topKind = "";
  let topCounter = 0;
  for (const entry of Object.entries(candidates)) {
    if (entry[1] > topCounter) {
      topKind = entry[0];
      topCounter = entry[1];
    }
  }
  return topKind;
}
function partition(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x of src) {
    if (predicate(x)) {
      matches.push(x);
    } else {
      rest.push(x);
    }
  }
  return { matches, rest };
}
function partition1(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x of src) {
    if (predicate(x)) {
      matches.push(x);
    } else {
      rest.push(x);
    }
  }
  return { matches, rest };
}
function comparatorPreferFirst(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index < acc.index;
}
function comparatorPreferLast(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index > acc.index;
}
class DecisionTree {
  constructor(input) {
    this.branches = weave(toAstTerminalPairs(input));
  }
  build(builder) {
    return builder(this.branches);
  }
}

class Picker {
  constructor(f) {
    this.f = f;
  }
  pickAll(el) {
    return this.f(el);
  }
  pick1(el, preferFirst = false) {
    const results = this.f(el);
    const len = results.length;
    if (len === 0) {
      return null;
    }
    if (len === 1) {
      return results[0].value;
    }
    const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;
    let result2 = results[0];
    for (let i = 1;i < len; i++) {
      const next = results[i];
      if (comparator(result2, next)) {
        result2 = next;
      }
    }
    return result2.value;
  }
}

// node_modules/@selderee/plugin-htmlparser2/lib/hp2-builder.mjs
function hp2Builder(nodes) {
  return new Picker(handleArray(nodes));
}
function handleArray(nodes) {
  const matchers = nodes.map(handleNode);
  return (el, ...tail) => matchers.flatMap((m) => m(el, ...tail));
}
function handleNode(node3) {
  switch (node3.type) {
    case "terminal": {
      const result2 = [node3.valueContainer];
      return (el, ...tail) => result2;
    }
    case "tagName":
      return handleTagName(node3);
    case "attrValue":
      return handleAttrValueName(node3);
    case "attrPresence":
      return handleAttrPresenceName(node3);
    case "pushElement":
      return handlePushElementNode(node3);
    case "popElement":
      return handlePopElementNode(node3);
  }
}
function handleTagName(node3) {
  const variants = {};
  for (const variant of node3.variants) {
    variants[variant.value] = handleArray(variant.cont);
  }
  return (el, ...tail) => {
    const continuation = variants[el.name];
    return continuation ? continuation(el, ...tail) : [];
  };
}
function handleAttrPresenceName(node3) {
  const attrName = node3.name;
  const continuation = handleArray(node3.cont);
  return (el, ...tail) => Object.prototype.hasOwnProperty.call(el.attribs, attrName) ? continuation(el, ...tail) : [];
}
function handleAttrValueName(node3) {
  const callbacks = [];
  for (const matcher of node3.matchers) {
    const predicate = matcher.predicate;
    const continuation = handleArray(matcher.cont);
    callbacks.push((attr, el, ...tail) => predicate(attr) ? continuation(el, ...tail) : []);
  }
  const attrName = node3.name;
  return (el, ...tail) => {
    const attr = el.attribs[attrName];
    return attr || attr === "" ? callbacks.flatMap((cb) => cb(attr, el, ...tail)) : [];
  };
}
function handlePushElementNode(node3) {
  const continuation = handleArray(node3.cont);
  const leftElementGetter = node3.combinator === "+" ? getPrecedingElement : getParentElement;
  return (el, ...tail) => {
    const next = leftElementGetter(el);
    if (next === null) {
      return [];
    }
    return continuation(next, el, ...tail);
  };
}
function handlePopElementNode(node3) {
  const continuation = handleArray(node3.cont);
  return (el, next, ...tail) => continuation(next, ...tail);
}
var getPrecedingElement = (el) => {
  const prev = el.prev;
  if (prev === null) {
    return null;
  }
  return isTag2(prev) ? prev : getPrecedingElement(prev);
};
var getParentElement = (el) => {
  const parent = el.parent;
  return parent && isTag2(parent) ? parent : null;
};

// node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array('\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\uD835\uDD04rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\uD835\uDD38plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\uD835\uDC9Cign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\uD835\uDD05pf;\uC000\uD835\uDD39eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\uD835\uDC9Ep\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\uD835\uDD07\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\uD835\uDD3B\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\uD835\uDC9Frok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\uD835\uDD08rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\uD835\uDD3Csilon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\uD835\uDD09lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\uD835\uDD3DAll;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\uD835\uDD0A;\u62D9pf;\uC000\uD835\uDD3Eeater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\uD835\uDCA2;\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\uD835\uDD40a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\uD835\uDD0Dpf;\uC000\uD835\uDD41\u01E3\u07C7\0\u07CCr;\uC000\uD835\uDCA5rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\uD835\uDD0Epf;\uC000\uD835\uDD42cr;\uC000\uD835\uDCA6\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\uD835\uDD0F\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\uD835\uDD43er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\uD835\uDD10nusPlus;\u6213pf;\uC000\uD835\uDD44c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\uD835\uDD11\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\uD835\uDCA9ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\uD835\uDD12rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\uD835\uDD46enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\uD835\uDCAAash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\uD835\uDD13i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\uD835\uDCAB;\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\uD835\uDD14pf;\u611Acr;\uC000\uD835\uDCAC\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\uD835\uDD16ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\uD835\uDD4A\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\uD835\uDCAEar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\uD835\uDD17\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\uD835\uDD4BipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\uD835\uDCAFrok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\uD835\uDD18rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\uD835\uDD4C\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\uD835\uDCB0ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\uD835\uDD19pf;\uC000\uD835\uDD4Dcr;\uC000\uD835\uDCB1dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\uD835\uDD1Apf;\uC000\uD835\uDD4Ecr;\uC000\uD835\uDCB2\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\uD835\uDD1B;\u439Epf;\uC000\uD835\uDD4Fcr;\uC000\uD835\uDCB3\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\uD835\uDD1Cpf;\uC000\uD835\uDD50cr;\uC000\uD835\uDCB4ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\uD835\uDCB5\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\uD835\uDD1Erave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\uD835\uDD52\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\uD835\uDCB6;\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\uD835\uDD1Fg\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\uD835\uDD53\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\uD835\uDCB7mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\uD835\uDD20\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\uD835\uDD54o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\uD835\uDCB8\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\uD835\uDD21ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\uD835\uDD55\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\uD835\uDCB9;\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\uD835\uDD22\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\uD835\uDD56\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\uD835\uDD23lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\uD835\uDD57\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\uD835\uDCBB\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\uD835\uDD24\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\uD835\uDD58\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\uD835\uDD25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\uD835\uDD59bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\uD835\uDCBDas\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\uD835\uDD26rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\uD835\uDD5Aa;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\uD835\uDCBEn\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\uD835\uDD27ath;\u4237pf;\uC000\uD835\uDD5B\u01E3\u23EC\0\u23F1r;\uC000\uD835\uDCBFrcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\uD835\uDD28reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\uD835\uDD5Ccr;\uC000\uD835\uDCC0\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\uD835\uDD29\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\uD835\uDD5Dus;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\uD835\uDCC1m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\uD835\uDD2Ao;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\uD835\uDD5E\u0100ct\u28F8\u28FDr;\uC000\uD835\uDCC2pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\uD835\uDD2B\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\uD835\uDD5F\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\uD835\uDCC3ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\uD835\uDD2C\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\uD835\uDD60\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\uD835\uDD2D\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\uD835\uDD61nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\uD835\uDCC5;\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\uD835\uDD2Epf;\uC000\uD835\uDD62rime;\u6057cr;\uC000\uD835\uDCC6\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\uD835\uDD2F\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\uD835\uDD63us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\uD835\uDCC7\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\uD835\uDD30\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\uD835\uDD64a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\uD835\uDCC8tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\uD835\uDD31\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\uD835\uDD65rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\uD835\uDCC9;\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\uD835\uDD32rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\uD835\uDD66\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\uD835\uDCCA\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\uD835\uDD33tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\uD835\uDD67ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\uD835\uDCCB\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\uD835\uDD34pf;\uC000\uD835\uDD68\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\uD835\uDCCC\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\uD835\uDD35\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\uD835\uDD69im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\uD835\uDCCD\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\uD835\uDD36cy;\u4457pf;\uC000\uD835\uDD6Acr;\uC000\uD835\uDCCE\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\uD835\uDD37cy;\u4436grarr;\u61DDpf;\uC000\uD835\uDD6Bcr;\uC000\uD835\uDCCF\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c2) => c2.charCodeAt(0)));

// node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array("\u0200aglq\t\x15\x18\x1B\u026D\x0F\0\0\x12p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c2) => c2.charCodeAt(0)));

// node_modules/entities/lib/esm/decode_codepoint.js
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== undefined ? _a2 : codePoint;
}
var _a2;
var decodeMap = new Map([
  [0, 65533],
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (_a2 = String.fromCodePoint) !== null && _a2 !== undefined ? _a2 : function(codePoint) {
  let output = "";
  if (codePoint > 65535) {
    codePoint -= 65536;
    output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
    codePoint = 56320 | codePoint & 1023;
  }
  output += String.fromCharCode(codePoint);
  return output;
};

// node_modules/entities/lib/esm/decode.js
function isNumber(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(str, offset + 1);
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result2 = ret + str.slice(lastIndex);
    ret = "";
    return result2;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo3 = nodeIdx;
  let hi2 = lo3 + branchCount - 1;
  while (lo3 <= hi2) {
    const mid = lo3 + hi2 >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo3 = mid + 1;
    } else if (midVal > char) {
      hi2 = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));

class EntityDecoder {
  constructor(decodeTree, emitCodePoint, errors6) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors6;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  emitNumericEntity(lastCp, expectedLength) {
    var _a3;
    if (this.consumed <= expectedLength) {
      (_a3 = this.errors) === null || _a3 === undefined || _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (;offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  emitNotTerminatedNamedEntity() {
    var _a3;
    const { result: result2, decodeTree } = this;
    const valueLength = (decodeTree[result2] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result2, valueLength, this.consumed);
    (_a3 = this.errors) === null || _a3 === undefined || _a3.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  emitNamedEntityData(result2, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result2] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result2 + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result2 + 2], consumed);
    }
    return consumed;
  }
  end() {
    var _a3;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a3 = this.errors) === null || _a3 === undefined || _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);

// node_modules/htmlparser2/lib/esm/Tokenizer.js
function isWhitespace(c2) {
  return c2 === CharCodes2.Space || c2 === CharCodes2.NewLine || c2 === CharCodes2.Tab || c2 === CharCodes2.FormFeed || c2 === CharCodes2.CarriageReturn;
}
function isEndOfTagSection(c2) {
  return c2 === CharCodes2.Slash || c2 === CharCodes2.Gt || isWhitespace(c2);
}
function isNumber2(c2) {
  return c2 >= CharCodes2.Zero && c2 <= CharCodes2.Nine;
}
function isASCIIAlpha(c2) {
  return c2 >= CharCodes2.LowerA && c2 <= CharCodes2.LowerZ || c2 >= CharCodes2.UpperA && c2 <= CharCodes2.UpperZ;
}
function isHexDigit(c2) {
  return c2 >= CharCodes2.UpperA && c2 <= CharCodes2.UpperF || c2 >= CharCodes2.LowerA && c2 <= CharCodes2.LowerF;
}
var CharCodes2;
(function(CharCodes3) {
  CharCodes3[CharCodes3["Tab"] = 9] = "Tab";
  CharCodes3[CharCodes3["NewLine"] = 10] = "NewLine";
  CharCodes3[CharCodes3["FormFeed"] = 12] = "FormFeed";
  CharCodes3[CharCodes3["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes3[CharCodes3["Space"] = 32] = "Space";
  CharCodes3[CharCodes3["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes3[CharCodes3["Number"] = 35] = "Number";
  CharCodes3[CharCodes3["Amp"] = 38] = "Amp";
  CharCodes3[CharCodes3["SingleQuote"] = 39] = "SingleQuote";
  CharCodes3[CharCodes3["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes3[CharCodes3["Dash"] = 45] = "Dash";
  CharCodes3[CharCodes3["Slash"] = 47] = "Slash";
  CharCodes3[CharCodes3["Zero"] = 48] = "Zero";
  CharCodes3[CharCodes3["Nine"] = 57] = "Nine";
  CharCodes3[CharCodes3["Semi"] = 59] = "Semi";
  CharCodes3[CharCodes3["Lt"] = 60] = "Lt";
  CharCodes3[CharCodes3["Eq"] = 61] = "Eq";
  CharCodes3[CharCodes3["Gt"] = 62] = "Gt";
  CharCodes3[CharCodes3["Questionmark"] = 63] = "Questionmark";
  CharCodes3[CharCodes3["UpperA"] = 65] = "UpperA";
  CharCodes3[CharCodes3["LowerA"] = 97] = "LowerA";
  CharCodes3[CharCodes3["UpperF"] = 70] = "UpperF";
  CharCodes3[CharCodes3["LowerF"] = 102] = "LowerF";
  CharCodes3[CharCodes3["UpperZ"] = 90] = "UpperZ";
  CharCodes3[CharCodes3["LowerZ"] = 122] = "LowerZ";
  CharCodes3[CharCodes3["LowerX"] = 120] = "LowerX";
  CharCodes3[CharCodes3["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes2 || (CharCodes2 = {}));
var State;
(function(State2) {
  State2[State2["Text"] = 1] = "Text";
  State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
  State2[State2["InTagName"] = 3] = "InTagName";
  State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
  State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State2[State2["InAttributeName"] = 9] = "InAttributeName";
  State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
  State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State2[State2["InDeclaration"] = 16] = "InDeclaration";
  State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State2[State2["BeforeComment"] = 18] = "BeforeComment";
  State2[State2["CDATASequence"] = 19] = "CDATASequence";
  State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
  State2[State2["InCommentLike"] = 21] = "InCommentLike";
  State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
  State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
  State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
  State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
  State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
  State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
  State2[State2["InHexEntity"] = 29] = "InHexEntity";
})(State || (State = {}));
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
var Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
};

class Tokenizer {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = undefined;
    this.sequenceIndex = 0;
    this.trieIndex = 0;
    this.trieCurrent = 0;
    this.entityResult = 0;
    this.entityExcess = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityTrie = xmlMode ? decode_data_xml_default : decode_data_html_default;
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = undefined;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  getIndex() {
    return this.index;
  }
  getSectionStart() {
    return this.sectionStart;
  }
  stateText(c2) {
    if (c2 === CharCodes2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes2.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.state = State.BeforeEntity;
    }
  }
  stateSpecialStartSequence(c2) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? isEndOfTagSection(c2) : (c2 | 32) === this.currentSequence[this.sequenceIndex];
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c2);
  }
  stateInSpecialTag(c2) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c2 === CharCodes2.Gt || isWhitespace(c2)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c2);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c2 | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c2 === CharCodes2.Amp) {
          this.state = State.BeforeEntity;
        }
      } else if (this.fastForwardTo(CharCodes2.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c2 === CharCodes2.Lt);
    }
  }
  stateCDATASequence(c2) {
    if (c2 === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c2);
    }
  }
  fastForwardTo(c2) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c2) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  stateInCommentLike(c2) {
    if (c2 === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c2 !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  isTagStartChar(c2) {
    return this.xmlMode ? !isEndOfTagSection(c2) : isASCIIAlpha(c2);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c2) {
    if (c2 === CharCodes2.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c2)) {
      const lower = c2 | 32;
      this.sectionStart = this.index;
      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
        this.startSpecial(Sequences.TitleEnd, 3);
      } else {
        this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
      }
    } else if (c2 === CharCodes2.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c2);
    }
  }
  stateInTagName(c2) {
    if (isEndOfTagSection(c2)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateBeforeClosingTagName(c2) {
    if (isWhitespace(c2)) {
    } else if (c2 === CharCodes2.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c2) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c2) {
    if (c2 === CharCodes2.Gt || isWhitespace(c2)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c2);
    }
  }
  stateAfterClosingTagName(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c2) {
    if (c2 === CharCodes2.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.baseState = this.state;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace(c2)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c2) {
    if (c2 === CharCodes2.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace(c2)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateInAttributeName(c2) {
    if (c2 === CharCodes2.Eq || isEndOfTagSection(c2)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c2);
    }
  }
  stateAfterAttributeName(c2) {
    if (c2 === CharCodes2.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c2 === CharCodes2.Slash || c2 === CharCodes2.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (!isWhitespace(c2)) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c2) {
    if (c2 === CharCodes2.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c2)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c2);
    }
  }
  handleInAttributeValue(c2, quote) {
    if (c2 === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateInAttributeValueDoubleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes2.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes2.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c2) {
    if (isWhitespace(c2) || c2 === CharCodes2.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateBeforeDeclaration(c2) {
    if (c2 === CharCodes2.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c2 === CharCodes2.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c2) {
    if (c2 === CharCodes2.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c2) {
    const lower = c2 | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c2);
    }
  }
  stateBeforeEntity(c2) {
    this.entityExcess = 1;
    this.entityResult = 0;
    if (c2 === CharCodes2.Number) {
      this.state = State.BeforeNumericEntity;
    } else if (c2 === CharCodes2.Amp) {
    } else {
      this.trieIndex = 0;
      this.trieCurrent = this.entityTrie[0];
      this.state = State.InNamedEntity;
      this.stateInNamedEntity(c2);
    }
  }
  stateInNamedEntity(c2) {
    this.entityExcess += 1;
    this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c2);
    if (this.trieIndex < 0) {
      this.emitNamedEntity();
      this.index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
    if (masked) {
      const valueLength = (masked >> 14) - 1;
      if (!this.allowLegacyEntity() && c2 !== CharCodes2.Semi) {
        this.trieIndex += valueLength;
      } else {
        const entityStart = this.index - this.entityExcess + 1;
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.entityResult = this.trieIndex;
        this.trieIndex += valueLength;
        this.entityExcess = 0;
        this.sectionStart = this.index + 1;
        if (valueLength === 0) {
          this.emitNamedEntity();
        }
      }
    }
  }
  emitNamedEntity() {
    this.state = this.baseState;
    if (this.entityResult === 0) {
      return;
    }
    const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
    switch (valueLength) {
      case 1: {
        this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);
        break;
      }
      case 2: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        break;
      }
      case 3: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
      }
    }
  }
  stateBeforeNumericEntity(c2) {
    if ((c2 | 32) === CharCodes2.LowerX) {
      this.entityExcess++;
      this.state = State.InHexEntity;
    } else {
      this.state = State.InNumericEntity;
      this.stateInNumericEntity(c2);
    }
  }
  emitNumericEntity(strict) {
    const entityStart = this.index - this.entityExcess - 1;
    const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
    if (numberStart !== this.index) {
      if (entityStart > this.sectionStart) {
        this.emitPartial(this.sectionStart, entityStart);
      }
      this.sectionStart = this.index + Number(strict);
      this.emitCodePoint(replaceCodePoint(this.entityResult));
    }
    this.state = this.baseState;
  }
  stateInNumericEntity(c2) {
    if (c2 === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c2)) {
      this.entityResult = this.entityResult * 10 + (c2 - CharCodes2.Zero);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  stateInHexEntity(c2) {
    if (c2 === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c2)) {
      this.entityResult = this.entityResult * 16 + (c2 - CharCodes2.Zero);
      this.entityExcess++;
    } else if (isHexDigit(c2)) {
      this.entityResult = this.entityResult * 16 + ((c2 | 32) - CharCodes2.LowerA + 10);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  allowLegacyEntity() {
    return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
  }
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  parse() {
    while (this.shouldContinue()) {
      const c2 = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c2);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c2);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c2);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c2);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c2);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c2);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c2);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c2);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c2);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c2);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c2);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c2);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c2);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c2);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c2);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c2);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c2);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c2);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c2);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c2);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c2);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c2);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c2);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c2);
          break;
        }
        case State.InNamedEntity: {
          this.stateInNamedEntity(c2);
          break;
        }
        case State.BeforeEntity: {
          this.stateBeforeEntity(c2);
          break;
        }
        case State.InHexEntity: {
          this.stateInHexEntity(c2);
          break;
        }
        case State.InNumericEntity: {
          this.stateInNumericEntity(c2);
          break;
        }
        default: {
          this.stateBeforeNumericEntity(c2);
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InNamedEntity) {
      this.emitNamedEntity();
    }
    if (this.sectionStart < this.index) {
      this.handleTrailingData();
    }
    this.cbs.onend();
  }
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
    } else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitPartial(start, endIndex) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribdata(start, endIndex);
    } else {
      this.cbs.ontext(start, endIndex);
    }
  }
  emitCodePoint(cp) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribentity(cp);
    } else {
      this.cbs.ontextentity(cp);
    }
  }
}

// node_modules/htmlparser2/lib/esm/Parser.js
var formTags = new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = new Set(["p"]);
var tableSectionTags = new Set(["thead", "tbody"]);
var ddtTags = new Set(["dd", "dt"]);
var rtpTags = new Set(["rt", "rp"]);
var openImpliesClose = new Map([
  ["tr", new Set(["tr", "th", "td"])],
  ["th", new Set(["th"])],
  ["td", new Set(["thead", "th", "td"])],
  ["body", new Set(["head", "link", "script"])],
  ["li", new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", new Set(["option"])],
  ["optgroup", new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = new Set(["math", "svg"]);
var htmlIntegrationElements = new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;

class Parser {
  constructor(cbs, options = {}) {
    var _a3, _b, _c, _d, _e3;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== undefined ? cbs : {};
    this.lowerCaseTagNames = (_a3 = options.lowerCaseTags) !== null && _a3 !== undefined ? _a3 : !options.xmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== undefined ? _b : !options.xmlMode;
    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== undefined ? _c : Tokenizer)(this.options, this);
    (_e3 = (_d = this.cbs).onparserinit) === null || _e3 === undefined || _e3.call(_d, this);
  }
  ontext(start, endIndex) {
    var _a3, _b;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a3 = this.cbs).ontext) === null || _b === undefined || _b.call(_a3, data);
    this.startIndex = endIndex;
  }
  ontextentity(cp) {
    var _a3, _b;
    const index2 = this.tokenizer.getSectionStart();
    this.endIndex = index2 - 1;
    (_b = (_a3 = this.cbs).ontext) === null || _b === undefined || _b.call(_a3, fromCodePoint(cp));
    this.startIndex = index2;
  }
  isVoidElement(name2) {
    return !this.options.xmlMode && voidElements.has(name2);
  }
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    this.emitOpenTag(name2);
  }
  emitOpenTag(name2) {
    var _a3, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name2;
    const impliesClose = !this.options.xmlMode && openImpliesClose.get(name2);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
        const element = this.stack.pop();
        (_b = (_a3 = this.cbs).onclosetag) === null || _b === undefined || _b.call(_a3, element, true);
      }
    }
    if (!this.isVoidElement(name2)) {
      this.stack.push(name2);
      if (foreignContextElements.has(name2)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements.has(name2)) {
        this.foreignContext.push(false);
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === undefined || _d.call(_c, name2);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a3, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a3 = this.cbs).onopentag) === null || _b === undefined || _b.call(_a3, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  onclosetag(start, endIndex) {
    var _a3, _b, _c, _d, _e3, _f;
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    if (foreignContextElements.has(name2) || htmlIntegrationElements.has(name2)) {
      this.foreignContext.pop();
    }
    if (!this.isVoidElement(name2)) {
      const pos = this.stack.lastIndexOf(name2);
      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          let count2 = this.stack.length - pos;
          while (count2--) {
            this.cbs.onclosetag(this.stack.pop(), count2 !== 0);
          }
        } else
          this.stack.length = pos;
      } else if (!this.options.xmlMode && name2 === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (!this.options.xmlMode && name2 === "br") {
      (_b = (_a3 = this.cbs).onopentagname) === null || _b === undefined || _b.call(_a3, "br");
      (_d = (_c = this.cbs).onopentag) === null || _d === undefined || _d.call(_c, "br", {}, true);
      (_f = (_e3 = this.cbs).onclosetag) === null || _f === undefined || _f.call(_e3, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a3, _b;
    const name2 = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[this.stack.length - 1] === name2) {
      (_b = (_a3 = this.cbs).onclosetag) === null || _b === undefined || _b.call(_a3, name2, !isOpenImplied);
      this.stack.pop();
    }
  }
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name2 = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name2.toLowerCase() : name2;
  }
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  onattribend(quote, endIndex) {
    var _a3, _b;
    this.endIndex = endIndex;
    (_b = (_a3 = this.cbs).onattribute) === null || _b === undefined || _b.call(_a3, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? undefined : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index2 = value.search(reNameEnd);
    let name2 = index2 < 0 ? value : value.substr(0, index2);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    return name2;
  }
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name2}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name2}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  oncomment(start, endIndex, offset) {
    var _a3, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a3 = this.cbs).oncomment) === null || _b === undefined || _b.call(_a3, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === undefined || _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  oncdata(start, endIndex, offset) {
    var _a3, _b, _c, _d, _e3, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b = (_a3 = this.cbs).oncdatastart) === null || _b === undefined || _b.call(_a3);
      (_d = (_c = this.cbs).ontext) === null || _d === undefined || _d.call(_c, value);
      (_f = (_e3 = this.cbs).oncdataend) === null || _f === undefined || _f.call(_e3);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === undefined || _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === undefined || _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  onend() {
    var _a3, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index2 = this.stack.length;index2 > 0; this.cbs.onclosetag(this.stack[--index2], true))
        ;
    }
    (_b = (_a3 = this.cbs).onend) === null || _b === undefined || _b.call(_a3);
  }
  reset() {
    var _a3, _b, _c, _d;
    (_b = (_a3 = this.cbs).onreset) === null || _b === undefined || _b.call(_a3);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === undefined || _d.call(_c, this);
    this.buffers.length = 0;
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  write(chunk) {
    var _a3, _b;
    if (this.ended) {
      (_b = (_a3 = this.cbs).onerror) === null || _b === undefined || _b.call(_a3, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  end(chunk) {
    var _a3, _b;
    if (this.ended) {
      (_b = (_a3 = this.cbs).onerror) === null || _b === undefined || _b.call(_a3, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  pause() {
    this.tokenizer.pause();
  }
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  parseChunk(chunk) {
    this.write(chunk);
  }
  done(chunk) {
    this.end(chunk);
  }
}

// node_modules/htmlparser2/lib/esm/index.js
function parseDocument(data, options) {
  const handler = new DomHandler(undefined, options);
  new Parser(handler, options).end(data);
  return handler.root;
}
// node_modules/entities/lib/esm/escape.js
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i = match.index;
    const char = str.charCodeAt(i);
    const next = xmlCodeMap.get(char);
    if (next !== undefined) {
      ret += str.substring(lastIdx, i) + next;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex, map2) {
  return function escape(data) {
    let match;
    let lastIdx = 0;
    let result2 = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result2 += data.substring(lastIdx, match.index);
      }
      result2 += map2.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result2 + data.substring(lastIdx);
  };
}
var xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = String.prototype.codePointAt != null ? (str, index2) => str.codePointAt(index2) : (c2, index2) => (c2.charCodeAt(index2) & 64512) === 55296 ? (c2.charCodeAt(index2) - 55296) * 1024 + c2.charCodeAt(index2 + 1) - 56320 + 65536 : c2.charCodeAt(index2);
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));
// node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// node_modules/dom-serializer/lib/esm/foreignNames.js
var elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val) => [val.toLowerCase(), val]));
var attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val) => [val.toLowerCase(), val]));

// node_modules/dom-serializer/lib/esm/index.js
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes, opts) {
  var _a3;
  if (!attributes)
    return;
  const encode = ((_a3 = opts.encodeEntities) !== null && _a3 !== undefined ? _a3 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes).map((key) => {
    var _a4, _b;
    const value = (_a4 = attributes[key]) !== null && _a4 !== undefined ? _a4 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== undefined ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return `${key}="${encode(value)}"`;
  }).join(" ");
}
function render(node3, options = {}) {
  const nodes = "length" in node3 ? node3 : [node3];
  let output = "";
  for (let i = 0;i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
function renderNode(node3, options) {
  switch (node3.type) {
    case Root:
      return render(node3.children, options);
    case Doctype:
    case Directive:
      return renderDirective(node3);
    case Comment:
      return renderComment(node3);
    case CDATA:
      return renderCdata(node3);
    case Script:
    case Style:
    case Tag:
      return renderTag(node3, options);
    case Text:
      return renderText(node3, options);
  }
}
function renderTag(elem, opts) {
  var _a3;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a3 = elementNames.get(elem.name)) !== null && _a3 !== undefined ? _a3 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a3;
  let data = elem.data || "";
  if (((_a3 = opts.encodeEntities) !== null && _a3 !== undefined ? _a3 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data) : escapeText(data);
  }
  return data;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}
var unencodedElements = new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
var singleTag = new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignModeIntegrationPoints = new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = new Set(["svg", "math"]);
// node_modules/html-to-text/lib/html-to-text.mjs
var import_deepmerge = __toESM(require_cjs4(), 1);
function limitedDepthRecursive(n2, f, g2 = () => {
  return;
}) {
  if (n2 === undefined) {
    const f1 = function(...args) {
      return f(f1, ...args);
    };
    return f1;
  }
  if (n2 >= 0) {
    return function(...args) {
      return f(limitedDepthRecursive(n2 - 1, f, g2), ...args);
    };
  }
  return g2;
}
function trimCharacter(str, char) {
  let start = 0;
  let end = str.length;
  while (start < end && str[start] === char) {
    ++start;
  }
  while (end > start && str[end - 1] === char) {
    --end;
  }
  return start > 0 || end < str.length ? str.substring(start, end) : str;
}
function trimCharacterEnd(str, char) {
  let end = str.length;
  while (end > 0 && str[end - 1] === char) {
    --end;
  }
  return end < str.length ? str.substring(0, end) : str;
}
function unicodeEscape(str) {
  return str.replace(/[\s\S]/g, (c2) => "\\u" + c2.charCodeAt().toString(16).padStart(4, "0"));
}
function mergeDuplicatesPreferLast(items, getKey) {
  const map2 = new Map;
  for (let i = items.length;i-- > 0; ) {
    const item = items[i];
    const key = getKey(item);
    map2.set(key, map2.has(key) ? import_deepmerge.default(item, map2.get(key), { arrayMerge: overwriteMerge$1 }) : item);
  }
  return [...map2.values()].reverse();
}
function get(obj, path) {
  for (const key of path) {
    if (!obj) {
      return;
    }
    obj = obj[key];
  }
  return obj;
}
function numberToLetterSequence(num, baseChar = "a", base = 26) {
  const digits = [];
  do {
    num -= 1;
    digits.push(num % base);
    num = num / base >> 0;
  } while (num > 0);
  const baseCode = baseChar.charCodeAt(0);
  return digits.reverse().map((n2) => String.fromCharCode(baseCode + n2)).join("");
}
function numberToRoman(num) {
  return [...num + ""].map((n2) => +n2).reverse().map((v3, i) => v3 % 5 < 4 ? (v3 < 5 ? "" : V3[i]) + I2[i].repeat(v3 % 5) : I2[i] + (v3 < 5 ? V3[i] : I2[i + 1])).reverse().join("");
}
function charactersToCodes(str) {
  return [...str].map((c2) => "\\u" + c2.charCodeAt(0).toString(16).padStart(4, "0")).join("");
}
function getText(stackItem) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can be requested for text contents.");
  }
  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();
}
function addText(stackItem, text2, leadingLineBreaks, trailingLineBreaks) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can contain text.");
  }
  const parentText = getText(stackItem);
  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);
  stackItem.inlineTextBuilder.clear();
  if (parentText) {
    stackItem.rawText = parentText + "\n".repeat(lineBreaks) + text2;
  } else {
    stackItem.rawText = text2;
    stackItem.leadingLineBreaks = lineBreaks;
  }
  stackItem.stashedLineBreaks = trailingLineBreaks;
}
function applyTransformer(str, transformer) {
  return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;
}
function compile$1(options = {}) {
  const selectorsWithoutFormat = options.selectors.filter((s2) => !s2.format);
  if (selectorsWithoutFormat.length) {
    throw new Error("Following selectors have no specified format: " + selectorsWithoutFormat.map((s2) => `\`${s2.selector}\``).join(", "));
  }
  const picker = new DecisionTree(options.selectors.map((s2) => [s2.selector, s2])).build(hp2Builder);
  if (typeof options.encodeCharacters !== "function") {
    options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);
  }
  const baseSelectorsPicker = new DecisionTree(options.baseElements.selectors.map((s2, i) => [s2, i + 1])).build(hp2Builder);
  function findBaseElements(dom) {
    return findBases(dom, options, baseSelectorsPicker);
  }
  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk, function(dom, builder) {
    builder.addInline(options.limits.ellipsis || "");
  });
  return function(html, metadata = undefined) {
    return process2(html, metadata, options, picker, findBaseElements, limitedWalk);
  };
}
function process2(html, metadata, options, picker, findBaseElements, walk) {
  const maxInputLength = options.limits.maxInputLength;
  if (maxInputLength && html && html.length > maxInputLength) {
    console.warn(`Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`);
    html = html.substring(0, maxInputLength);
  }
  const document = parseDocument(html, { decodeEntities: options.decodeEntities });
  const bases = findBaseElements(document.children);
  const builder = new BlockTextBuilder(options, picker, metadata);
  walk(bases, builder);
  return builder.toString();
}
function findBases(dom, options, baseSelectorsPicker) {
  const results = [];
  function recursiveWalk(walk, dom2) {
    dom2 = dom2.slice(0, options.limits.maxChildNodes);
    for (const elem of dom2) {
      if (elem.type !== "tag") {
        continue;
      }
      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
      if (pickedSelectorIndex > 0) {
        results.push({ selectorIndex: pickedSelectorIndex, element: elem });
      } else if (elem.children) {
        walk(elem.children);
      }
      if (results.length >= options.limits.maxBaseElements) {
        return;
      }
    }
  }
  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk);
  limitedWalk(dom);
  if (options.baseElements.orderBy !== "occurrence") {
    results.sort((a, b4) => a.selectorIndex - b4.selectorIndex);
  }
  return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map((x) => x.element);
}
function recursiveWalk(walk, dom, builder) {
  if (!dom) {
    return;
  }
  const options = builder.options;
  const tooManyChildNodes = dom.length > options.limits.maxChildNodes;
  if (tooManyChildNodes) {
    dom = dom.slice(0, options.limits.maxChildNodes);
    dom.push({
      data: options.limits.ellipsis,
      type: "text"
    });
  }
  for (const elem of dom) {
    switch (elem.type) {
      case "text": {
        builder.addInline(elem.data);
        break;
      }
      case "tag": {
        const tagDefinition = builder.picker.pick1(elem);
        const format = options.formatters[tagDefinition.format];
        format(elem, walk, builder, tagDefinition.options || {});
        break;
      }
    }
  }
  return;
}
function makeReplacerFromDict(dict) {
  if (!dict || Object.keys(dict).length === 0) {
    return;
  }
  const entries = Object.entries(dict).filter(([, v3]) => v3 !== false);
  const regex = new RegExp(entries.map(([c2]) => `(${unicodeEscape([...c2][0])})`).join("|"), "g");
  const values2 = entries.map(([, v3]) => v3);
  const replacer = (m, ...cgs) => values2[cgs.findIndex((cg) => cg)];
  return (str) => str.replace(regex, replacer);
}
function formatSkip(elem, walk, builder, formatOptions) {
}
function formatInlineString(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.string || "");
}
function formatBlockString(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addLiteral(formatOptions.string || "");
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInline(elem, walk, builder, formatOptions) {
  walk(elem.children, builder);
}
function formatBlock$1(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function renderOpenTag(elem) {
  const attrs = elem.attribs && elem.attribs.length ? " " + Object.entries(elem.attribs).map(([k3, v3]) => v3 === "" ? k3 : `${k3}=${v3.replace(/"/g, "&quot;")}`).join(" ") : "";
  return `<${elem.name}${attrs}>`;
}
function renderCloseTag(elem) {
  return `</${elem.name}>`;
}
function formatInlineTag(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
}
function formatBlockTag(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineHtml(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(render(elem, { decodeEntities: builder.options.decodeEntities }));
  builder.stopNoWrap();
}
function formatBlockHtml(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(render(elem, { decodeEntities: builder.options.decodeEntities }));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineSurround(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.prefix || "");
  walk(elem.children, builder);
  builder.addLiteral(formatOptions.suffix || "");
}
function getRow(matrix, j3) {
  if (!matrix[j3]) {
    matrix[j3] = [];
  }
  return matrix[j3];
}
function findFirstVacantIndex(row, x = 0) {
  while (row[x]) {
    x++;
  }
  return x;
}
function transposeInPlace(matrix, maxSize) {
  for (let i = 0;i < maxSize; i++) {
    const rowI = getRow(matrix, i);
    for (let j3 = 0;j3 < i; j3++) {
      const rowJ = getRow(matrix, j3);
      if (rowI[j3] || rowJ[i]) {
        const temp = rowI[j3];
        rowI[j3] = rowJ[i];
        rowJ[i] = temp;
      }
    }
  }
}
function putCellIntoLayout(cell, layout, baseRow, baseCol) {
  for (let r2 = 0;r2 < cell.rowspan; r2++) {
    const layoutRow = getRow(layout, baseRow + r2);
    for (let c2 = 0;c2 < cell.colspan; c2++) {
      layoutRow[baseCol + c2] = cell;
    }
  }
}
function getOrInitOffset(offsets, index2) {
  if (offsets[index2] === undefined) {
    offsets[index2] = index2 === 0 ? 0 : 1 + getOrInitOffset(offsets, index2 - 1);
  }
  return offsets[index2];
}
function updateOffset(offsets, base, span, value) {
  offsets[base + span] = Math.max(getOrInitOffset(offsets, base + span), getOrInitOffset(offsets, base) + value);
}
function tableToString(tableRows, rowSpacing, colSpacing) {
  const layout = [];
  let colNumber = 0;
  const rowNumber = tableRows.length;
  const rowOffsets = [0];
  for (let j3 = 0;j3 < rowNumber; j3++) {
    const layoutRow = getRow(layout, j3);
    const cells = tableRows[j3];
    let x = 0;
    for (let i = 0;i < cells.length; i++) {
      const cell = cells[i];
      x = findFirstVacantIndex(layoutRow, x);
      putCellIntoLayout(cell, layout, j3, x);
      x += cell.colspan;
      cell.lines = cell.text.split("\n");
      const cellHeight = cell.lines.length;
      updateOffset(rowOffsets, j3, cell.rowspan, cellHeight + rowSpacing);
    }
    colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;
  }
  transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);
  const outputLines = [];
  const colOffsets = [0];
  for (let x = 0;x < colNumber; x++) {
    let y2 = 0;
    let cell;
    const rowsInThisColumn = Math.min(rowNumber, layout[x].length);
    while (y2 < rowsInThisColumn) {
      cell = layout[x][y2];
      if (cell) {
        if (!cell.rendered) {
          let cellWidth = 0;
          for (let j3 = 0;j3 < cell.lines.length; j3++) {
            const line = cell.lines[j3];
            const lineOffset = rowOffsets[y2] + j3;
            outputLines[lineOffset] = (outputLines[lineOffset] || "").padEnd(colOffsets[x]) + line;
            cellWidth = line.length > cellWidth ? line.length : cellWidth;
          }
          updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);
          cell.rendered = true;
        }
        y2 += cell.rowspan;
      } else {
        const lineOffset = rowOffsets[y2];
        outputLines[lineOffset] = outputLines[lineOffset] || "";
        y2++;
      }
    }
  }
  return outputLines.join("\n");
}
function formatLineBreak(elem, walk, builder, formatOptions) {
  builder.addLineBreak();
}
function formatWbr(elem, walk, builder, formatOptions) {
  builder.addWordBreakOpportunity();
}
function formatHorizontalLine(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addInline("-".repeat(formatOptions.length || builder.options.wordwrap || 40));
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatParagraph(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatPre(elem, walk, builder, formatOptions) {
  builder.openBlock({
    isPre: true,
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2
  });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatHeading(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  if (formatOptions.uppercase !== false) {
    builder.pushWordTransform((str) => str.toUpperCase());
    walk(elem.children, builder);
    builder.popWordTransform();
  } else {
    walk(elem.children, builder);
  }
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatBlockquote(elem, walk, builder, formatOptions) {
  builder.openBlock({
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
    reservedLineLength: 2
  });
  walk(elem.children, builder);
  builder.closeBlock({
    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
    blockTransform: (str) => (formatOptions.trimEmptyLines !== false ? trimCharacter(str, "\n") : str).split("\n").map((line) => "> " + line).join("\n")
  });
}
function withBrackets(str, brackets) {
  if (!brackets) {
    return str;
  }
  const lbr = typeof brackets[0] === "string" ? brackets[0] : "[";
  const rbr = typeof brackets[1] === "string" ? brackets[1] : "]";
  return lbr + str + rbr;
}
function pathRewrite(path, rewriter, baseUrl, metadata, elem) {
  const modifiedPath = typeof rewriter === "function" ? rewriter(path, metadata, elem) : path;
  return modifiedPath[0] === "/" && baseUrl ? trimCharacterEnd(baseUrl, "/") + modifiedPath : modifiedPath;
}
function formatImage(elem, walk, builder, formatOptions) {
  const attribs = elem.attribs || {};
  const alt = attribs.alt ? attribs.alt : "";
  const src = !attribs.src ? "" : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
  const text2 = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + " " + withBrackets(src, formatOptions.linkBrackets);
  builder.addInline(text2, { noWordTransform: true });
}
function formatAnchor(elem, walk, builder, formatOptions) {
  function getHref() {
    if (formatOptions.ignoreHref) {
      return "";
    }
    if (!elem.attribs || !elem.attribs.href) {
      return "";
    }
    let href2 = elem.attribs.href.replace(/^mailto:/, "");
    if (formatOptions.noAnchorUrl && href2[0] === "#") {
      return "";
    }
    href2 = pathRewrite(href2, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
    return href2;
  }
  const href = getHref();
  if (!href) {
    walk(elem.children, builder);
  } else {
    let text2 = "";
    builder.pushWordTransform((str) => {
      if (str) {
        text2 += str;
      }
      return str;
    });
    walk(elem.children, builder);
    builder.popWordTransform();
    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text2;
    if (!hideSameLink) {
      builder.addInline(!text2 ? href : " " + withBrackets(href, formatOptions.linkBrackets), { noWordTransform: true });
    }
  }
}
function formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {
  const isNestedList = get(elem, ["parent", "name"]) === "li";
  let maxPrefixLength = 0;
  const listItems = (elem.children || []).filter((child) => child.type !== "text" || !/^\s*$/.test(child.data)).map(function(child) {
    if (child.name !== "li") {
      return { node: child, prefix: "" };
    }
    const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();
    if (prefix.length > maxPrefixLength) {
      maxPrefixLength = prefix.length;
    }
    return { node: child, prefix };
  });
  if (!listItems.length) {
    return;
  }
  builder.openList({
    interRowLineBreaks: 1,
    leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,
    maxPrefixLength,
    prefixAlign: "left"
  });
  for (const { node: node3, prefix } of listItems) {
    builder.openListItem({ prefix });
    walk([node3], builder);
    builder.closeListItem();
  }
  builder.closeList({ trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2 });
}
function formatUnorderedList(elem, walk, builder, formatOptions) {
  const prefix = formatOptions.itemPrefix || " * ";
  return formatList(elem, walk, builder, formatOptions, () => prefix);
}
function formatOrderedList(elem, walk, builder, formatOptions) {
  let nextIndex = Number(elem.attribs.start || "1");
  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
  const nextPrefixCallback = () => " " + indexFunction(nextIndex++) + ". ";
  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
}
function getOrderedListIndexFunction(olType = "1") {
  switch (olType) {
    case "a":
      return (i) => numberToLetterSequence(i, "a");
    case "A":
      return (i) => numberToLetterSequence(i, "A");
    case "i":
      return (i) => numberToRoman(i).toLowerCase();
    case "I":
      return (i) => numberToRoman(i);
    case "1":
    default:
      return (i) => i.toString();
  }
}
function splitClassesAndIds(selectors) {
  const classes = [];
  const ids = [];
  for (const selector of selectors) {
    if (selector.startsWith(".")) {
      classes.push(selector.substring(1));
    } else if (selector.startsWith("#")) {
      ids.push(selector.substring(1));
    }
  }
  return { classes, ids };
}
function isDataTable(attr, tables) {
  if (tables === true) {
    return true;
  }
  if (!attr) {
    return false;
  }
  const { classes, ids } = splitClassesAndIds(tables);
  const attrClasses = (attr["class"] || "").split(" ");
  const attrIds = (attr["id"] || "").split(" ");
  return attrClasses.some((x) => classes.includes(x)) || attrIds.some((x) => ids.includes(x));
}
function formatTable(elem, walk, builder, formatOptions) {
  return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);
}
function formatBlock(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });
}
function formatDataTable(elem, walk, builder, formatOptions) {
  builder.openTable();
  elem.children.forEach(walkTable);
  builder.closeTable({
    tableToString: (rows) => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),
    leadingLineBreaks: formatOptions.leadingLineBreaks,
    trailingLineBreaks: formatOptions.trailingLineBreaks
  });
  function formatCell(cellNode) {
    const colspan = +get(cellNode, ["attribs", "colspan"]) || 1;
    const rowspan = +get(cellNode, ["attribs", "rowspan"]) || 1;
    builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });
    walk(cellNode.children, builder);
    builder.closeTableCell({ colspan, rowspan });
  }
  function walkTable(elem2) {
    if (elem2.type !== "tag") {
      return;
    }
    const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? (cellNode) => {
      builder.pushWordTransform((str) => str.toUpperCase());
      formatCell(cellNode);
      builder.popWordTransform();
    } : formatCell;
    switch (elem2.name) {
      case "thead":
      case "tbody":
      case "tfoot":
      case "center":
        elem2.children.forEach(walkTable);
        return;
      case "tr": {
        builder.openTableRow();
        for (const childOfTr of elem2.children) {
          if (childOfTr.type !== "tag") {
            continue;
          }
          switch (childOfTr.name) {
            case "th": {
              formatHeaderCell(childOfTr);
              break;
            }
            case "td": {
              formatCell(childOfTr);
              break;
            }
          }
        }
        builder.closeTableRow();
        break;
      }
    }
  }
}
function compile(options = {}) {
  options = import_deepmerge.default(DEFAULT_OPTIONS, options, {
    arrayMerge: overwriteMerge,
    customMerge: (key) => key === "selectors" ? selectorsMerge : undefined
  });
  options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);
  options.selectors = mergeDuplicatesPreferLast(options.selectors, (s2) => s2.selector);
  handleDeprecatedOptions(options);
  return compile$1(options);
}
function convert(html, options = {}, metadata = undefined) {
  return compile(options)(html, metadata);
}
function handleDeprecatedOptions(options) {
  if (options.tags) {
    const tagDefinitions = Object.entries(options.tags).map(([selector, definition]) => ({ ...definition, selector: selector || "*" }));
    options.selectors.push(...tagDefinitions);
    options.selectors = mergeDuplicatesPreferLast(options.selectors, (s2) => s2.selector);
  }
  function set(obj, path, value) {
    const valueKey = path.pop();
    for (const key of path) {
      let nested = obj[key];
      if (!nested) {
        nested = {};
        obj[key] = nested;
      }
      obj = nested;
    }
    obj[valueKey] = value;
  }
  if (options["baseElement"]) {
    const baseElement = options["baseElement"];
    set(options, ["baseElements", "selectors"], Array.isArray(baseElement) ? baseElement : [baseElement]);
  }
  if (options["returnDomByDefault"] !== undefined) {
    set(options, ["baseElements", "returnDomByDefault"], options["returnDomByDefault"]);
  }
  for (const definition of options.selectors) {
    if (definition.format === "anchor" && get(definition, ["options", "noLinkBrackets"])) {
      set(definition, ["options", "linkBrackets"], false);
    }
  }
}
var overwriteMerge$1 = (acc, src, options) => [...src];
var I2 = ["I", "X", "C", "M"];
var V3 = ["V", "L", "D"];

class InlineTextBuilder {
  constructor(options, maxLineLength = undefined) {
    this.lines = [];
    this.nextLineWords = [];
    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;
    this.nextLineAvailableChars = this.maxLineLength;
    this.wrapCharacters = get(options, ["longWordSplit", "wrapCharacters"]) || [];
    this.forceWrapOnLimit = get(options, ["longWordSplit", "forceWrapOnLimit"]) || false;
    this.stashedSpace = false;
    this.wordBreakOpportunity = false;
  }
  pushWord(word, noWrap = false) {
    if (this.nextLineAvailableChars <= 0 && !noWrap) {
      this.startNewLine();
    }
    const isLineStart = this.nextLineWords.length === 0;
    const cost = word.length + (isLineStart ? 0 : 1);
    if (cost <= this.nextLineAvailableChars || noWrap) {
      this.nextLineWords.push(word);
      this.nextLineAvailableChars -= cost;
    } else {
      const [first, ...rest] = this.splitLongWord(word);
      if (!isLineStart) {
        this.startNewLine();
      }
      this.nextLineWords.push(first);
      this.nextLineAvailableChars -= first.length;
      for (const part of rest) {
        this.startNewLine();
        this.nextLineWords.push(part);
        this.nextLineAvailableChars -= part.length;
      }
    }
  }
  popWord() {
    const lastWord = this.nextLineWords.pop();
    if (lastWord !== undefined) {
      const isLineStart = this.nextLineWords.length === 0;
      const cost = lastWord.length + (isLineStart ? 0 : 1);
      this.nextLineAvailableChars += cost;
    }
    return lastWord;
  }
  concatWord(word, noWrap = false) {
    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
      this.pushWord(word, noWrap);
      this.wordBreakOpportunity = false;
    } else {
      const lastWord = this.popWord();
      this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);
    }
  }
  startNewLine(n2 = 1) {
    this.lines.push(this.nextLineWords);
    if (n2 > 1) {
      this.lines.push(...Array.from({ length: n2 - 1 }, () => []));
    }
    this.nextLineWords = [];
    this.nextLineAvailableChars = this.maxLineLength;
  }
  isEmpty() {
    return this.lines.length === 0 && this.nextLineWords.length === 0;
  }
  clear() {
    this.lines.length = 0;
    this.nextLineWords.length = 0;
    this.nextLineAvailableChars = this.maxLineLength;
  }
  toString() {
    return [...this.lines, this.nextLineWords].map((words) => words.join(" ")).join("\n");
  }
  splitLongWord(word) {
    const parts = [];
    let idx = 0;
    while (word.length > this.maxLineLength) {
      const firstLine = word.substring(0, this.maxLineLength);
      const remainingChars = word.substring(this.maxLineLength);
      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);
      if (splitIndex > -1) {
        word = firstLine.substring(splitIndex + 1) + remainingChars;
        parts.push(firstLine.substring(0, splitIndex + 1));
      } else {
        idx++;
        if (idx < this.wrapCharacters.length) {
          word = firstLine + remainingChars;
        } else {
          if (this.forceWrapOnLimit) {
            parts.push(firstLine);
            word = remainingChars;
            if (word.length > this.maxLineLength) {
              continue;
            }
          } else {
            word = firstLine + remainingChars;
          }
          break;
        }
      }
    }
    parts.push(word);
    return parts;
  }
}

class StackItem {
  constructor(next = null) {
    this.next = next;
  }
  getRoot() {
    return this.next ? this.next : this;
  }
}

class BlockStackItem extends StackItem {
  constructor(options, next = null, leadingLineBreaks = 1, maxLineLength = undefined) {
    super(next);
    this.leadingLineBreaks = leadingLineBreaks;
    this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);
    this.rawText = "";
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class ListStackItem extends BlockStackItem {
  constructor(options, next = null, {
    interRowLineBreaks = 1,
    leadingLineBreaks = 2,
    maxLineLength = undefined,
    maxPrefixLength = 0,
    prefixAlign = "left"
  } = {}) {
    super(options, next, leadingLineBreaks, maxLineLength);
    this.maxPrefixLength = maxPrefixLength;
    this.prefixAlign = prefixAlign;
    this.interRowLineBreaks = interRowLineBreaks;
  }
}

class ListItemStackItem extends BlockStackItem {
  constructor(options, next = null, {
    leadingLineBreaks = 1,
    maxLineLength = undefined,
    prefix = ""
  } = {}) {
    super(options, next, leadingLineBreaks, maxLineLength);
    this.prefix = prefix;
  }
}

class TableStackItem extends StackItem {
  constructor(next = null) {
    super(next);
    this.rows = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TableRowStackItem extends StackItem {
  constructor(next = null) {
    super(next);
    this.cells = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TableCellStackItem extends StackItem {
  constructor(options, next = null, maxColumnWidth = undefined) {
    super(next);
    this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);
    this.rawText = "";
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TransformerStackItem extends StackItem {
  constructor(next = null, transform) {
    super(next);
    this.transform = transform;
  }
}

class WhitespaceProcessor {
  constructor(options) {
    this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\n/g, "") : options.whitespaceCharacters;
    const whitespaceCodes = charactersToCodes(this.whitespaceChars);
    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]\$`);
    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*\$`);
    this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, "g");
    this.newlineOrNonNewlineStringRe = new RegExp(`(\\n|[^\\n]+)`, "g");
    if (options.preserveNewlines) {
      const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, "gm");
      this.shrinkWrapAdd = function(text2, inlineTextBuilder, transform = (str) => str, noWrap = false) {
        if (!text2) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordOrNewlineRe.exec(text2);
        if (m) {
          anyMatch = true;
          if (m[0] === "\n") {
            inlineTextBuilder.startNewLine();
          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text2)) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform(m[0]), noWrap);
          }
          while ((m = wordOrNewlineRe.exec(text2)) !== null) {
            if (m[0] === "\n") {
              inlineTextBuilder.startNewLine();
            } else {
              inlineTextBuilder.pushWord(transform(m[0]), noWrap);
            }
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text2);
      };
    } else {
      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, "g");
      this.shrinkWrapAdd = function(text2, inlineTextBuilder, transform = (str) => str, noWrap = false) {
        if (!text2) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordRe.exec(text2);
        if (m) {
          anyMatch = true;
          if (previouslyStashedSpace || this.testLeadingWhitespace(text2)) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform(m[0]), noWrap);
          }
          while ((m = wordRe.exec(text2)) !== null) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text2);
      };
    }
  }
  addLiteral(text2, inlineTextBuilder, noWrap = true) {
    if (!text2) {
      return;
    }
    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
    let anyMatch = false;
    let m = this.newlineOrNonNewlineStringRe.exec(text2);
    if (m) {
      anyMatch = true;
      if (m[0] === "\n") {
        inlineTextBuilder.startNewLine();
      } else if (previouslyStashedSpace) {
        inlineTextBuilder.pushWord(m[0], noWrap);
      } else {
        inlineTextBuilder.concatWord(m[0], noWrap);
      }
      while ((m = this.newlineOrNonNewlineStringRe.exec(text2)) !== null) {
        if (m[0] === "\n") {
          inlineTextBuilder.startNewLine();
        } else {
          inlineTextBuilder.pushWord(m[0], noWrap);
        }
      }
    }
    inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;
  }
  testLeadingWhitespace(text2) {
    return this.leadingWhitespaceRe.test(text2);
  }
  testTrailingWhitespace(text2) {
    return this.trailingWhitespaceRe.test(text2);
  }
  testContainsWords(text2) {
    return !this.allWhitespaceOrEmptyRe.test(text2);
  }
  countNewlinesNoWords(text2) {
    this.newlineOrNonWhitespaceRe.lastIndex = 0;
    let counter = 0;
    let match;
    while ((match = this.newlineOrNonWhitespaceRe.exec(text2)) !== null) {
      if (match[0] === "\n") {
        counter++;
      } else {
        return 0;
      }
    }
    return counter;
  }
}

class BlockTextBuilder {
  constructor(options, picker, metadata = undefined) {
    this.options = options;
    this.picker = picker;
    this.metadata = metadata;
    this.whitespaceProcessor = new WhitespaceProcessor(options);
    this._stackItem = new BlockStackItem(options);
    this._wordTransformer = undefined;
  }
  pushWordTransform(wordTransform) {
    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
  }
  popWordTransform() {
    if (!this._wordTransformer) {
      return;
    }
    const transform = this._wordTransformer.transform;
    this._wordTransformer = this._wordTransformer.next;
    return transform;
  }
  startNoWrap() {
    this._stackItem.isNoWrap = true;
  }
  stopNoWrap() {
    this._stackItem.isNoWrap = false;
  }
  _getCombinedWordTransformer() {
    const wt3 = this._wordTransformer ? (str) => applyTransformer(str, this._wordTransformer) : undefined;
    const ce3 = this.options.encodeCharacters;
    return wt3 ? ce3 ? (str) => ce3(wt3(str)) : wt3 : ce3;
  }
  _popStackItem() {
    const item = this._stackItem;
    this._stackItem = item.next;
    return item;
  }
  addLineBreak() {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += "\n";
    } else {
      this._stackItem.inlineTextBuilder.startNewLine();
    }
  }
  addWordBreakOpportunity() {
    if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {
      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
    }
  }
  addInline(str, { noWordTransform = false } = {}) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (str.length === 0 || this._stackItem.stashedLineBreaks && !this.whitespaceProcessor.testContainsWords(str)) {
      return;
    }
    if (this.options.preserveNewlines) {
      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
      if (newlinesNumber > 0) {
        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
        return;
      }
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, noWordTransform ? undefined : this._getCombinedWordTransformer(), this._stackItem.isNoWrap);
    this._stackItem.stashedLineBreaks = 0;
  }
  addLiteral(str) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (str.length === 0) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.addLiteral(str, this._stackItem.inlineTextBuilder, this._stackItem.isNoWrap);
    this._stackItem.stashedLineBreaks = 0;
  }
  openBlock({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
    this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);
    if (isPre) {
      this._stackItem.isPre = true;
    }
  }
  closeBlock({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {
    const block = this._popStackItem();
    const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);
    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));
  }
  openList({ maxPrefixLength = 0, prefixAlign = "left", interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {
    this._stackItem = new ListStackItem(this.options, this._stackItem, {
      interRowLineBreaks,
      leadingLineBreaks,
      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,
      maxPrefixLength,
      prefixAlign
    });
  }
  openListItem({ prefix = "" } = {}) {
    if (!(this._stackItem instanceof ListStackItem)) {
      throw new Error("Can\'t add a list item to something that is not a list! Check the formatter.");
    }
    const list = this._stackItem;
    const prefixLength = Math.max(prefix.length, list.maxPrefixLength);
    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);
    this._stackItem = new ListItemStackItem(this.options, list, {
      prefix,
      maxLineLength,
      leadingLineBreaks: list.interRowLineBreaks
    });
  }
  closeListItem() {
    const listItem = this._popStackItem();
    const list = listItem.next;
    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);
    const spacing = "\n" + " ".repeat(prefixLength);
    const prefix = list.prefixAlign === "right" ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);
    const text2 = prefix + getText(listItem).replace(/\n/g, spacing);
    addText(list, text2, listItem.leadingLineBreaks, Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks));
  }
  closeList({ trailingLineBreaks = 2 } = {}) {
    const list = this._popStackItem();
    const text2 = getText(list);
    if (text2) {
      addText(this._stackItem, text2, list.leadingLineBreaks, trailingLineBreaks);
    }
  }
  openTable() {
    this._stackItem = new TableStackItem(this._stackItem);
  }
  openTableRow() {
    if (!(this._stackItem instanceof TableStackItem)) {
      throw new Error("Can\'t add a table row to something that is not a table! Check the formatter.");
    }
    this._stackItem = new TableRowStackItem(this._stackItem);
  }
  openTableCell({ maxColumnWidth = undefined } = {}) {
    if (!(this._stackItem instanceof TableRowStackItem)) {
      throw new Error("Can\'t add a table cell to something that is not a table row! Check the formatter.");
    }
    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
  }
  closeTableCell({ colspan = 1, rowspan = 1 } = {}) {
    const cell = this._popStackItem();
    const text2 = trimCharacter(getText(cell), "\n");
    cell.next.cells.push({ colspan, rowspan, text: text2 });
  }
  closeTableRow() {
    const row = this._popStackItem();
    row.next.rows.push(row.cells);
  }
  closeTable({ tableToString: tableToString2, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {
    const table16 = this._popStackItem();
    const output = tableToString2(table16.rows);
    if (output) {
      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
    }
  }
  toString() {
    return getText(this._stackItem.getRoot());
  }
}
var genericFormatters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  block: formatBlock$1,
  blockHtml: formatBlockHtml,
  blockString: formatBlockString,
  blockTag: formatBlockTag,
  inline: formatInline,
  inlineHtml: formatInlineHtml,
  inlineString: formatInlineString,
  inlineSurround: formatInlineSurround,
  inlineTag: formatInlineTag,
  skip: formatSkip
});
var textFormatters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  anchor: formatAnchor,
  blockquote: formatBlockquote,
  dataTable: formatDataTable,
  heading: formatHeading,
  horizontalLine: formatHorizontalLine,
  image: formatImage,
  lineBreak: formatLineBreak,
  orderedList: formatOrderedList,
  paragraph: formatParagraph,
  pre: formatPre,
  table: formatTable,
  unorderedList: formatUnorderedList,
  wbr: formatWbr
});
var DEFAULT_OPTIONS = {
  baseElements: {
    selectors: ["body"],
    orderBy: "selectors",
    returnDomByDefault: true
  },
  decodeEntities: true,
  encodeCharacters: {},
  formatters: {},
  limits: {
    ellipsis: "...",
    maxBaseElements: undefined,
    maxChildNodes: undefined,
    maxDepth: undefined,
    maxInputLength: 1 << 24
  },
  longWordSplit: {
    forceWrapOnLimit: false,
    wrapCharacters: []
  },
  preserveNewlines: false,
  selectors: [
    { selector: "*", format: "inline" },
    {
      selector: "a",
      format: "anchor",
      options: {
        baseUrl: null,
        hideLinkHrefIfSameAsText: false,
        ignoreHref: false,
        linkBrackets: ["[", "]"],
        noAnchorUrl: true
      }
    },
    { selector: "article", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "aside", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "blockquote",
      format: "blockquote",
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }
    },
    { selector: "br", format: "lineBreak" },
    { selector: "div", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "footer", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "form", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "h1", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h2", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h3", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h4", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h5", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h6", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "header", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "hr",
      format: "horizontalLine",
      options: { leadingLineBreaks: 2, length: undefined, trailingLineBreaks: 2 }
    },
    {
      selector: "img",
      format: "image",
      options: { baseUrl: null, linkBrackets: ["[", "]"] }
    },
    { selector: "main", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "nav", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "ol",
      format: "orderedList",
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: "p", format: "paragraph", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: "pre", format: "pre", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: "section", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "table",
      format: "table",
      options: {
        colSpacing: 3,
        leadingLineBreaks: 2,
        maxColumnWidth: 60,
        rowSpacing: 0,
        trailingLineBreaks: 2,
        uppercaseHeaderCells: true
      }
    },
    {
      selector: "ul",
      format: "unorderedList",
      options: { itemPrefix: " * ", leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: "wbr", format: "wbr" }
  ],
  tables: [],
  whitespaceCharacters: ` 	\r
\u200B`,
  wordwrap: 80
};
var concatMerge = (acc, src, options) => [...acc, ...src];
var overwriteMerge = (acc, src, options) => [...src];
var selectorsMerge = (acc, src, options) => acc.some((s2) => typeof s2 === "object") ? concatMerge(acc, src) : overwriteMerge(acc, src);

// node_modules/@react-email/render/dist/node/index.mjs
var jsx_runtime = __toESM(require_jsx_runtime(), 1);
function toPlainText(html2, options) {
  return convert(html2, __spreadValues({
    selectors: plainTextSelectors
  }, options));
}
import {Writable} from "node:stream";
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b4) => {
  for (var prop in b4 || (b4 = {}))
    if (__hasOwnProp2.call(b4, prop))
      __defNormalProp(a, prop, b4[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b4)) {
      if (__propIsEnum.call(b4, prop))
        __defNormalProp(a, prop, b4[prop]);
    }
  return a;
};
var __spreadProps = (a, b4) => __defProps(a, __getOwnPropDescs(b4));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var modifiedHtml = __spreadValues({}, exports_html);
if (modifiedHtml.printers) {
  const previousPrint = modifiedHtml.printers.html.print;
  modifiedHtml.printers.html.print = (path, options, print, args) => {
    const node3 = path.getNode();
    const rawPrintingResult = previousPrint(path, options, print, args);
    if (node3.type === "ieConditionalComment") {
      const printingResult = recursivelyMapDoc(rawPrintingResult, (doc) => {
        if (typeof doc === "object" && doc.type === "line") {
          return doc.soft ? "" : " ";
        }
        return doc;
      });
      return printingResult;
    }
    return rawPrintingResult;
  };
}
var defaults = {
  endOfLine: "lf",
  tabWidth: 2,
  plugins: [modifiedHtml],
  bracketSameLine: true,
  parser: "html"
};
var pretty = (str, options = {}) => {
  return fu(str.replaceAll("\0", ""), __spreadValues(__spreadValues({}, defaults), options));
};
var plainTextSelectors = [
  { selector: "img", format: "skip" },
  { selector: "[data-skip-in-text=true]", format: "skip" },
  {
    selector: "a",
    options: { linkBrackets: false }
  }
];
var decoder = new TextDecoder("utf-8");
var readStream = (stream2) => __async(undefined, null, function* () {
  let result2 = "";
  if ("pipeTo" in stream2) {
    const writableStream = new WritableStream({
      write(chunk) {
        result2 += decoder.decode(chunk);
      }
    });
    yield stream2.pipeTo(writableStream);
  } else {
    const writable = new Writable({
      write(chunk, _encoding, callback) {
        result2 += decoder.decode(chunk);
        callback();
      }
    });
    stream2.pipe(writable);
    yield new Promise((resolve, reject) => {
      writable.on("error", reject);
      writable.on("close", () => {
        resolve();
      });
    });
  }
  return result2;
});
var render2 = (node3, options) => __async(undefined, null, function* () {
  const suspendedElement = /* @__PURE__ */ jsx_runtime.jsx(import_react.Suspense, { children: node3 });
  const reactDOMServer = yield Promise.resolve().then(() => (init_server_node(), exports_server_node)).then((m) => m.default);
  let html2;
  if (Object.hasOwn(reactDOMServer, "renderToReadableStream")) {
    html2 = yield readStream(yield reactDOMServer.renderToReadableStream(suspendedElement, {
      progressiveChunkSize: Number.POSITIVE_INFINITY
    }));
  } else {
    yield new Promise((resolve, reject) => {
      const stream2 = reactDOMServer.renderToPipeableStream(suspendedElement, {
        onAllReady() {
          return __async(this, null, function* () {
            html2 = yield readStream(stream2);
            resolve();
          });
        },
        onError(error) {
          reject(error);
        },
        progressiveChunkSize: Number.POSITIVE_INFINITY
      });
    });
  }
  if (options == null ? undefined : options.plainText) {
    return toPlainText(html2, options.htmlToTextOptions);
  }
  const doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
  const document = `${doctype}${html2.replace(/<!DOCTYPE.*?>/, "")}`;
  if (options == null ? undefined : options.pretty) {
    return pretty(document);
  }
  return document;
});

// node_modules/@react-email/body/dist/index.mjs
var jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var __defProp3 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => (key in obj) ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b4) => {
  for (var prop in b4 || (b4 = {}))
    if (__hasOwnProp3.call(b4, prop))
      __defNormalProp2(a, prop, b4[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b4)) {
      if (__propIsEnum2.call(b4, prop))
        __defNormalProp2(a, prop, b4[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b4) => __defProps2(a, __getOwnPropDescs2(b4));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp3.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Body = (_a3) => {
  var _b = _a3, {
    children,
    style
  } = _b, props = __objRest(_b, [
    "children",
    "style"
  ]);
  return /* @__PURE__ */ jsx_runtime2.jsx("body", __spreadProps2(__spreadValues2({}, props), { style, children }));
};
Body.displayName = "Body";

// node_modules/@react-email/button/dist/index.mjs
var jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
function convertToPx(value) {
  let px = 0;
  if (!value) {
    return px;
  }
  if (typeof value === "number") {
    return value;
  }
  const matches = value.match(/^([\d.]+)(px|em|rem|%)$/);
  if (matches && matches.length === 3) {
    const numValue = parseFloat(matches[1]);
    const unit = matches[2];
    switch (unit) {
      case "px":
        return numValue;
      case "em":
      case "rem":
        px = numValue * 16;
        return px;
      case "%":
        px = numValue / 100 * 600;
        return px;
      default:
        return numValue;
    }
  } else {
    return 0;
  }
}
function parsePadding({
  padding = "",
  paddingTop,
  paddingRight,
  paddingBottom,
  paddingLeft
}) {
  let pt3 = 0;
  let pr3 = 0;
  let pb = 0;
  let pl = 0;
  if (typeof padding === "number") {
    pt3 = padding;
    pr3 = padding;
    pb = padding;
    pl = padding;
  } else {
    const values2 = padding.split(/\s+/);
    switch (values2.length) {
      case 1:
        pt3 = convertToPx(values2[0]);
        pr3 = convertToPx(values2[0]);
        pb = convertToPx(values2[0]);
        pl = convertToPx(values2[0]);
        break;
      case 2:
        pt3 = convertToPx(values2[0]);
        pb = convertToPx(values2[0]);
        pr3 = convertToPx(values2[1]);
        pl = convertToPx(values2[1]);
        break;
      case 3:
        pt3 = convertToPx(values2[0]);
        pr3 = convertToPx(values2[1]);
        pl = convertToPx(values2[1]);
        pb = convertToPx(values2[2]);
        break;
      case 4:
        pt3 = convertToPx(values2[0]);
        pr3 = convertToPx(values2[1]);
        pb = convertToPx(values2[2]);
        pl = convertToPx(values2[3]);
        break;
      default:
        break;
    }
  }
  return {
    pt: paddingTop ? convertToPx(paddingTop) : pt3,
    pr: paddingRight ? convertToPx(paddingRight) : pr3,
    pb: paddingBottom ? convertToPx(paddingBottom) : pb,
    pl: paddingLeft ? convertToPx(paddingLeft) : pl
  };
}
var __defProp4 = Object.defineProperty;
var __defProps3 = Object.defineProperties;
var __getOwnPropDescs3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp3 = (obj, key, value) => (key in obj) ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a, b4) => {
  for (var prop in b4 || (b4 = {}))
    if (__hasOwnProp4.call(b4, prop))
      __defNormalProp3(a, prop, b4[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b4)) {
      if (__propIsEnum3.call(b4, prop))
        __defNormalProp3(a, prop, b4[prop]);
    }
  return a;
};
var __spreadProps3 = (a, b4) => __defProps3(a, __getOwnPropDescs3(b4));
var __objRest2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp4.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum3.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var pxToPt = (px) => typeof px === "number" && !isNaN(Number(px)) ? px * 3 / 4 : null;
var Button = (_a3) => {
  var _b = _a3, {
    children,
    style,
    target = "_blank"
  } = _b, props = __objRest2(_b, [
    "children",
    "style",
    "target"
  ]);
  const { pt: pt3, pr: pr3, pb, pl } = parsePadding({
    padding: style == null ? undefined : style.padding,
    paddingLeft: style == null ? undefined : style.paddingLeft,
    paddingRight: style == null ? undefined : style.paddingRight,
    paddingTop: style == null ? undefined : style.paddingTop,
    paddingBottom: style == null ? undefined : style.paddingBottom
  });
  const y2 = pt3 + pb;
  const textRaise = pxToPt(y2);
  return /* @__PURE__ */ jsx_runtime3.jsxs("a", __spreadProps3(__spreadValues3({}, props), {
    style: buttonStyle(__spreadProps3(__spreadValues3({}, style), { pt: pt3, pr: pr3, pb, pl })),
    target,
    children: [
      /* @__PURE__ */ jsx_runtime3.jsx("span", {
        dangerouslySetInnerHTML: {
          __html: `<!--[if mso]><i style="letter-spacing: ${pl}px;mso-font-width:-100%;mso-text-raise:${textRaise}" hidden>&nbsp;</i><![endif]-->`
        }
      }),
      /* @__PURE__ */ jsx_runtime3.jsx("span", { style: buttonTextStyle(pb), children }),
      /* @__PURE__ */ jsx_runtime3.jsx("span", {
        dangerouslySetInnerHTML: {
          __html: `<!--[if mso]><i style="letter-spacing: ${pr3}px;mso-font-width:-100%" hidden>&nbsp;</i><![endif]-->`
        }
      })
    ]
  }));
};
var buttonStyle = (style) => {
  const _a3 = style || {}, { pt: pt3, pr: pr3, pb, pl } = _a3, rest = __objRest2(_a3, ["pt", "pr", "pb", "pl"]);
  return __spreadProps3(__spreadValues3({}, rest), {
    lineHeight: "100%",
    textDecoration: "none",
    display: "inline-block",
    maxWidth: "100%",
    padding: `${pt3}px ${pr3}px ${pb}px ${pl}px`
  });
};
var buttonTextStyle = (pb) => {
  return {
    maxWidth: "100%",
    display: "inline-block",
    lineHeight: "120%",
    msoPaddingAlt: "0px",
    msoTextRaise: pxToPt(pb || 0)
  };
};

// node_modules/@react-email/container/dist/index.mjs
var jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var __defProp5 = Object.defineProperty;
var __defProps4 = Object.defineProperties;
var __getOwnPropDescs4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols4 = Object.getOwnPropertySymbols;
var __hasOwnProp5 = Object.prototype.hasOwnProperty;
var __propIsEnum4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp4 = (obj, key, value) => (key in obj) ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues4 = (a, b4) => {
  for (var prop in b4 || (b4 = {}))
    if (__hasOwnProp5.call(b4, prop))
      __defNormalProp4(a, prop, b4[prop]);
  if (__getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(b4)) {
      if (__propIsEnum4.call(b4, prop))
        __defNormalProp4(a, prop, b4[prop]);
    }
  return a;
};
var __spreadProps4 = (a, b4) => __defProps4(a, __getOwnPropDescs4(b4));
var __objRest3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp5.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum4.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Container = (_a3) => {
  var _b = _a3, {
    children,
    style
  } = _b, props = __objRest3(_b, [
    "children",
    "style"
  ]);
  return /* @__PURE__ */ jsx_runtime4.jsx("table", __spreadProps4(__spreadValues4({
    align: "center",
    width: "100%"
  }, props), {
    border: 0,
    cellPadding: "0",
    cellSpacing: "0",
    role: "presentation",
    style: __spreadValues4({ maxWidth: "37.5em" }, style),
    children: /* @__PURE__ */ jsx_runtime4.jsx("tbody", { children: /* @__PURE__ */ jsx_runtime4.jsx("tr", { style: { width: "100%" }, children: /* @__PURE__ */ jsx_runtime4.jsx("td", { children }) }) })
  }));
};

// node_modules/@react-email/head/dist/index.mjs
var jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var __defProp6 = Object.defineProperty;
var __defProps5 = Object.defineProperties;
var __getOwnPropDescs5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols5 = Object.getOwnPropertySymbols;
var __hasOwnProp6 = Object.prototype.hasOwnProperty;
var __propIsEnum5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp5 = (obj, key, value) => (key in obj) ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues5 = (a, b4) => {
  for (var prop in b4 || (b4 = {}))
    if (__hasOwnProp6.call(b4, prop))
      __defNormalProp5(a, prop, b4[prop]);
  if (__getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(b4)) {
      if (__propIsEnum5.call(b4, prop))
        __defNormalProp5(a, prop, b4[prop]);
    }
  return a;
};
var __spreadProps5 = (a, b4) => __defProps5(a, __getOwnPropDescs5(b4));
var __objRest4 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp6.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum5.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Head = (_a3) => {
  var _b = _a3, { children } = _b, props = __objRest4(_b, ["children"]);
  return /* @__PURE__ */ jsx_runtime5.jsxs("head", __spreadProps5(__spreadValues5({}, props), { children: [
    /* @__PURE__ */ jsx_runtime5.jsx("meta", { content: "text/html; charset=UTF-8", httpEquiv: "Content-Type" }),
    children
  ] }));
};

// node_modules/@radix-ui/react-slot/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// node_modules/@radix-ui/react-slot/dist/index.mjs
var import_react3 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var import_react2 = __toESM(require_react(), 1);
function $6ed0406888f73fc4$var$setRef(ref, value) {
  if (typeof ref === "function")
    ref(value);
  else if (ref !== null && ref !== undefined)
    ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {
  return (node3) => refs.forEach((ref) => $6ed0406888f73fc4$var$setRef(ref, node3));
}

// node_modules/@radix-ui/react-slot/dist/index.mjs
function $5e63c961fc1ce211$var$isSlottable(child) {
  return /* @__PURE__ */ import_react3.isValidElement(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
}
function $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue)
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      else if (slotPropValue)
        overrideProps[propName] = slotPropValue;
    } else if (propName === "style")
      overrideProps[propName] = {
        ...slotPropValue,
        ...childPropValue
      };
    else if (propName === "className")
      overrideProps[propName] = [
        slotPropValue,
        childPropValue
      ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}
var $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ import_react3.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = import_react3.Children.toArray(children);
  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (import_react3.Children.count(newElement) > 1)
          return import_react3.Children.only(null);
        return /* @__PURE__ */ import_react3.isValidElement(newElement) ? newElement.props.children : null;
      } else
        return child;
    });
    return /* @__PURE__ */ import_react3.createElement($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
      ref: forwardedRef
    }), /* @__PURE__ */ import_react3.isValidElement(newElement) ? /* @__PURE__ */ import_react3.cloneElement(newElement, undefined, newChildren) : null);
  }
  return /* @__PURE__ */ import_react3.createElement($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
    ref: forwardedRef
  }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
var $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ import_react3.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (/* @__PURE__ */ import_react3.isValidElement(children))
    return /* @__PURE__ */ import_react3.cloneElement(children, {
      ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),
      ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref) : children.ref
    });
  return import_react3.Children.count(children) > 1 ? import_react3.Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
var $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {
  return /* @__PURE__ */ import_react3.createElement(import_react3.Fragment, null, children);
};

// node_modules/@react-email/heading/dist/index.mjs
var React = __toESM(require_react(), 1);
var jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var __defProp7 = Object.defineProperty;
var __defProps6 = Object.defineProperties;
var __getOwnPropDescs6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols6 = Object.getOwnPropertySymbols;
var __hasOwnProp7 = Object.prototype.hasOwnProperty;
var __propIsEnum6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp6 = (obj, key, value) => (key in obj) ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues6 = (a, b4) => {
  for (var prop in b4 || (b4 = {}))
    if (__hasOwnProp7.call(b4, prop))
      __defNormalProp6(a, prop, b4[prop]);
  if (__getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(b4)) {
      if (__propIsEnum6.call(b4, prop))
        __defNormalProp6(a, prop, b4[prop]);
    }
  return a;
};
var __spreadProps6 = (a, b4) => __defProps6(a, __getOwnPropDescs6(b4));
var __objRest5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp7.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum6.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var withMargin = (props) => {
  const nonEmptyStyles = [
    withSpace(props.m, ["margin"]),
    withSpace(props.mx, ["marginLeft", "marginRight"]),
    withSpace(props.my, ["marginTop", "marginBottom"]),
    withSpace(props.mt, ["marginTop"]),
    withSpace(props.mr, ["marginRight"]),
    withSpace(props.mb, ["marginBottom"]),
    withSpace(props.ml, ["marginLeft"])
  ].filter((s3) => Object.keys(s3).length);
  const mergedStyles = nonEmptyStyles.reduce((acc, style) => {
    return __spreadValues6(__spreadValues6({}, acc), style);
  }, {});
  return mergedStyles;
};
var withSpace = (value, properties) => {
  return properties.reduce((styles, property) => {
    if (!isNaN(parseFloat(value))) {
      return __spreadProps6(__spreadValues6({}, styles), { [property]: `${value}px` });
    }
    return styles;
  }, {});
};
var Heading = React.forwardRef((_a3, forwardedRef) => {
  var _b = _a3, { as: Tag2 = "h1", children, style, m, mx, my, mt: mt3, mr: mr3, mb, ml } = _b, props = __objRest5(_b, ["as", "children", "style", "m", "mx", "my", "mt", "mr", "mb", "ml"]);
  return /* @__PURE__ */ jsx_runtime6.jsx($5e63c961fc1ce211$export$8c6ed5c666ac1360, __spreadProps6(__spreadValues6({}, props), {
    ref: forwardedRef,
    style: __spreadValues6(__spreadValues6({}, withMargin({ m, mx, my, mt: mt3, mr: mr3, mb, ml })), style),
    children: /* @__PURE__ */ jsx_runtime6.jsx(Tag2, { children })
  }));
});
Heading.displayName = "Heading";

// node_modules/@react-email/hr/dist/index.mjs
var jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var __defProp8 = Object.defineProperty;
var __defProps7 = Object.defineProperties;
var __getOwnPropDescs7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols7 = Object.getOwnPropertySymbols;
var __hasOwnProp8 = Object.prototype.hasOwnProperty;
var __propIsEnum7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp7 = (obj, key, value) => (key in obj) ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues7 = (a, b4) => {
  for (var prop in b4 || (b4 = {}))
    if (__hasOwnProp8.call(b4, prop))
      __defNormalProp7(a, prop, b4[prop]);
  if (__getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(b4)) {
      if (__propIsEnum7.call(b4, prop))
        __defNormalProp7(a, prop, b4[prop]);
    }
  return a;
};
var __spreadProps7 = (a, b4) => __defProps7(a, __getOwnPropDescs7(b4));
var __objRest6 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp8.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum7.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Hr2 = (_a3) => {
  var _b = _a3, { style } = _b, props = __objRest6(_b, ["style"]);
  return /* @__PURE__ */ jsx_runtime7.jsx("hr", __spreadProps7(__spreadValues7({}, props), {
    style: __spreadValues7({
      width: "100%",
      border: "none",
      borderTop: "1px solid #eaeaea"
    }, style)
  }));
};

// node_modules/@react-email/html/dist/index.mjs
var jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var __defProp9 = Object.defineProperty;
var __defProps8 = Object.defineProperties;
var __getOwnPropDescs8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols8 = Object.getOwnPropertySymbols;
var __hasOwnProp9 = Object.prototype.hasOwnProperty;
var __propIsEnum8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp8 = (obj, key, value) => (key in obj) ? __defProp9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues8 = (a, b4) => {
  for (var prop in b4 || (b4 = {}))
    if (__hasOwnProp9.call(b4, prop))
      __defNormalProp8(a, prop, b4[prop]);
  if (__getOwnPropSymbols8)
    for (var prop of __getOwnPropSymbols8(b4)) {
      if (__propIsEnum8.call(b4, prop))
        __defNormalProp8(a, prop, b4[prop]);
    }
  return a;
};
var __spreadProps8 = (a, b4) => __defProps8(a, __getOwnPropDescs8(b4));
var __objRest7 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp9.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols8)
    for (var prop of __getOwnPropSymbols8(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum8.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Html = (_a3) => {
  var _b = _a3, {
    children,
    lang = "en",
    dir = "ltr"
  } = _b, props = __objRest7(_b, [
    "children",
    "lang",
    "dir"
  ]);
  return /* @__PURE__ */ jsx_runtime8.jsx("html", __spreadProps8(__spreadValues8({}, props), { dir, lang, children }));
};

// node_modules/@react-email/link/dist/index.mjs
var jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var __defProp10 = Object.defineProperty;
var __defProps9 = Object.defineProperties;
var __getOwnPropDescs9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols9 = Object.getOwnPropertySymbols;
var __hasOwnProp10 = Object.prototype.hasOwnProperty;
var __propIsEnum9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp9 = (obj, key, value) => (key in obj) ? __defProp10(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues9 = (a, b4) => {
  for (var prop in b4 || (b4 = {}))
    if (__hasOwnProp10.call(b4, prop))
      __defNormalProp9(a, prop, b4[prop]);
  if (__getOwnPropSymbols9)
    for (var prop of __getOwnPropSymbols9(b4)) {
      if (__propIsEnum9.call(b4, prop))
        __defNormalProp9(a, prop, b4[prop]);
    }
  return a;
};
var __spreadProps9 = (a, b4) => __defProps9(a, __getOwnPropDescs9(b4));
var __objRest8 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp10.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols9)
    for (var prop of __getOwnPropSymbols9(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum9.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Link = (_a3) => {
  var _b = _a3, {
    target = "_blank",
    style
  } = _b, props = __objRest8(_b, [
    "target",
    "style"
  ]);
  return /* @__PURE__ */ jsx_runtime9.jsx("a", __spreadProps9(__spreadValues9({}, props), {
    style: __spreadValues9({
      color: "#067df7",
      textDecoration: "none"
    }, style),
    target,
    children: props.children
  }));
};

// node_modules/@react-email/preview/dist/index.mjs
var jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var __defProp11 = Object.defineProperty;
var __defProps10 = Object.defineProperties;
var __getOwnPropDescs10 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols10 = Object.getOwnPropertySymbols;
var __hasOwnProp11 = Object.prototype.hasOwnProperty;
var __propIsEnum10 = Object.prototype.propertyIsEnumerable;
var __defNormalProp10 = (obj, key, value) => (key in obj) ? __defProp11(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues10 = (a, b4) => {
  for (var prop in b4 || (b4 = {}))
    if (__hasOwnProp11.call(b4, prop))
      __defNormalProp10(a, prop, b4[prop]);
  if (__getOwnPropSymbols10)
    for (var prop of __getOwnPropSymbols10(b4)) {
      if (__propIsEnum10.call(b4, prop))
        __defNormalProp10(a, prop, b4[prop]);
    }
  return a;
};
var __spreadProps10 = (a, b4) => __defProps10(a, __getOwnPropDescs10(b4));
var __objRest9 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp11.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols10)
    for (var prop of __getOwnPropSymbols10(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum10.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var PREVIEW_MAX_LENGTH = 150;
var Preview = (_a3) => {
  var _b = _a3, {
    children = ""
  } = _b, props = __objRest9(_b, [
    "children"
  ]);
  let text2 = Array.isArray(children) ? children.join("") : children;
  text2 = text2.substr(0, PREVIEW_MAX_LENGTH);
  return /* @__PURE__ */ jsx_runtime10.jsxs("div", __spreadProps10(__spreadValues10({
    style: {
      display: "none",
      overflow: "hidden",
      lineHeight: "1px",
      opacity: 0,
      maxHeight: 0,
      maxWidth: 0
    }
  }, props), {
    children: [
      text2,
      renderWhiteSpace(text2)
    ]
  }));
};
var renderWhiteSpace = (text2) => {
  if (text2.length >= PREVIEW_MAX_LENGTH) {
    return null;
  }
  const whiteSpaceCodes = "\xA0\u200C\u200B\u200D\u200E\u200F\uFEFF";
  return /* @__PURE__ */ jsx_runtime10.jsx("div", { children: whiteSpaceCodes.repeat(PREVIEW_MAX_LENGTH - text2.length) });
};

// node_modules/@react-email/section/dist/index.mjs
var jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var __defProp12 = Object.defineProperty;
var __defProps11 = Object.defineProperties;
var __getOwnPropDescs11 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols11 = Object.getOwnPropertySymbols;
var __hasOwnProp12 = Object.prototype.hasOwnProperty;
var __propIsEnum11 = Object.prototype.propertyIsEnumerable;
var __defNormalProp11 = (obj, key, value) => (key in obj) ? __defProp12(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues11 = (a, b4) => {
  for (var prop in b4 || (b4 = {}))
    if (__hasOwnProp12.call(b4, prop))
      __defNormalProp11(a, prop, b4[prop]);
  if (__getOwnPropSymbols11)
    for (var prop of __getOwnPropSymbols11(b4)) {
      if (__propIsEnum11.call(b4, prop))
        __defNormalProp11(a, prop, b4[prop]);
    }
  return a;
};
var __spreadProps11 = (a, b4) => __defProps11(a, __getOwnPropDescs11(b4));
var __objRest10 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp12.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols11)
    for (var prop of __getOwnPropSymbols11(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum11.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Section = (_a3) => {
  var _b = _a3, {
    children,
    style
  } = _b, props = __objRest10(_b, [
    "children",
    "style"
  ]);
  return /* @__PURE__ */ jsx_runtime11.jsx("table", __spreadProps11(__spreadValues11({
    align: "center",
    width: "100%"
  }, props), {
    border: 0,
    cellPadding: "0",
    cellSpacing: "0",
    role: "presentation",
    style,
    children: /* @__PURE__ */ jsx_runtime11.jsx("tbody", { children: /* @__PURE__ */ jsx_runtime11.jsx("tr", { children: /* @__PURE__ */ jsx_runtime11.jsx("td", { children }) }) })
  }));
};

// node_modules/@react-email/tailwind/dist/index.mjs
var React2 = __toESM(require_react(), 1);
init_server_node();

// node_modules/tw-to-css/dist/index.mjs
function $n3() {
}
function Un3(t9) {
  let e2 = new Set, r2 = new Set, n2 = new Set;
  if (t9.walkAtRules((i) => {
    i.name === "apply" && n2.add(i), i.name === "import" && (i.params === '"tailwindcss/base"' || i.params === "'tailwindcss/base'" ? (i.name = "tailwind", i.params = "base") : i.params === '"tailwindcss/components"' || i.params === "'tailwindcss/components'" ? (i.name = "tailwind", i.params = "components") : i.params === '"tailwindcss/utilities"' || i.params === "'tailwindcss/utilities'" ? (i.name = "tailwind", i.params = "utilities") : (i.params === '"tailwindcss/screens"' || i.params === "'tailwindcss/screens'" || i.params === '"tailwindcss/variants"' || i.params === "'tailwindcss/variants'") && (i.name = "tailwind", i.params = "variants")), i.name === "tailwind" && (i.params === "screens" && (i.params = "variants"), e2.add(i.params)), ["layer", "responsive", "variants"].includes(i.name) && (["responsive", "variants"].includes(i.name) && L3.warn(`${i.name}-at-rule-deprecated`, [`The \`@${i.name}\` directive has been deprecated in Tailwind CSS v3.0.`, "Use `@layer utilities` or `@layer components` instead.", "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"]), r2.add(i));
  }), !e2.has("base") || !e2.has("components") || !e2.has("utilities")) {
    for (let i of r2)
      if (i.name === "layer" && ["base", "components", "utilities"].includes(i.params)) {
        if (!e2.has(i.params))
          throw i.error(`\`@layer ${i.params}\` is used but no matching \`@tailwind ${i.params}\` directive is present.`);
      } else if (i.name === "responsive") {
        if (!e2.has("utilities"))
          throw i.error("`@responsive` is used but `@tailwind utilities` is missing.");
      } else if (i.name === "variants" && !e2.has("utilities"))
        throw i.error("`@variants` is used but `@tailwind utilities` is missing.");
  }
  return { tailwindDirectives: e2, applyDirectives: n2 };
}
function Dp(t9) {
  if (t9 === undefined)
    return false;
  if (t9 === "true" || t9 === "1")
    return true;
  if (t9 === "false" || t9 === "0")
    return false;
  if (t9 === "*")
    return true;
  let e2 = t9.split(",").map((r2) => r2.split(":")[0]);
  return e2.includes("-tailwindcss") ? false : !!e2.includes("tailwindcss");
}
function nt3(t9) {
  return Array.isArray(t9) ? t9.flatMap((e2) => R3([(0, $u2.default)({ bubble: ["screen"] })]).process(e2, { parser: tn3 }).root.nodes) : nt3([t9]);
}
function X3(t9) {
  if (Object.prototype.toString.call(t9) !== "[object Object]")
    return false;
  let e2 = Object.getPrototypeOf(t9);
  return e2 === null || e2 === Object.prototype;
}
function it3(t9, e2, r2 = false) {
  if (t9 === "")
    return e2;
  let n2 = typeof e2 == "string" ? (0, Uu2.default)().astSync(e2) : e2;
  return n2.walkClasses((i) => {
    let a = i.value, s3 = r2 && a.startsWith("-");
    i.value = s3 ? `-${t9}${a.slice(1)}` : `${t9}${a}`;
  }), typeof e2 == "string" ? n2.toString() : n2;
}
function Be2(t9) {
  return t9.replace(/\\,/g, "\\2c ");
}
function ir3(t9, { loose: e2 = false } = {}) {
  var a, s3, o2;
  if (typeof t9 != "string")
    return null;
  if (t9 = t9.trim(), t9 === "transparent")
    return { mode: "rgb", color: ["0", "0", "0"], alpha: "0" };
  if (t9 in ks2)
    return { mode: "rgb", color: ks2[t9].map((l3) => l3.toString()) };
  let r2 = t9.replace(A0, (l3, u, f, p, c2) => ["#", u, u, f, f, p, p, c2 ? c2 + c2 : ""].join("")).match(C0);
  if (r2 !== null)
    return { mode: "rgb", color: [parseInt(r2[1], 16), parseInt(r2[2], 16), parseInt(r2[3], 16)].map((l3) => l3.toString()), alpha: r2[4] ? (parseInt(r2[4], 16) / 255).toString() : undefined };
  let n2 = (a = t9.match(_0)) != null ? a : t9.match(T0);
  if (n2 === null)
    return null;
  let i = [n2[2], n2[3], n2[4]].filter(Boolean).map((l3) => l3.toString());
  return i.length === 2 && i[0].startsWith("var(") ? { mode: n2[1], color: [i[0]], alpha: i[1] } : !e2 && i.length !== 3 || i.length < 3 && !i.some((l3) => /^var\(.*?\)$/.test(l3)) ? null : { mode: n2[1], color: i, alpha: (o2 = (s3 = n2[5]) == null ? undefined : s3.toString) == null ? undefined : o2.call(s3) };
}
function Os2({ mode: t9, color: e2, alpha: r2 }) {
  let n2 = r2 !== undefined;
  return t9 === "rgba" || t9 === "hsla" ? `${t9}(${e2.join(", ")}${n2 ? `, ${r2}` : ""})` : `${t9}(${e2.join(" ")}${n2 ? ` / ${r2}` : ""})`;
}
function we3(t9, e2, r2) {
  if (typeof t9 == "function")
    return t9({ opacityValue: e2 });
  let n2 = ir3(t9, { loose: true });
  return n2 === null ? r2 : Os2({ ...n2, alpha: e2 });
}
function Z3({ color: t9, property: e2, variable: r2 }) {
  let n2 = [].concat(e2);
  if (typeof t9 == "function")
    return { [r2]: "1", ...Object.fromEntries(n2.map((a) => [a, t9({ opacityVariable: r2, opacityValue: `var(${r2})` })])) };
  let i = ir3(t9);
  return i === null ? Object.fromEntries(n2.map((a) => [a, t9])) : i.alpha !== undefined ? Object.fromEntries(n2.map((a) => [a, t9])) : { [r2]: "1", ...Object.fromEntries(n2.map((a) => [a, Os2({ ...i, alpha: `var(${r2})` })])) };
}
function ee3(t9, e2) {
  let r2 = [], n2 = [], i = 0, a = false;
  for (let s3 = 0;s3 < t9.length; s3++) {
    let o2 = t9[s3];
    r2.length === 0 && o2 === e2[0] && !a && (e2.length === 1 || t9.slice(s3, s3 + e2.length) === e2) && (n2.push(t9.slice(i, s3)), i = s3 + e2.length), a ? a = false : o2 === "\\" && (a = true), o2 === "(" || o2 === "[" || o2 === "{" ? r2.push(o2) : (o2 === ")" && r2[r2.length - 1] === "(" || o2 === "]" && r2[r2.length - 1] === "[" || o2 === "}" && r2[r2.length - 1] === "{") && r2.pop();
  }
  return n2.push(t9.slice(i)), n2;
}
function nn2(t9) {
  return ee3(t9, ",").map((r2) => {
    let n2 = r2.trim(), i = { raw: n2 }, a = n2.split(I0), s3 = new Set;
    for (let o2 of a)
      zu2.lastIndex = 0, !s3.has("KEYWORD") && P0.has(o2) ? (i.keyword = o2, s3.add("KEYWORD")) : zu2.test(o2) ? s3.has("X") ? s3.has("Y") ? s3.has("BLUR") ? s3.has("SPREAD") || (i.spread = o2, s3.add("SPREAD")) : (i.blur = o2, s3.add("BLUR")) : (i.y = o2, s3.add("Y")) : (i.x = o2, s3.add("X")) : i.color ? (i.unknown || (i.unknown = []), i.unknown.push(o2)) : i.color = o2;
    return i.valid = i.x !== undefined && i.y !== undefined, i;
  });
}
function Vu2(t9) {
  return t9.map((e2) => e2.valid ? [e2.keyword, e2.x, e2.y, e2.blur, e2.spread, e2.color].filter(Boolean).join(" ") : e2.raw).join(", ");
}
function Es2(t9) {
  return R0.some((e2) => new RegExp(`^${e2}\\(.*\\)`).test(t9));
}
function z4(t9, e2 = true) {
  return t9.startsWith("--") ? `var(${t9})` : t9.includes("url(") ? t9.split(/(url\(.*?\))/g).filter(Boolean).map((r2) => /^url\(.*?\)$/.test(r2) ? r2 : z4(r2, false)).join("") : (t9 = t9.replace(/([^\\])_+/g, (r2, n2) => n2 + " ".repeat(r2.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_"), e2 && (t9 = t9.trim()), t9 = t9.replace(/(calc|min|max|clamp)\(.+\)/g, (r2) => {
    let n2 = [];
    return r2.replace(/var\((--.+?)[,)]/g, (i, a) => (n2.push(a), i.replace(a, Wu2))).replace(/(-?\d*\.?\d(?!\b-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(D0, () => n2.shift());
  }), t9);
}
function Cs2(t9) {
  return t9.startsWith("url(");
}
function As2(t9) {
  return !isNaN(Number(t9)) || Es2(t9);
}
function sr3(t9) {
  return t9.endsWith("%") && As2(t9.slice(0, -1)) || Es2(t9);
}
function ar3(t9) {
  return t9 === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${F0}\$`).test(t9) || Es2(t9);
}
function Bu2(t9) {
  return L0.has(t9);
}
function Gu2(t9) {
  let e2 = nn2(z4(t9));
  for (let r2 of e2)
    if (!r2.valid)
      return false;
  return true;
}
function Yu2(t9) {
  let e2 = 0;
  return ee3(t9, "_").every((n2) => (n2 = z4(n2), n2.startsWith("var(") ? true : ir3(n2, { loose: true }) !== null ? (e2++, true) : false)) ? e2 > 0 : false;
}
function Hu2(t9) {
  let e2 = 0;
  return ee3(t9, ",").every((n2) => (n2 = z4(n2), n2.startsWith("var(") ? true : Cs2(n2) || q0(n2) || ["element(", "image(", "cross-fade(", "image-set("].some((i) => n2.startsWith(i)) ? (e2++, true) : false)) ? e2 > 0 : false;
}
function q0(t9) {
  t9 = z4(t9);
  for (let e2 of N0)
    if (t9.startsWith(`${e2}(`))
      return true;
  return false;
}
function Qu2(t9) {
  let e2 = 0;
  return ee3(t9, "_").every((n2) => (n2 = z4(n2), n2.startsWith("var(") ? true : $0.has(n2) || ar3(n2) || sr3(n2) ? (e2++, true) : false)) ? e2 > 0 : false;
}
function Ju2(t9) {
  let e2 = 0;
  return ee3(t9, ",").every((n2) => (n2 = z4(n2), n2.startsWith("var(") ? true : n2.includes(" ") && !/(['"])([^"']+)\1/g.test(n2) || /^\d/g.test(n2) ? false : (e2++, true))) ? e2 > 0 : false;
}
function Xu2(t9) {
  return U0.has(t9);
}
function Ku2(t9) {
  return j0.has(t9);
}
function Zu2(t9) {
  return z0.has(t9);
}
function Re3(t9) {
  if (t9 = `${t9}`, t9 === "0")
    return "0";
  if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(t9))
    return t9.replace(/^[+-]?/, (r2) => r2 === "-" ? "" : "-");
  let e2 = ["var", "calc", "min", "max", "clamp"];
  for (let r2 of e2)
    if (t9.includes(`${r2}(`))
      return `calc(${t9} * -1)`;
}
function ef(t9) {
  let e2 = ["cover", "contain"];
  return ee3(t9, ",").every((r2) => {
    let n2 = ee3(r2, "_").filter(Boolean);
    return n2.length === 1 && e2.includes(n2[0]) ? true : n2.length !== 1 && n2.length !== 2 ? false : n2.every((i) => ar3(i) || sr3(i) || i === "auto");
  });
}
function G3(t9, e2) {
  var r2, n2, i, a, s3, o2;
  return sn2.future.includes(e2) ? t9.future === "all" || ((i = (n2 = (r2 = t9 == null ? undefined : t9.future) == null ? undefined : r2[e2]) != null ? n2 : tf[e2]) != null ? i : false) : sn2.experimental.includes(e2) ? t9.experimental === "all" || ((o2 = (s3 = (a = t9 == null ? undefined : t9.experimental) == null ? undefined : a[e2]) != null ? s3 : tf[e2]) != null ? o2 : false) : false;
}
function nf(t9) {
  if (false) {
  }
}
function af(t9, e2) {
  t9.walkClasses((r2) => {
    r2.value = e2(r2.value), r2.raws && r2.raws.value && (r2.raws.value = Be2(r2.raws.value));
  });
}
function of(t9, e2) {
  if (!De3(t9))
    return;
  let r2 = t9.slice(1, -1);
  if (!!e2(r2))
    return z4(r2);
}
function V0(t9, e2 = {}, r2) {
  let n2 = e2[t9];
  if (n2 !== undefined)
    return Re3(n2);
  if (De3(t9)) {
    let i = of(t9, r2);
    return i === undefined ? undefined : Re3(i);
  }
}
function an2(t9, e2 = {}, { validate: r2 = () => true } = {}) {
  var i;
  let n2 = (i = e2.values) == null ? undefined : i[t9];
  return n2 !== undefined ? n2 : e2.supportsNegativeValues && t9.startsWith("-") ? V0(t9.slice(1), e2.values, r2) : of(t9, r2);
}
function De3(t9) {
  return t9.startsWith("[") && t9.endsWith("]");
}
function lf(t9) {
  let e2 = t9.lastIndexOf("/");
  return e2 === -1 || e2 === t9.length - 1 ? [t9, undefined] : De3(t9) && !t9.includes("]/[") ? [t9, undefined] : [t9.slice(0, e2), t9.slice(e2 + 1)];
}
function st3(t9) {
  if (typeof t9 == "string" && t9.includes("<alpha-value>")) {
    let e2 = t9;
    return ({ opacityValue: r2 = 1 }) => e2.replace("<alpha-value>", r2);
  }
  return t9;
}
function uf(t9) {
  return z4(t9.slice(1, -1));
}
function W0(t9, e2 = {}, { tailwindConfig: r2 = {} } = {}) {
  var a, s3, o2, l3, u, f;
  if (((a = e2.values) == null ? undefined : a[t9]) !== undefined)
    return st3((s3 = e2.values) == null ? undefined : s3[t9]);
  let [n2, i] = lf(t9);
  if (i !== undefined) {
    let p = (l3 = (o2 = e2.values) == null ? undefined : o2[n2]) != null ? l3 : De3(n2) ? n2.slice(1, -1) : undefined;
    return p === undefined ? undefined : (p = st3(p), De3(i) ? we3(p, uf(i)) : ((f = (u = r2.theme) == null ? undefined : u.opacity) == null ? undefined : f[i]) === undefined ? undefined : we3(p, r2.theme.opacity[i]));
  }
  return an2(t9, e2, { validate: Yu2 });
}
function B0(t9, e2 = {}) {
  var r2;
  return (r2 = e2.values) == null ? undefined : r2[t9];
}
function oe2(t9) {
  return (e2, r2) => an2(e2, r2, { validate: t9 });
}
function G0(t9, e2) {
  let r2 = t9.indexOf(e2);
  return r2 === -1 ? [undefined, t9] : [t9.slice(0, r2), t9.slice(r2 + 1)];
}
function Ts2(t9, e2, r2, n2) {
  if (r2.values && e2 in r2.values)
    for (let { type: a } of t9 != null ? t9 : []) {
      let s3 = _s2[a](e2, r2, { tailwindConfig: n2 });
      if (s3 !== undefined)
        return [s3, a, null];
    }
  if (De3(e2)) {
    let a = e2.slice(1, -1), [s3, o2] = G0(a, ":");
    if (!/^[\w-_]+$/g.test(s3))
      o2 = a;
    else if (s3 !== undefined && !sf.includes(s3))
      return [];
    if (o2.length > 0 && sf.includes(s3))
      return [an2(`[${o2}]`, r2), s3, null];
  }
  let i = Ps2(t9, e2, r2, n2);
  for (let a of i)
    return a;
  return [];
}
function* Ps2(t9, e2, r2, n2) {
  var l3, u;
  let i = G3(n2, "generalizedModifiers"), [a, s3] = lf(e2);
  if (i && r2.modifiers != null && (r2.modifiers === "any" || typeof r2.modifiers == "object" && (s3 && De3(s3) || (s3 in r2.modifiers))) || (a = e2, s3 = undefined), s3 !== undefined && a === "" && (a = "DEFAULT"), s3 !== undefined && typeof r2.modifiers == "object") {
    let f = (u = (l3 = r2.modifiers) == null ? undefined : l3[s3]) != null ? u : null;
    f !== null ? s3 = f : De3(s3) && (s3 = uf(s3));
  }
  for (let { type: f } of t9 != null ? t9 : []) {
    let p = _s2[f](a, r2, { tailwindConfig: n2 });
    p !== undefined && (yield [p, f, s3 != null ? s3 : null]);
  }
}
function re3(t9) {
  var r2, n2;
  let e2 = ff.default.className();
  return e2.value = t9, Be2((n2 = (r2 = e2 == null ? undefined : e2.raws) == null ? undefined : r2.value) != null ? n2 : e2.value);
}
function at3(t9) {
  let [e2] = cf(t9);
  return e2.forEach(([r2, n2]) => r2.removeChild(n2)), t9.nodes.push(...e2.map(([, r2]) => r2)), t9;
}
function cf(t9) {
  var n2;
  let e2 = [], r2 = null;
  for (let i of t9.nodes)
    if (i.type === "combinator")
      e2 = e2.filter(([, a]) => Rs2(a).includes("jumpable")), r2 = null;
    else if (i.type === "pseudo") {
      Y0(i) ? (r2 = i, e2.push([t9, i, null])) : r2 && H0(i, r2) ? e2.push([t9, i, r2]) : r2 = null;
      for (let a of (n2 = i.nodes) != null ? n2 : []) {
        let [s3, o2] = cf(a);
        r2 = o2 || r2, e2.push(...s3);
      }
    }
  return [e2, r2];
}
function pf(t9) {
  return t9.value.startsWith("::") || Is2[t9.value] !== undefined;
}
function Y0(t9) {
  return pf(t9) && Rs2(t9).includes("terminal");
}
function H0(t9, e2) {
  return t9.type !== "pseudo" || pf(t9) ? false : Rs2(e2).includes("actionable");
}
function Rs2(t9) {
  var e2;
  return (e2 = Is2[t9.value]) != null ? e2 : Is2.__default__;
}
function ot3(t9, { context: e2, candidate: r2 }) {
  var s3;
  let n2 = (s3 = e2 == null ? undefined : e2.tailwindConfig.prefix) != null ? s3 : "", i = t9.map((o2) => {
    let l3 = (0, be3.default)().astSync(o2.format);
    return { ...o2, ast: o2.isArbitraryVariant ? l3 : it3(n2, l3) };
  }), a = be3.default.root({ nodes: [be3.default.selector({ nodes: [be3.default.className({ value: re3(r2) })] })] });
  for (let { ast: o2 } of i)
    [a, o2] = J0(a, o2), o2.walkNesting((l3) => l3.replaceWith(...a.nodes[0].nodes)), a = o2;
  return a;
}
function df(t9) {
  let e2 = [];
  for (;t9.prev() && t9.prev().type !== "combinator"; )
    t9 = t9.prev();
  for (;t9 && t9.type !== "combinator"; )
    e2.push(t9), t9 = t9.next();
  return e2;
}
function Q0(t9) {
  return t9.sort((e2, r2) => e2.type === "tag" && r2.type === "class" ? -1 : e2.type === "class" && r2.type === "tag" ? 1 : e2.type === "class" && r2.type === "pseudo" && r2.value.startsWith("::") ? -1 : e2.type === "pseudo" && e2.value.startsWith("::") && r2.type === "class" ? 1 : t9.index(e2) - t9.index(r2)), t9;
}
function Ms2(t9, e2) {
  let r2 = false;
  t9.walk((n2) => {
    if (n2.type === "class" && n2.value === e2)
      return r2 = true, false;
  }), r2 || t9.remove();
}
function on3(t9, e2, { context: r2, candidate: n2, base: i }) {
  var f, p;
  let a = (p = (f = r2 == null ? undefined : r2.tailwindConfig) == null ? undefined : f.separator) != null ? p : ":";
  i = i != null ? i : n2.split(new RegExp(`\\${a}(?![^[]*\\])`)).pop();
  let s3 = (0, be3.default)().astSync(t9);
  s3.walkClasses((c2) => {
    c2.raws && c2.value.includes(i) && (c2.raws.value = re3((0, hf.default)(c2.raws.value)));
  }), s3.each((c2) => Ms2(c2, i));
  let o2 = Array.isArray(e2) ? ot3(e2, { context: r2, candidate: n2 }) : e2;
  if (o2 === null)
    return s3.toString();
  let l3 = be3.default.comment({ value: "/*__simple__*/" }), u = be3.default.comment({ value: "/*__simple__*/" });
  return s3.walkClasses((c2) => {
    if (c2.value !== i)
      return;
    let d2 = c2.parent, h2 = o2.nodes[0].nodes;
    if (d2.nodes.length === 1) {
      c2.replaceWith(...h2);
      return;
    }
    let y2 = df(c2);
    d2.insertBefore(y2[0], l3), d2.insertAfter(y2[y2.length - 1], u);
    for (let g2 of h2)
      d2.insertBefore(y2[0], g2.clone());
    c2.remove(), y2 = df(l3);
    let m = d2.index(l3);
    d2.nodes.splice(m, y2.length, ...Q0(be3.default.selector({ nodes: y2 })).nodes), l3.remove(), u.remove();
  }), s3.walkPseudos((c2) => {
    c2.value === Ds2 && c2.replaceWith(c2.nodes);
  }), s3.each((c2) => at3(c2)), s3.toString();
}
function J0(t9, e2) {
  let r2 = [];
  return t9.walkPseudos((n2) => {
    n2.value === Ds2 && r2.push({ pseudo: n2, value: n2.nodes[0].toString() });
  }), e2.walkPseudos((n2) => {
    if (n2.value !== Ds2)
      return;
    let i = n2.nodes[0].toString(), a = r2.find((u) => u.value === i);
    if (!a)
      return;
    let s3 = [], o2 = n2.next();
    for (;o2 && o2.type !== "combinator"; )
      s3.push(o2), o2 = o2.next();
    let l3 = o2;
    a.pseudo.parent.insertAfter(a.pseudo, be3.default.selector({ nodes: s3.map((u) => u.clone()) })), n2.remove(), s3.forEach((u) => u.remove()), l3 && l3.type === "combinator" && l3.remove();
  }), [t9, e2];
}
function Fs2(t9) {
  return Be2(`.${re3(t9)}`);
}
function ln3(t9, e2) {
  return Fs2(or4(t9, e2));
}
function or4(t9, e2) {
  return e2 === "DEFAULT" ? t9 : e2 === "-" || e2 === "-DEFAULT" ? `-${t9}` : e2.startsWith("-") ? `-${t9}${e2}` : e2.startsWith("/") ? `${t9}${e2}` : `${t9}-${e2}`;
}
function Ce3(t9) {
  return ["fontSize", "outline"].includes(t9) ? (e2) => (typeof e2 == "function" && (e2 = e2({})), Array.isArray(e2) && (e2 = e2[0]), e2) : t9 === "fontFamily" ? (e2) => {
    typeof e2 == "function" && (e2 = e2({}));
    let r2 = Array.isArray(e2) && X3(e2[1]) ? e2[0] : e2;
    return Array.isArray(r2) ? r2.join(", ") : r2;
  } : ["boxShadow", "transitionProperty", "transitionDuration", "transitionDelay", "transitionTimingFunction", "backgroundImage", "backgroundSize", "backgroundColor", "cursor", "animation"].includes(t9) ? (e2) => (typeof e2 == "function" && (e2 = e2({})), Array.isArray(e2) && (e2 = e2.join(", ")), e2) : ["gridTemplateColumns", "gridTemplateRows", "objectPosition"].includes(t9) ? (e2) => (typeof e2 == "function" && (e2 = e2({})), typeof e2 == "string" && (e2 = R3.list.comma(e2).join(" ")), e2) : (e2, r2 = {}) => (typeof e2 == "function" && (e2 = e2(r2)), e2);
}
function T3(t9, e2 = [[t9, [t9]]], { filterDefault: r2 = false, ...n2 } = {}) {
  let i = Ce3(t9);
  return function({ matchUtilities: a, theme: s3 }) {
    var o2;
    for (let l3 of e2) {
      let u = Array.isArray(l3[0]) ? l3 : [l3];
      a(u.reduce((f, [p, c2]) => Object.assign(f, { [p]: (d2) => c2.reduce((h2, y2) => Array.isArray(y2) ? Object.assign(h2, { [y2[0]]: y2[1] }) : Object.assign(h2, { [y2]: i(d2) }), {}) }), {}), { ...n2, values: r2 ? Object.fromEntries(Object.entries((o2 = s3(t9)) != null ? o2 : {}).filter(([f]) => f !== "DEFAULT")) : s3(t9) });
    }
  };
}
function Me3(t9) {
  return t9 = Array.isArray(t9) ? t9 : [t9], t9.map((e2) => {
    let r2 = e2.values.map((n2) => n2.raw !== undefined ? n2.raw : [n2.min && `(min-width: ${n2.min})`, n2.max && `(max-width: ${n2.max})`].filter(Boolean).join(" and "));
    return e2.not ? `not all and ${r2}` : r2;
  }).join(", ");
}
function $s(t9) {
  return t9.split(nv).map((r2) => {
    let n2 = r2.trim(), i = { value: n2 }, a = n2.split(iv), s3 = new Set;
    for (let o2 of a)
      !s3.has("DIRECTIONS") && X0.has(o2) ? (i.direction = o2, s3.add("DIRECTIONS")) : !s3.has("PLAY_STATES") && K0.has(o2) ? (i.playState = o2, s3.add("PLAY_STATES")) : !s3.has("FILL_MODES") && Z0.has(o2) ? (i.fillMode = o2, s3.add("FILL_MODES")) : !s3.has("ITERATION_COUNTS") && (ev.has(o2) || sv.test(o2)) ? (i.iterationCount = o2, s3.add("ITERATION_COUNTS")) : !s3.has("TIMING_FUNCTION") && tv.has(o2) || !s3.has("TIMING_FUNCTION") && rv.some((l3) => o2.startsWith(`${l3}(`)) ? (i.timingFunction = o2, s3.add("TIMING_FUNCTION")) : !s3.has("DURATION") && mf.test(o2) ? (i.duration = o2, s3.add("DURATION")) : !s3.has("DELAY") && mf.test(o2) ? (i.delay = o2, s3.add("DELAY")) : s3.has("NAME") ? (i.unknown || (i.unknown = []), i.unknown.push(o2)) : (i.name = o2, s3.add("NAME"));
    return i;
  });
}
function M2(t9) {
  return typeof t9 == "function" ? t9({}) : t9;
}
function Fe3(t9, e2 = true) {
  return Array.isArray(t9) ? t9.map((r2) => {
    if (e2 && Array.isArray(r2))
      throw new Error("The tuple syntax is not supported for `screens`.");
    if (typeof r2 == "string")
      return { name: r2.toString(), not: false, values: [{ min: r2, max: undefined }] };
    let [n2, i] = r2;
    return n2 = n2.toString(), typeof i == "string" ? { name: n2, not: false, values: [{ min: i, max: undefined }] } : Array.isArray(i) ? { name: n2, not: false, values: i.map((a) => yf(a)) } : { name: n2, not: false, values: [yf(i)] };
  }) : Fe3(Object.entries(t9 != null ? t9 : {}), false);
}
function un3(t9) {
  return t9.values.length !== 1 ? { result: false, reason: "multiple-values" } : t9.values[0].raw !== undefined ? { result: false, reason: "raw-values" } : t9.values[0].min !== undefined && t9.values[0].max !== undefined ? { result: false, reason: "min-and-max" } : { result: true, reason: null };
}
function vf(t9, e2, r2) {
  let n2 = fn3(e2, t9), i = fn3(r2, t9), a = un3(n2), s3 = un3(i);
  if (a.reason === "multiple-values" || s3.reason === "multiple-values")
    throw new Error("Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.");
  if (a.reason === "raw-values" || s3.reason === "raw-values")
    throw new Error("Attempted to sort a screen with raw values. This should never happen. Please open a bug report.");
  if (a.reason === "min-and-max" || s3.reason === "min-and-max")
    throw new Error("Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.");
  let { min: o2, max: l3 } = n2.values[0], { min: u, max: f } = i.values[0];
  e2.not && ([o2, l3] = [l3, o2]), r2.not && ([u, f] = [f, u]), o2 = o2 === undefined ? o2 : parseFloat(o2), l3 = l3 === undefined ? l3 : parseFloat(l3), u = u === undefined ? u : parseFloat(u), f = f === undefined ? f : parseFloat(f);
  let [p, c2] = t9 === "min" ? [o2, u] : [f, l3];
  return p - c2;
}
function fn3(t9, e2) {
  return typeof t9 == "object" ? t9 : { name: "arbitrary-screen", values: [{ [e2]: t9 }] };
}
function yf({ "min-width": t9, min: e2 = t9, max: r2, raw: n2 } = {}) {
  return { min: e2, max: r2, raw: n2 };
}
function cn3(t9, e2) {
  t9.walkDecls((r2) => {
    if (e2.includes(r2.prop)) {
      r2.remove();
      return;
    }
    for (let n2 of e2)
      r2.value.includes(`/ var(${n2})`) && (r2.value = r2.value.replace(`/ var(${n2})`, ""));
  });
}
function Le3(t9) {
  if (Array.isArray(t9))
    return t9;
  let e2 = t9.split("[").length - 1, r2 = t9.split("]").length - 1;
  if (e2 !== r2)
    throw new Error(`Path is invalid. Has unbalanced brackets: ${t9}`);
  return t9.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
}
function lt3(t9) {
  let e2 = [], r2 = false;
  for (let n2 = 0;n2 < t9.length; n2++) {
    let i = t9[n2];
    if (i === ":" && !r2 && e2.length === 0)
      return false;
    if (av.has(i) && t9[n2 - 1] !== "\\" && (r2 = !r2), !r2 && t9[n2 - 1] !== "\\") {
      if (xf.has(i))
        e2.push(i);
      else if (bf.has(i)) {
        let a = bf.get(i);
        if (e2.length <= 0 || e2.pop() !== a)
          return false;
      }
    }
  }
  return !(e2.length > 0);
}
function pn3(t9) {
  return (t9 > 0n) - (t9 < 0n);
}
function Sf(t9, e2) {
  let r2 = 0n, n2 = 0n;
  for (let [i, a] of e2)
    t9 & i && (r2 = r2 | i, n2 = n2 | a);
  return t9 & ~r2 | n2;
}
function kf(t9) {
  let e2 = null;
  for (let r2 of t9)
    e2 = e2 != null ? e2 : r2, e2 = e2 > r2 ? e2 : r2;
  return e2;
}
function ov(t9, e2) {
  let r2 = t9.length, n2 = e2.length, i = r2 < n2 ? r2 : n2;
  for (let a = 0;a < i; a++) {
    let s3 = t9.charCodeAt(a) - e2.charCodeAt(a);
    if (s3 !== 0)
      return s3;
  }
  return r2 - n2;
}
function js2(t9, e2) {
  let r2 = t9.tailwindConfig.prefix;
  return typeof r2 == "function" ? r2(e2) : r2 + e2;
}
function Of({ type: t9 = "any", ...e2 }) {
  let r2 = [].concat(t9);
  return { ...e2, types: r2.map((n2) => Array.isArray(n2) ? { type: n2[0], ...n2[1] } : { type: n2, preferOnConflict: false }) };
}
function lv(t9) {
  let e2 = [], r2 = "", n2 = 0;
  for (let i = 0;i < t9.length; i++) {
    let a = t9[i];
    if (a === "\\")
      r2 += "\\" + t9[++i];
    else if (a === "{")
      ++n2, e2.push(r2.trim()), r2 = "";
    else if (a === "}") {
      if (--n2 < 0)
        throw new Error("Your { and } are unbalanced.");
      e2.push(r2.trim()), r2 = "";
    } else
      r2 += a;
  }
  return r2.length > 0 && e2.push(r2.trim()), e2 = e2.filter((i) => i !== ""), e2;
}
function uv(t9, e2, { before: r2 = [] } = {}) {
  if (r2 = [].concat(r2), r2.length <= 0) {
    t9.push(e2);
    return;
  }
  let n2 = t9.length - 1;
  for (let i of r2) {
    let a = t9.indexOf(i);
    a !== -1 && (n2 = Math.min(n2, a));
  }
  t9.splice(n2, 0, e2);
}
function Af(t9) {
  return Array.isArray(t9) ? t9.flatMap((e2) => !Array.isArray(e2) && !X3(e2) ? e2 : nt3(e2)) : Af([t9]);
}
function Ef(t9, e2) {
  return (0, Vs2.default)((n2) => {
    let i = [];
    return e2 && e2(n2), n2.walkClasses((a) => {
      i.push(a.value);
    }), i;
  }).transformSync(t9);
}
function fv(t9, e2 = { containsNonOnDemandable: false }, r2 = 0) {
  let n2 = [];
  if (t9.type === "rule") {
    let i = function(a) {
      a.walkPseudos((s3) => {
        s3.value === ":not" && s3.remove();
      });
    };
    for (let a of t9.selectors) {
      let s3 = Ef(a, i);
      s3.length === 0 && (e2.containsNonOnDemandable = true);
      for (let o2 of s3)
        n2.push(o2);
    }
  } else
    t9.type === "atrule" && t9.walkRules((i) => {
      for (let a of i.selectors.flatMap((s3) => Ef(s3)))
        n2.push(a);
    });
  return r2 === 0 ? [e2.containsNonOnDemandable || n2.length === 0, n2] : n2;
}
function hn3(t9) {
  return Af(t9).flatMap((e2) => {
    let r2 = new Map, [n2, i] = fv(e2);
    return n2 && i.unshift(ke3), i.map((a) => (r2.has(e2) || r2.set(e2, e2), [a, r2.get(e2)]));
  });
}
function mn3(t9) {
  return t9.startsWith("@") || t9.includes("&");
}
function lr3(t9) {
  t9 = t9.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
  let e2 = lv(t9).map((r2) => {
    if (!r2.startsWith("@"))
      return ({ format: a }) => a(r2);
    let [, n2, i] = /@(.*?)( .+|[({].*)/g.exec(r2);
    return ({ wrap: a }) => a(R3.atRule({ name: n2, params: i.trim() }));
  }).reverse();
  return (r2) => {
    for (let n2 of e2)
      n2(r2);
  };
}
function cv(t9, e2, { variantList: r2, variantMap: n2, offsets: i, classList: a }) {
  function s3(c2, d2) {
    return c2 ? (0, Cf.default)(t9, c2, d2) : t9;
  }
  function o2(c2) {
    return it3(t9.prefix, c2);
  }
  function l3(c2, d2) {
    return c2 === ke3 ? ke3 : d2.respectPrefix ? e2.tailwindConfig.prefix + c2 : c2;
  }
  function u(c2, d2, h2 = {}) {
    let y2 = Le3(c2), m = s3(["theme", ...y2], d2);
    return Ce3(y2[0])(m, h2);
  }
  let f = 0, p = { postcss: R3, prefix: o2, e: re3, config: s3, theme: u, corePlugins: (c2) => Array.isArray(t9.corePlugins) ? t9.corePlugins.includes(c2) : s3(["corePlugins", c2], true), variants: () => [], addBase(c2) {
    for (let [d2, h2] of hn3(c2)) {
      let y2 = l3(d2, {}), m = i.create("base");
      e2.candidateRuleMap.has(y2) || e2.candidateRuleMap.set(y2, []), e2.candidateRuleMap.get(y2).push([{ sort: m, layer: "base" }, h2]);
    }
  }, addDefaults(c2, d2) {
    let h2 = { [`@defaults ${c2}`]: d2 };
    for (let [y2, m] of hn3(h2)) {
      let g2 = l3(y2, {});
      e2.candidateRuleMap.has(g2) || e2.candidateRuleMap.set(g2, []), e2.candidateRuleMap.get(g2).push([{ sort: i.create("defaults"), layer: "defaults" }, m]);
    }
  }, addComponents(c2, d2) {
    d2 = Object.assign({}, { preserveSource: false, respectPrefix: true, respectImportant: false }, Array.isArray(d2) ? {} : d2);
    for (let [y2, m] of hn3(c2)) {
      let g2 = l3(y2, d2);
      a.add(g2), e2.candidateRuleMap.has(g2) || e2.candidateRuleMap.set(g2, []), e2.candidateRuleMap.get(g2).push([{ sort: i.create("components"), layer: "components", options: d2 }, m]);
    }
  }, addUtilities(c2, d2) {
    d2 = Object.assign({}, { preserveSource: false, respectPrefix: true, respectImportant: true }, Array.isArray(d2) ? {} : d2);
    for (let [y2, m] of hn3(c2)) {
      let g2 = l3(y2, d2);
      a.add(g2), e2.candidateRuleMap.has(g2) || e2.candidateRuleMap.set(g2, []), e2.candidateRuleMap.get(g2).push([{ sort: i.create("utilities"), layer: "utilities", options: d2 }, m]);
    }
  }, matchUtilities: function(c2, d2) {
    d2 = Of({ ...{ respectPrefix: true, respectImportant: true, modifiers: false }, ...d2 });
    let y2 = i.create("utilities");
    for (let m in c2) {
      let b4 = function(O3, { isOnlyPlugin: x }) {
        let [A, E2, I3] = Ts2(d2.types, O3, d2, t9);
        if (A === undefined)
          return [];
        if (!d2.types.some(({ type: B3 }) => B3 === E2))
          if (x)
            L3.warn([`Unnecessary typehint \`${E2}\` in \`${m}-${O3}\`.`, `You can safely update it to \`${m}-${O3.replace(E2 + ":", "")}\`.`]);
          else
            return [];
        if (!lt3(A))
          return [];
        let F = { get modifier() {
          return d2.modifiers || L3.warn(`modifier-used-without-options-for-${m}`, ["Your plugin must set `modifiers: true` in its options to support modifiers."]), I3;
        } }, Y3 = G3(t9, "generalizedModifiers");
        return [].concat(Y3 ? w3(A, F) : w3(A)).filter(Boolean).map((B3) => ({ [ln3(m, O3)]: B3 }));
      }, g2 = l3(m, d2), w3 = c2[m];
      a.add([g2, d2]);
      let v3 = [{ sort: y2, layer: "utilities", options: d2 }, b4];
      e2.candidateRuleMap.has(g2) || e2.candidateRuleMap.set(g2, []), e2.candidateRuleMap.get(g2).push(v3);
    }
  }, matchComponents: function(c2, d2) {
    d2 = Of({ ...{ respectPrefix: true, respectImportant: false, modifiers: false }, ...d2 });
    let y2 = i.create("components");
    for (let m in c2) {
      let b4 = function(O3, { isOnlyPlugin: x }) {
        let [A, E2, I3] = Ts2(d2.types, O3, d2, t9);
        if (A === undefined)
          return [];
        if (!d2.types.some(({ type: B3 }) => B3 === E2))
          if (x)
            L3.warn([`Unnecessary typehint \`${E2}\` in \`${m}-${O3}\`.`, `You can safely update it to \`${m}-${O3.replace(E2 + ":", "")}\`.`]);
          else
            return [];
        if (!lt3(A))
          return [];
        let F = { get modifier() {
          return d2.modifiers || L3.warn(`modifier-used-without-options-for-${m}`, ["Your plugin must set `modifiers: true` in its options to support modifiers."]), I3;
        } }, Y3 = G3(t9, "generalizedModifiers");
        return [].concat(Y3 ? w3(A, F) : w3(A)).filter(Boolean).map((B3) => ({ [ln3(m, O3)]: B3 }));
      }, g2 = l3(m, d2), w3 = c2[m];
      a.add([g2, d2]);
      let v3 = [{ sort: y2, layer: "components", options: d2 }, b4];
      e2.candidateRuleMap.has(g2) || e2.candidateRuleMap.set(g2, []), e2.candidateRuleMap.get(g2).push(v3);
    }
  }, addVariant(c2, d2, h2 = {}) {
    d2 = [].concat(d2).map((y2) => {
      if (typeof y2 != "string")
        return (m = {}) => {
          let { args: g2, modifySelectors: w3, container: b4, separator: v3, wrap: O3, format: x } = m, A = y2(Object.assign({ modifySelectors: w3, container: b4, separator: v3 }, h2.type === Us2.MatchVariant && { args: g2, wrap: O3, format: x }));
          if (typeof A == "string" && !mn3(A))
            throw new Error(`Your custom variant \`${c2}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
          return Array.isArray(A) ? A.filter((E2) => typeof E2 == "string").map((E2) => lr3(E2)) : A && typeof A == "string" && lr3(A)(m);
        };
      if (!mn3(y2))
        throw new Error(`Your custom variant \`${c2}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
      return lr3(y2);
    }), uv(r2, c2, h2), n2.set(c2, d2), e2.variantOptions.set(c2, h2);
  }, matchVariant(c2, d2, h2) {
    var b4, v3, O3;
    let y2 = (b4 = h2 == null ? undefined : h2.id) != null ? b4 : ++f, m = c2 === "@", g2 = G3(t9, "generalizedModifiers");
    for (let [x, A] of Object.entries((v3 = h2 == null ? undefined : h2.values) != null ? v3 : {}))
      x !== "DEFAULT" && p.addVariant(m ? `${c2}${x}` : `${c2}-${x}`, ({ args: E2, container: I3 }) => d2(A, g2 ? { modifier: E2 == null ? undefined : E2.modifier, container: I3 } : { container: I3 }), { ...h2, value: A, id: y2, type: Us2.MatchVariant, variantInfo: zs2.Base });
    let w3 = "DEFAULT" in ((O3 = h2 == null ? undefined : h2.values) != null ? O3 : {});
    p.addVariant(c2, ({ args: x, container: A }) => {
      var E2;
      return (x == null ? undefined : x.value) === mt3 && !w3 ? null : d2((x == null ? undefined : x.value) === mt3 ? h2.values.DEFAULT : (E2 = x == null ? undefined : x.value) != null ? E2 : typeof x == "string" ? x : "", g2 ? { modifier: x == null ? undefined : x.modifier, container: A } : { container: A });
    }, { ...h2, id: y2, type: Us2.MatchVariant, variantInfo: zs2.Dynamic });
  } };
  return p;
}
function _f(t9) {
  t9.walkAtRules((e2) => {
    ["responsive", "variants"].includes(e2.name) && (_f(e2), e2.before(e2.nodes), e2.remove());
  });
}
function pv(t9) {
  let e2 = [];
  return t9.each((r2) => {
    r2.type === "atrule" && ["responsive", "variants"].includes(r2.name) && (r2.name = "layer", r2.params = "utilities");
  }), t9.walkAtRules("layer", (r2) => {
    if (_f(r2), r2.params === "base") {
      for (let n2 of r2.nodes)
        e2.push(function({ addBase: i }) {
          i(n2, { respectPrefix: false });
        });
      r2.remove();
    } else if (r2.params === "components") {
      for (let n2 of r2.nodes)
        e2.push(function({ addComponents: i }) {
          i(n2, { respectPrefix: false, preserveSource: true });
        });
      r2.remove();
    } else if (r2.params === "utilities") {
      for (let n2 of r2.nodes)
        e2.push(function({ addUtilities: i }) {
          i(n2, { respectPrefix: false, preserveSource: true });
        });
      r2.remove();
    }
  }), e2;
}
function dv(t9, e2) {
  let r2 = Object.entries({ ...ne4, ...wf }).map(([o2, l3]) => t9.tailwindConfig.corePlugins.includes(o2) ? l3 : null).filter(Boolean), n2 = t9.tailwindConfig.plugins.map((o2) => (o2.__isOptionsFunction && (o2 = o2()), typeof o2 == "function" ? o2 : o2.handler)), i = pv(e2), a = [ne4.pseudoElementVariants, ne4.pseudoClassVariants, ne4.ariaVariants, ne4.dataVariants], s3 = [ne4.supportsVariants, ne4.directionVariants, ne4.reducedMotionVariants, ne4.prefersContrastVariants, ne4.darkVariants, ne4.printVariant, ne4.screenVariants, ne4.orientationVariants];
  return [...r2, ...a, ...n2, ...s3, ...i];
}
function hv(t9, e2) {
  var f, p, c2;
  let r2 = [], n2 = new Map;
  e2.variantMap = n2;
  let i = new dn3;
  e2.offsets = i;
  let a = new Set, s3 = cv(e2.tailwindConfig, e2, { variantList: r2, variantMap: n2, offsets: i, classList: a });
  for (let d2 of t9)
    if (Array.isArray(d2))
      for (let h2 of d2)
        h2(s3);
    else
      d2 == null || d2(s3);
  i.recordVariants(r2, (d2) => n2.get(d2).length);
  for (let [d2, h2] of n2.entries())
    e2.variantMap.set(d2, h2.map((y2, m) => [i.forVariant(d2, m), y2]));
  let o2 = ((f = e2.tailwindConfig.safelist) != null ? f : []).filter(Boolean);
  if (o2.length > 0) {
    let d2 = [];
    for (let h2 of o2) {
      if (typeof h2 == "string") {
        e2.changedContent.push({ content: h2, extension: "html" });
        continue;
      }
      if (h2 instanceof RegExp) {
        L3.warn("root-regex", ["Regular expressions in `safelist` work differently in Tailwind CSS v3.0.", "Update your `safelist` configuration to eliminate this warning.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);
        continue;
      }
      d2.push(h2);
    }
    if (d2.length > 0) {
      let h2 = new Map, y2 = e2.tailwindConfig.prefix.length, m = d2.some((g2) => g2.pattern.source.includes("!"));
      for (let g2 of a) {
        let w3 = Array.isArray(g2) ? (() => {
          var A;
          let [b4, v3] = g2, x = Object.keys((A = v3 == null ? undefined : v3.values) != null ? A : {}).map((E2) => or4(b4, E2));
          return v3 != null && v3.supportsNegativeValues && (x = [...x, ...x.map((E2) => "-" + E2)], x = [...x, ...x.map((E2) => E2.slice(0, y2) + "-" + E2.slice(y2))]), v3.types.some(({ type: E2 }) => E2 === "color") && (x = [...x, ...x.flatMap((E2) => Object.keys(e2.tailwindConfig.theme.opacity).map((I3) => `${E2}/${I3}`))]), m && (v3 == null ? undefined : v3.respectImportant) && (x = [...x, ...x.map((E2) => "!" + E2)]), x;
        })() : [g2];
        for (let b4 of w3)
          for (let { pattern: v3, variants: O3 = [] } of d2)
            if (v3.lastIndex = 0, h2.has(v3) || h2.set(v3, 0), !!v3.test(b4)) {
              h2.set(v3, h2.get(v3) + 1), e2.changedContent.push({ content: b4, extension: "html" });
              for (let x of O3)
                e2.changedContent.push({ content: x + e2.tailwindConfig.separator + b4, extension: "html" });
            }
      }
      for (let [g2, w3] of h2.entries())
        w3 === 0 && L3.warn([`The safelist pattern \`${g2}\` doesn't match any Tailwind CSS classes.`, "Fix this pattern or remove it from your `safelist` configuration.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);
    }
  }
  let l3 = (c2 = [].concat((p = e2.tailwindConfig.darkMode) != null ? p : "media")[1]) != null ? c2 : "dark", u = [js2(e2, l3), js2(e2, "group"), js2(e2, "peer")];
  e2.getClassOrder = function(h2) {
    let y2 = [...h2].sort((b4, v3) => b4 === v3 ? 0 : b4 < v3 ? -1 : 1), m = new Map(y2.map((b4) => [b4, null])), g2 = gn3(new Set(y2), e2);
    g2 = e2.offsets.sort(g2);
    let w3 = BigInt(u.length);
    for (let [, b4] of g2)
      m.set(b4.raws.tailwind.candidate, w3++);
    return h2.map((b4) => {
      var x;
      let v3 = (x = m.get(b4)) != null ? x : null, O3 = u.indexOf(b4);
      return v3 === null && O3 !== -1 && (v3 = BigInt(O3)), [b4, v3];
    });
  }, e2.getClassList = function(h2 = {}) {
    var m, g2, w3, b4;
    let y2 = [];
    for (let v3 of a)
      if (Array.isArray(v3)) {
        let [O3, x] = v3, A = [], E2 = Object.keys((m = x == null ? undefined : x.modifiers) != null ? m : {});
        (g2 = x == null ? undefined : x.types) != null && g2.some(({ type: Y3 }) => Y3 === "color") && E2.push(...Object.keys((w3 = e2.tailwindConfig.theme.opacity) != null ? w3 : {}));
        let I3 = { modifiers: E2 }, F = h2.includeMetadata && E2.length > 0;
        for (let [Y3, K3] of Object.entries((b4 = x == null ? undefined : x.values) != null ? b4 : {})) {
          if (K3 == null)
            continue;
          let B3 = or4(O3, Y3);
          if (y2.push(F ? [B3, I3] : B3), (x == null ? undefined : x.supportsNegativeValues) && Re3(K3)) {
            let qe3 = or4(O3, `-${Y3}`);
            A.push(F ? [qe3, I3] : qe3);
          }
        }
        y2.push(...A);
      } else
        y2.push(v3);
    return y2;
  }, e2.getVariants = function() {
    var y2;
    let h2 = [];
    for (let [m, g2] of e2.variantOptions.entries())
      g2.variantInfo !== zs2.Base && h2.push({ name: m, isArbitrary: g2.type === Symbol.for("MATCH_VARIANT"), values: Object.keys((y2 = g2.values) != null ? y2 : {}), hasDash: m !== "@", selectors({ modifier: w3, value: b4 } = {}) {
        var Ca2, Aa2, _a3, Ta2;
        let v3 = "__TAILWIND_PLACEHOLDER__", O3 = R3.rule({ selector: `.${v3}` }), x = R3.root({ nodes: [O3.clone()] }), A = x.toString(), E2 = ((Ca2 = e2.variantMap.get(m)) != null ? Ca2 : []).flatMap(([ie3, se3]) => se3), I3 = [];
        for (let ie3 of E2) {
          let se3 = [], hr3 = { args: { modifier: w3, value: (_a3 = (Aa2 = g2.values) == null ? undefined : Aa2[b4]) != null ? _a3 : b4 }, separator: e2.tailwindConfig.separator, modifySelectors(pe3) {
            return x.each((qn3) => {
              qn3.type === "rule" && (qn3.selectors = qn3.selectors.map((Pa2) => pe3({ get className() {
                return Ws2(Pa2);
              }, selector: Pa2 })));
            }), x;
          }, format(pe3) {
            se3.push(pe3);
          }, wrap(pe3) {
            se3.push(`@${pe3.name} ${pe3.params} { & }`);
          }, container: x }, mr3 = ie3(hr3);
          if (se3.length > 0 && I3.push(se3), Array.isArray(mr3))
            for (let pe3 of mr3)
              se3 = [], pe3(hr3), I3.push(se3);
        }
        let F = [], Y3 = x.toString();
        A !== Y3 && (x.walkRules((ie3) => {
          let se3 = ie3.selector, hr3 = (0, Vs2.default)((mr3) => {
            mr3.walkClasses((pe3) => {
              pe3.value = `${m}${e2.tailwindConfig.separator}${pe3.value}`;
            });
          }).processSync(se3);
          F.push(se3.replace(hr3, "&").replace(v3, "&"));
        }), x.walkAtRules((ie3) => {
          F.push(`@${ie3.name} (${ie3.params}) { & }`);
        }));
        let K3 = !(b4 in ((Ta2 = g2.values) != null ? Ta2 : {}));
        I3 = I3.map((ie3) => ie3.map((se3) => ({ format: se3, isArbitraryVariant: K3 }))), F = F.map((ie3) => ({ format: ie3, isArbitraryVariant: K3 }));
        let B3 = { candidate: v3, context: e2 }, qe3 = I3.map((ie3) => on3(`.${v3}`, ot3(ie3, B3), B3).replace(`.${v3}`, "&").replace("{ & }", "").trim());
        return F.length > 0 && qe3.push(ot3(F, B3).toString().replace(`.${v3}`, "&")), qe3;
      } });
    return h2;
  };
}
function Tf(t9, e2) {
  !t9.classCache.has(e2) || (t9.notClassCache.add(e2), t9.classCache.delete(e2), t9.applyClassCache.delete(e2), t9.candidateRuleMap.delete(e2), t9.candidateRuleCache.delete(e2), t9.stylesheetCache = null);
}
function mv(t9, e2) {
  let r2 = e2.raws.tailwind.candidate;
  if (!!r2) {
    for (let n2 of t9.ruleCache)
      n2[1].raws.tailwind.candidate === r2 && t9.ruleCache.delete(n2);
    Tf(t9, r2);
  }
}
function Pf(t9, e2 = [], r2 = R3.root()) {
  var a;
  let n2 = { disposables: [], ruleCache: new Set, candidateRuleCache: new Map, classCache: new Map, applyClassCache: new Map, notClassCache: new Set((a = t9.blocklist) != null ? a : []), postCssNodeCache: new Map, candidateRuleMap: new Map, tailwindConfig: t9, changedContent: e2, variantMap: new Map, stylesheetCache: null, variantOptions: new Map, markInvalidUtilityCandidate: (s3) => Tf(n2, s3), markInvalidUtilityNode: (s3) => mv(n2, s3) }, i = dv(n2, r2);
  return hv(i, n2), n2;
}
function yn3(t9, e2) {
  let r2 = (0, Bs2.default)().astSync(t9);
  return r2.each((n2) => {
    n2.nodes[0].type === "pseudo" && n2.nodes[0].value === ":is" && n2.nodes.every((a) => a.type !== "combinator") || (n2.nodes = [Bs2.default.pseudo({ value: ":is", nodes: [n2.clone()] })]), at3(n2);
  }), `${e2} ${r2.toString()}`;
}
function Ws2(t9) {
  return gv.transformSync(t9);
}
function* yv(t9) {
  let e2 = 1 / 0;
  for (;e2 >= 0; ) {
    let r2, n2 = false;
    if (e2 === 1 / 0 && t9.endsWith("]")) {
      let s3 = t9.indexOf("[");
      t9[s3 - 1] === "-" ? r2 = s3 - 1 : t9[s3 - 1] === "/" ? (r2 = s3 - 1, n2 = true) : r2 = -1;
    } else
      e2 === 1 / 0 && t9.includes("/") ? (r2 = t9.lastIndexOf("/"), n2 = true) : r2 = t9.lastIndexOf("-", e2);
    if (r2 < 0)
      break;
    let i = t9.slice(0, r2), a = t9.slice(n2 ? r2 : r2 + 1);
    e2 = r2 - 1, !(i === "" || a === "/") && (yield [i, a]);
  }
}
function vv(t9, e2) {
  if (t9.length === 0 || e2.tailwindConfig.prefix === "")
    return t9;
  for (let r2 of t9) {
    let [n2] = r2;
    if (n2.options.respectPrefix) {
      let i = R3.root({ nodes: [r2[1].clone()] }), a = r2[1].raws.tailwind.classCandidate;
      i.walkRules((s3) => {
        let o2 = a.startsWith("-");
        s3.selector = it3(e2.tailwindConfig.prefix, s3.selector, o2);
      }), r2[1] = i.nodes[0];
    }
  }
  return t9;
}
function wv(t9, e2) {
  if (t9.length === 0)
    return t9;
  let r2 = [];
  for (let [n2, i] of t9) {
    let a = R3.root({ nodes: [i.clone()] });
    a.walkRules((s3) => {
      let o2 = (0, wn3.default)().astSync(s3.selector);
      o2.each((l3) => Ms2(l3, e2)), af(o2, (l3) => l3 === e2 ? `!${l3}` : l3), s3.selector = o2.toString(), s3.walkDecls((l3) => l3.important = true);
    }), r2.push([{ ...n2, important: true }, a.nodes[0]]);
  }
  return r2;
}
function bv(t9, e2, r2) {
  var i;
  if (e2.length === 0)
    return e2;
  let n2 = { modifier: null, value: mt3 };
  {
    let [a, ...s3] = ee3(t9, "/");
    if (s3.length > 1 && (a = a + "/" + s3.slice(0, -1).join("/"), s3 = s3.slice(-1)), s3.length && !r2.variantMap.has(t9) && (t9 = a, n2.modifier = s3[0], !G3(r2.tailwindConfig, "generalizedModifiers")))
      return [];
  }
  if (t9.endsWith("]") && !t9.startsWith("[")) {
    let a = /(.)(-?)\[(.*)\]/g.exec(t9);
    if (a) {
      let [, s3, o2, l3] = a;
      if (s3 === "@" && o2 === "-")
        return [];
      if (s3 !== "@" && o2 === "")
        return [];
      t9 = t9.replace(`${o2}[${l3}]`, ""), n2.value = l3;
    }
  }
  if (Ys2(t9) && !r2.variantMap.has(t9)) {
    let a = r2.offsets.recordVariant(t9), s3 = z4(t9.slice(1, -1)), o2 = ee3(s3, ",");
    if (o2.length > 1)
      return [];
    if (!o2.every(mn3))
      return [];
    let l3 = o2.map((u, f) => [r2.offsets.applyParallelOffset(a, f), lr3(u.trim())]);
    r2.variantMap.set(t9, l3);
  }
  if (r2.variantMap.has(t9)) {
    let a = Ys2(t9), s3 = r2.variantMap.get(t9).slice(), o2 = [];
    for (let [l3, u] of e2) {
      if (l3.layer === "user")
        continue;
      let f = R3.root({ nodes: [u.clone()] });
      for (let [p, c2, d2] of s3) {
        let m = function() {
          h2.raws.neededBackup || (h2.raws.neededBackup = true, h2.walkRules((v3) => v3.raws.originalSelector = v3.selector));
        }, g2 = function(v3) {
          return m(), h2.each((O3) => {
            O3.type === "rule" && (O3.selectors = O3.selectors.map((x) => v3({ get className() {
              return Ws2(x);
            }, selector: x })));
          }), h2;
        }, h2 = (d2 != null ? d2 : f).clone(), y2 = [], w3 = c2({ get container() {
          return m(), h2;
        }, separator: r2.tailwindConfig.separator, modifySelectors: g2, wrap(v3) {
          let O3 = h2.nodes;
          h2.removeAll(), v3.append(O3), h2.append(v3);
        }, format(v3) {
          y2.push({ format: v3, isArbitraryVariant: a });
        }, args: n2 });
        if (Array.isArray(w3)) {
          for (let [v3, O3] of w3.entries())
            s3.push([r2.offsets.applyParallelOffset(p, v3), O3, h2.clone()]);
          continue;
        }
        if (typeof w3 == "string" && y2.push({ format: w3, isArbitraryVariant: a }), w3 === null)
          continue;
        h2.raws.neededBackup && (delete h2.raws.neededBackup, h2.walkRules((v3) => {
          let O3 = v3.raws.originalSelector;
          if (!O3 || (delete v3.raws.originalSelector, O3 === v3.selector))
            return;
          let x = v3.selector, A = (0, wn3.default)((E2) => {
            E2.walkClasses((I3) => {
              I3.value = `${t9}${r2.tailwindConfig.separator}${I3.value}`;
            });
          }).processSync(O3);
          y2.push({ format: x.replace(A, "&"), isArbitraryVariant: a }), v3.selector = O3;
        })), h2.nodes[0].raws.tailwind = { ...h2.nodes[0].raws.tailwind, parentLayer: l3.layer };
        let b4 = [{ ...l3, sort: r2.offsets.applyVariantOffset(l3.sort, p, Object.assign(n2, r2.variantOptions.get(t9))), collectedFormats: ((i = l3.collectedFormats) != null ? i : []).concat(y2) }, h2.nodes[0]];
        o2.push(b4);
      }
    }
    return o2;
  }
  return [];
}
function Gs2(t9, e2, r2 = {}) {
  return !X3(t9) && !Array.isArray(t9) ? [[t9], r2] : Array.isArray(t9) ? Gs2(t9[0], e2, t9[1]) : (e2.has(t9) || e2.set(t9, nt3(t9)), [e2.get(t9), r2]);
}
function Sv(t9) {
  return xv.test(t9);
}
function kv(t9) {
  if (!t9.includes("://"))
    return false;
  try {
    let e2 = new URL(t9);
    return e2.scheme !== "" && e2.host !== "";
  } catch {
    return false;
  }
}
function If(t9) {
  let e2 = true;
  return t9.walkDecls((r2) => {
    if (!Rf(r2.prop, r2.value))
      return e2 = false, false;
  }), e2;
}
function Rf(t9, e2) {
  if (kv(`${t9}:${e2}`))
    return false;
  try {
    return R3.parse(`a{${t9}:${e2}}`).toResult(), true;
  } catch {
    return false;
  }
}
function Ov(t9, e2) {
  var s3;
  let [, r2, n2] = (s3 = t9.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) != null ? s3 : [];
  if (n2 === undefined || !Sv(r2) || !lt3(n2))
    return null;
  let i = z4(n2);
  return Rf(r2, i) ? [[{ sort: e2.offsets.arbitraryProperty(), layer: "utilities" }, () => ({ [Fs2(t9)]: { [r2]: i } })]] : null;
}
function* Ev(t9, e2) {
  e2.candidateRuleMap.has(t9) && (yield [e2.candidateRuleMap.get(t9), "DEFAULT"]), yield* function* (o2) {
    o2 !== null && (yield [o2, "DEFAULT"]);
  }(Ov(t9, e2));
  let r2 = t9, n2 = false, i = e2.tailwindConfig.prefix, a = i.length, s3 = r2.startsWith(i) || r2.startsWith(`-${i}`);
  r2[a] === "-" && s3 && (n2 = true, r2 = i + r2.slice(a + 1)), n2 && e2.candidateRuleMap.has(r2) && (yield [e2.candidateRuleMap.get(r2), "-DEFAULT"]);
  for (let [o2, l3] of yv(r2))
    e2.candidateRuleMap.has(o2) && (yield [e2.candidateRuleMap.get(o2), n2 ? `-${l3}` : l3]);
}
function Cv(t9, e2) {
  return t9 === ke3 ? [ke3] : ee3(t9, e2);
}
function* Av(t9, e2) {
  var r2, n2;
  for (let i of t9)
    i[1].raws.tailwind = { ...i[1].raws.tailwind, classCandidate: e2, preserveSource: (n2 = (r2 = i[0].options) == null ? undefined : r2.preserveSource) != null ? n2 : false }, yield i;
}
function* bn3(t9, e2, r2 = t9) {
  var o2, l3, u, f;
  let n2 = e2.tailwindConfig.separator, [i, ...a] = Cv(t9, n2).reverse(), s3 = false;
  if (i.startsWith("!") && (s3 = true, i = i.slice(1)), G3(e2.tailwindConfig, "variantGrouping") && i.startsWith("(") && i.endsWith(")")) {
    let p = a.slice().reverse().join(n2);
    for (let c2 of ee3(i.slice(1, -1), ","))
      yield* bn3(p + n2 + c2, e2, r2);
  }
  for (let p of Ev(i, e2)) {
    let c2 = [], d2 = new Map, [h2, y2] = p, m = h2.length === 1;
    for (let [g2, w3] of h2) {
      let b4 = [];
      if (typeof w3 == "function")
        for (let v3 of [].concat(w3(y2, { isOnlyPlugin: m }))) {
          let [O3, x] = Gs2(v3, e2.postCssNodeCache);
          for (let A of O3)
            b4.push([{ ...g2, options: { ...g2.options, ...x } }, A]);
        }
      else if (y2 === "DEFAULT" || y2 === "-DEFAULT") {
        let v3 = w3, [O3, x] = Gs2(v3, e2.postCssNodeCache);
        for (let A of O3)
          b4.push([{ ...g2, options: { ...g2.options, ...x } }, A]);
      }
      if (b4.length > 0) {
        let v3 = Array.from(Ps2((l3 = (o2 = g2.options) == null ? undefined : o2.types) != null ? l3 : [], y2, (u = g2.options) != null ? u : {}, e2.tailwindConfig)).map(([O3, x]) => x);
        v3.length > 0 && d2.set(b4, v3), c2.push(b4);
      }
    }
    if (Ys2(y2)) {
      if (c2.length > 1) {
        let b4 = function(O3) {
          return O3.length === 1 ? O3[0] : O3.find((x) => {
            let A = d2.get(x);
            return x.some(([{ options: E2 }, I3]) => If(I3) ? E2.types.some(({ type: F, preferOnConflict: Y3 }) => A.includes(F) && Y3) : false);
          });
        }, [g2, w3] = c2.reduce((O3, x) => (x.some(([{ options: E2 }]) => E2.types.some(({ type: I3 }) => I3 === "any")) ? O3[0].push(x) : O3[1].push(x), O3), [[], []]), v3 = (f = b4(w3)) != null ? f : b4(g2);
        if (v3)
          c2 = [v3];
        else {
          let O3 = c2.map((A) => {
            var E2;
            return new Set([...(E2 = d2.get(A)) != null ? E2 : []]);
          });
          for (let A of O3)
            for (let E2 of A) {
              let I3 = false;
              for (let F of O3)
                A !== F && F.has(E2) && (F.delete(E2), I3 = true);
              I3 && A.delete(E2);
            }
          let x = [];
          for (let [A, E2] of O3.entries())
            for (let I3 of E2) {
              let F = c2[A].map(([, Y3]) => Y3).flat().map((Y3) => Y3.toString().split(`
`).slice(1, -1).map((K3) => K3.trim()).map((K3) => `      ${K3}`).join(`
`)).join(`

`);
              x.push(`  Use \`${t9.replace("[", `[${I3}:`)}\` for \`${F.trim()}\``);
              break;
            }
          L3.warn([`The class \`${t9}\` is ambiguous and matches multiple utilities.`, ...x, `If this is content and not a class, replace it with \`${t9.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`]);
          continue;
        }
      }
      c2 = c2.map((g2) => g2.filter((w3) => If(w3[1])));
    }
    c2 = c2.flat(), c2 = Array.from(Av(c2, i)), c2 = vv(c2, e2), s3 && (c2 = wv(c2, i));
    for (let g2 of a)
      c2 = bv(g2, c2, e2);
    for (let g2 of c2)
      g2[1].raws.tailwind = { ...g2[1].raws.tailwind, candidate: t9 }, g2 = _v(g2, { context: e2, candidate: t9, original: r2 }), g2 !== null && (yield g2);
  }
}
function _v(t9, { context: e2, candidate: r2, original: n2 }) {
  if (!t9[0].collectedFormats)
    return t9;
  let i = true, a;
  try {
    a = ot3(t9[0].collectedFormats, { context: e2, candidate: r2 });
  } catch {
    return null;
  }
  let s3 = R3.root({ nodes: [t9[1].clone()] });
  return s3.walkRules((o2) => {
    if (!vn3(o2))
      try {
        o2.selector = on3(o2.selector, a, { candidate: n2, context: e2 });
      } catch {
        return i = false, false;
      }
  }), i ? (t9[1] = s3.nodes[0], t9) : null;
}
function vn3(t9) {
  return t9.parent && t9.parent.type === "atrule" && t9.parent.name === "keyframes";
}
function Tv(t9) {
  if (t9 === true)
    return (e2) => {
      vn3(e2) || e2.walkDecls((r2) => {
        r2.parent.type === "rule" && !vn3(r2.parent) && (r2.important = true);
      });
    };
  if (typeof t9 == "string")
    return (e2) => {
      vn3(e2) || (e2.selectors = e2.selectors.map((r2) => yn3(r2, t9)));
    };
}
function gn3(t9, e2) {
  var i;
  let r2 = [], n2 = Tv(e2.tailwindConfig.important);
  for (let a of t9) {
    if (e2.notClassCache.has(a))
      continue;
    if (e2.candidateRuleCache.has(a)) {
      r2 = r2.concat(Array.from(e2.candidateRuleCache.get(a)));
      continue;
    }
    let s3 = Array.from(bn3(a, e2));
    if (s3.length === 0) {
      e2.notClassCache.add(a);
      continue;
    }
    e2.classCache.set(a, s3);
    let o2 = (i = e2.candidateRuleCache.get(a)) != null ? i : new Set;
    e2.candidateRuleCache.set(a, o2);
    for (let l3 of s3) {
      let [{ sort: u, options: f }, p] = l3;
      if (f.respectImportant && n2) {
        let d2 = R3.root({ nodes: [p.clone()] });
        d2.walkRules(n2), p = d2.nodes[0];
      }
      let c2 = [u, p];
      o2.add(c2), e2.ruleCache.add(c2), r2.push(c2);
    }
  }
  return r2;
}
function Ys2(t9) {
  return t9.startsWith("[") && t9.endsWith("]");
}
function Ge4(t9, e2 = undefined, r2 = undefined) {
  return t9.map((n2) => {
    var s3;
    let i = n2.clone(), a = ((s3 = n2.raws.tailwind) == null ? undefined : s3.preserveSource) !== true || !i.source;
    return e2 !== undefined && a && (i.source = e2, ("walk" in i) && i.walk((o2) => {
      o2.source = e2;
    })), r2 !== undefined && (i.raws.tailwind = { ...i.raws.tailwind, ...r2 }), i;
  });
}
function xn3(t9) {
  return t9 = Array.isArray(t9) ? t9 : [t9], t9 = t9.map((e2) => e2 instanceof RegExp ? e2.source : e2), t9.join("");
}
function ce3(t9) {
  return new RegExp(xn3(t9), "g");
}
function ut3(t9) {
  return `(?:${t9.map(xn3).join("|")})`;
}
function Hs2(t9) {
  return `(?:${xn3(t9)})?`;
}
function Mf(t9) {
  return `(?:${xn3(t9)})*`;
}
function Ff(t9) {
  return t9 && Pv.test(t9) ? t9.replace(Df, "\\$&") : t9 || "";
}
function Lf(t9) {
  let e2 = Array.from(Rv(t9));
  return (r2) => {
    var i;
    let n2 = [];
    for (let a of e2)
      n2 = [...n2, ...(i = r2.match(a)) != null ? i : []];
    return n2.filter((a) => a !== undefined).map(Fv);
  };
}
function* Rv(t9) {
  let e2 = t9.tailwindConfig.separator, r2 = G3(t9.tailwindConfig, "variantGrouping"), n2 = t9.tailwindConfig.prefix !== "" ? Hs2(ce3([/-?/, Ff(t9.tailwindConfig.prefix)])) : "", i = ut3([/\[[^\s:'"`]+:[^\s\[\]]+\]/, /\[[^\s:'"`]+:[^\s]+?\[[^\s]+\][^\s]+?\]/, ce3([/-?(?:\w+)/, Hs2(ut3([ce3([/-(?:\w+-)*\[[^\s:]+\]/, /(?![{([]])/, /(?:\/[^\s'"`\\><$]*)?/]), ce3([/-(?:\w+-)*\[[^\s]+\]/, /(?![{([]])/, /(?:\/[^\s'"`\\$]*)?/]), /[-\/][^\s'"`\\$={><]*/]))])]), a = [ut3([ce3([/@\[[^\s"'`]+\](\/[^\s"'`]+)?/, e2]), ce3([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/, e2]), ce3([/[^\s"'`\[\\]+/, e2])]), ut3([ce3([/([^\s"'`\[\\]+-)?\[[^\s`]+\]/, e2]), ce3([/[^\s`\[\\]+/, e2])])];
  for (let s3 of a)
    yield ce3(["((?=((", s3, ")+))\\2)?", /!?/, n2, r2 ? ut3([ce3([/\(/, i, Mf([/,/, i]), /\)/]), i]) : i]);
  yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
}
function Fv(t9) {
  if (!t9.includes("-["))
    return t9;
  let e2 = 0, r2 = [], n2 = t9.matchAll(Dv);
  n2 = Array.from(n2).flatMap((i) => {
    let [, ...a] = i;
    return a.map((s3, o2) => Object.assign([], i, { index: i.index + o2, 0: s3 }));
  });
  for (let i of n2) {
    let a = i[0], s3 = r2[r2.length - 1];
    if (a === s3 ? r2.pop() : (a === "'" || a === '"' || a === "`") && r2.push(a), !s3) {
      if (a === "[") {
        e2++;
        continue;
      } else if (a === "]") {
        e2--;
        continue;
      }
      if (e2 < 0)
        return t9.substring(0, i.index - 1);
      if (e2 === 0 && !Mv.test(a))
        return t9.substring(0, i.index);
    }
  }
  return t9;
}
function Lv(t9, e2) {
  let r2 = t9.tailwindConfig.content.extract;
  return r2[e2] || r2.DEFAULT || Nf[e2] || Nf.DEFAULT(t9);
}
function Nv(t9, e2) {
  let r2 = t9.content.transform;
  return r2[e2] || r2.DEFAULT || qf[e2] || qf.DEFAULT;
}
function qv(t9, e2, r2, n2) {
  ur3.has(e2) || ur3.set(e2, new $f.default({ maxSize: 25000 }));
  for (let i of t9.split(`
`))
    if (i = i.trim(), !n2.has(i))
      if (n2.add(i), ur3.get(e2).has(i))
        for (let a of ur3.get(e2).get(i))
          r2.add(a);
      else {
        let a = e2(i).filter((o2) => o2 !== "!*"), s3 = new Set(a);
        for (let o2 of s3)
          r2.add(o2);
        ur3.get(e2).set(i, s3);
      }
}
function $v(t9, e2) {
  let r2 = e2.offsets.sort(t9), n2 = { base: new Set, defaults: new Set, components: new Set, utilities: new Set, variants: new Set };
  for (let [i, a] of r2)
    n2[i.layer].add(a);
  return n2;
}
function Qs(t9) {
  return (e2) => {
    var h2;
    let r2 = { base: null, components: null, utilities: null, variants: null };
    if (e2.walkAtRules((y2) => {
      y2.name === "tailwind" && Object.keys(r2).includes(y2.params) && (r2[y2.params] = y2);
    }), Object.values(r2).every((y2) => y2 === null))
      return e2;
    let n2 = new Set([...(h2 = t9.candidates) != null ? h2 : [], ke3]), i = new Set;
    Ae3.DEBUG && console.time("Reading changed files");
    for (let { file: y2, content: m, extension: g2 } of t9.changedContent) {
      let w3 = Nv(t9.tailwindConfig, g2), b4 = Lv(t9, g2);
      m = y2 ? ht3.readFileSync(y2, "utf8") : m, qv(w3(m), b4, n2, i);
    }
    Ae3.DEBUG && console.timeEnd("Reading changed files");
    let a = t9.classCache.size;
    Ae3.DEBUG && console.time("Generate rules"), Ae3.DEBUG && console.time("Sorting candidates");
    let s3 = new Set([...n2].sort((y2, m) => y2 === m ? 0 : y2 < m ? -1 : 1));
    Ae3.DEBUG && console.timeEnd("Sorting candidates"), gn3(s3, t9), Ae3.DEBUG && console.timeEnd("Generate rules"), Ae3.DEBUG && console.time("Build stylesheet"), (t9.stylesheetCache === null || t9.classCache.size !== a) && (t9.stylesheetCache = $v([...t9.ruleCache], t9)), Ae3.DEBUG && console.timeEnd("Build stylesheet");
    let { defaults: o2, base: l3, components: u, utilities: f, variants: p } = t9.stylesheetCache;
    r2.base && (r2.base.before(Ge4([...l3, ...o2], r2.base.source, { layer: "base" })), r2.base.remove()), r2.components && (r2.components.before(Ge4([...u], r2.components.source, { layer: "components" })), r2.components.remove()), r2.utilities && (r2.utilities.before(Ge4([...f], r2.utilities.source, { layer: "utilities" })), r2.utilities.remove());
    let c2 = Array.from(p).filter((y2) => {
      var g2;
      let m = (g2 = y2.raws.tailwind) == null ? undefined : g2.parentLayer;
      return m === "components" ? r2.components !== null : m === "utilities" ? r2.utilities !== null : true;
    });
    r2.variants ? (r2.variants.before(Ge4(c2, r2.variants.source, { layer: "variants" })), r2.variants.remove()) : c2.length > 0 && e2.append(Ge4(c2, e2.source, { layer: "variants" }));
    let d2 = c2.some((y2) => {
      var m;
      return ((m = y2.raws.tailwind) == null ? undefined : m.parentLayer) === "utilities";
    });
    r2.utilities && f.size === 0 && !d2 && L3.warn("content-problems", ["No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.", "https://tailwindcss.com/docs/content-configuration"]), Ae3.DEBUG && (console.log("Potential classes: ", n2.size), console.log("Active contexts: ", Wn3.size)), t9.changedContent = [], e2.walkAtRules("layer", (y2) => {
      Object.keys(r2).includes(y2.params) && y2.remove();
    });
  };
}
function Sn3(t9) {
  let e2 = new Map;
  R3.root({ nodes: [t9.clone()] }).walkRules((a) => {
    (0, kn3.default)((s3) => {
      s3.walkClasses((o2) => {
        let l3 = o2.parent.toString(), u = e2.get(l3);
        u || e2.set(l3, u = new Set), u.add(o2.value);
      });
    }).processSync(a.selector);
  });
  let n2 = Array.from(e2.values(), (a) => Array.from(a)), i = n2.flat();
  return Object.assign(i, { groups: n2 });
}
function Js(t9) {
  return Uv.astSync(t9);
}
function Uf(t9, e2) {
  let r2 = new Set;
  for (let n2 of t9)
    r2.add(n2.split(e2).pop());
  return Array.from(r2);
}
function jf(t9, e2) {
  let r2 = t9.tailwindConfig.prefix;
  return typeof r2 == "function" ? r2(e2) : r2 + e2;
}
function* Vf(t9) {
  for (yield t9;t9.parent; )
    yield t9.parent, t9 = t9.parent;
}
function jv(t9, e2 = {}) {
  let r2 = t9.nodes;
  t9.nodes = [];
  let n2 = t9.clone(e2);
  return t9.nodes = r2, n2;
}
function zv(t9) {
  for (let e2 of Vf(t9))
    if (t9 !== e2) {
      if (e2.type === "root")
        break;
      t9 = jv(e2, { nodes: [t9] });
    }
  return t9;
}
function Vv(t9, e2) {
  let r2 = new Map;
  return t9.walkRules((n2) => {
    var s3;
    for (let o2 of Vf(n2))
      if (((s3 = o2.raws.tailwind) == null ? undefined : s3.layer) !== undefined)
        return;
    let i = zv(n2), a = e2.offsets.create("user");
    for (let o2 of Sn3(n2)) {
      let l3 = r2.get(o2) || [];
      r2.set(o2, l3), l3.push([{ layer: "user", sort: a, important: false }, i]);
    }
  }), r2;
}
function Wv(t9, e2) {
  for (let r2 of t9) {
    if (e2.notClassCache.has(r2) || e2.applyClassCache.has(r2))
      continue;
    if (e2.classCache.has(r2)) {
      e2.applyClassCache.set(r2, e2.classCache.get(r2).map(([i, a]) => [i, a.clone()]));
      continue;
    }
    let n2 = Array.from(bn3(r2, e2));
    if (n2.length === 0) {
      e2.notClassCache.add(r2);
      continue;
    }
    e2.applyClassCache.set(r2, n2);
  }
  return e2.applyClassCache;
}
function Bv(t9) {
  let e2 = null;
  return { get: (r2) => (e2 = e2 || t9(), e2.get(r2)), has: (r2) => (e2 = e2 || t9(), e2.has(r2)) };
}
function Gv(t9) {
  return { get: (e2) => t9.flatMap((r2) => r2.get(e2) || []), has: (e2) => t9.some((r2) => r2.has(e2)) };
}
function zf(t9) {
  let e2 = t9.split(/[\s\t\n]+/g);
  return e2[e2.length - 1] === "!important" ? [e2.slice(0, -1), true] : [e2, false];
}
function Wf(t9, e2, r2) {
  let n2 = new Set, i = [];
  if (t9.walkAtRules("apply", (l3) => {
    let [u] = zf(l3.params);
    for (let f of u)
      n2.add(f);
    i.push(l3);
  }), i.length === 0)
    return;
  let a = Gv([r2, Wv(n2, e2)]);
  function s3(l3, u, f) {
    let p = Js(l3), c2 = Js(u), h2 = Js(`.${re3(f)}`).nodes[0].nodes[0];
    return p.each((y2) => {
      let m = new Set;
      c2.each((g2) => {
        let w3 = false;
        g2 = g2.clone(), g2.walkClasses((b4) => {
          b4.value === h2.value && (w3 || (b4.replaceWith(...y2.nodes.map((v3) => v3.clone())), m.add(g2), w3 = true));
        });
      });
      for (let g2 of m) {
        let w3 = [[]];
        for (let b4 of g2.nodes)
          b4.type === "combinator" ? (w3.push(b4), w3.push([])) : w3[w3.length - 1].push(b4);
        g2.nodes = [];
        for (let b4 of w3)
          Array.isArray(b4) && b4.sort((v3, O3) => v3.type === "tag" && O3.type === "class" ? -1 : v3.type === "class" && O3.type === "tag" ? 1 : v3.type === "class" && O3.type === "pseudo" && O3.value.startsWith("::") ? -1 : v3.type === "pseudo" && v3.value.startsWith("::") && O3.type === "class" ? 1 : 0), g2.nodes = g2.nodes.concat(b4);
      }
      y2.replaceWith(...m);
    }), p.toString();
  }
  let o2 = new Map;
  for (let l3 of i) {
    let [u] = o2.get(l3.parent) || [[], l3.source];
    o2.set(l3.parent, [u, l3.source]);
    let [f, p] = zf(l3.params);
    if (l3.parent.type === "atrule") {
      if (l3.parent.name === "screen") {
        let c2 = l3.parent.params;
        throw l3.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${f.map((d2) => `${c2}:${d2}`).join(" ")} instead.`);
      }
      throw l3.error(`@apply is not supported within nested at-rules like @${l3.parent.name}. You can fix this by un-nesting @${l3.parent.name}.`);
    }
    for (let c2 of f) {
      if ([jf(e2, "group"), jf(e2, "peer")].includes(c2))
        throw l3.error(`@apply should not be used with the '${c2}' utility`);
      if (!a.has(c2))
        throw l3.error(`The \`${c2}\` class does not exist. If \`${c2}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
      let d2 = a.get(c2);
      u.push([c2, p, d2]);
    }
  }
  for (let [l3, [u, f]] of o2) {
    let p = [];
    for (let [d2, h2, y2] of u) {
      let m = [d2, ...Uf([d2], e2.tailwindConfig.separator)];
      for (let [g2, w3] of y2) {
        let b4 = Sn3(l3), v3 = Sn3(w3);
        if (v3 = v3.groups.filter((E2) => E2.some((I3) => m.includes(I3))).flat(), v3 = v3.concat(Uf(v3, e2.tailwindConfig.separator)), b4.some((E2) => v3.includes(E2)))
          throw w3.error(`You cannot \`@apply\` the \`${d2}\` utility here because it creates a circular dependency.`);
        let x = R3.root({ nodes: [w3.clone()] });
        x.walk((E2) => {
          E2.source = f;
        }), (w3.type !== "atrule" || w3.type === "atrule" && w3.name !== "keyframes") && x.walkRules((E2) => {
          if (!Sn3(E2).some((B3) => B3 === d2)) {
            E2.remove();
            return;
          }
          let I3 = typeof e2.tailwindConfig.important == "string" ? e2.tailwindConfig.important : null, Y3 = l3.raws.tailwind !== undefined && I3 && l3.selector.indexOf(I3) === 0 ? l3.selector.slice(I3.length) : l3.selector;
          E2.selector = s3(Y3, E2.selector, d2), I3 && Y3 !== l3.selector && (E2.selector = yn3(E2.selector, I3)), E2.walkDecls((B3) => {
            B3.important = g2.important || h2;
          });
          let K3 = (0, kn3.default)().astSync(E2.selector);
          K3.each((B3) => at3(B3)), E2.selector = K3.toString();
        }), x.nodes[0] && p.push([g2.sort, x.nodes[0]]);
      }
    }
    let c2 = e2.offsets.sort(p).map((d2) => d2[1]);
    l3.after(c2);
  }
  for (let l3 of i)
    l3.parent.nodes.length > 1 ? l3.remove() : l3.parent.remove();
  Wf(t9, e2, r2);
}
function Xs2(t9) {
  return (e2) => {
    let r2 = Bv(() => Vv(e2, t9));
    Wf(e2, t9, r2);
  };
}
function sa2(t9) {
  return typeof t9 == "object" && t9 !== null;
}
function tw(t9, e2) {
  let r2 = Le3(e2);
  do
    if (r2.pop(), (0, fr3.default)(t9, r2) !== undefined)
      break;
  while (r2.length);
  return r2.length ? r2 : undefined;
}
function ct3(t9) {
  return typeof t9 == "string" ? t9 : t9.reduce((e2, r2, n2) => r2.includes(".") ? `${e2}[${r2}]` : n2 === 0 ? r2 : `${e2}.${r2}`, "");
}
function lc(t9) {
  return t9.map((e2) => `'${e2}'`).join(", ");
}
function ac(t9) {
  return lc(Object.keys(t9));
}
function aa2(t9, e2, r2, n2 = {}) {
  let i = Array.isArray(e2) ? ct3(e2) : e2.replace(/^['"]+|['"]+$/g, ""), a = Array.isArray(e2) ? e2 : Le3(i), s3 = (0, fr3.default)(t9.theme, a, r2);
  if (s3 === undefined) {
    let l3 = `'${i}' does not exist in your theme config.`, u = a.slice(0, -1), f = (0, fr3.default)(t9.theme, u);
    if (sa2(f)) {
      let p = Object.keys(f).filter((d2) => aa2(t9, [...u, d2]).isValid), c2 = (0, oc.default)(a[a.length - 1], p);
      c2 ? l3 += ` Did you mean '${ct3([...u, c2])}'?` : p.length > 0 && (l3 += ` '${ct3(u)}' has the following valid keys: ${lc(p)}`);
    } else {
      let p = tw(t9.theme, i);
      if (p) {
        let c2 = (0, fr3.default)(t9.theme, p);
        sa2(c2) ? l3 += ` '${ct3(p)}' has the following keys: ${ac(c2)}` : l3 += ` '${ct3(p)}' is not an object.`;
      } else
        l3 += ` Your theme has the following top-level keys: ${ac(t9.theme)}`;
    }
    return { isValid: false, error: l3 };
  }
  if (!(typeof s3 == "string" || typeof s3 == "number" || typeof s3 == "function" || s3 instanceof String || s3 instanceof Number || Array.isArray(s3))) {
    let l3 = `'${i}' was found but does not resolve to a string.`;
    if (sa2(s3)) {
      let u = Object.keys(s3).filter((f) => aa2(t9, [...a, f]).isValid);
      u.length && (l3 += ` Did you mean something like '${ct3([...a, u[0]])}'?`);
    }
    return { isValid: false, error: l3 };
  }
  let [o2] = a;
  return { isValid: true, value: Ce3(o2)(s3, n2) };
}
function rw(t9, e2, r2) {
  e2 = e2.map((i) => uc(t9, i, r2));
  let n2 = [""];
  for (let i of e2)
    i.type === "div" && i.value === "," ? n2.push("") : n2[n2.length - 1] += oa2.default.stringify(i);
  return n2;
}
function uc(t9, e2, r2) {
  if (e2.type === "function" && r2[e2.value] !== undefined) {
    let n2 = rw(t9, e2.nodes, r2);
    e2.type = "word", e2.value = r2[e2.value](t9, ...n2);
  }
  return e2;
}
function nw(t9, e2, r2) {
  return (0, oa2.default)(e2).walk((n2) => {
    uc(t9, n2, r2);
  }).toString();
}
function* sw(t9) {
  t9 = t9.replace(/^['"]+|['"]+$/g, "");
  let e2 = t9.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/), r2;
  yield [t9, undefined], e2 && (t9 = e2[1], r2 = e2[2], yield [t9, r2]);
}
function aw(t9, e2, r2) {
  var i;
  let n2 = Array.from(sw(e2)).map(([a, s3]) => Object.assign(aa2(t9, a, r2, { opacityValue: s3 }), { resolvedPath: a, alpha: s3 }));
  return (i = n2.find((a) => a.isValid)) != null ? i : n2[0];
}
function fc(t9) {
  let e2 = t9.tailwindConfig, r2 = { theme: (n2, i, ...a) => {
    var c2;
    let { isValid: s3, value: o2, error: l3, alpha: u } = aw(e2, i, a.length ? a : undefined);
    if (!s3) {
      let d2 = n2.parent, h2 = (c2 = d2 == null ? undefined : d2.raws.tailwind) == null ? undefined : c2.candidate;
      if (d2 && h2 !== undefined) {
        t9.markInvalidUtilityNode(d2), d2.remove(), L3.warn("invalid-theme-key-in-class", [`The utility \`${h2}\` contains an invalid theme value and was not generated.`]);
        return;
      }
      throw n2.error(l3);
    }
    let f = st3(o2);
    return (u !== undefined || f !== undefined && typeof f == "function") && (u === undefined && (u = 1), o2 = we3(f, u, f)), o2;
  }, screen: (n2, i) => {
    i = i.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
    let s3 = Fe3(e2.theme.screens).find(({ name: o2 }) => o2 === i);
    if (!s3)
      throw n2.error(`The '${i}' screen does not exist in your theme.`);
    return Me3(s3);
  } };
  return (n2) => {
    n2.walk((i) => {
      let a = iw[i.type];
      a !== undefined && (i[a] = nw(i, i[a], r2));
    });
  };
}
function cc({ tailwindConfig: { theme: t9 } }) {
  return function(e2) {
    e2.walkAtRules("screen", (r2) => {
      let n2 = r2.params, a = Fe3(t9.screens).find(({ name: s3 }) => s3 === n2);
      if (!a)
        throw r2.error(`No \`${n2}\` screen found.`);
      r2.name = "media", r2.params = Me3(a);
    });
  };
}
function ow(t9) {
  let e2 = t9.filter((o2) => o2.type !== "pseudo" || o2.nodes.length > 0 ? true : o2.value.startsWith("::") || [":before", ":after", ":first-line", ":first-letter"].includes(o2.value)).reverse(), r2 = new Set(["tag", "class", "id", "attribute"]), n2 = e2.findIndex((o2) => r2.has(o2.type));
  if (n2 === -1)
    return e2.reverse().join("").trim();
  let i = e2[n2], a = pc[i.type] ? pc[i.type](i) : i;
  e2 = e2.slice(0, n2);
  let s3 = e2.findIndex((o2) => o2.type === "combinator" && o2.value === ">");
  return s3 !== -1 && (e2.splice(0, s3), e2.unshift(Tn3.default.universal())), [a, ...e2.reverse()].join("").trim();
}
function uw(t9) {
  return la2.has(t9) || la2.set(t9, lw.transformSync(t9)), la2.get(t9);
}
function ua2({ tailwindConfig: t9 }) {
  return (e2) => {
    var i, a;
    let r2 = new Map, n2 = new Set;
    if (e2.walkAtRules("defaults", (s3) => {
      if (s3.nodes && s3.nodes.length > 0) {
        n2.add(s3);
        return;
      }
      let o2 = s3.params;
      r2.has(o2) || r2.set(o2, new Set), r2.get(o2).add(s3.parent), s3.remove();
    }), G3(t9, "optimizeUniversalDefaults"))
      for (let s3 of n2) {
        let o2 = new Map, l3 = (i = r2.get(s3.params)) != null ? i : [];
        for (let u of l3)
          for (let f of uw(u.selector)) {
            let p = f.includes(":-") || f.includes("::-") ? f : "__DEFAULT__", c2 = (a = o2.get(p)) != null ? a : new Set;
            o2.set(p, c2), c2.add(f);
          }
        if (G3(t9, "optimizeUniversalDefaults")) {
          if (o2.size === 0) {
            s3.remove();
            continue;
          }
          for (let [, u] of o2) {
            let f = R3.rule({ source: s3.source });
            f.selectors = [...u], f.append(s3.nodes.map((p) => p.clone())), s3.before(f);
          }
        }
        s3.remove();
      }
    else if (n2.size) {
      let s3 = R3.rule({ selectors: ["*", "::before", "::after"] });
      for (let l3 of n2)
        s3.append(l3.nodes), s3.parent || l3.before(s3), s3.source || (s3.source = l3.source), l3.remove();
      let o2 = s3.clone({ selectors: ["::backdrop"] });
      s3.after(o2);
    }
  };
}
function fa2() {
  function t9(e2) {
    let r2 = null;
    e2.each((n2) => {
      if (!fw.has(n2.type)) {
        r2 = null;
        return;
      }
      if (r2 === null) {
        r2 = n2;
        return;
      }
      let i = dc[n2.type];
      n2.type === "atrule" && n2.name === "font-face" ? r2 = n2 : i.every((a) => {
        var s3, o2;
        return ((s3 = n2[a]) != null ? s3 : "").replace(/\s+/g, " ") === ((o2 = r2[a]) != null ? o2 : "").replace(/\s+/g, " ");
      }) ? (n2.nodes && r2.append(n2.nodes), n2.remove()) : r2 = n2;
    }), e2.each((n2) => {
      n2.type === "atrule" && t9(n2);
    });
  }
  return (e2) => {
    t9(e2);
  };
}
function ca2() {
  return (t9) => {
    t9.walkRules((e2) => {
      let r2 = new Map, n2 = new Set([]), i = new Map;
      e2.walkDecls((a) => {
        if (a.parent === e2) {
          if (r2.has(a.prop)) {
            if (r2.get(a.prop).value === a.value) {
              n2.add(r2.get(a.prop)), r2.set(a.prop, a);
              return;
            }
            i.has(a.prop) || i.set(a.prop, new Set), i.get(a.prop).add(r2.get(a.prop)), i.get(a.prop).add(a);
          }
          r2.set(a.prop, a);
        }
      });
      for (let a of n2)
        a.remove();
      for (let a of i.values()) {
        let s3 = new Map;
        for (let o2 of a) {
          let l3 = pw(o2.value);
          l3 !== null && (s3.has(l3) || s3.set(l3, new Set), s3.get(l3).add(o2));
        }
        for (let o2 of s3.values()) {
          let l3 = Array.from(o2).slice(0, -1);
          for (let u of l3)
            u.remove();
        }
      }
    });
  };
}
function pw(t9) {
  var r2;
  let e2 = /^-?\d*.?\d+([\w%]+)?$/g.exec(t9);
  return e2 ? (r2 = e2[1]) != null ? r2 : cw : null;
}
function dw(t9) {
  if (!t9.walkAtRules)
    return;
  let e2 = new Set;
  if (t9.walkAtRules("apply", (r2) => {
    e2.add(r2.parent);
  }), e2.size !== 0)
    for (let r2 of e2) {
      let n2 = [], i = [];
      for (let a of r2.nodes)
        a.type === "atrule" && a.name === "apply" ? (i.length > 0 && (n2.push(i), i = []), n2.push([a])) : i.push(a);
      if (i.length > 0 && n2.push(i), n2.length !== 1) {
        for (let a of [...n2].reverse()) {
          let s3 = r2.clone({ nodes: [] });
          s3.append(a), r2.after(s3);
        }
        r2.remove();
      }
    }
}
function Pn3() {
  return (t9) => {
    dw(t9);
  };
}
function hw(t9) {
  return t9.type === "root";
}
function mw(t9) {
  return t9.type === "atrule" && t9.name === "layer";
}
function hc(t9) {
  return (e2, r2) => {
    let n2 = false;
    e2.walkAtRules("tailwind", (i) => {
      if (n2)
        return false;
      if (i.parent && !(hw(i.parent) || mw(i.parent)))
        return n2 = true, i.warn(r2, ["Nested @tailwind rules were detected, but are not supported.", "Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix", "Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy"].join(`
`)), false;
    }), e2.walkRules((i) => {
      if (n2)
        return false;
      i.walkRules((a) => (n2 = true, a.warn(r2, ["Nested CSS was detected, but CSS nesting has not been configured correctly.", "Please enable a CSS nesting plugin *before* Tailwind in your configuration.", "See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting"].join(`
`)), false));
    });
  };
}
function pa2(t9) {
  return function(e2, r2) {
    let { tailwindDirectives: n2, applyDirectives: i } = Un3(e2);
    hc()(e2, r2), Pn3()(e2, r2);
    let a = t9({ tailwindDirectives: n2, applyDirectives: i, registerDependency(s3) {
      r2.messages.push({ plugin: "tailwindcss", parent: r2.opts.from, ...s3 });
    }, createContext(s3, o2) {
      return Pf(s3, o2, e2);
    } })(e2, r2);
    if (a.tailwindConfig.separator === "-")
      throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
    nf(a.tailwindConfig), Qs(a)(e2, r2), Pn3()(e2, r2), Xs2(a)(e2, r2), fc(a)(e2, r2), cc(a)(e2, r2), ua2(a)(e2, r2), fa2(a)(e2, r2), ca2(a)(e2, r2);
  };
}
function gc(t9, e2) {
  return t9 === undefined ? e2 : Array.isArray(t9) ? t9 : [...new Set(e2.filter((n2) => t9 !== false && t9[n2] !== false).concat(Object.keys(t9).filter((n2) => t9[n2] !== false)))];
}
function cr3({ version: t9, from: e2, to: r2 }) {
  L3.warn(`${e2}-color-renamed`, [`As of Tailwind CSS ${t9}, \`${e2}\` has been renamed to \`${r2}\`.`, "Update your configuration file to silence this warning."]);
}
function da2(t9, ...e2) {
  var r2, n2;
  for (let i of e2) {
    for (let a in i)
      (r2 = t9 == null ? undefined : t9.hasOwnProperty) != null && r2.call(t9, a) || (t9[a] = i[a]);
    for (let a of Object.getOwnPropertySymbols(i))
      (n2 = t9 == null ? undefined : t9.hasOwnProperty) != null && n2.call(t9, a) || (t9[a] = i[a]);
  }
  return t9;
}
function vc(t9) {
  var r2;
  (() => {
    if (t9.purge || !t9.content || !Array.isArray(t9.content) && !(typeof t9.content == "object" && t9.content !== null))
      return false;
    if (Array.isArray(t9.content))
      return t9.content.every((n2) => typeof n2 == "string" ? true : !(typeof (n2 == null ? undefined : n2.raw) != "string" || (n2 == null ? undefined : n2.extension) && typeof (n2 == null ? undefined : n2.extension) != "string"));
    if (typeof t9.content == "object" && t9.content !== null) {
      if (Object.keys(t9.content).some((n2) => !["files", "relative", "extract", "transform"].includes(n2)))
        return false;
      if (Array.isArray(t9.content.files)) {
        if (!t9.content.files.every((n2) => typeof n2 == "string" ? true : !(typeof (n2 == null ? undefined : n2.raw) != "string" || (n2 == null ? undefined : n2.extension) && typeof (n2 == null ? undefined : n2.extension) != "string")))
          return false;
        if (typeof t9.content.extract == "object") {
          for (let n2 of Object.values(t9.content.extract))
            if (typeof n2 != "function")
              return false;
        } else if (!(t9.content.extract === undefined || typeof t9.content.extract == "function"))
          return false;
        if (typeof t9.content.transform == "object") {
          for (let n2 of Object.values(t9.content.transform))
            if (typeof n2 != "function")
              return false;
        } else if (!(t9.content.transform === undefined || typeof t9.content.transform == "function"))
          return false;
        if (typeof t9.content.relative != "boolean" && typeof t9.content.relative < "u")
          return false;
      }
      return true;
    }
    return false;
  })() || L3.warn("purge-deprecation", ["The `purge`/`content` options have changed in Tailwind CSS v3.0.", "Update your configuration file to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"]), t9.safelist = (() => {
    var s3;
    let { content: n2, purge: i, safelist: a } = t9;
    return Array.isArray(a) ? a : Array.isArray(n2 == null ? undefined : n2.safelist) ? n2.safelist : Array.isArray(i == null ? undefined : i.safelist) ? i.safelist : Array.isArray((s3 = i == null ? undefined : i.options) == null ? undefined : s3.safelist) ? i.options.safelist : [];
  })(), t9.blocklist = (() => {
    let { blocklist: n2 } = t9;
    if (Array.isArray(n2)) {
      if (n2.every((i) => typeof i == "string"))
        return n2;
      L3.warn("blocklist-invalid", ["The `blocklist` option must be an array of strings.", "https://tailwindcss.com/docs/content-configuration#discarding-classes"]);
    }
    return [];
  })(), typeof t9.prefix == "function" ? (L3.warn("prefix-function", ["As of Tailwind CSS v3.0, `prefix` cannot be a function.", "Update `prefix` in your configuration to be a string to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"]), t9.prefix = "") : t9.prefix = (r2 = t9.prefix) != null ? r2 : "", t9.content = { relative: (() => {
    let { content: n2 } = t9;
    return n2 != null && n2.relative ? n2.relative : G3(t9, "relativeContentPathsByDefault");
  })(), files: (() => {
    let { content: n2, purge: i } = t9;
    return Array.isArray(i) ? i : Array.isArray(i == null ? undefined : i.content) ? i.content : Array.isArray(n2) ? n2 : Array.isArray(n2 == null ? undefined : n2.content) ? n2.content : Array.isArray(n2 == null ? undefined : n2.files) ? n2.files : [];
  })(), extract: (() => {
    let n2 = (() => {
      var s3, o2, l3, u, f, p, c2, d2, h2, y2;
      return (s3 = t9.purge) != null && s3.extract ? t9.purge.extract : (o2 = t9.content) != null && o2.extract ? t9.content.extract : (u = (l3 = t9.purge) == null ? undefined : l3.extract) != null && u.DEFAULT ? t9.purge.extract.DEFAULT : (p = (f = t9.content) == null ? undefined : f.extract) != null && p.DEFAULT ? t9.content.extract.DEFAULT : (d2 = (c2 = t9.purge) == null ? undefined : c2.options) != null && d2.extractors ? t9.purge.options.extractors : (y2 = (h2 = t9.content) == null ? undefined : h2.options) != null && y2.extractors ? t9.content.options.extractors : {};
    })(), i = {}, a = (() => {
      var s3, o2, l3, u;
      if ((o2 = (s3 = t9.purge) == null ? undefined : s3.options) != null && o2.defaultExtractor)
        return t9.purge.options.defaultExtractor;
      if ((u = (l3 = t9.content) == null ? undefined : l3.options) != null && u.defaultExtractor)
        return t9.content.options.defaultExtractor;
    })();
    if (a !== undefined && (i.DEFAULT = a), typeof n2 == "function")
      i.DEFAULT = n2;
    else if (Array.isArray(n2))
      for (let { extensions: s3, extractor: o2 } of n2 != null ? n2 : [])
        for (let l3 of s3)
          i[l3] = o2;
    else
      typeof n2 == "object" && n2 !== null && Object.assign(i, n2);
    return i;
  })(), transform: (() => {
    let n2 = (() => {
      var a, s3, o2, l3, u, f;
      return (a = t9.purge) != null && a.transform ? t9.purge.transform : (s3 = t9.content) != null && s3.transform ? t9.content.transform : (l3 = (o2 = t9.purge) == null ? undefined : o2.transform) != null && l3.DEFAULT ? t9.purge.transform.DEFAULT : (f = (u = t9.content) == null ? undefined : u.transform) != null && f.DEFAULT ? t9.content.transform.DEFAULT : {};
    })(), i = {};
    return typeof n2 == "function" && (i.DEFAULT = n2), typeof n2 == "object" && n2 !== null && Object.assign(i, n2), i;
  })() };
  for (let n2 of t9.content.files)
    if (typeof n2 == "string" && /{([^,]*?)}/g.test(n2)) {
      L3.warn("invalid-glob-braces", [`The glob pattern ${n2} in your Tailwind CSS configuration is invalid.`, `Update it to ${n2.replace(/{([^,]*?)}/g, "$1")} to silence this warning.`]);
      break;
    }
  return t9;
}
function In3(t9) {
  return Array.isArray(t9) ? t9.map((e2) => In3(e2)) : typeof t9 == "object" && t9 !== null ? Object.fromEntries(Object.entries(t9).map(([e2, r2]) => [e2, In3(r2)])) : t9;
}
function pt3(t9) {
  return typeof t9 == "function";
}
function pr3(t9, ...e2) {
  let r2 = e2.pop();
  for (let n2 of e2)
    for (let i in n2) {
      let a = r2(t9[i], n2[i]);
      a === undefined ? X3(t9[i]) && X3(n2[i]) ? t9[i] = pr3({}, t9[i], n2[i], r2) : t9[i] = n2[i] : t9[i] = a;
    }
  return t9;
}
function gw(t9, ...e2) {
  return pt3(t9) ? t9(...e2) : t9;
}
function yw(t9) {
  return t9.reduce((e2, { extend: r2 }) => pr3(e2, r2, (n2, i) => n2 === undefined ? [i] : Array.isArray(n2) ? [i, ...n2] : [i, n2]), {});
}
function vw(t9) {
  return { ...t9.reduce((e2, r2) => da2(e2, r2), {}), extend: yw(t9) };
}
function wc(t9, e2) {
  if (Array.isArray(t9) && X3(t9[0]))
    return t9.concat(e2);
  if (Array.isArray(e2) && X3(e2[0]) && X3(t9))
    return [t9, ...e2];
  if (Array.isArray(e2))
    return e2;
}
function ww({ extend: t9, ...e2 }) {
  return pr3(e2, t9, (r2, n2) => !pt3(r2) && !n2.some(pt3) ? pr3({}, r2, ...n2, wc) : (i, a) => pr3({}, ...[r2, ...n2].map((s3) => gw(s3, i, a)), wc));
}
function* bw(t9) {
  let e2 = Le3(t9);
  if (e2.length === 0 || (yield e2, Array.isArray(t9)))
    return;
  let r2 = /^(.*?)\s*\/\s*([^/]+)$/, n2 = t9.match(r2);
  if (n2 !== null) {
    let [, i, a] = n2, s3 = Le3(i);
    s3.alpha = a, yield s3;
  }
}
function xw(t9) {
  let e2 = (r2, n2) => {
    for (let i of bw(r2)) {
      let a = 0, s3 = t9;
      for (;s3 != null && a < i.length; )
        s3 = s3[i[a++]], s3 = pt3(s3) && (i.alpha === undefined || a <= i.length - 1) ? s3(e2, ha2) : s3;
      if (s3 !== undefined) {
        if (i.alpha !== undefined) {
          let o2 = st3(s3);
          return we3(o2, i.alpha, M2(o2));
        }
        return X3(s3) ? In3(s3) : s3;
      }
    }
    return n2;
  };
  return Object.assign(e2, { theme: e2, ...ha2 }), Object.keys(t9).reduce((r2, n2) => (r2[n2] = pt3(t9[n2]) ? t9[n2](e2, ha2) : t9[n2], r2), {});
}
function bc(t9) {
  let e2 = [];
  return t9.forEach((r2) => {
    var i;
    e2 = [...e2, r2];
    let n2 = (i = r2 == null ? undefined : r2.plugins) != null ? i : [];
    n2.length !== 0 && n2.forEach((a) => {
      var s3;
      a.__isOptionsFunction && (a = a()), e2 = [...e2, ...bc([(s3 = a == null ? undefined : a.config) != null ? s3 : {}])];
    });
  }), e2;
}
function Sw(t9) {
  return [...t9].reduceRight((r2, n2) => pt3(n2) ? n2({ corePlugins: r2 }) : gc(n2, r2), mc);
}
function kw(t9) {
  return [...t9].reduceRight((r2, n2) => [...r2, ...n2], []);
}
function ma2(t9) {
  let e2 = [...bc(t9), { prefix: "", important: false, separator: ":" }];
  return vc(da2({ theme: xw(ww(vw(e2.map((r2) => {
    var n2;
    return (n2 = r2 == null ? undefined : r2.theme) != null ? n2 : {};
  })))), corePlugins: Sw(e2.map((r2) => r2.corePlugins)), plugins: kw(t9.map((r2) => {
    var n2;
    return (n2 = r2 == null ? undefined : r2.plugins) != null ? n2 : [];
  })) }, ...e2));
}
function Rn3(t9) {
  var i;
  let e2 = ((i = t9 == null ? undefined : t9.presets) != null ? i : [kc.default]).slice().reverse().flatMap((a) => Rn3(a instanceof Function ? a() : a)), r2 = { respectDefaultRingColorOpacity: { theme: { ringColor: ({ theme: a }) => ({ DEFAULT: "#3b82f67f", ...a("colors") }) } }, disableColorOpacityUtilitiesByDefault: { corePlugins: { backgroundOpacity: false, borderOpacity: false, divideOpacity: false, placeholderOpacity: false, ringOpacity: false, textOpacity: false } } }, n2 = Object.keys(r2).filter((a) => G3(t9, a)).map((a) => r2[a]);
  return [t9, ...n2, ...e2];
}
function ga2(...t9) {
  let [, ...e2] = Rn3(t9[0]);
  return ma2([...t9, ...e2]);
}
function kp(t9) {
  let e2 = R3.parse(t9);
  return tn3.objectify(e2);
}
var Ap = Object.create;
var gr3 = Object.defineProperty;
var _p = Object.getOwnPropertyDescriptor;
var Tp = Object.getOwnPropertyNames;
var Pp = Object.getPrototypeOf;
var Ip = Object.prototype.hasOwnProperty;
var dt2 = (t9, e2) => () => (t9 && (e2 = t9(t9 = 0)), e2);
var S3 = (t9, e2) => () => (e2 || t9((e2 = { exports: {} }).exports, e2), e2.exports);
var yr3 = (t9, e2) => {
  for (var r2 in e2)
    gr3(t9, r2, { get: e2[r2], enumerable: true });
};
var Ia2 = (t9, e2, r2, n2) => {
  if (e2 && typeof e2 == "object" || typeof e2 == "function")
    for (let i of Tp(e2))
      !Ip.call(t9, i) && i !== r2 && gr3(t9, i, { get: () => e2[i], enumerable: !(n2 = _p(e2, i)) || n2.enumerable });
  return t9;
};
var H3 = (t9, e2, r2) => (r2 = t9 != null ? Ap(Pp(t9)) : {}, Ia2(e2 || !t9 || !t9.__esModule ? gr3(r2, "default", { value: t9, enumerable: true }) : r2, t9));
var $e2 = (t9) => Ia2(gr3({}, "__esModule", { value: true }), t9);
var Ma2;
var Da2 = dt2(() => {
  Ma2 = `*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:theme("borderColor.DEFAULT",currentColor)}:before,:after{--tw-content: ""}html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:theme("fontFamily.sans",ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:theme("fontFamily.sans[1].fontFeatureSettings",normal);font-variation-settings:theme("fontFamily.sans[1].fontVariationSettings",normal)}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:theme("fontFamily.mono",ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:theme("colors.gray.400",#9ca3af)}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}
`;
});
var Fa2 = {};
yr3(Fa2, { default: () => ht3 });
var ht3;
var vr3 = dt2(() => {
  Da2();
  ht3 = { readFileSync: () => Ma2 };
});
var Na2 = S3((mb, La2) => {
  var jn3 = class {
    constructor(e2 = {}) {
      if (!(e2.maxSize && e2.maxSize > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      if (typeof e2.maxAge == "number" && e2.maxAge === 0)
        throw new TypeError("`maxAge` must be a number greater than 0");
      this.maxSize = e2.maxSize, this.maxAge = e2.maxAge || 1 / 0, this.onEviction = e2.onEviction, this.cache = new Map, this.oldCache = new Map, this._size = 0;
    }
    _emitEvictions(e2) {
      if (typeof this.onEviction == "function")
        for (let [r2, n2] of e2)
          this.onEviction(r2, n2.value);
    }
    _deleteIfExpired(e2, r2) {
      return typeof r2.expiry == "number" && r2.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(e2, r2.value), this.delete(e2)) : false;
    }
    _getOrDeleteIfExpired(e2, r2) {
      if (this._deleteIfExpired(e2, r2) === false)
        return r2.value;
    }
    _getItemValue(e2, r2) {
      return r2.expiry ? this._getOrDeleteIfExpired(e2, r2) : r2.value;
    }
    _peek(e2, r2) {
      let n2 = r2.get(e2);
      return this._getItemValue(e2, n2);
    }
    _set(e2, r2) {
      this.cache.set(e2, r2), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = new Map);
    }
    _moveToRecent(e2, r2) {
      this.oldCache.delete(e2), this._set(e2, r2);
    }
    *_entriesAscending() {
      for (let e2 of this.oldCache) {
        let [r2, n2] = e2;
        this.cache.has(r2) || this._deleteIfExpired(r2, n2) === false && (yield e2);
      }
      for (let e2 of this.cache) {
        let [r2, n2] = e2;
        this._deleteIfExpired(r2, n2) === false && (yield e2);
      }
    }
    get(e2) {
      if (this.cache.has(e2)) {
        let r2 = this.cache.get(e2);
        return this._getItemValue(e2, r2);
      }
      if (this.oldCache.has(e2)) {
        let r2 = this.oldCache.get(e2);
        if (this._deleteIfExpired(e2, r2) === false)
          return this._moveToRecent(e2, r2), r2.value;
      }
    }
    set(e2, r2, { maxAge: n2 = this.maxAge === 1 / 0 ? undefined : Date.now() + this.maxAge } = {}) {
      this.cache.has(e2) ? this.cache.set(e2, { value: r2, maxAge: n2 }) : this._set(e2, { value: r2, expiry: n2 });
    }
    has(e2) {
      return this.cache.has(e2) ? !this._deleteIfExpired(e2, this.cache.get(e2)) : this.oldCache.has(e2) ? !this._deleteIfExpired(e2, this.oldCache.get(e2)) : false;
    }
    peek(e2) {
      if (this.cache.has(e2))
        return this._peek(e2, this.cache);
      if (this.oldCache.has(e2))
        return this._peek(e2, this.oldCache);
    }
    delete(e2) {
      let r2 = this.cache.delete(e2);
      return r2 && this._size--, this.oldCache.delete(e2) || r2;
    }
    clear() {
      this.cache.clear(), this.oldCache.clear(), this._size = 0;
    }
    resize(e2) {
      if (!(e2 && e2 > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      let r2 = [...this._entriesAscending()], n2 = r2.length - e2;
      n2 < 0 ? (this.cache = new Map(r2), this.oldCache = new Map, this._size = r2.length) : (n2 > 0 && this._emitEvictions(r2.slice(0, n2)), this.oldCache = new Map(r2.slice(n2)), this.cache = new Map, this._size = 0), this.maxSize = e2;
    }
    *keys() {
      for (let [e2] of this)
        yield e2;
    }
    *values() {
      for (let [, e2] of this)
        yield e2;
    }
    *[Symbol.iterator]() {
      for (let e2 of this.cache) {
        let [r2, n2] = e2;
        this._deleteIfExpired(r2, n2) === false && (yield [r2, n2.value]);
      }
      for (let e2 of this.oldCache) {
        let [r2, n2] = e2;
        this.cache.has(r2) || this._deleteIfExpired(r2, n2) === false && (yield [r2, n2.value]);
      }
    }
    *entriesDescending() {
      let e2 = [...this.cache];
      for (let r2 = e2.length - 1;r2 >= 0; --r2) {
        let n2 = e2[r2], [i, a] = n2;
        this._deleteIfExpired(i, a) === false && (yield [i, a.value]);
      }
      e2 = [...this.oldCache];
      for (let r2 = e2.length - 1;r2 >= 0; --r2) {
        let n2 = e2[r2], [i, a] = n2;
        this.cache.has(i) || this._deleteIfExpired(i, a) === false && (yield [i, a.value]);
      }
    }
    *entriesAscending() {
      for (let [e2, r2] of this._entriesAscending())
        yield [e2, r2.value];
    }
    get size() {
      if (!this._size)
        return this.oldCache.size;
      let e2 = 0;
      for (let r2 of this.oldCache.keys())
        this.cache.has(r2) || e2++;
      return Math.min(this._size + e2, this.maxSize);
    }
  };
  La2.exports = jn3;
});
var Ua2 = {};
yr3(Ua2, { default: () => Bn3 });
var Bn3;
var Gn3 = dt2(() => {
  Bn3 = { yellow: (t9) => t9 };
});
var Yn3 = S3(() => {
});
var br3 = S3((bb, Va2) => {
  var ja2 = (Gn3(), $e2(Ua2)), za2 = Yn3(), Ue3 = class extends Error {
    constructor(e2, r2, n2, i, a, s3) {
      super(e2), this.name = "CssSyntaxError", this.reason = e2, a && (this.file = a), i && (this.source = i), s3 && (this.plugin = s3), typeof r2 < "u" && typeof n2 < "u" && (typeof r2 == "number" ? (this.line = r2, this.column = n2) : (this.line = r2.line, this.column = r2.column, this.endLine = n2.line, this.endColumn = n2.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, Ue3);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(e2) {
      if (!this.source)
        return "";
      let r2 = this.source;
      e2 == null && (e2 = ja2.isColorSupported), za2 && e2 && (r2 = za2(r2));
      let n2 = r2.split(/\r?\n/), i = Math.max(this.line - 3, 0), a = Math.min(this.line + 2, n2.length), s3 = String(a).length, o2, l3;
      if (e2) {
        let { bold: u, gray: f, red: p } = ja2.createColors(true);
        o2 = (c2) => u(p(c2)), l3 = (c2) => f(c2);
      } else
        o2 = l3 = (u) => u;
      return n2.slice(i, a).map((u, f) => {
        let p = i + 1 + f, c2 = " " + (" " + p).slice(-s3) + " | ";
        if (p === this.line) {
          let d2 = l3(c2.replace(/\d/g, " ")) + u.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return o2(">") + l3(c2) + u + `
 ` + d2 + o2("^");
        }
        return " " + l3(c2) + u;
      }).join(`
`);
    }
    toString() {
      let e2 = this.showSourceCode();
      return e2 && (e2 = `

` + e2 + `
`), this.name + ": " + this.message + e2;
    }
  };
  Va2.exports = Ue3;
  Ue3.default = Ue3;
});
var xr3 = S3((xb, Hn3) => {
  Hn3.exports.isClean = Symbol("isClean");
  Hn3.exports.my = Symbol("my");
});
var Qn3 = S3((Sb, Ba2) => {
  var Wa2 = { after: `
`, beforeClose: `
`, beforeComment: `
`, beforeDecl: `
`, beforeOpen: " ", beforeRule: `
`, colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: false };
  function Mp(t9) {
    return t9[0].toUpperCase() + t9.slice(1);
  }
  var gt4 = class {
    constructor(e2) {
      this.builder = e2;
    }
    atrule(e2, r2) {
      let n2 = "@" + e2.name, i = e2.params ? this.rawValue(e2, "params") : "";
      if (typeof e2.raws.afterName < "u" ? n2 += e2.raws.afterName : i && (n2 += " "), e2.nodes)
        this.block(e2, n2 + i);
      else {
        let a = (e2.raws.between || "") + (r2 ? ";" : "");
        this.builder(n2 + i + a, e2);
      }
    }
    beforeAfter(e2, r2) {
      let n2;
      e2.type === "decl" ? n2 = this.raw(e2, null, "beforeDecl") : e2.type === "comment" ? n2 = this.raw(e2, null, "beforeComment") : r2 === "before" ? n2 = this.raw(e2, null, "beforeRule") : n2 = this.raw(e2, null, "beforeClose");
      let i = e2.parent, a = 0;
      for (;i && i.type !== "root"; )
        a += 1, i = i.parent;
      if (n2.includes(`
`)) {
        let s3 = this.raw(e2, null, "indent");
        if (s3.length)
          for (let o2 = 0;o2 < a; o2++)
            n2 += s3;
      }
      return n2;
    }
    block(e2, r2) {
      let n2 = this.raw(e2, "between", "beforeOpen");
      this.builder(r2 + n2 + "{", e2, "start");
      let i;
      e2.nodes && e2.nodes.length ? (this.body(e2), i = this.raw(e2, "after")) : i = this.raw(e2, "after", "emptyBody"), i && this.builder(i), this.builder("}", e2, "end");
    }
    body(e2) {
      let r2 = e2.nodes.length - 1;
      for (;r2 > 0 && e2.nodes[r2].type === "comment"; )
        r2 -= 1;
      let n2 = this.raw(e2, "semicolon");
      for (let i = 0;i < e2.nodes.length; i++) {
        let a = e2.nodes[i], s3 = this.raw(a, "before");
        s3 && this.builder(s3), this.stringify(a, r2 !== i || n2);
      }
    }
    comment(e2) {
      let r2 = this.raw(e2, "left", "commentLeft"), n2 = this.raw(e2, "right", "commentRight");
      this.builder("/*" + r2 + e2.text + n2 + "*/", e2);
    }
    decl(e2, r2) {
      let n2 = this.raw(e2, "between", "colon"), i = e2.prop + n2 + this.rawValue(e2, "value");
      e2.important && (i += e2.raws.important || " !important"), r2 && (i += ";"), this.builder(i, e2);
    }
    document(e2) {
      this.body(e2);
    }
    raw(e2, r2, n2) {
      let i;
      if (n2 || (n2 = r2), r2 && (i = e2.raws[r2], typeof i < "u"))
        return i;
      let a = e2.parent;
      if (n2 === "before" && (!a || a.type === "root" && a.first === e2 || a && a.type === "document"))
        return "";
      if (!a)
        return Wa2[n2];
      let s3 = e2.root();
      if (s3.rawCache || (s3.rawCache = {}), typeof s3.rawCache[n2] < "u")
        return s3.rawCache[n2];
      if (n2 === "before" || n2 === "after")
        return this.beforeAfter(e2, n2);
      {
        let o2 = "raw" + Mp(n2);
        this[o2] ? i = this[o2](s3, e2) : s3.walk((l3) => {
          if (i = l3.raws[r2], typeof i < "u")
            return false;
        });
      }
      return typeof i > "u" && (i = Wa2[n2]), s3.rawCache[n2] = i, i;
    }
    rawBeforeClose(e2) {
      let r2;
      return e2.walk((n2) => {
        if (n2.nodes && n2.nodes.length > 0 && typeof n2.raws.after < "u")
          return r2 = n2.raws.after, r2.includes(`
`) && (r2 = r2.replace(/[^\n]+$/, "")), false;
      }), r2 && (r2 = r2.replace(/\S/g, "")), r2;
    }
    rawBeforeComment(e2, r2) {
      let n2;
      return e2.walkComments((i) => {
        if (typeof i.raws.before < "u")
          return n2 = i.raws.before, n2.includes(`
`) && (n2 = n2.replace(/[^\n]+$/, "")), false;
      }), typeof n2 > "u" ? n2 = this.raw(r2, null, "beforeDecl") : n2 && (n2 = n2.replace(/\S/g, "")), n2;
    }
    rawBeforeDecl(e2, r2) {
      let n2;
      return e2.walkDecls((i) => {
        if (typeof i.raws.before < "u")
          return n2 = i.raws.before, n2.includes(`
`) && (n2 = n2.replace(/[^\n]+$/, "")), false;
      }), typeof n2 > "u" ? n2 = this.raw(r2, null, "beforeRule") : n2 && (n2 = n2.replace(/\S/g, "")), n2;
    }
    rawBeforeOpen(e2) {
      let r2;
      return e2.walk((n2) => {
        if (n2.type !== "decl" && (r2 = n2.raws.between, typeof r2 < "u"))
          return false;
      }), r2;
    }
    rawBeforeRule(e2) {
      let r2;
      return e2.walk((n2) => {
        if (n2.nodes && (n2.parent !== e2 || e2.first !== n2) && typeof n2.raws.before < "u")
          return r2 = n2.raws.before, r2.includes(`
`) && (r2 = r2.replace(/[^\n]+$/, "")), false;
      }), r2 && (r2 = r2.replace(/\S/g, "")), r2;
    }
    rawColon(e2) {
      let r2;
      return e2.walkDecls((n2) => {
        if (typeof n2.raws.between < "u")
          return r2 = n2.raws.between.replace(/[^\s:]/g, ""), false;
      }), r2;
    }
    rawEmptyBody(e2) {
      let r2;
      return e2.walk((n2) => {
        if (n2.nodes && n2.nodes.length === 0 && (r2 = n2.raws.after, typeof r2 < "u"))
          return false;
      }), r2;
    }
    rawIndent(e2) {
      if (e2.raws.indent)
        return e2.raws.indent;
      let r2;
      return e2.walk((n2) => {
        let i = n2.parent;
        if (i && i !== e2 && i.parent && i.parent === e2 && typeof n2.raws.before < "u") {
          let a = n2.raws.before.split(`
`);
          return r2 = a[a.length - 1], r2 = r2.replace(/\S/g, ""), false;
        }
      }), r2;
    }
    rawSemicolon(e2) {
      let r2;
      return e2.walk((n2) => {
        if (n2.nodes && n2.nodes.length && n2.last.type === "decl" && (r2 = n2.raws.semicolon, typeof r2 < "u"))
          return false;
      }), r2;
    }
    rawValue(e2, r2) {
      let n2 = e2[r2], i = e2.raws[r2];
      return i && i.value === n2 ? i.raw : n2;
    }
    root(e2) {
      this.body(e2), e2.raws.after && this.builder(e2.raws.after);
    }
    rule(e2) {
      this.block(e2, this.rawValue(e2, "selector")), e2.raws.ownSemicolon && this.builder(e2.raws.ownSemicolon, e2, "end");
    }
    stringify(e2, r2) {
      if (!this[e2.type])
        throw new Error("Unknown AST node type " + e2.type + ". Maybe you need to change PostCSS stringifier.");
      this[e2.type](e2, r2);
    }
  };
  Ba2.exports = gt4;
  gt4.default = gt4;
});
var yt3 = S3((kb, Ga2) => {
  var Fp = Qn3();
  function Jn3(t9, e2) {
    new Fp(e2).stringify(t9);
  }
  Ga2.exports = Jn3;
  Jn3.default = Jn3;
});
var wt3 = S3((Ob, Ya2) => {
  var { isClean: Sr3, my: Lp } = xr3(), Np = br3(), qp = Qn3(), $p = yt3();
  function Xn3(t9, e2) {
    let r2 = new t9.constructor;
    for (let n2 in t9) {
      if (!Object.prototype.hasOwnProperty.call(t9, n2) || n2 === "proxyCache")
        continue;
      let i = t9[n2], a = typeof i;
      n2 === "parent" && a === "object" ? e2 && (r2[n2] = e2) : n2 === "source" ? r2[n2] = i : Array.isArray(i) ? r2[n2] = i.map((s3) => Xn3(s3, r2)) : (a === "object" && i !== null && (i = Xn3(i)), r2[n2] = i);
    }
    return r2;
  }
  var vt3 = class {
    constructor(e2 = {}) {
      this.raws = {}, this[Sr3] = false, this[Lp] = true;
      for (let r2 in e2)
        if (r2 === "nodes") {
          this.nodes = [];
          for (let n2 of e2[r2])
            typeof n2.clone == "function" ? this.append(n2.clone()) : this.append(n2);
        } else
          this[r2] = e2[r2];
    }
    addToError(e2) {
      if (e2.postcssNode = this, e2.stack && this.source && /\n\s{4}at /.test(e2.stack)) {
        let r2 = this.source;
        e2.stack = e2.stack.replace(/\n\s{4}at /, `\$&${r2.input.from}:${r2.start.line}:${r2.start.column}\$&`);
      }
      return e2;
    }
    after(e2) {
      return this.parent.insertAfter(this, e2), this;
    }
    assign(e2 = {}) {
      for (let r2 in e2)
        this[r2] = e2[r2];
      return this;
    }
    before(e2) {
      return this.parent.insertBefore(this, e2), this;
    }
    cleanRaws(e2) {
      delete this.raws.before, delete this.raws.after, e2 || delete this.raws.between;
    }
    clone(e2 = {}) {
      let r2 = Xn3(this);
      for (let n2 in e2)
        r2[n2] = e2[n2];
      return r2;
    }
    cloneAfter(e2 = {}) {
      let r2 = this.clone(e2);
      return this.parent.insertAfter(this, r2), r2;
    }
    cloneBefore(e2 = {}) {
      let r2 = this.clone(e2);
      return this.parent.insertBefore(this, r2), r2;
    }
    error(e2, r2 = {}) {
      if (this.source) {
        let { end: n2, start: i } = this.rangeBy(r2);
        return this.source.input.error(e2, { column: i.column, line: i.line }, { column: n2.column, line: n2.line }, r2);
      }
      return new Np(e2);
    }
    getProxyProcessor() {
      return { get(e2, r2) {
        return r2 === "proxyOf" ? e2 : r2 === "root" ? () => e2.root().toProxy() : e2[r2];
      }, set(e2, r2, n2) {
        return e2[r2] === n2 || (e2[r2] = n2, (r2 === "prop" || r2 === "value" || r2 === "name" || r2 === "params" || r2 === "important" || r2 === "text") && e2.markDirty()), true;
      } };
    }
    markDirty() {
      if (this[Sr3]) {
        this[Sr3] = false;
        let e2 = this;
        for (;e2 = e2.parent; )
          e2[Sr3] = false;
      }
    }
    next() {
      if (!this.parent)
        return;
      let e2 = this.parent.index(this);
      return this.parent.nodes[e2 + 1];
    }
    positionBy(e2, r2) {
      let n2 = this.source.start;
      if (e2.index)
        n2 = this.positionInside(e2.index, r2);
      else if (e2.word) {
        r2 = this.toString();
        let i = r2.indexOf(e2.word);
        i !== -1 && (n2 = this.positionInside(i, r2));
      }
      return n2;
    }
    positionInside(e2, r2) {
      let n2 = r2 || this.toString(), i = this.source.start.column, a = this.source.start.line;
      for (let s3 = 0;s3 < e2; s3++)
        n2[s3] === `
` ? (i = 1, a += 1) : i += 1;
      return { column: i, line: a };
    }
    prev() {
      if (!this.parent)
        return;
      let e2 = this.parent.index(this);
      return this.parent.nodes[e2 - 1];
    }
    rangeBy(e2) {
      let r2 = { column: this.source.start.column, line: this.source.start.line }, n2 = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: r2.column + 1, line: r2.line };
      if (e2.word) {
        let i = this.toString(), a = i.indexOf(e2.word);
        a !== -1 && (r2 = this.positionInside(a, i), n2 = this.positionInside(a + e2.word.length, i));
      } else
        e2.start ? r2 = { column: e2.start.column, line: e2.start.line } : e2.index && (r2 = this.positionInside(e2.index)), e2.end ? n2 = { column: e2.end.column, line: e2.end.line } : e2.endIndex ? n2 = this.positionInside(e2.endIndex) : e2.index && (n2 = this.positionInside(e2.index + 1));
      return (n2.line < r2.line || n2.line === r2.line && n2.column <= r2.column) && (n2 = { column: r2.column + 1, line: r2.line }), { end: n2, start: r2 };
    }
    raw(e2, r2) {
      return new qp().raw(this, e2, r2);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = undefined, this;
    }
    replaceWith(...e2) {
      if (this.parent) {
        let r2 = this, n2 = false;
        for (let i of e2)
          i === this ? n2 = true : n2 ? (this.parent.insertAfter(r2, i), r2 = i) : this.parent.insertBefore(r2, i);
        n2 || this.remove();
      }
      return this;
    }
    root() {
      let e2 = this;
      for (;e2.parent && e2.parent.type !== "document"; )
        e2 = e2.parent;
      return e2;
    }
    toJSON(e2, r2) {
      let n2 = {}, i = r2 == null;
      r2 = r2 || new Map;
      let a = 0;
      for (let s3 in this) {
        if (!Object.prototype.hasOwnProperty.call(this, s3) || s3 === "parent" || s3 === "proxyCache")
          continue;
        let o2 = this[s3];
        if (Array.isArray(o2))
          n2[s3] = o2.map((l3) => typeof l3 == "object" && l3.toJSON ? l3.toJSON(null, r2) : l3);
        else if (typeof o2 == "object" && o2.toJSON)
          n2[s3] = o2.toJSON(null, r2);
        else if (s3 === "source") {
          let l3 = r2.get(o2.input);
          l3 == null && (l3 = a, r2.set(o2.input, a), a++), n2[s3] = { end: o2.end, inputId: l3, start: o2.start };
        } else
          n2[s3] = o2;
      }
      return i && (n2.inputs = [...r2.keys()].map((s3) => s3.toJSON())), n2;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(e2 = $p) {
      e2.stringify && (e2 = e2.stringify);
      let r2 = "";
      return e2(this, (n2) => {
        r2 += n2;
      }), r2;
    }
    warn(e2, r2, n2) {
      let i = { node: this };
      for (let a in n2)
        i[a] = n2[a];
      return e2.warn(r2, i);
    }
    get proxyOf() {
      return this;
    }
  };
  Ya2.exports = vt3;
  vt3.default = vt3;
});
var xt3 = S3((Eb, Ha2) => {
  var Up = wt3(), bt3 = class extends Up {
    constructor(e2) {
      e2 && typeof e2.value < "u" && typeof e2.value != "string" && (e2 = { ...e2, value: String(e2.value) }), super(e2), this.type = "decl";
    }
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
  };
  Ha2.exports = bt3;
  bt3.default = bt3;
});
var kr3 = S3(() => {
});
var St3 = {};
yr3(St3, { join: () => Kn3 });
var Kn3;
var kt3 = dt2(() => {
  Kn3 = () => "";
});
var Zn3 = {};
yr3(Zn3, { default: () => jp });
var jp;
var ei2 = dt2(() => {
  jp = null;
});
var Ja2 = S3((_b, Qa2) => {
  var zp = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", Vp = (t9, e2 = 21) => (r2 = e2) => {
    let n2 = "", i = r2;
    for (;i--; )
      n2 += t9[Math.random() * t9.length | 0];
    return n2;
  }, Wp = (t9 = 21) => {
    let e2 = "", r2 = t9;
    for (;r2--; )
      e2 += zp[Math.random() * 64 | 0];
    return e2;
  };
  Qa2.exports = { nanoid: Wp, customAlphabet: Vp };
});
var ri3 = S3((Tb, Za2) => {
  var { SourceMapConsumer: Xa2, SourceMapGenerator: Ka2 } = kr3(), { existsSync: Bp, readFileSync: Gp } = (vr3(), $e2(Fa2)), { dirname: ti3, join: Yp } = (kt3(), $e2(St3));
  function Hp(t9) {
    return Buffer ? Buffer.from(t9, "base64").toString() : window.atob(t9);
  }
  var Ot3 = class {
    constructor(e2, r2) {
      if (r2.map === false)
        return;
      this.loadAnnotation(e2), this.inline = this.startWith(this.annotation, "data:");
      let n2 = r2.map ? r2.map.prev : undefined, i = this.loadMap(r2.from, n2);
      !this.mapFile && r2.from && (this.mapFile = r2.from), this.mapFile && (this.root = ti3(this.mapFile)), i && (this.text = i);
    }
    consumer() {
      return this.consumerCache || (this.consumerCache = new Xa2(this.text)), this.consumerCache;
    }
    decodeInline(e2) {
      let r2 = /^data:application\/json;charset=utf-?8;base64,/, n2 = /^data:application\/json;base64,/, i = /^data:application\/json;charset=utf-?8,/, a = /^data:application\/json,/;
      if (i.test(e2) || a.test(e2))
        return decodeURIComponent(e2.substr(RegExp.lastMatch.length));
      if (r2.test(e2) || n2.test(e2))
        return Hp(e2.substr(RegExp.lastMatch.length));
      let s3 = e2.match(/data:application\/json;([^,]+),/)[1];
      throw new Error("Unsupported source map encoding " + s3);
    }
    getAnnotationURL(e2) {
      return e2.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
    }
    isMap(e2) {
      return typeof e2 != "object" ? false : typeof e2.mappings == "string" || typeof e2._mappings == "string" || Array.isArray(e2.sections);
    }
    loadAnnotation(e2) {
      let r2 = e2.match(/\/\*\s*# sourceMappingURL=/gm);
      if (!r2)
        return;
      let n2 = e2.lastIndexOf(r2.pop()), i = e2.indexOf("*/", n2);
      n2 > -1 && i > -1 && (this.annotation = this.getAnnotationURL(e2.substring(n2, i)));
    }
    loadFile(e2) {
      if (this.root = ti3(e2), Bp(e2))
        return this.mapFile = e2, Gp(e2, "utf-8").toString().trim();
    }
    loadMap(e2, r2) {
      if (r2 === false)
        return false;
      if (r2) {
        if (typeof r2 == "string")
          return r2;
        if (typeof r2 == "function") {
          let n2 = r2(e2);
          if (n2) {
            let i = this.loadFile(n2);
            if (!i)
              throw new Error("Unable to load previous source map: " + n2.toString());
            return i;
          }
        } else {
          if (r2 instanceof Xa2)
            return Ka2.fromSourceMap(r2).toString();
          if (r2 instanceof Ka2)
            return r2.toString();
          if (this.isMap(r2))
            return JSON.stringify(r2);
          throw new Error("Unsupported previous source map format: " + r2.toString());
        }
      } else {
        if (this.inline)
          return this.decodeInline(this.annotation);
        if (this.annotation) {
          let n2 = this.annotation;
          return e2 && (n2 = Yp(ti3(e2), n2)), this.loadFile(n2);
        }
      }
    }
    startWith(e2, r2) {
      return e2 ? e2.substr(0, r2.length) === r2 : false;
    }
    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
  };
  Za2.exports = Ot3;
  Ot3.default = Ot3;
});
var Et3 = S3((Pb, no3) => {
  var { SourceMapConsumer: Qp, SourceMapGenerator: Jp } = kr3(), { fileURLToPath: eo3, pathToFileURL: Or3 } = (ei2(), $e2(Zn3)), { isAbsolute: si2, resolve: ai } = (kt3(), $e2(St3)), { nanoid: Xp } = Ja2(), ni3 = Yn3(), to3 = br3(), Kp = ri3(), ii2 = Symbol("fromOffsetCache"), Zp = Boolean(Qp && Jp), ro3 = Boolean(ai && si2), Ye3 = class {
    constructor(e2, r2 = {}) {
      if (e2 === null || typeof e2 > "u" || typeof e2 == "object" && !e2.toString)
        throw new Error(`PostCSS received ${e2} instead of CSS string`);
      if (this.css = e2.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, r2.from && (!ro3 || /^\w+:\/\//.test(r2.from) || si2(r2.from) ? this.file = r2.from : this.file = ai(r2.from)), ro3 && Zp) {
        let n2 = new Kp(this.css, r2);
        if (n2.text) {
          this.map = n2;
          let i = n2.consumer().file;
          !this.file && i && (this.file = this.mapResolve(i));
        }
      }
      this.file || (this.id = "<input css " + Xp(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(e2, r2, n2, i = {}) {
      let a, s3, o2;
      if (r2 && typeof r2 == "object") {
        let u = r2, f = n2;
        if (typeof u.offset == "number") {
          let p = this.fromOffset(u.offset);
          r2 = p.line, n2 = p.col;
        } else
          r2 = u.line, n2 = u.column;
        if (typeof f.offset == "number") {
          let p = this.fromOffset(f.offset);
          s3 = p.line, o2 = p.col;
        } else
          s3 = f.line, o2 = f.column;
      } else if (!n2) {
        let u = this.fromOffset(r2);
        r2 = u.line, n2 = u.col;
      }
      let l3 = this.origin(r2, n2, s3, o2);
      return l3 ? a = new to3(e2, l3.endLine === undefined ? l3.line : { column: l3.column, line: l3.line }, l3.endLine === undefined ? l3.column : { column: l3.endColumn, line: l3.endLine }, l3.source, l3.file, i.plugin) : a = new to3(e2, s3 === undefined ? r2 : { column: n2, line: r2 }, s3 === undefined ? n2 : { column: o2, line: s3 }, this.css, this.file, i.plugin), a.input = { column: n2, endColumn: o2, endLine: s3, line: r2, source: this.css }, this.file && (Or3 && (a.input.url = Or3(this.file).toString()), a.input.file = this.file), a;
    }
    fromOffset(e2) {
      let r2, n2;
      if (this[ii2])
        n2 = this[ii2];
      else {
        let a = this.css.split(`
`);
        n2 = new Array(a.length);
        let s3 = 0;
        for (let o2 = 0, l3 = a.length;o2 < l3; o2++)
          n2[o2] = s3, s3 += a[o2].length + 1;
        this[ii2] = n2;
      }
      r2 = n2[n2.length - 1];
      let i = 0;
      if (e2 >= r2)
        i = n2.length - 1;
      else {
        let a = n2.length - 2, s3;
        for (;i < a; )
          if (s3 = i + (a - i >> 1), e2 < n2[s3])
            a = s3 - 1;
          else if (e2 >= n2[s3 + 1])
            i = s3 + 1;
          else {
            i = s3;
            break;
          }
      }
      return { col: e2 - n2[i] + 1, line: i + 1 };
    }
    mapResolve(e2) {
      return /^\w+:\/\//.test(e2) ? e2 : ai(this.map.consumer().sourceRoot || this.map.root || ".", e2);
    }
    origin(e2, r2, n2, i) {
      if (!this.map)
        return false;
      let a = this.map.consumer(), s3 = a.originalPositionFor({ column: r2, line: e2 });
      if (!s3.source)
        return false;
      let o2;
      typeof n2 == "number" && (o2 = a.originalPositionFor({ column: i, line: n2 }));
      let l3;
      si2(s3.source) ? l3 = Or3(s3.source) : l3 = new URL(s3.source, this.map.consumer().sourceRoot || Or3(this.map.mapFile));
      let u = { column: s3.column, endColumn: o2 && o2.column, endLine: o2 && o2.line, line: s3.line, url: l3.toString() };
      if (l3.protocol === "file:")
        if (eo3)
          u.file = eo3(l3);
        else
          throw new Error("file: protocol is not available in this PostCSS build");
      let f = a.sourceContentFor(s3.source);
      return f && (u.source = f), u;
    }
    toJSON() {
      let e2 = {};
      for (let r2 of ["hasBOM", "css", "file", "id"])
        this[r2] != null && (e2[r2] = this[r2]);
      return this.map && (e2.map = { ...this.map }, e2.map.consumerCache && (e2.map.consumerCache = undefined)), e2;
    }
    get from() {
      return this.file || this.id;
    }
  };
  no3.exports = Ye3;
  Ye3.default = Ye3;
  ni3 && ni3.registerInput && ni3.registerInput(Ye3);
});
var li2 = S3((Ib, uo3) => {
  var { SourceMapConsumer: so3, SourceMapGenerator: Er3 } = kr3(), { dirname: Cr3, relative: ao3, resolve: oo3, sep: lo3 } = (kt3(), $e2(St3)), { pathToFileURL: io3 } = (ei2(), $e2(Zn3)), ed = Et3(), td = Boolean(so3 && Er3), rd = Boolean(Cr3 && oo3 && ao3 && lo3), oi = class {
    constructor(e2, r2, n2, i) {
      this.stringify = e2, this.mapOpts = n2.map || {}, this.root = r2, this.opts = n2, this.css = i, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = new Map, this.memoizedPaths = new Map, this.memoizedURLs = new Map;
    }
    addAnnotation() {
      let e2;
      this.isInline() ? e2 = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e2 = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e2 = this.mapOpts.annotation(this.opts.to, this.root) : e2 = this.outputFile() + ".map";
      let r2 = `
`;
      this.css.includes(`\r
`) && (r2 = `\r
`), this.css += r2 + "/*# sourceMappingURL=" + e2 + " */";
    }
    applyPrevMaps() {
      for (let e2 of this.previous()) {
        let r2 = this.toUrl(this.path(e2.file)), n2 = e2.root || Cr3(e2.file), i;
        this.mapOpts.sourcesContent === false ? (i = new so3(e2.text), i.sourcesContent && (i.sourcesContent = i.sourcesContent.map(() => null))) : i = e2.consumer(), this.map.applySourceMap(i, r2, this.toUrl(this.path(n2)));
      }
    }
    clearAnnotation() {
      if (this.mapOpts.annotation !== false)
        if (this.root) {
          let e2;
          for (let r2 = this.root.nodes.length - 1;r2 >= 0; r2--)
            e2 = this.root.nodes[r2], e2.type === "comment" && e2.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(r2);
        } else
          this.css && (this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, ""));
    }
    generate() {
      if (this.clearAnnotation(), rd && td && this.isMap())
        return this.generateMap();
      {
        let e2 = "";
        return this.stringify(this.root, (r2) => {
          e2 += r2;
        }), [e2];
      }
    }
    generateMap() {
      if (this.root)
        this.generateString();
      else if (this.previous().length === 1) {
        let e2 = this.previous()[0].consumer();
        e2.file = this.outputFile(), this.map = Er3.fromSourceMap(e2);
      } else
        this.map = new Er3({ file: this.outputFile() }), this.map.addMapping({ generated: { column: 0, line: 1 }, original: { column: 0, line: 1 }, source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>" });
      return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
    }
    generateString() {
      this.css = "", this.map = new Er3({ file: this.outputFile() });
      let e2 = 1, r2 = 1, n2 = "<no source>", i = { generated: { column: 0, line: 0 }, original: { column: 0, line: 0 }, source: "" }, a, s3;
      this.stringify(this.root, (o2, l3, u) => {
        if (this.css += o2, l3 && u !== "end" && (i.generated.line = e2, i.generated.column = r2 - 1, l3.source && l3.source.start ? (i.source = this.sourcePath(l3), i.original.line = l3.source.start.line, i.original.column = l3.source.start.column - 1, this.map.addMapping(i)) : (i.source = n2, i.original.line = 1, i.original.column = 0, this.map.addMapping(i))), a = o2.match(/\n/g), a ? (e2 += a.length, s3 = o2.lastIndexOf(`
`), r2 = o2.length - s3) : r2 += o2.length, l3 && u !== "start") {
          let f = l3.parent || { raws: {} };
          (!(l3.type === "decl" || l3.type === "atrule" && !l3.nodes) || l3 !== f.last || f.raws.semicolon) && (l3.source && l3.source.end ? (i.source = this.sourcePath(l3), i.original.line = l3.source.end.line, i.original.column = l3.source.end.column - 1, i.generated.line = e2, i.generated.column = r2 - 2, this.map.addMapping(i)) : (i.source = n2, i.original.line = 1, i.original.column = 0, i.generated.line = e2, i.generated.column = r2 - 1, this.map.addMapping(i)));
        }
      });
    }
    isAnnotation() {
      return this.isInline() ? true : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e2) => e2.annotation) : true;
    }
    isInline() {
      if (typeof this.mapOpts.inline < "u")
        return this.mapOpts.inline;
      let e2 = this.mapOpts.annotation;
      return typeof e2 < "u" && e2 !== true ? false : this.previous().length ? this.previous().some((r2) => r2.inline) : true;
    }
    isMap() {
      return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
    }
    isSourcesContent() {
      return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e2) => e2.withContent()) : true;
    }
    outputFile() {
      return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
    }
    path(e2) {
      if (this.mapOpts.absolute || e2.charCodeAt(0) === 60 || /^\w+:\/\//.test(e2))
        return e2;
      let r2 = this.memoizedPaths.get(e2);
      if (r2)
        return r2;
      let n2 = this.opts.to ? Cr3(this.opts.to) : ".";
      typeof this.mapOpts.annotation == "string" && (n2 = Cr3(oo3(n2, this.mapOpts.annotation)));
      let i = ao3(n2, e2);
      return this.memoizedPaths.set(e2, i), i;
    }
    previous() {
      if (!this.previousMaps)
        if (this.previousMaps = [], this.root)
          this.root.walk((e2) => {
            if (e2.source && e2.source.input.map) {
              let r2 = e2.source.input.map;
              this.previousMaps.includes(r2) || this.previousMaps.push(r2);
            }
          });
        else {
          let e2 = new ed(this.css, this.opts);
          e2.map && this.previousMaps.push(e2.map);
        }
      return this.previousMaps;
    }
    setSourcesContent() {
      let e2 = {};
      if (this.root)
        this.root.walk((r2) => {
          if (r2.source) {
            let n2 = r2.source.input.from;
            if (n2 && !e2[n2]) {
              e2[n2] = true;
              let i = this.usesFileUrls ? this.toFileUrl(n2) : this.toUrl(this.path(n2));
              this.map.setSourceContent(i, r2.source.input.css);
            }
          }
        });
      else if (this.css) {
        let r2 = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
        this.map.setSourceContent(r2, this.css);
      }
    }
    sourcePath(e2) {
      return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e2.source.input.from) : this.toUrl(this.path(e2.source.input.from));
    }
    toBase64(e2) {
      return Buffer ? Buffer.from(e2).toString("base64") : window.btoa(unescape(encodeURIComponent(e2)));
    }
    toFileUrl(e2) {
      let r2 = this.memoizedFileURLs.get(e2);
      if (r2)
        return r2;
      if (io3) {
        let n2 = io3(e2).toString();
        return this.memoizedFileURLs.set(e2, n2), n2;
      } else
        throw new Error("`map.absolute` option is not available in this PostCSS build");
    }
    toUrl(e2) {
      let r2 = this.memoizedURLs.get(e2);
      if (r2)
        return r2;
      lo3 === "\\" && (e2 = e2.replace(/\\/g, "/"));
      let n2 = encodeURI(e2).replace(/[#?]/g, encodeURIComponent);
      return this.memoizedURLs.set(e2, n2), n2;
    }
  };
  uo3.exports = oi;
});
var At3 = S3((Rb, fo2) => {
  var nd = wt3(), Ct3 = class extends nd {
    constructor(e2) {
      super(e2), this.type = "comment";
    }
  };
  fo2.exports = Ct3;
  Ct3.default = Ct3;
});
var _e3 = S3((Db, bo2) => {
  var { isClean: co3, my: po3 } = xr3(), ho2 = xt3(), mo2 = At3(), id = wt3(), go2, ui2, fi2, yo2;
  function vo2(t9) {
    return t9.map((e2) => (e2.nodes && (e2.nodes = vo2(e2.nodes)), delete e2.source, e2));
  }
  function wo2(t9) {
    if (t9[co3] = false, t9.proxyOf.nodes)
      for (let e2 of t9.proxyOf.nodes)
        wo2(e2);
  }
  var ae3 = class extends id {
    append(...e2) {
      for (let r2 of e2) {
        let n2 = this.normalize(r2, this.last);
        for (let i of n2)
          this.proxyOf.nodes.push(i);
      }
      return this.markDirty(), this;
    }
    cleanRaws(e2) {
      if (super.cleanRaws(e2), this.nodes)
        for (let r2 of this.nodes)
          r2.cleanRaws(e2);
    }
    each(e2) {
      if (!this.proxyOf.nodes)
        return;
      let r2 = this.getIterator(), n2, i;
      for (;this.indexes[r2] < this.proxyOf.nodes.length && (n2 = this.indexes[r2], i = e2(this.proxyOf.nodes[n2], n2), i !== false); )
        this.indexes[r2] += 1;
      return delete this.indexes[r2], i;
    }
    every(e2) {
      return this.nodes.every(e2);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let e2 = this.lastEach;
      return this.indexes[e2] = 0, e2;
    }
    getProxyProcessor() {
      return { get(e2, r2) {
        return r2 === "proxyOf" ? e2 : e2[r2] ? r2 === "each" || typeof r2 == "string" && r2.startsWith("walk") ? (...n2) => e2[r2](...n2.map((i) => typeof i == "function" ? (a, s3) => i(a.toProxy(), s3) : i)) : r2 === "every" || r2 === "some" ? (n2) => e2[r2]((i, ...a) => n2(i.toProxy(), ...a)) : r2 === "root" ? () => e2.root().toProxy() : r2 === "nodes" ? e2.nodes.map((n2) => n2.toProxy()) : r2 === "first" || r2 === "last" ? e2[r2].toProxy() : e2[r2] : e2[r2];
      }, set(e2, r2, n2) {
        return e2[r2] === n2 || (e2[r2] = n2, (r2 === "name" || r2 === "params" || r2 === "selector") && e2.markDirty()), true;
      } };
    }
    index(e2) {
      return typeof e2 == "number" ? e2 : (e2.proxyOf && (e2 = e2.proxyOf), this.proxyOf.nodes.indexOf(e2));
    }
    insertAfter(e2, r2) {
      let n2 = this.index(e2), i = this.normalize(r2, this.proxyOf.nodes[n2]).reverse();
      n2 = this.index(e2);
      for (let s3 of i)
        this.proxyOf.nodes.splice(n2 + 1, 0, s3);
      let a;
      for (let s3 in this.indexes)
        a = this.indexes[s3], n2 < a && (this.indexes[s3] = a + i.length);
      return this.markDirty(), this;
    }
    insertBefore(e2, r2) {
      let n2 = this.index(e2), i = n2 === 0 ? "prepend" : false, a = this.normalize(r2, this.proxyOf.nodes[n2], i).reverse();
      n2 = this.index(e2);
      for (let o2 of a)
        this.proxyOf.nodes.splice(n2, 0, o2);
      let s3;
      for (let o2 in this.indexes)
        s3 = this.indexes[o2], n2 <= s3 && (this.indexes[o2] = s3 + a.length);
      return this.markDirty(), this;
    }
    normalize(e2, r2) {
      if (typeof e2 == "string")
        e2 = vo2(go2(e2).nodes);
      else if (Array.isArray(e2)) {
        e2 = e2.slice(0);
        for (let i of e2)
          i.parent && i.parent.removeChild(i, "ignore");
      } else if (e2.type === "root" && this.type !== "document") {
        e2 = e2.nodes.slice(0);
        for (let i of e2)
          i.parent && i.parent.removeChild(i, "ignore");
      } else if (e2.type)
        e2 = [e2];
      else if (e2.prop) {
        if (typeof e2.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof e2.value != "string" && (e2.value = String(e2.value)), e2 = [new ho2(e2)];
      } else if (e2.selector)
        e2 = [new ui2(e2)];
      else if (e2.name)
        e2 = [new fi2(e2)];
      else if (e2.text)
        e2 = [new mo2(e2)];
      else
        throw new Error("Unknown node type in node creation");
      return e2.map((i) => (i[po3] || ae3.rebuild(i), i = i.proxyOf, i.parent && i.parent.removeChild(i), i[co3] && wo2(i), typeof i.raws.before > "u" && r2 && typeof r2.raws.before < "u" && (i.raws.before = r2.raws.before.replace(/\S/g, "")), i.parent = this.proxyOf, i));
    }
    prepend(...e2) {
      e2 = e2.reverse();
      for (let r2 of e2) {
        let n2 = this.normalize(r2, this.first, "prepend").reverse();
        for (let i of n2)
          this.proxyOf.nodes.unshift(i);
        for (let i in this.indexes)
          this.indexes[i] = this.indexes[i] + n2.length;
      }
      return this.markDirty(), this;
    }
    push(e2) {
      return e2.parent = this, this.proxyOf.nodes.push(e2), this;
    }
    removeAll() {
      for (let e2 of this.proxyOf.nodes)
        e2.parent = undefined;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(e2) {
      e2 = this.index(e2), this.proxyOf.nodes[e2].parent = undefined, this.proxyOf.nodes.splice(e2, 1);
      let r2;
      for (let n2 in this.indexes)
        r2 = this.indexes[n2], r2 >= e2 && (this.indexes[n2] = r2 - 1);
      return this.markDirty(), this;
    }
    replaceValues(e2, r2, n2) {
      return n2 || (n2 = r2, r2 = {}), this.walkDecls((i) => {
        r2.props && !r2.props.includes(i.prop) || r2.fast && !i.value.includes(r2.fast) || (i.value = i.value.replace(e2, n2));
      }), this.markDirty(), this;
    }
    some(e2) {
      return this.nodes.some(e2);
    }
    walk(e2) {
      return this.each((r2, n2) => {
        let i;
        try {
          i = e2(r2, n2);
        } catch (a) {
          throw r2.addToError(a);
        }
        return i !== false && r2.walk && (i = r2.walk(e2)), i;
      });
    }
    walkAtRules(e2, r2) {
      return r2 ? e2 instanceof RegExp ? this.walk((n2, i) => {
        if (n2.type === "atrule" && e2.test(n2.name))
          return r2(n2, i);
      }) : this.walk((n2, i) => {
        if (n2.type === "atrule" && n2.name === e2)
          return r2(n2, i);
      }) : (r2 = e2, this.walk((n2, i) => {
        if (n2.type === "atrule")
          return r2(n2, i);
      }));
    }
    walkComments(e2) {
      return this.walk((r2, n2) => {
        if (r2.type === "comment")
          return e2(r2, n2);
      });
    }
    walkDecls(e2, r2) {
      return r2 ? e2 instanceof RegExp ? this.walk((n2, i) => {
        if (n2.type === "decl" && e2.test(n2.prop))
          return r2(n2, i);
      }) : this.walk((n2, i) => {
        if (n2.type === "decl" && n2.prop === e2)
          return r2(n2, i);
      }) : (r2 = e2, this.walk((n2, i) => {
        if (n2.type === "decl")
          return r2(n2, i);
      }));
    }
    walkRules(e2, r2) {
      return r2 ? e2 instanceof RegExp ? this.walk((n2, i) => {
        if (n2.type === "rule" && e2.test(n2.selector))
          return r2(n2, i);
      }) : this.walk((n2, i) => {
        if (n2.type === "rule" && n2.selector === e2)
          return r2(n2, i);
      }) : (r2 = e2, this.walk((n2, i) => {
        if (n2.type === "rule")
          return r2(n2, i);
      }));
    }
    get first() {
      if (!!this.proxyOf.nodes)
        return this.proxyOf.nodes[0];
    }
    get last() {
      if (!!this.proxyOf.nodes)
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
  };
  ae3.registerParse = (t9) => {
    go2 = t9;
  };
  ae3.registerRule = (t9) => {
    ui2 = t9;
  };
  ae3.registerAtRule = (t9) => {
    fi2 = t9;
  };
  ae3.registerRoot = (t9) => {
    yo2 = t9;
  };
  bo2.exports = ae3;
  ae3.default = ae3;
  ae3.rebuild = (t9) => {
    t9.type === "atrule" ? Object.setPrototypeOf(t9, fi2.prototype) : t9.type === "rule" ? Object.setPrototypeOf(t9, ui2.prototype) : t9.type === "decl" ? Object.setPrototypeOf(t9, ho2.prototype) : t9.type === "comment" ? Object.setPrototypeOf(t9, mo2.prototype) : t9.type === "root" && Object.setPrototypeOf(t9, yo2.prototype), t9[po3] = true, t9.nodes && t9.nodes.forEach((e2) => {
      ae3.rebuild(e2);
    });
  };
});
var Ar3 = S3((Mb, ko2) => {
  var sd = _e3(), xo2, So2, je3 = class extends sd {
    constructor(e2) {
      super({ type: "document", ...e2 }), this.nodes || (this.nodes = []);
    }
    toResult(e2 = {}) {
      return new xo2(new So2, this, e2).stringify();
    }
  };
  je3.registerLazyResult = (t9) => {
    xo2 = t9;
  };
  je3.registerProcessor = (t9) => {
    So2 = t9;
  };
  ko2.exports = je3;
  je3.default = je3;
});
var ci2 = S3((Fb, Eo2) => {
  var Oo3 = {};
  Eo2.exports = function(e2) {
    Oo3[e2] || (Oo3[e2] = true, typeof console < "u" && console.warn && console.warn(e2));
  };
});
var pi2 = S3((Lb, Co) => {
  var _t3 = class {
    constructor(e2, r2 = {}) {
      if (this.type = "warning", this.text = e2, r2.node && r2.node.source) {
        let n2 = r2.node.rangeBy(r2);
        this.line = n2.start.line, this.column = n2.start.column, this.endLine = n2.end.line, this.endColumn = n2.end.column;
      }
      for (let n2 in r2)
        this[n2] = r2[n2];
    }
    toString() {
      return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  };
  Co.exports = _t3;
  _t3.default = _t3;
});
var _r3 = S3((Nb, Ao2) => {
  var ad = pi2(), Tt3 = class {
    constructor(e2, r2, n2) {
      this.processor = e2, this.messages = [], this.root = r2, this.opts = n2, this.css = undefined, this.map = undefined;
    }
    toString() {
      return this.css;
    }
    warn(e2, r2 = {}) {
      r2.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (r2.plugin = this.lastPlugin.postcssPlugin);
      let n2 = new ad(e2, r2);
      return this.messages.push(n2), n2;
    }
    warnings() {
      return this.messages.filter((e2) => e2.type === "warning");
    }
    get content() {
      return this.css;
    }
  };
  Ao2.exports = Tt3;
  Tt3.default = Tt3;
});
var Ro3 = S3((qb, Io3) => {
  var di2 = "'".charCodeAt(0), _o2 = '"'.charCodeAt(0), Tr3 = "\\".charCodeAt(0), To2 = "/".charCodeAt(0), Pr3 = `
`.charCodeAt(0), Pt3 = " ".charCodeAt(0), Ir3 = "\f".charCodeAt(0), Rr3 = "	".charCodeAt(0), Dr3 = "\r".charCodeAt(0), od = "[".charCodeAt(0), ld = "]".charCodeAt(0), ud = "(".charCodeAt(0), fd = ")".charCodeAt(0), cd = "{".charCodeAt(0), pd = "}".charCodeAt(0), dd = ";".charCodeAt(0), hd = "*".charCodeAt(0), md = ":".charCodeAt(0), gd = "@".charCodeAt(0), Mr2 = /[\t\n\f\r "#'()/;[\\\]{}]/g, Fr3 = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, yd = /.[\r\n"'(/\\]/, Po2 = /[\da-f]/i;
  Io3.exports = function(e2, r2 = {}) {
    let n2 = e2.css.valueOf(), i = r2.ignoreErrors, a, s3, o2, l3, u, f, p, c2, d2, h2, y2 = n2.length, m = 0, g2 = [], w3 = [];
    function b4() {
      return m;
    }
    function v3(E2) {
      throw e2.error("Unclosed " + E2, m);
    }
    function O3() {
      return w3.length === 0 && m >= y2;
    }
    function x(E2) {
      if (w3.length)
        return w3.pop();
      if (m >= y2)
        return;
      let I3 = E2 ? E2.ignoreUnclosed : false;
      switch (a = n2.charCodeAt(m), a) {
        case Pr3:
        case Pt3:
        case Rr3:
        case Dr3:
        case Ir3: {
          s3 = m;
          do
            s3 += 1, a = n2.charCodeAt(s3);
          while (a === Pt3 || a === Pr3 || a === Rr3 || a === Dr3 || a === Ir3);
          h2 = ["space", n2.slice(m, s3)], m = s3 - 1;
          break;
        }
        case od:
        case ld:
        case cd:
        case pd:
        case md:
        case dd:
        case fd: {
          let F = String.fromCharCode(a);
          h2 = [F, F, m];
          break;
        }
        case ud: {
          if (c2 = g2.length ? g2.pop()[1] : "", d2 = n2.charCodeAt(m + 1), c2 === "url" && d2 !== di2 && d2 !== _o2 && d2 !== Pt3 && d2 !== Pr3 && d2 !== Rr3 && d2 !== Ir3 && d2 !== Dr3) {
            s3 = m;
            do {
              if (f = false, s3 = n2.indexOf(")", s3 + 1), s3 === -1)
                if (i || I3) {
                  s3 = m;
                  break;
                } else
                  v3("bracket");
              for (p = s3;n2.charCodeAt(p - 1) === Tr3; )
                p -= 1, f = !f;
            } while (f);
            h2 = ["brackets", n2.slice(m, s3 + 1), m, s3], m = s3;
          } else
            s3 = n2.indexOf(")", m + 1), l3 = n2.slice(m, s3 + 1), s3 === -1 || yd.test(l3) ? h2 = ["(", "(", m] : (h2 = ["brackets", l3, m, s3], m = s3);
          break;
        }
        case di2:
        case _o2: {
          o2 = a === di2 ? "'" : '"', s3 = m;
          do {
            if (f = false, s3 = n2.indexOf(o2, s3 + 1), s3 === -1)
              if (i || I3) {
                s3 = m + 1;
                break;
              } else
                v3("string");
            for (p = s3;n2.charCodeAt(p - 1) === Tr3; )
              p -= 1, f = !f;
          } while (f);
          h2 = ["string", n2.slice(m, s3 + 1), m, s3], m = s3;
          break;
        }
        case gd: {
          Mr2.lastIndex = m + 1, Mr2.test(n2), Mr2.lastIndex === 0 ? s3 = n2.length - 1 : s3 = Mr2.lastIndex - 2, h2 = ["at-word", n2.slice(m, s3 + 1), m, s3], m = s3;
          break;
        }
        case Tr3: {
          for (s3 = m, u = true;n2.charCodeAt(s3 + 1) === Tr3; )
            s3 += 1, u = !u;
          if (a = n2.charCodeAt(s3 + 1), u && a !== To2 && a !== Pt3 && a !== Pr3 && a !== Rr3 && a !== Dr3 && a !== Ir3 && (s3 += 1, Po2.test(n2.charAt(s3)))) {
            for (;Po2.test(n2.charAt(s3 + 1)); )
              s3 += 1;
            n2.charCodeAt(s3 + 1) === Pt3 && (s3 += 1);
          }
          h2 = ["word", n2.slice(m, s3 + 1), m, s3], m = s3;
          break;
        }
        default: {
          a === To2 && n2.charCodeAt(m + 1) === hd ? (s3 = n2.indexOf("*/", m + 2) + 1, s3 === 0 && (i || I3 ? s3 = n2.length : v3("comment")), h2 = ["comment", n2.slice(m, s3 + 1), m, s3], m = s3) : (Fr3.lastIndex = m + 1, Fr3.test(n2), Fr3.lastIndex === 0 ? s3 = n2.length - 1 : s3 = Fr3.lastIndex - 2, h2 = ["word", n2.slice(m, s3 + 1), m, s3], g2.push(h2), m = s3);
          break;
        }
      }
      return m++, h2;
    }
    function A(E2) {
      w3.push(E2);
    }
    return { back: A, endOfFile: O3, nextToken: x, position: b4 };
  };
});
var Lr3 = S3(($b, Mo3) => {
  var Do2 = _e3(), He3 = class extends Do2 {
    constructor(e2) {
      super(e2), this.type = "atrule";
    }
    append(...e2) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...e2);
    }
    prepend(...e2) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e2);
    }
  };
  Mo3.exports = He3;
  He3.default = He3;
  Do2.registerAtRule(He3);
});
var Qe3 = S3((Ub, qo3) => {
  var Fo2 = _e3(), Lo, No2, Te3 = class extends Fo2 {
    constructor(e2) {
      super(e2), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(e2, r2, n2) {
      let i = super.normalize(e2);
      if (r2) {
        if (n2 === "prepend")
          this.nodes.length > 1 ? r2.raws.before = this.nodes[1].raws.before : delete r2.raws.before;
        else if (this.first !== r2)
          for (let a of i)
            a.raws.before = r2.raws.before;
      }
      return i;
    }
    removeChild(e2, r2) {
      let n2 = this.index(e2);
      return !r2 && n2 === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[n2].raws.before), super.removeChild(e2);
    }
    toResult(e2 = {}) {
      return new Lo(new No2, this, e2).stringify();
    }
  };
  Te3.registerLazyResult = (t9) => {
    Lo = t9;
  };
  Te3.registerProcessor = (t9) => {
    No2 = t9;
  };
  qo3.exports = Te3;
  Te3.default = Te3;
  Fo2.registerRoot(Te3);
});
var hi2 = S3((jb, $o3) => {
  var It3 = { comma(t9) {
    return It3.split(t9, [","], true);
  }, space(t9) {
    let e2 = [" ", `
`, "	"];
    return It3.split(t9, e2);
  }, split(t9, e2, r2) {
    let n2 = [], i = "", a = false, s3 = 0, o2 = false, l3 = "", u = false;
    for (let f of t9)
      u ? u = false : f === "\\" ? u = true : o2 ? f === l3 && (o2 = false) : f === '"' || f === "'" ? (o2 = true, l3 = f) : f === "(" ? s3 += 1 : f === ")" ? s3 > 0 && (s3 -= 1) : s3 === 0 && e2.includes(f) && (a = true), a ? (i !== "" && n2.push(i.trim()), i = "", a = false) : i += f;
    return (r2 || i !== "") && n2.push(i.trim()), n2;
  } };
  $o3.exports = It3;
  It3.default = It3;
});
var Nr3 = S3((zb, jo3) => {
  var Uo3 = _e3(), vd = hi2(), Je3 = class extends Uo3 {
    constructor(e2) {
      super(e2), this.type = "rule", this.nodes || (this.nodes = []);
    }
    get selectors() {
      return vd.comma(this.selector);
    }
    set selectors(e2) {
      let r2 = this.selector ? this.selector.match(/,\s*/) : null, n2 = r2 ? r2[0] : "," + this.raw("between", "beforeOpen");
      this.selector = e2.join(n2);
    }
  };
  jo3.exports = Je3;
  Je3.default = Je3;
  Uo3.registerRule(Je3);
});
var Bo2 = S3((Vb, Wo3) => {
  var wd = xt3(), bd = Ro3(), xd = At3(), Sd = Lr3(), kd = Qe3(), zo3 = Nr3(), Vo3 = { empty: true, space: true };
  function Od(t9) {
    for (let e2 = t9.length - 1;e2 >= 0; e2--) {
      let r2 = t9[e2], n2 = r2[3] || r2[2];
      if (n2)
        return n2;
    }
  }
  var mi2 = class {
    constructor(e2) {
      this.input = e2, this.root = new kd, this.current = this.root, this.spaces = "", this.semicolon = false, this.customProperty = false, this.createTokenizer(), this.root.source = { input: e2, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(e2) {
      let r2 = new Sd;
      r2.name = e2[1].slice(1), r2.name === "" && this.unnamedAtrule(r2, e2), this.init(r2, e2[2]);
      let n2, i, a, s3 = false, o2 = false, l3 = [], u = [];
      for (;!this.tokenizer.endOfFile(); ) {
        if (e2 = this.tokenizer.nextToken(), n2 = e2[0], n2 === "(" || n2 === "[" ? u.push(n2 === "(" ? ")" : "]") : n2 === "{" && u.length > 0 ? u.push("}") : n2 === u[u.length - 1] && u.pop(), u.length === 0)
          if (n2 === ";") {
            r2.source.end = this.getPosition(e2[2]), r2.source.end.offset++, this.semicolon = true;
            break;
          } else if (n2 === "{") {
            o2 = true;
            break;
          } else if (n2 === "}") {
            if (l3.length > 0) {
              for (a = l3.length - 1, i = l3[a];i && i[0] === "space"; )
                i = l3[--a];
              i && (r2.source.end = this.getPosition(i[3] || i[2]), r2.source.end.offset++);
            }
            this.end(e2);
            break;
          } else
            l3.push(e2);
        else
          l3.push(e2);
        if (this.tokenizer.endOfFile()) {
          s3 = true;
          break;
        }
      }
      r2.raws.between = this.spacesAndCommentsFromEnd(l3), l3.length ? (r2.raws.afterName = this.spacesAndCommentsFromStart(l3), this.raw(r2, "params", l3), s3 && (e2 = l3[l3.length - 1], r2.source.end = this.getPosition(e2[3] || e2[2]), r2.source.end.offset++, this.spaces = r2.raws.between, r2.raws.between = "")) : (r2.raws.afterName = "", r2.params = ""), o2 && (r2.nodes = [], this.current = r2);
    }
    checkMissedSemicolon(e2) {
      let r2 = this.colon(e2);
      if (r2 === false)
        return;
      let n2 = 0, i;
      for (let a = r2 - 1;a >= 0 && (i = e2[a], !(i[0] !== "space" && (n2 += 1, n2 === 2))); a--)
        ;
      throw this.input.error("Missed semicolon", i[0] === "word" ? i[3] + 1 : i[2]);
    }
    colon(e2) {
      let r2 = 0, n2, i, a;
      for (let [s3, o2] of e2.entries()) {
        if (n2 = o2, i = n2[0], i === "(" && (r2 += 1), i === ")" && (r2 -= 1), r2 === 0 && i === ":")
          if (!a)
            this.doubleColon(n2);
          else {
            if (a[0] === "word" && a[1] === "progid")
              continue;
            return s3;
          }
        a = n2;
      }
      return false;
    }
    comment(e2) {
      let r2 = new xd;
      this.init(r2, e2[2]), r2.source.end = this.getPosition(e2[3] || e2[2]), r2.source.end.offset++;
      let n2 = e2[1].slice(2, -2);
      if (/^\s*$/.test(n2))
        r2.text = "", r2.raws.left = n2, r2.raws.right = "";
      else {
        let i = n2.match(/^(\s*)([^]*\S)(\s*)$/);
        r2.text = i[2], r2.raws.left = i[1], r2.raws.right = i[3];
      }
    }
    createTokenizer() {
      this.tokenizer = bd(this.input);
    }
    decl(e2, r2) {
      let n2 = new wd;
      this.init(n2, e2[0][2]);
      let i = e2[e2.length - 1];
      for (i[0] === ";" && (this.semicolon = true, e2.pop()), n2.source.end = this.getPosition(i[3] || i[2] || Od(e2)), n2.source.end.offset++;e2[0][0] !== "word"; )
        e2.length === 1 && this.unknownWord(e2), n2.raws.before += e2.shift()[1];
      for (n2.source.start = this.getPosition(e2[0][2]), n2.prop = "";e2.length; ) {
        let u = e2[0][0];
        if (u === ":" || u === "space" || u === "comment")
          break;
        n2.prop += e2.shift()[1];
      }
      n2.raws.between = "";
      let a;
      for (;e2.length; )
        if (a = e2.shift(), a[0] === ":") {
          n2.raws.between += a[1];
          break;
        } else
          a[0] === "word" && /\w/.test(a[1]) && this.unknownWord([a]), n2.raws.between += a[1];
      (n2.prop[0] === "_" || n2.prop[0] === "*") && (n2.raws.before += n2.prop[0], n2.prop = n2.prop.slice(1));
      let s3 = [], o2;
      for (;e2.length && (o2 = e2[0][0], !(o2 !== "space" && o2 !== "comment")); )
        s3.push(e2.shift());
      this.precheckMissedSemicolon(e2);
      for (let u = e2.length - 1;u >= 0; u--) {
        if (a = e2[u], a[1].toLowerCase() === "!important") {
          n2.important = true;
          let f = this.stringFrom(e2, u);
          f = this.spacesFromEnd(e2) + f, f !== " !important" && (n2.raws.important = f);
          break;
        } else if (a[1].toLowerCase() === "important") {
          let f = e2.slice(0), p = "";
          for (let c2 = u;c2 > 0; c2--) {
            let d2 = f[c2][0];
            if (p.trim().indexOf("!") === 0 && d2 !== "space")
              break;
            p = f.pop()[1] + p;
          }
          p.trim().indexOf("!") === 0 && (n2.important = true, n2.raws.important = p, e2 = f);
        }
        if (a[0] !== "space" && a[0] !== "comment")
          break;
      }
      e2.some((u) => u[0] !== "space" && u[0] !== "comment") && (n2.raws.between += s3.map((u) => u[1]).join(""), s3 = []), this.raw(n2, "value", s3.concat(e2), r2), n2.value.includes(":") && !r2 && this.checkMissedSemicolon(e2);
    }
    doubleColon(e2) {
      throw this.input.error("Double colon", { offset: e2[2] }, { offset: e2[2] + e2[1].length });
    }
    emptyRule(e2) {
      let r2 = new zo3;
      this.init(r2, e2[2]), r2.selector = "", r2.raws.between = "", this.current = r2;
    }
    end(e2) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e2[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e2);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(e2) {
      if (this.spaces += e2[1], this.current.nodes) {
        let r2 = this.current.nodes[this.current.nodes.length - 1];
        r2 && r2.type === "rule" && !r2.raws.ownSemicolon && (r2.raws.ownSemicolon = this.spaces, this.spaces = "");
      }
    }
    getPosition(e2) {
      let r2 = this.input.fromOffset(e2);
      return { column: r2.col, line: r2.line, offset: e2 };
    }
    init(e2, r2) {
      this.current.push(e2), e2.source = { input: this.input, start: this.getPosition(r2) }, e2.raws.before = this.spaces, this.spaces = "", e2.type !== "comment" && (this.semicolon = false);
    }
    other(e2) {
      let r2 = false, n2 = null, i = false, a = null, s3 = [], o2 = e2[1].startsWith("--"), l3 = [], u = e2;
      for (;u; ) {
        if (n2 = u[0], l3.push(u), n2 === "(" || n2 === "[")
          a || (a = u), s3.push(n2 === "(" ? ")" : "]");
        else if (o2 && i && n2 === "{")
          a || (a = u), s3.push("}");
        else if (s3.length === 0)
          if (n2 === ";")
            if (i) {
              this.decl(l3, o2);
              return;
            } else
              break;
          else if (n2 === "{") {
            this.rule(l3);
            return;
          } else if (n2 === "}") {
            this.tokenizer.back(l3.pop()), r2 = true;
            break;
          } else
            n2 === ":" && (i = true);
        else
          n2 === s3[s3.length - 1] && (s3.pop(), s3.length === 0 && (a = null));
        u = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (r2 = true), s3.length > 0 && this.unclosedBracket(a), r2 && i) {
        if (!o2)
          for (;l3.length && (u = l3[l3.length - 1][0], !(u !== "space" && u !== "comment")); )
            this.tokenizer.back(l3.pop());
        this.decl(l3, o2);
      } else
        this.unknownWord(l3);
    }
    parse() {
      let e2;
      for (;!this.tokenizer.endOfFile(); )
        switch (e2 = this.tokenizer.nextToken(), e2[0]) {
          case "space":
            this.spaces += e2[1];
            break;
          case ";":
            this.freeSemicolon(e2);
            break;
          case "}":
            this.end(e2);
            break;
          case "comment":
            this.comment(e2);
            break;
          case "at-word":
            this.atrule(e2);
            break;
          case "{":
            this.emptyRule(e2);
            break;
          default:
            this.other(e2);
            break;
        }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(e2, r2, n2, i) {
      let a, s3, o2 = n2.length, l3 = "", u = true, f, p;
      for (let c2 = 0;c2 < o2; c2 += 1)
        a = n2[c2], s3 = a[0], s3 === "space" && c2 === o2 - 1 && !i ? u = false : s3 === "comment" ? (p = n2[c2 - 1] ? n2[c2 - 1][0] : "empty", f = n2[c2 + 1] ? n2[c2 + 1][0] : "empty", !Vo3[p] && !Vo3[f] ? l3.slice(-1) === "," ? u = false : l3 += a[1] : u = false) : l3 += a[1];
      if (!u) {
        let c2 = n2.reduce((d2, h2) => d2 + h2[1], "");
        e2.raws[r2] = { raw: c2, value: l3 };
      }
      e2[r2] = l3;
    }
    rule(e2) {
      e2.pop();
      let r2 = new zo3;
      this.init(r2, e2[0][2]), r2.raws.between = this.spacesAndCommentsFromEnd(e2), this.raw(r2, "selector", e2), this.current = r2;
    }
    spacesAndCommentsFromEnd(e2) {
      let r2, n2 = "";
      for (;e2.length && (r2 = e2[e2.length - 1][0], !(r2 !== "space" && r2 !== "comment")); )
        n2 = e2.pop()[1] + n2;
      return n2;
    }
    spacesAndCommentsFromStart(e2) {
      let r2, n2 = "";
      for (;e2.length && (r2 = e2[0][0], !(r2 !== "space" && r2 !== "comment")); )
        n2 += e2.shift()[1];
      return n2;
    }
    spacesFromEnd(e2) {
      let r2, n2 = "";
      for (;e2.length && (r2 = e2[e2.length - 1][0], r2 === "space"); )
        n2 = e2.pop()[1] + n2;
      return n2;
    }
    stringFrom(e2, r2) {
      let n2 = "";
      for (let i = r2;i < e2.length; i++)
        n2 += e2[i][1];
      return e2.splice(r2, e2.length - r2), n2;
    }
    unclosedBlock() {
      let e2 = this.current.source.start;
      throw this.input.error("Unclosed block", e2.line, e2.column);
    }
    unclosedBracket(e2) {
      throw this.input.error("Unclosed bracket", { offset: e2[2] }, { offset: e2[2] + 1 });
    }
    unexpectedClose(e2) {
      throw this.input.error("Unexpected }", { offset: e2[2] }, { offset: e2[2] + 1 });
    }
    unknownWord(e2) {
      throw this.input.error("Unknown word", { offset: e2[0][2] }, { offset: e2[0][2] + e2[0][1].length });
    }
    unnamedAtrule(e2, r2) {
      throw this.input.error("At-rule without name", { offset: r2[2] }, { offset: r2[2] + r2[1].length });
    }
  };
  Wo3.exports = mi2;
});
var $r3 = S3((Wb, Go3) => {
  var Ed = _e3(), Cd = Bo2(), Ad = Et3();
  function qr2(t9, e2) {
    let r2 = new Ad(t9, e2), n2 = new Cd(r2);
    try {
      n2.parse();
    } catch (i) {
      throw i;
    }
    return n2.root;
  }
  Go3.exports = qr2;
  qr2.default = qr2;
  Ed.registerParse(qr2);
});
var vi2 = S3((Gb, Jo3) => {
  var { isClean: me3, my: _d } = xr3(), Td = li2(), Pd = yt3(), Id = _e3(), Rd = Ar3(), Bb = ci2(), Yo3 = _r3(), Dd = $r3(), Md = Qe3(), Fd = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" }, Ld = { AtRule: true, AtRuleExit: true, Comment: true, CommentExit: true, Declaration: true, DeclarationExit: true, Document: true, DocumentExit: true, Once: true, OnceExit: true, postcssPlugin: true, prepare: true, Root: true, RootExit: true, Rule: true, RuleExit: true }, Nd = { Once: true, postcssPlugin: true, prepare: true }, Xe3 = 0;
  function Rt3(t9) {
    return typeof t9 == "object" && typeof t9.then == "function";
  }
  function Qo3(t9) {
    let e2 = false, r2 = Fd[t9.type];
    return t9.type === "decl" ? e2 = t9.prop.toLowerCase() : t9.type === "atrule" && (e2 = t9.name.toLowerCase()), e2 && t9.append ? [r2, r2 + "-" + e2, Xe3, r2 + "Exit", r2 + "Exit-" + e2] : e2 ? [r2, r2 + "-" + e2, r2 + "Exit", r2 + "Exit-" + e2] : t9.append ? [r2, Xe3, r2 + "Exit"] : [r2, r2 + "Exit"];
  }
  function Ho3(t9) {
    let e2;
    return t9.type === "document" ? e2 = ["Document", Xe3, "DocumentExit"] : t9.type === "root" ? e2 = ["Root", Xe3, "RootExit"] : e2 = Qo3(t9), { eventIndex: 0, events: e2, iterator: 0, node: t9, visitorIndex: 0, visitors: [] };
  }
  function gi2(t9) {
    return t9[me3] = false, t9.nodes && t9.nodes.forEach((e2) => gi2(e2)), t9;
  }
  var yi2 = {}, ge3 = class {
    constructor(e2, r2, n2) {
      this.stringified = false, this.processed = false;
      let i;
      if (typeof r2 == "object" && r2 !== null && (r2.type === "root" || r2.type === "document"))
        i = gi2(r2);
      else if (r2 instanceof ge3 || r2 instanceof Yo3)
        i = gi2(r2.root), r2.map && (typeof n2.map > "u" && (n2.map = {}), n2.map.inline || (n2.map.inline = false), n2.map.prev = r2.map);
      else {
        let a = Dd;
        n2.syntax && (a = n2.syntax.parse), n2.parser && (a = n2.parser), a.parse && (a = a.parse);
        try {
          i = a(r2, n2);
        } catch (s3) {
          this.processed = true, this.error = s3;
        }
        i && !i[_d] && Id.rebuild(i);
      }
      this.result = new Yo3(e2, i, n2), this.helpers = { ...yi2, postcss: yi2, result: this.result }, this.plugins = this.processor.plugins.map((a) => typeof a == "object" && a.prepare ? { ...a, ...a.prepare(this.result) } : a);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(e2) {
      return this.async().catch(e2);
    }
    finally(e2) {
      return this.async().then(e2, e2);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(e2, r2) {
      let n2 = this.result.lastPlugin;
      try {
        r2 && r2.addToError(e2), this.error = e2, e2.name === "CssSyntaxError" && !e2.plugin ? (e2.plugin = n2.postcssPlugin, e2.setMessage()) : n2.postcssVersion;
      } catch (i) {
        console && console.error && console.error(i);
      }
      return e2;
    }
    prepareVisitors() {
      this.listeners = {};
      let e2 = (r2, n2, i) => {
        this.listeners[n2] || (this.listeners[n2] = []), this.listeners[n2].push([r2, i]);
      };
      for (let r2 of this.plugins)
        if (typeof r2 == "object")
          for (let n2 in r2) {
            if (!Ld[n2] && /^[A-Z]/.test(n2))
              throw new Error(`Unknown event ${n2} in ${r2.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
            if (!Nd[n2])
              if (typeof r2[n2] == "object")
                for (let i in r2[n2])
                  i === "*" ? e2(r2, n2, r2[n2][i]) : e2(r2, n2 + "-" + i.toLowerCase(), r2[n2][i]);
              else
                typeof r2[n2] == "function" && e2(r2, n2, r2[n2]);
          }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let e2 = 0;e2 < this.plugins.length; e2++) {
        let r2 = this.plugins[e2], n2 = this.runOnRoot(r2);
        if (Rt3(n2))
          try {
            await n2;
          } catch (i) {
            throw this.handleError(i);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e2 = this.result.root;
        for (;!e2[me3]; ) {
          e2[me3] = true;
          let r2 = [Ho3(e2)];
          for (;r2.length > 0; ) {
            let n2 = this.visitTick(r2);
            if (Rt3(n2))
              try {
                await n2;
              } catch (i) {
                let a = r2[r2.length - 1].node;
                throw this.handleError(i, a);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [r2, n2] of this.listeners.OnceExit) {
            this.result.lastPlugin = r2;
            try {
              if (e2.type === "document") {
                let i = e2.nodes.map((a) => n2(a, this.helpers));
                await Promise.all(i);
              } else
                await n2(e2, this.helpers);
            } catch (i) {
              throw this.handleError(i);
            }
          }
      }
      return this.processed = true, this.stringify();
    }
    runOnRoot(e2) {
      this.result.lastPlugin = e2;
      try {
        if (typeof e2 == "object" && e2.Once) {
          if (this.result.root.type === "document") {
            let r2 = this.result.root.nodes.map((n2) => e2.Once(n2, this.helpers));
            return Rt3(r2[0]) ? Promise.all(r2) : r2;
          }
          return e2.Once(this.result.root, this.helpers);
        } else if (typeof e2 == "function")
          return e2(this.result.root, this.result);
      } catch (r2) {
        throw this.handleError(r2);
      }
    }
    stringify() {
      if (this.error)
        throw this.error;
      if (this.stringified)
        return this.result;
      this.stringified = true, this.sync();
      let e2 = this.result.opts, r2 = Pd;
      e2.syntax && (r2 = e2.syntax.stringify), e2.stringifier && (r2 = e2.stringifier), r2.stringify && (r2 = r2.stringify);
      let i = new Td(r2, this.result.root, this.result.opts).generate();
      return this.result.css = i[0], this.result.map = i[1], this.result;
    }
    sync() {
      if (this.error)
        throw this.error;
      if (this.processed)
        return this.result;
      if (this.processed = true, this.processing)
        throw this.getAsyncError();
      for (let e2 of this.plugins) {
        let r2 = this.runOnRoot(e2);
        if (Rt3(r2))
          throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e2 = this.result.root;
        for (;!e2[me3]; )
          e2[me3] = true, this.walkSync(e2);
        if (this.listeners.OnceExit)
          if (e2.type === "document")
            for (let r2 of e2.nodes)
              this.visitSync(this.listeners.OnceExit, r2);
          else
            this.visitSync(this.listeners.OnceExit, e2);
      }
      return this.result;
    }
    then(e2, r2) {
      return this.async().then(e2, r2);
    }
    toString() {
      return this.css;
    }
    visitSync(e2, r2) {
      for (let [n2, i] of e2) {
        this.result.lastPlugin = n2;
        let a;
        try {
          a = i(r2, this.helpers);
        } catch (s3) {
          throw this.handleError(s3, r2.proxyOf);
        }
        if (r2.type !== "root" && r2.type !== "document" && !r2.parent)
          return true;
        if (Rt3(a))
          throw this.getAsyncError();
      }
    }
    visitTick(e2) {
      let r2 = e2[e2.length - 1], { node: n2, visitors: i } = r2;
      if (n2.type !== "root" && n2.type !== "document" && !n2.parent) {
        e2.pop();
        return;
      }
      if (i.length > 0 && r2.visitorIndex < i.length) {
        let [s3, o2] = i[r2.visitorIndex];
        r2.visitorIndex += 1, r2.visitorIndex === i.length && (r2.visitors = [], r2.visitorIndex = 0), this.result.lastPlugin = s3;
        try {
          return o2(n2.toProxy(), this.helpers);
        } catch (l3) {
          throw this.handleError(l3, n2);
        }
      }
      if (r2.iterator !== 0) {
        let s3 = r2.iterator, o2;
        for (;o2 = n2.nodes[n2.indexes[s3]]; )
          if (n2.indexes[s3] += 1, !o2[me3]) {
            o2[me3] = true, e2.push(Ho3(o2));
            return;
          }
        r2.iterator = 0, delete n2.indexes[s3];
      }
      let a = r2.events;
      for (;r2.eventIndex < a.length; ) {
        let s3 = a[r2.eventIndex];
        if (r2.eventIndex += 1, s3 === Xe3) {
          n2.nodes && n2.nodes.length && (n2[me3] = true, r2.iterator = n2.getIterator());
          return;
        } else if (this.listeners[s3]) {
          r2.visitors = this.listeners[s3];
          return;
        }
      }
      e2.pop();
    }
    walkSync(e2) {
      e2[me3] = true;
      let r2 = Qo3(e2);
      for (let n2 of r2)
        if (n2 === Xe3)
          e2.nodes && e2.each((i) => {
            i[me3] || this.walkSync(i);
          });
        else {
          let i = this.listeners[n2];
          if (i && this.visitSync(i, e2.toProxy()))
            return;
        }
    }
    warnings() {
      return this.sync().warnings();
    }
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
  };
  ge3.registerPostcss = (t9) => {
    yi2 = t9;
  };
  Jo3.exports = ge3;
  ge3.default = ge3;
  Md.registerLazyResult(ge3);
  Rd.registerLazyResult(ge3);
});
var Ko3 = S3((Hb, Xo3) => {
  var qd = li2(), $d = yt3(), Yb = ci2(), Ud = $r3(), jd = _r3(), Dt3 = class {
    constructor(e2, r2, n2) {
      r2 = r2.toString(), this.stringified = false, this._processor = e2, this._css = r2, this._opts = n2, this._map = undefined;
      let i, a = $d;
      this.result = new jd(this._processor, i, this._opts), this.result.css = r2;
      let s3 = this;
      Object.defineProperty(this.result, "root", { get() {
        return s3.root;
      } });
      let o2 = new qd(a, i, this._opts, r2);
      if (o2.isMap()) {
        let [l3, u] = o2.generate();
        l3 && (this.result.css = l3), u && (this.result.map = u);
      }
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(e2) {
      return this.async().catch(e2);
    }
    finally(e2) {
      return this.async().then(e2, e2);
    }
    sync() {
      if (this.error)
        throw this.error;
      return this.result;
    }
    then(e2, r2) {
      return this.async().then(e2, r2);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root)
        return this._root;
      let e2, r2 = Ud;
      try {
        e2 = r2(this._css, this._opts);
      } catch (n2) {
        this.error = n2;
      }
      if (this.error)
        throw this.error;
      return this._root = e2, e2;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
  };
  Xo3.exports = Dt3;
  Dt3.default = Dt3;
});
var el = S3((Qb, Zo3) => {
  var zd = Ko3(), Vd = vi2(), Wd = Ar3(), Bd = Qe3(), ze3 = class {
    constructor(e2 = []) {
      this.version = "8.4.31", this.plugins = this.normalize(e2);
    }
    normalize(e2) {
      let r2 = [];
      for (let n2 of e2)
        if (n2.postcss === true ? n2 = n2() : n2.postcss && (n2 = n2.postcss), typeof n2 == "object" && Array.isArray(n2.plugins))
          r2 = r2.concat(n2.plugins);
        else if (typeof n2 == "object" && n2.postcssPlugin)
          r2.push(n2);
        else if (typeof n2 == "function")
          r2.push(n2);
        else if (!(typeof n2 == "object" && (n2.parse || n2.stringify)))
          throw new Error(n2 + " is not a PostCSS plugin");
      return r2;
    }
    process(e2, r2 = {}) {
      return this.plugins.length === 0 && typeof r2.parser > "u" && typeof r2.stringifier > "u" && typeof r2.syntax > "u" ? new zd(this, e2, r2) : new Vd(this, e2, r2);
    }
    use(e2) {
      return this.plugins = this.plugins.concat(this.normalize([e2])), this;
    }
  };
  Zo3.exports = ze3;
  ze3.default = ze3;
  Bd.registerProcessor(ze3);
  Wd.registerProcessor(ze3);
});
var rl = S3((Jb, tl) => {
  var Gd = xt3(), Yd = ri3(), Hd = At3(), Qd = Lr3(), Jd = Et3(), Xd = Qe3(), Kd = Nr3();
  function Mt2(t9, e2) {
    if (Array.isArray(t9))
      return t9.map((i) => Mt2(i));
    let { inputs: r2, ...n2 } = t9;
    if (r2) {
      e2 = [];
      for (let i of r2) {
        let a = { ...i, __proto__: Jd.prototype };
        a.map && (a.map = { ...a.map, __proto__: Yd.prototype }), e2.push(a);
      }
    }
    if (n2.nodes && (n2.nodes = t9.nodes.map((i) => Mt2(i, e2))), n2.source) {
      let { inputId: i, ...a } = n2.source;
      n2.source = a, i != null && (n2.source.input = e2[i]);
    }
    if (n2.type === "root")
      return new Xd(n2);
    if (n2.type === "decl")
      return new Gd(n2);
    if (n2.type === "rule")
      return new Kd(n2);
    if (n2.type === "comment")
      return new Hd(n2);
    if (n2.type === "atrule")
      return new Qd(n2);
    throw new Error("Unknown node type: " + t9.type);
  }
  tl.exports = Mt2;
  Mt2.default = Mt2;
});
var Ke3 = S3((Xb, ul) => {
  var Zd = br3(), nl2 = xt3(), eh = vi2(), th = _e3(), wi2 = el(), rh = yt3(), nh = rl(), il = Ar3(), ih = pi2(), sl = At3(), al = Lr3(), sh = _r3(), ah2 = Et3(), oh = $r3(), lh = hi2(), ol = Nr3(), ll = Qe3(), uh = wt3();
  function N3(...t9) {
    return t9.length === 1 && Array.isArray(t9[0]) && (t9 = t9[0]), new wi2(t9);
  }
  N3.plugin = function(e2, r2) {
    let n2 = false;
    function i(...s3) {
      console && console.warn && !n2 && (n2 = true, console.warn(e2 + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(e2 + `: \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:
https://www.w3ctech.com/topic/2226`));
      let o2 = r2(...s3);
      return o2.postcssPlugin = e2, o2.postcssVersion = new wi2().version, o2;
    }
    let a;
    return Object.defineProperty(i, "postcss", { get() {
      return a || (a = i()), a;
    } }), i.process = function(s3, o2, l3) {
      return N3([i(l3)]).process(s3, o2);
    }, i;
  };
  N3.stringify = rh;
  N3.parse = oh;
  N3.fromJSON = nh;
  N3.list = lh;
  N3.comment = (t9) => new sl(t9);
  N3.atRule = (t9) => new al(t9);
  N3.decl = (t9) => new nl2(t9);
  N3.rule = (t9) => new ol(t9);
  N3.root = (t9) => new ll(t9);
  N3.document = (t9) => new il(t9);
  N3.CssSyntaxError = Zd;
  N3.Declaration = nl2;
  N3.Container = th;
  N3.Processor = wi2;
  N3.Document = il;
  N3.Comment = sl;
  N3.Warning = ih;
  N3.AtRule = al;
  N3.Result = sh;
  N3.Input = ah2;
  N3.Rule = ol;
  N3.Root = ll;
  N3.Node = uh;
  eh.registerPostcss(N3);
  ul.exports = N3;
  N3.default = N3;
});
var jr3 = S3((Ur3, fl) => {
  Ur3.__esModule = true;
  Ur3.default = ph;
  function fh(t9) {
    for (var e2 = t9.toLowerCase(), r2 = "", n2 = false, i = 0;i < 6 && e2[i] !== undefined; i++) {
      var a = e2.charCodeAt(i), s3 = a >= 97 && a <= 102 || a >= 48 && a <= 57;
      if (n2 = a === 32, !s3)
        break;
      r2 += e2[i];
    }
    if (r2.length !== 0) {
      var o2 = parseInt(r2, 16), l3 = o2 >= 55296 && o2 <= 57343;
      return l3 || o2 === 0 || o2 > 1114111 ? ["\uFFFD", r2.length + (n2 ? 1 : 0)] : [String.fromCodePoint(o2), r2.length + (n2 ? 1 : 0)];
    }
  }
  var ch = /\\/;
  function ph(t9) {
    var e2 = ch.test(t9);
    if (!e2)
      return t9;
    for (var r2 = "", n2 = 0;n2 < t9.length; n2++) {
      if (t9[n2] === "\\") {
        var i = fh(t9.slice(n2 + 1, n2 + 7));
        if (i !== undefined) {
          r2 += i[0], n2 += i[1];
          continue;
        }
        if (t9[n2 + 1] === "\\") {
          r2 += "\\", n2++;
          continue;
        }
        t9.length === n2 + 1 && (r2 += t9[n2]);
        continue;
      }
      r2 += t9[n2];
    }
    return r2;
  }
  fl.exports = Ur3.default;
});
var pl = S3((zr2, cl) => {
  zr2.__esModule = true;
  zr2.default = dh;
  function dh(t9) {
    for (var e2 = arguments.length, r2 = new Array(e2 > 1 ? e2 - 1 : 0), n2 = 1;n2 < e2; n2++)
      r2[n2 - 1] = arguments[n2];
    for (;r2.length > 0; ) {
      var i = r2.shift();
      if (!t9[i])
        return;
      t9 = t9[i];
    }
    return t9;
  }
  cl.exports = zr2.default;
});
var hl = S3((Vr2, dl) => {
  Vr2.__esModule = true;
  Vr2.default = hh;
  function hh(t9) {
    for (var e2 = arguments.length, r2 = new Array(e2 > 1 ? e2 - 1 : 0), n2 = 1;n2 < e2; n2++)
      r2[n2 - 1] = arguments[n2];
    for (;r2.length > 0; ) {
      var i = r2.shift();
      t9[i] || (t9[i] = {}), t9 = t9[i];
    }
  }
  dl.exports = Vr2.default;
});
var gl = S3((Wr3, ml) => {
  Wr3.__esModule = true;
  Wr3.default = mh;
  function mh(t9) {
    for (var e2 = "", r2 = t9.indexOf("/*"), n2 = 0;r2 >= 0; ) {
      e2 = e2 + t9.slice(n2, r2);
      var i = t9.indexOf("*/", r2 + 2);
      if (i < 0)
        return e2;
      n2 = i + 2, r2 = t9.indexOf("/*", n2);
    }
    return e2 = e2 + t9.slice(n2), e2;
  }
  ml.exports = Wr3.default;
});
var Ft2 = S3((ye2) => {
  ye2.__esModule = true;
  ye2.unesc = ye2.stripComments = ye2.getProp = ye2.ensureObject = undefined;
  var gh = Br3(jr3());
  ye2.unesc = gh.default;
  var yh = Br3(pl());
  ye2.getProp = yh.default;
  var vh = Br3(hl());
  ye2.ensureObject = vh.default;
  var wh = Br3(gl());
  ye2.stripComments = wh.default;
  function Br3(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
});
var Oe3 = S3((Lt3, wl) => {
  Lt3.__esModule = true;
  Lt3.default = undefined;
  var yl = Ft2();
  function vl(t9, e2) {
    for (var r2 = 0;r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t9, n2.key, n2);
    }
  }
  function bh(t9, e2, r2) {
    return e2 && vl(t9.prototype, e2), r2 && vl(t9, r2), Object.defineProperty(t9, "prototype", { writable: false }), t9;
  }
  var xh = function t(e2, r2) {
    if (typeof e2 != "object" || e2 === null)
      return e2;
    var n2 = new e2.constructor;
    for (var i in e2)
      if (!!e2.hasOwnProperty(i)) {
        var a = e2[i], s3 = typeof a;
        i === "parent" && s3 === "object" ? r2 && (n2[i] = r2) : a instanceof Array ? n2[i] = a.map(function(o2) {
          return t(o2, n2);
        }) : n2[i] = t(a, n2);
      }
    return n2;
  }, Sh = function() {
    function t9(r2) {
      r2 === undefined && (r2 = {}), Object.assign(this, r2), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
    }
    var e2 = t9.prototype;
    return e2.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = undefined, this;
    }, e2.replaceWith = function() {
      if (this.parent) {
        for (var n2 in arguments)
          this.parent.insertBefore(this, arguments[n2]);
        this.remove();
      }
      return this;
    }, e2.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, e2.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, e2.clone = function(n2) {
      n2 === undefined && (n2 = {});
      var i = xh(this);
      for (var a in n2)
        i[a] = n2[a];
      return i;
    }, e2.appendToPropertyAndEscape = function(n2, i, a) {
      this.raws || (this.raws = {});
      var s3 = this[n2], o2 = this.raws[n2];
      this[n2] = s3 + i, o2 || a !== i ? this.raws[n2] = (o2 || s3) + a : delete this.raws[n2];
    }, e2.setPropertyAndEscape = function(n2, i, a) {
      this.raws || (this.raws = {}), this[n2] = i, this.raws[n2] = a;
    }, e2.setPropertyWithoutEscape = function(n2, i) {
      this[n2] = i, this.raws && delete this.raws[n2];
    }, e2.isAtPosition = function(n2, i) {
      if (this.source && this.source.start && this.source.end)
        return !(this.source.start.line > n2 || this.source.end.line < n2 || this.source.start.line === n2 && this.source.start.column > i || this.source.end.line === n2 && this.source.end.column < i);
    }, e2.stringifyProperty = function(n2) {
      return this.raws && this.raws[n2] || this[n2];
    }, e2.valueToString = function() {
      return String(this.stringifyProperty("value"));
    }, e2.toString = function() {
      return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
    }, bh(t9, [{ key: "rawSpaceBefore", get: function() {
      var n2 = this.raws && this.raws.spaces && this.raws.spaces.before;
      return n2 === undefined && (n2 = this.spaces && this.spaces.before), n2 || "";
    }, set: function(n2) {
      (0, yl.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = n2;
    } }, { key: "rawSpaceAfter", get: function() {
      var n2 = this.raws && this.raws.spaces && this.raws.spaces.after;
      return n2 === undefined && (n2 = this.spaces.after), n2 || "";
    }, set: function(n2) {
      (0, yl.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = n2;
    } }]), t9;
  }();
  Lt3.default = Sh;
  wl.exports = Lt3.default;
});
var J3 = S3((U2) => {
  U2.__esModule = true;
  U2.UNIVERSAL = U2.TAG = U2.STRING = U2.SELECTOR = U2.ROOT = U2.PSEUDO = U2.NESTING = U2.ID = U2.COMMENT = U2.COMBINATOR = U2.CLASS = U2.ATTRIBUTE = undefined;
  var kh = "tag";
  U2.TAG = kh;
  var Oh = "string";
  U2.STRING = Oh;
  var Eh = "selector";
  U2.SELECTOR = Eh;
  var Ch = "root";
  U2.ROOT = Ch;
  var Ah = "pseudo";
  U2.PSEUDO = Ah;
  var _h = "nesting";
  U2.NESTING = _h;
  var Th = "id";
  U2.ID = Th;
  var Ph = "comment";
  U2.COMMENT = Ph;
  var Ih = "combinator";
  U2.COMBINATOR = Ih;
  var Rh = "class";
  U2.CLASS = Rh;
  var Dh = "attribute";
  U2.ATTRIBUTE = Dh;
  var Mh = "universal";
  U2.UNIVERSAL = Mh;
});
var Gr3 = S3((Nt3, kl) => {
  Nt3.__esModule = true;
  Nt3.default = undefined;
  var Fh = Nh(Oe3()), Ee3 = Lh(J3());
  function Sl(t9) {
    if (typeof WeakMap != "function")
      return null;
    var e2 = new WeakMap, r2 = new WeakMap;
    return (Sl = function(i) {
      return i ? r2 : e2;
    })(t9);
  }
  function Lh(t9, e2) {
    if (!e2 && t9 && t9.__esModule)
      return t9;
    if (t9 === null || typeof t9 != "object" && typeof t9 != "function")
      return { default: t9 };
    var r2 = Sl(e2);
    if (r2 && r2.has(t9))
      return r2.get(t9);
    var n2 = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t9)
      if (a !== "default" && Object.prototype.hasOwnProperty.call(t9, a)) {
        var s3 = i ? Object.getOwnPropertyDescriptor(t9, a) : null;
        s3 && (s3.get || s3.set) ? Object.defineProperty(n2, a, s3) : n2[a] = t9[a];
      }
    return n2.default = t9, r2 && r2.set(t9, n2), n2;
  }
  function Nh(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  function qh(t9, e2) {
    var r2 = typeof Symbol < "u" && t9[Symbol.iterator] || t9["@@iterator"];
    if (r2)
      return (r2 = r2.call(t9)).next.bind(r2);
    if (Array.isArray(t9) || (r2 = $h(t9)) || e2 && t9 && typeof t9.length == "number") {
      r2 && (t9 = r2);
      var n2 = 0;
      return function() {
        return n2 >= t9.length ? { done: true } : { done: false, value: t9[n2++] };
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function $h(t9, e2) {
    if (!!t9) {
      if (typeof t9 == "string")
        return bl(t9, e2);
      var r2 = Object.prototype.toString.call(t9).slice(8, -1);
      if (r2 === "Object" && t9.constructor && (r2 = t9.constructor.name), r2 === "Map" || r2 === "Set")
        return Array.from(t9);
      if (r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
        return bl(t9, e2);
    }
  }
  function bl(t9, e2) {
    (e2 == null || e2 > t9.length) && (e2 = t9.length);
    for (var r2 = 0, n2 = new Array(e2);r2 < e2; r2++)
      n2[r2] = t9[r2];
    return n2;
  }
  function xl(t9, e2) {
    for (var r2 = 0;r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t9, n2.key, n2);
    }
  }
  function Uh(t9, e2, r2) {
    return e2 && xl(t9.prototype, e2), r2 && xl(t9, r2), Object.defineProperty(t9, "prototype", { writable: false }), t9;
  }
  function jh(t9, e2) {
    t9.prototype = Object.create(e2.prototype), t9.prototype.constructor = t9, bi2(t9, e2);
  }
  function bi2(t9, e2) {
    return bi2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i) {
      return n2.__proto__ = i, n2;
    }, bi2(t9, e2);
  }
  var zh = function(t9) {
    jh(e2, t9);
    function e2(n2) {
      var i;
      return i = t9.call(this, n2) || this, i.nodes || (i.nodes = []), i;
    }
    var r2 = e2.prototype;
    return r2.append = function(i) {
      return i.parent = this, this.nodes.push(i), this;
    }, r2.prepend = function(i) {
      return i.parent = this, this.nodes.unshift(i), this;
    }, r2.at = function(i) {
      return this.nodes[i];
    }, r2.index = function(i) {
      return typeof i == "number" ? i : this.nodes.indexOf(i);
    }, r2.removeChild = function(i) {
      i = this.index(i), this.at(i).parent = undefined, this.nodes.splice(i, 1);
      var a;
      for (var s3 in this.indexes)
        a = this.indexes[s3], a >= i && (this.indexes[s3] = a - 1);
      return this;
    }, r2.removeAll = function() {
      for (var i = qh(this.nodes), a;!(a = i()).done; ) {
        var s3 = a.value;
        s3.parent = undefined;
      }
      return this.nodes = [], this;
    }, r2.empty = function() {
      return this.removeAll();
    }, r2.insertAfter = function(i, a) {
      a.parent = this;
      var s3 = this.index(i);
      this.nodes.splice(s3 + 1, 0, a), a.parent = this;
      var o2;
      for (var l3 in this.indexes)
        o2 = this.indexes[l3], s3 <= o2 && (this.indexes[l3] = o2 + 1);
      return this;
    }, r2.insertBefore = function(i, a) {
      a.parent = this;
      var s3 = this.index(i);
      this.nodes.splice(s3, 0, a), a.parent = this;
      var o2;
      for (var l3 in this.indexes)
        o2 = this.indexes[l3], o2 <= s3 && (this.indexes[l3] = o2 + 1);
      return this;
    }, r2._findChildAtPosition = function(i, a) {
      var s3 = undefined;
      return this.each(function(o2) {
        if (o2.atPosition) {
          var l3 = o2.atPosition(i, a);
          if (l3)
            return s3 = l3, false;
        } else if (o2.isAtPosition(i, a))
          return s3 = o2, false;
      }), s3;
    }, r2.atPosition = function(i, a) {
      if (this.isAtPosition(i, a))
        return this._findChildAtPosition(i, a) || this;
    }, r2._inferEndPosition = function() {
      this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
    }, r2.each = function(i) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var a = this.lastEach;
      if (this.indexes[a] = 0, !!this.length) {
        for (var s3, o2;this.indexes[a] < this.length && (s3 = this.indexes[a], o2 = i(this.at(s3), s3), o2 !== false); )
          this.indexes[a] += 1;
        if (delete this.indexes[a], o2 === false)
          return false;
      }
    }, r2.walk = function(i) {
      return this.each(function(a, s3) {
        var o2 = i(a, s3);
        if (o2 !== false && a.length && (o2 = a.walk(i)), o2 === false)
          return false;
      });
    }, r2.walkAttributes = function(i) {
      var a = this;
      return this.walk(function(s3) {
        if (s3.type === Ee3.ATTRIBUTE)
          return i.call(a, s3);
      });
    }, r2.walkClasses = function(i) {
      var a = this;
      return this.walk(function(s3) {
        if (s3.type === Ee3.CLASS)
          return i.call(a, s3);
      });
    }, r2.walkCombinators = function(i) {
      var a = this;
      return this.walk(function(s3) {
        if (s3.type === Ee3.COMBINATOR)
          return i.call(a, s3);
      });
    }, r2.walkComments = function(i) {
      var a = this;
      return this.walk(function(s3) {
        if (s3.type === Ee3.COMMENT)
          return i.call(a, s3);
      });
    }, r2.walkIds = function(i) {
      var a = this;
      return this.walk(function(s3) {
        if (s3.type === Ee3.ID)
          return i.call(a, s3);
      });
    }, r2.walkNesting = function(i) {
      var a = this;
      return this.walk(function(s3) {
        if (s3.type === Ee3.NESTING)
          return i.call(a, s3);
      });
    }, r2.walkPseudos = function(i) {
      var a = this;
      return this.walk(function(s3) {
        if (s3.type === Ee3.PSEUDO)
          return i.call(a, s3);
      });
    }, r2.walkTags = function(i) {
      var a = this;
      return this.walk(function(s3) {
        if (s3.type === Ee3.TAG)
          return i.call(a, s3);
      });
    }, r2.walkUniversals = function(i) {
      var a = this;
      return this.walk(function(s3) {
        if (s3.type === Ee3.UNIVERSAL)
          return i.call(a, s3);
      });
    }, r2.split = function(i) {
      var a = this, s3 = [];
      return this.reduce(function(o2, l3, u) {
        var f = i.call(a, l3);
        return s3.push(l3), f ? (o2.push(s3), s3 = []) : u === a.length - 1 && o2.push(s3), o2;
      }, []);
    }, r2.map = function(i) {
      return this.nodes.map(i);
    }, r2.reduce = function(i, a) {
      return this.nodes.reduce(i, a);
    }, r2.every = function(i) {
      return this.nodes.every(i);
    }, r2.some = function(i) {
      return this.nodes.some(i);
    }, r2.filter = function(i) {
      return this.nodes.filter(i);
    }, r2.sort = function(i) {
      return this.nodes.sort(i);
    }, r2.toString = function() {
      return this.map(String).join("");
    }, Uh(e2, [{ key: "first", get: function() {
      return this.at(0);
    } }, { key: "last", get: function() {
      return this.at(this.length - 1);
    } }, { key: "length", get: function() {
      return this.nodes.length;
    } }]), e2;
  }(Fh.default);
  Nt3.default = zh;
  kl.exports = Nt3.default;
});
var Si2 = S3((qt3, El) => {
  qt3.__esModule = true;
  qt3.default = undefined;
  var Vh = Bh(Gr3()), Wh = J3();
  function Bh(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  function Ol(t9, e2) {
    for (var r2 = 0;r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t9, n2.key, n2);
    }
  }
  function Gh(t9, e2, r2) {
    return e2 && Ol(t9.prototype, e2), r2 && Ol(t9, r2), Object.defineProperty(t9, "prototype", { writable: false }), t9;
  }
  function Yh(t9, e2) {
    t9.prototype = Object.create(e2.prototype), t9.prototype.constructor = t9, xi2(t9, e2);
  }
  function xi2(t9, e2) {
    return xi2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i) {
      return n2.__proto__ = i, n2;
    }, xi2(t9, e2);
  }
  var Hh = function(t9) {
    Yh(e2, t9);
    function e2(n2) {
      var i;
      return i = t9.call(this, n2) || this, i.type = Wh.ROOT, i;
    }
    var r2 = e2.prototype;
    return r2.toString = function() {
      var i = this.reduce(function(a, s3) {
        return a.push(String(s3)), a;
      }, []).join(",");
      return this.trailingComma ? i + "," : i;
    }, r2.error = function(i, a) {
      return this._error ? this._error(i, a) : new Error(i);
    }, Gh(e2, [{ key: "errorGenerator", set: function(i) {
      this._error = i;
    } }]), e2;
  }(Vh.default);
  qt3.default = Hh;
  El.exports = qt3.default;
});
var Oi2 = S3(($t3, Cl) => {
  $t3.__esModule = true;
  $t3.default = undefined;
  var Qh = Xh(Gr3()), Jh = J3();
  function Xh(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  function Kh(t9, e2) {
    t9.prototype = Object.create(e2.prototype), t9.prototype.constructor = t9, ki2(t9, e2);
  }
  function ki2(t9, e2) {
    return ki2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i) {
      return n2.__proto__ = i, n2;
    }, ki2(t9, e2);
  }
  var Zh = function(t9) {
    Kh(e2, t9);
    function e2(r2) {
      var n2;
      return n2 = t9.call(this, r2) || this, n2.type = Jh.SELECTOR, n2;
    }
    return e2;
  }(Qh.default);
  $t3.default = Zh;
  Cl.exports = $t3.default;
});
var Yr2 = S3((Ex, Al) => {
  var em = {}, tm = em.hasOwnProperty, rm = function(e2, r2) {
    if (!e2)
      return r2;
    var n2 = {};
    for (var i in r2)
      n2[i] = tm.call(e2, i) ? e2[i] : r2[i];
    return n2;
  }, nm = /[ -,\.\/:-@\[-\^`\{-~]/, im = /[ -,\.\/:-@\[\]\^`\{-~]/, sm = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, Ei = function t(e2, r2) {
    r2 = rm(r2, t.options), r2.quotes != "single" && r2.quotes != "double" && (r2.quotes = "single");
    for (var n2 = r2.quotes == "double" ? '"' : "'", i = r2.isIdentifier, a = e2.charAt(0), s3 = "", o2 = 0, l3 = e2.length;o2 < l3; ) {
      var u = e2.charAt(o2++), f = u.charCodeAt(), p = undefined;
      if (f < 32 || f > 126) {
        if (f >= 55296 && f <= 56319 && o2 < l3) {
          var c2 = e2.charCodeAt(o2++);
          (c2 & 64512) == 56320 ? f = ((f & 1023) << 10) + (c2 & 1023) + 65536 : o2--;
        }
        p = "\\" + f.toString(16).toUpperCase() + " ";
      } else
        r2.escapeEverything ? nm.test(u) ? p = "\\" + u : p = "\\" + f.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(u) ? p = "\\" + f.toString(16).toUpperCase() + " " : u == "\\" || !i && (u == '"' && n2 == u || u == "'" && n2 == u) || i && im.test(u) ? p = "\\" + u : p = u;
      s3 += p;
    }
    return i && (/^-[-\d]/.test(s3) ? s3 = "\\-" + s3.slice(1) : /\d/.test(a) && (s3 = "\\3" + a + " " + s3.slice(1))), s3 = s3.replace(sm, function(d2, h2, y2) {
      return h2 && h2.length % 2 ? d2 : (h2 || "") + y2;
    }), !i && r2.wrap ? n2 + s3 + n2 : s3;
  };
  Ei.options = { escapeEverything: false, isIdentifier: false, quotes: "single", wrap: false };
  Ei.version = "3.0.0";
  Al.exports = Ei;
});
var Ai2 = S3((Ut3, Pl) => {
  Ut3.__esModule = true;
  Ut3.default = undefined;
  var am = Tl(Yr2()), om = Ft2(), lm = Tl(Oe3()), um = J3();
  function Tl(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  function _l(t9, e2) {
    for (var r2 = 0;r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t9, n2.key, n2);
    }
  }
  function fm(t9, e2, r2) {
    return e2 && _l(t9.prototype, e2), r2 && _l(t9, r2), Object.defineProperty(t9, "prototype", { writable: false }), t9;
  }
  function cm(t9, e2) {
    t9.prototype = Object.create(e2.prototype), t9.prototype.constructor = t9, Ci2(t9, e2);
  }
  function Ci2(t9, e2) {
    return Ci2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i) {
      return n2.__proto__ = i, n2;
    }, Ci2(t9, e2);
  }
  var pm = function(t9) {
    cm(e2, t9);
    function e2(n2) {
      var i;
      return i = t9.call(this, n2) || this, i.type = um.CLASS, i._constructed = true, i;
    }
    var r2 = e2.prototype;
    return r2.valueToString = function() {
      return "." + t9.prototype.valueToString.call(this);
    }, fm(e2, [{ key: "value", get: function() {
      return this._value;
    }, set: function(i) {
      if (this._constructed) {
        var a = (0, am.default)(i, { isIdentifier: true });
        a !== i ? ((0, om.ensureObject)(this, "raws"), this.raws.value = a) : this.raws && delete this.raws.value;
      }
      this._value = i;
    } }]), e2;
  }(lm.default);
  Ut3.default = pm;
  Pl.exports = Ut3.default;
});
var Ti = S3((jt3, Il) => {
  jt3.__esModule = true;
  jt3.default = undefined;
  var dm = mm(Oe3()), hm = J3();
  function mm(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  function gm(t9, e2) {
    t9.prototype = Object.create(e2.prototype), t9.prototype.constructor = t9, _i2(t9, e2);
  }
  function _i2(t9, e2) {
    return _i2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i) {
      return n2.__proto__ = i, n2;
    }, _i2(t9, e2);
  }
  var ym2 = function(t9) {
    gm(e2, t9);
    function e2(r2) {
      var n2;
      return n2 = t9.call(this, r2) || this, n2.type = hm.COMMENT, n2;
    }
    return e2;
  }(dm.default);
  jt3.default = ym2;
  Il.exports = jt3.default;
});
var Ii2 = S3((zt3, Rl) => {
  zt3.__esModule = true;
  zt3.default = undefined;
  var vm = bm(Oe3()), wm = J3();
  function bm(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  function xm(t9, e2) {
    t9.prototype = Object.create(e2.prototype), t9.prototype.constructor = t9, Pi2(t9, e2);
  }
  function Pi2(t9, e2) {
    return Pi2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i) {
      return n2.__proto__ = i, n2;
    }, Pi2(t9, e2);
  }
  var Sm = function(t9) {
    xm(e2, t9);
    function e2(n2) {
      var i;
      return i = t9.call(this, n2) || this, i.type = wm.ID, i;
    }
    var r2 = e2.prototype;
    return r2.valueToString = function() {
      return "#" + t9.prototype.valueToString.call(this);
    }, e2;
  }(vm.default);
  zt3.default = Sm;
  Rl.exports = zt3.default;
});
var Hr3 = S3((Vt3, Fl) => {
  Vt3.__esModule = true;
  Vt3.default = undefined;
  var km = Ml(Yr2()), Om = Ft2(), Em = Ml(Oe3());
  function Ml(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  function Dl(t9, e2) {
    for (var r2 = 0;r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t9, n2.key, n2);
    }
  }
  function Cm(t9, e2, r2) {
    return e2 && Dl(t9.prototype, e2), r2 && Dl(t9, r2), Object.defineProperty(t9, "prototype", { writable: false }), t9;
  }
  function Am(t9, e2) {
    t9.prototype = Object.create(e2.prototype), t9.prototype.constructor = t9, Ri2(t9, e2);
  }
  function Ri2(t9, e2) {
    return Ri2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i) {
      return n2.__proto__ = i, n2;
    }, Ri2(t9, e2);
  }
  var _m = function(t9) {
    Am(e2, t9);
    function e2() {
      return t9.apply(this, arguments) || this;
    }
    var r2 = e2.prototype;
    return r2.qualifiedName = function(i) {
      return this.namespace ? this.namespaceString + "|" + i : i;
    }, r2.valueToString = function() {
      return this.qualifiedName(t9.prototype.valueToString.call(this));
    }, Cm(e2, [{ key: "namespace", get: function() {
      return this._namespace;
    }, set: function(i) {
      if (i === true || i === "*" || i === "&") {
        this._namespace = i, this.raws && delete this.raws.namespace;
        return;
      }
      var a = (0, km.default)(i, { isIdentifier: true });
      this._namespace = i, a !== i ? ((0, Om.ensureObject)(this, "raws"), this.raws.namespace = a) : this.raws && delete this.raws.namespace;
    } }, { key: "ns", get: function() {
      return this._namespace;
    }, set: function(i) {
      this.namespace = i;
    } }, { key: "namespaceString", get: function() {
      if (this.namespace) {
        var i = this.stringifyProperty("namespace");
        return i === true ? "" : i;
      } else
        return "";
    } }]), e2;
  }(Em.default);
  Vt3.default = _m;
  Fl.exports = Vt3.default;
});
var Mi2 = S3((Wt3, Ll) => {
  Wt3.__esModule = true;
  Wt3.default = undefined;
  var Tm = Im(Hr3()), Pm = J3();
  function Im(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  function Rm(t9, e2) {
    t9.prototype = Object.create(e2.prototype), t9.prototype.constructor = t9, Di2(t9, e2);
  }
  function Di2(t9, e2) {
    return Di2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i) {
      return n2.__proto__ = i, n2;
    }, Di2(t9, e2);
  }
  var Dm = function(t9) {
    Rm(e2, t9);
    function e2(r2) {
      var n2;
      return n2 = t9.call(this, r2) || this, n2.type = Pm.TAG, n2;
    }
    return e2;
  }(Tm.default);
  Wt3.default = Dm;
  Ll.exports = Wt3.default;
});
var Li2 = S3((Bt3, Nl) => {
  Bt3.__esModule = true;
  Bt3.default = undefined;
  var Mm = Lm(Oe3()), Fm = J3();
  function Lm(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  function Nm(t9, e2) {
    t9.prototype = Object.create(e2.prototype), t9.prototype.constructor = t9, Fi2(t9, e2);
  }
  function Fi2(t9, e2) {
    return Fi2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i) {
      return n2.__proto__ = i, n2;
    }, Fi2(t9, e2);
  }
  var qm = function(t9) {
    Nm(e2, t9);
    function e2(r2) {
      var n2;
      return n2 = t9.call(this, r2) || this, n2.type = Fm.STRING, n2;
    }
    return e2;
  }(Mm.default);
  Bt3.default = qm;
  Nl.exports = Bt3.default;
});
var qi2 = S3((Gt3, ql) => {
  Gt3.__esModule = true;
  Gt3.default = undefined;
  var $m = jm(Gr3()), Um = J3();
  function jm(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  function zm(t9, e2) {
    t9.prototype = Object.create(e2.prototype), t9.prototype.constructor = t9, Ni2(t9, e2);
  }
  function Ni2(t9, e2) {
    return Ni2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i) {
      return n2.__proto__ = i, n2;
    }, Ni2(t9, e2);
  }
  var Vm = function(t9) {
    zm(e2, t9);
    function e2(n2) {
      var i;
      return i = t9.call(this, n2) || this, i.type = Um.PSEUDO, i;
    }
    var r2 = e2.prototype;
    return r2.toString = function() {
      var i = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.rawSpaceBefore, this.stringifyProperty("value"), i, this.rawSpaceAfter].join("");
    }, e2;
  }($m.default);
  Gt3.default = Vm;
  ql.exports = Gt3.default;
});
var Ul = S3((Cx, $l) => {
  $l.exports = Wm;
  function Wm(t9, e2) {
    if ($i2("noDeprecation"))
      return t9;
    var r2 = false;
    function n2() {
      if (!r2) {
        if ($i2("throwDeprecation"))
          throw new Error(e2);
        $i2("traceDeprecation") ? console.trace(e2) : console.warn(e2), r2 = true;
      }
      return t9.apply(this, arguments);
    }
    return n2;
  }
  function $i2(t9) {
    try {
      if (!global.localStorage)
        return false;
    } catch {
      return false;
    }
    var e2 = global.localStorage[t9];
    return e2 == null ? false : String(e2).toLowerCase() === "true";
  }
});
var Bi2 = S3((Qt3) => {
  Qt3.__esModule = true;
  Qt3.default = undefined;
  Qt3.unescapeValue = Wi2;
  var Yt3 = Vi2(Yr2()), Bm = Vi2(jr3()), Gm = Vi2(Hr3()), Ym = J3(), Ui2;
  function Vi2(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  function jl(t9, e2) {
    for (var r2 = 0;r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t9, n2.key, n2);
    }
  }
  function Hm(t9, e2, r2) {
    return e2 && jl(t9.prototype, e2), r2 && jl(t9, r2), Object.defineProperty(t9, "prototype", { writable: false }), t9;
  }
  function Qm(t9, e2) {
    t9.prototype = Object.create(e2.prototype), t9.prototype.constructor = t9, zi2(t9, e2);
  }
  function zi2(t9, e2) {
    return zi2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i) {
      return n2.__proto__ = i, n2;
    }, zi2(t9, e2);
  }
  var Ht3 = Ul(), Jm = /^('|")([^]*)\1$/, Xm = Ht3(function() {
  }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), Km = Ht3(function() {
  }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), Zm = Ht3(function() {
  }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
  function Wi2(t9) {
    var e2 = false, r2 = null, n2 = t9, i = n2.match(Jm);
    return i && (r2 = i[1], n2 = i[2]), n2 = (0, Bm.default)(n2), n2 !== t9 && (e2 = true), { deprecatedUsage: e2, unescaped: n2, quoteMark: r2 };
  }
  function eg(t9) {
    if (t9.quoteMark !== undefined || t9.value === undefined)
      return t9;
    Zm();
    var e2 = Wi2(t9.value), r2 = e2.quoteMark, n2 = e2.unescaped;
    return t9.raws || (t9.raws = {}), t9.raws.value === undefined && (t9.raws.value = t9.value), t9.value = n2, t9.quoteMark = r2, t9;
  }
  var Qr3 = function(t9) {
    Qm(e2, t9);
    function e2(n2) {
      var i;
      return n2 === undefined && (n2 = {}), i = t9.call(this, eg(n2)) || this, i.type = Ym.ATTRIBUTE, i.raws = i.raws || {}, Object.defineProperty(i.raws, "unquoted", { get: Ht3(function() {
        return i.value;
      }, "attr.raws.unquoted is deprecated. Call attr.value instead."), set: Ht3(function() {
        return i.value;
      }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.") }), i._constructed = true, i;
    }
    var r2 = e2.prototype;
    return r2.getQuotedValue = function(i) {
      i === undefined && (i = {});
      var a = this._determineQuoteMark(i), s3 = ji2[a], o2 = (0, Yt3.default)(this._value, s3);
      return o2;
    }, r2._determineQuoteMark = function(i) {
      return i.smart ? this.smartQuoteMark(i) : this.preferredQuoteMark(i);
    }, r2.setValue = function(i, a) {
      a === undefined && (a = {}), this._value = i, this._quoteMark = this._determineQuoteMark(a), this._syncRawValue();
    }, r2.smartQuoteMark = function(i) {
      var a = this.value, s3 = a.replace(/[^']/g, "").length, o2 = a.replace(/[^"]/g, "").length;
      if (s3 + o2 === 0) {
        var l3 = (0, Yt3.default)(a, { isIdentifier: true });
        if (l3 === a)
          return e2.NO_QUOTE;
        var u = this.preferredQuoteMark(i);
        if (u === e2.NO_QUOTE) {
          var f = this.quoteMark || i.quoteMark || e2.DOUBLE_QUOTE, p = ji2[f], c2 = (0, Yt3.default)(a, p);
          if (c2.length < l3.length)
            return f;
        }
        return u;
      } else
        return o2 === s3 ? this.preferredQuoteMark(i) : o2 < s3 ? e2.DOUBLE_QUOTE : e2.SINGLE_QUOTE;
    }, r2.preferredQuoteMark = function(i) {
      var a = i.preferCurrentQuoteMark ? this.quoteMark : i.quoteMark;
      return a === undefined && (a = i.preferCurrentQuoteMark ? i.quoteMark : this.quoteMark), a === undefined && (a = e2.DOUBLE_QUOTE), a;
    }, r2._syncRawValue = function() {
      var i = (0, Yt3.default)(this._value, ji2[this.quoteMark]);
      i === this._value ? this.raws && delete this.raws.value : this.raws.value = i;
    }, r2._handleEscapes = function(i, a) {
      if (this._constructed) {
        var s3 = (0, Yt3.default)(a, { isIdentifier: true });
        s3 !== a ? this.raws[i] = s3 : delete this.raws[i];
      }
    }, r2._spacesFor = function(i) {
      var a = { before: "", after: "" }, s3 = this.spaces[i] || {}, o2 = this.raws.spaces && this.raws.spaces[i] || {};
      return Object.assign(a, s3, o2);
    }, r2._stringFor = function(i, a, s3) {
      a === undefined && (a = i), s3 === undefined && (s3 = zl);
      var o2 = this._spacesFor(a);
      return s3(this.stringifyProperty(i), o2);
    }, r2.offsetOf = function(i) {
      var a = 1, s3 = this._spacesFor("attribute");
      if (a += s3.before.length, i === "namespace" || i === "ns")
        return this.namespace ? a : -1;
      if (i === "attributeNS" || (a += this.namespaceString.length, this.namespace && (a += 1), i === "attribute"))
        return a;
      a += this.stringifyProperty("attribute").length, a += s3.after.length;
      var o2 = this._spacesFor("operator");
      a += o2.before.length;
      var l3 = this.stringifyProperty("operator");
      if (i === "operator")
        return l3 ? a : -1;
      a += l3.length, a += o2.after.length;
      var u = this._spacesFor("value");
      a += u.before.length;
      var f = this.stringifyProperty("value");
      if (i === "value")
        return f ? a : -1;
      a += f.length, a += u.after.length;
      var p = this._spacesFor("insensitive");
      return a += p.before.length, i === "insensitive" && this.insensitive ? a : -1;
    }, r2.toString = function() {
      var i = this, a = [this.rawSpaceBefore, "["];
      return a.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (a.push(this._stringFor("operator")), a.push(this._stringFor("value")), a.push(this._stringFor("insensitiveFlag", "insensitive", function(s3, o2) {
        return s3.length > 0 && !i.quoted && o2.before.length === 0 && !(i.spaces.value && i.spaces.value.after) && (o2.before = " "), zl(s3, o2);
      }))), a.push("]"), a.push(this.rawSpaceAfter), a.join("");
    }, Hm(e2, [{ key: "quoted", get: function() {
      var i = this.quoteMark;
      return i === "'" || i === '"';
    }, set: function(i) {
      Km();
    } }, { key: "quoteMark", get: function() {
      return this._quoteMark;
    }, set: function(i) {
      if (!this._constructed) {
        this._quoteMark = i;
        return;
      }
      this._quoteMark !== i && (this._quoteMark = i, this._syncRawValue());
    } }, { key: "qualifiedAttribute", get: function() {
      return this.qualifiedName(this.raws.attribute || this.attribute);
    } }, { key: "insensitiveFlag", get: function() {
      return this.insensitive ? "i" : "";
    } }, { key: "value", get: function() {
      return this._value;
    }, set: function(i) {
      if (this._constructed) {
        var a = Wi2(i), s3 = a.deprecatedUsage, o2 = a.unescaped, l3 = a.quoteMark;
        if (s3 && Xm(), o2 === this._value && l3 === this._quoteMark)
          return;
        this._value = o2, this._quoteMark = l3, this._syncRawValue();
      } else
        this._value = i;
    } }, { key: "insensitive", get: function() {
      return this._insensitive;
    }, set: function(i) {
      i || (this._insensitive = false, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = undefined)), this._insensitive = i;
    } }, { key: "attribute", get: function() {
      return this._attribute;
    }, set: function(i) {
      this._handleEscapes("attribute", i), this._attribute = i;
    } }]), e2;
  }(Gm.default);
  Qt3.default = Qr3;
  Qr3.NO_QUOTE = null;
  Qr3.SINGLE_QUOTE = "'";
  Qr3.DOUBLE_QUOTE = '"';
  var ji2 = (Ui2 = { "'": { quotes: "single", wrap: true }, '"': { quotes: "double", wrap: true } }, Ui2[null] = { isIdentifier: true }, Ui2);
  function zl(t9, e2) {
    return "" + e2.before + t9 + e2.after;
  }
});
var Yi2 = S3((Jt2, Vl) => {
  Jt2.__esModule = true;
  Jt2.default = undefined;
  var tg = ng(Hr3()), rg = J3();
  function ng(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  function ig(t9, e2) {
    t9.prototype = Object.create(e2.prototype), t9.prototype.constructor = t9, Gi2(t9, e2);
  }
  function Gi2(t9, e2) {
    return Gi2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i) {
      return n2.__proto__ = i, n2;
    }, Gi2(t9, e2);
  }
  var sg = function(t9) {
    ig(e2, t9);
    function e2(r2) {
      var n2;
      return n2 = t9.call(this, r2) || this, n2.type = rg.UNIVERSAL, n2.value = "*", n2;
    }
    return e2;
  }(tg.default);
  Jt2.default = sg;
  Vl.exports = Jt2.default;
});
var Qi2 = S3((Xt3, Wl) => {
  Xt3.__esModule = true;
  Xt3.default = undefined;
  var ag = lg(Oe3()), og = J3();
  function lg(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  function ug(t9, e2) {
    t9.prototype = Object.create(e2.prototype), t9.prototype.constructor = t9, Hi2(t9, e2);
  }
  function Hi2(t9, e2) {
    return Hi2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i) {
      return n2.__proto__ = i, n2;
    }, Hi2(t9, e2);
  }
  var fg = function(t9) {
    ug(e2, t9);
    function e2(r2) {
      var n2;
      return n2 = t9.call(this, r2) || this, n2.type = og.COMBINATOR, n2;
    }
    return e2;
  }(ag.default);
  Xt3.default = fg;
  Wl.exports = Xt3.default;
});
var Xi2 = S3((Kt3, Bl) => {
  Kt3.__esModule = true;
  Kt3.default = undefined;
  var cg = dg(Oe3()), pg = J3();
  function dg(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  function hg(t9, e2) {
    t9.prototype = Object.create(e2.prototype), t9.prototype.constructor = t9, Ji2(t9, e2);
  }
  function Ji2(t9, e2) {
    return Ji2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i) {
      return n2.__proto__ = i, n2;
    }, Ji2(t9, e2);
  }
  var mg = function(t9) {
    hg(e2, t9);
    function e2(r2) {
      var n2;
      return n2 = t9.call(this, r2) || this, n2.type = pg.NESTING, n2.value = "&", n2;
    }
    return e2;
  }(cg.default);
  Kt3.default = mg;
  Bl.exports = Kt3.default;
});
var Yl = S3((Jr3, Gl) => {
  Jr3.__esModule = true;
  Jr3.default = gg;
  function gg(t9) {
    return t9.sort(function(e2, r2) {
      return e2 - r2;
    });
  }
  Gl.exports = Jr3.default;
});
var Ki2 = S3((P3) => {
  P3.__esModule = true;
  P3.word = P3.tilde = P3.tab = P3.str = P3.space = P3.slash = P3.singleQuote = P3.semicolon = P3.plus = P3.pipe = P3.openSquare = P3.openParenthesis = P3.newline = P3.greaterThan = P3.feed = P3.equals = P3.doubleQuote = P3.dollar = P3.cr = P3.comment = P3.comma = P3.combinator = P3.colon = P3.closeSquare = P3.closeParenthesis = P3.caret = P3.bang = P3.backslash = P3.at = P3.asterisk = P3.ampersand = undefined;
  var yg = 38;
  P3.ampersand = yg;
  var vg = 42;
  P3.asterisk = vg;
  var wg = 64;
  P3.at = wg;
  var bg = 44;
  P3.comma = bg;
  var xg = 58;
  P3.colon = xg;
  var Sg = 59;
  P3.semicolon = Sg;
  var kg = 40;
  P3.openParenthesis = kg;
  var Og = 41;
  P3.closeParenthesis = Og;
  var Eg = 91;
  P3.openSquare = Eg;
  var Cg = 93;
  P3.closeSquare = Cg;
  var Ag = 36;
  P3.dollar = Ag;
  var _g = 126;
  P3.tilde = _g;
  var Tg = 94;
  P3.caret = Tg;
  var Pg = 43;
  P3.plus = Pg;
  var Ig = 61;
  P3.equals = Ig;
  var Rg = 124;
  P3.pipe = Rg;
  var Dg = 62;
  P3.greaterThan = Dg;
  var Mg = 32;
  P3.space = Mg;
  var Hl = 39;
  P3.singleQuote = Hl;
  var Fg = 34;
  P3.doubleQuote = Fg;
  var Lg = 47;
  P3.slash = Lg;
  var Ng = 33;
  P3.bang = Ng;
  var qg = 92;
  P3.backslash = qg;
  var $g = 13;
  P3.cr = $g;
  var Ug = 12;
  P3.feed = Ug;
  var jg = 10;
  P3.newline = jg;
  var zg = 9;
  P3.tab = zg;
  var Vg = Hl;
  P3.str = Vg;
  var Wg = -1;
  P3.comment = Wg;
  var Bg = -2;
  P3.word = Bg;
  var Gg = -3;
  P3.combinator = Gg;
});
var Xl = S3((Zt2) => {
  Zt2.__esModule = true;
  Zt2.FIELDS = undefined;
  Zt2.default = Zg;
  var C = Yg(Ki2()), Ze3, q2;
  function Jl(t9) {
    if (typeof WeakMap != "function")
      return null;
    var e2 = new WeakMap, r2 = new WeakMap;
    return (Jl = function(i) {
      return i ? r2 : e2;
    })(t9);
  }
  function Yg(t9, e2) {
    if (!e2 && t9 && t9.__esModule)
      return t9;
    if (t9 === null || typeof t9 != "object" && typeof t9 != "function")
      return { default: t9 };
    var r2 = Jl(e2);
    if (r2 && r2.has(t9))
      return r2.get(t9);
    var n2 = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t9)
      if (a !== "default" && Object.prototype.hasOwnProperty.call(t9, a)) {
        var s3 = i ? Object.getOwnPropertyDescriptor(t9, a) : null;
        s3 && (s3.get || s3.set) ? Object.defineProperty(n2, a, s3) : n2[a] = t9[a];
      }
    return n2.default = t9, r2 && r2.set(t9, n2), n2;
  }
  var Hg = (Ze3 = {}, Ze3[C.tab] = true, Ze3[C.newline] = true, Ze3[C.cr] = true, Ze3[C.feed] = true, Ze3), Qg = (q2 = {}, q2[C.space] = true, q2[C.tab] = true, q2[C.newline] = true, q2[C.cr] = true, q2[C.feed] = true, q2[C.ampersand] = true, q2[C.asterisk] = true, q2[C.bang] = true, q2[C.comma] = true, q2[C.colon] = true, q2[C.semicolon] = true, q2[C.openParenthesis] = true, q2[C.closeParenthesis] = true, q2[C.openSquare] = true, q2[C.closeSquare] = true, q2[C.singleQuote] = true, q2[C.doubleQuote] = true, q2[C.plus] = true, q2[C.pipe] = true, q2[C.tilde] = true, q2[C.greaterThan] = true, q2[C.equals] = true, q2[C.dollar] = true, q2[C.caret] = true, q2[C.slash] = true, q2), Zi2 = {}, Ql = "0123456789abcdefABCDEF";
  for (Xr3 = 0;Xr3 < Ql.length; Xr3++)
    Zi2[Ql.charCodeAt(Xr3)] = true;
  var Xr3;
  function Jg(t9, e2) {
    var r2 = e2, n2;
    do {
      if (n2 = t9.charCodeAt(r2), Qg[n2])
        return r2 - 1;
      n2 === C.backslash ? r2 = Xg(t9, r2) + 1 : r2++;
    } while (r2 < t9.length);
    return r2 - 1;
  }
  function Xg(t9, e2) {
    var r2 = e2, n2 = t9.charCodeAt(r2 + 1);
    if (!Hg[n2])
      if (Zi2[n2]) {
        var i = 0;
        do
          r2++, i++, n2 = t9.charCodeAt(r2 + 1);
        while (Zi2[n2] && i < 6);
        i < 6 && n2 === C.space && r2++;
      } else
        r2++;
    return r2;
  }
  var Kg = { TYPE: 0, START_LINE: 1, START_COL: 2, END_LINE: 3, END_COL: 4, START_POS: 5, END_POS: 6 };
  Zt2.FIELDS = Kg;
  function Zg(t9) {
    var e2 = [], r2 = t9.css.valueOf(), n2 = r2, i = n2.length, a = -1, s3 = 1, o2 = 0, l3 = 0, u, f, p, c2, d2, h2, y2, m, g2, w3, b4, v3, O3;
    function x(A, E2) {
      if (t9.safe)
        r2 += E2, g2 = r2.length - 1;
      else
        throw t9.error("Unclosed " + A, s3, o2 - a, o2);
    }
    for (;o2 < i; ) {
      switch (u = r2.charCodeAt(o2), u === C.newline && (a = o2, s3 += 1), u) {
        case C.space:
        case C.tab:
        case C.newline:
        case C.cr:
        case C.feed:
          g2 = o2;
          do
            g2 += 1, u = r2.charCodeAt(g2), u === C.newline && (a = g2, s3 += 1);
          while (u === C.space || u === C.newline || u === C.tab || u === C.cr || u === C.feed);
          O3 = C.space, c2 = s3, p = g2 - a - 1, l3 = g2;
          break;
        case C.plus:
        case C.greaterThan:
        case C.tilde:
        case C.pipe:
          g2 = o2;
          do
            g2 += 1, u = r2.charCodeAt(g2);
          while (u === C.plus || u === C.greaterThan || u === C.tilde || u === C.pipe);
          O3 = C.combinator, c2 = s3, p = o2 - a, l3 = g2;
          break;
        case C.asterisk:
        case C.ampersand:
        case C.bang:
        case C.comma:
        case C.equals:
        case C.dollar:
        case C.caret:
        case C.openSquare:
        case C.closeSquare:
        case C.colon:
        case C.semicolon:
        case C.openParenthesis:
        case C.closeParenthesis:
          g2 = o2, O3 = u, c2 = s3, p = o2 - a, l3 = g2 + 1;
          break;
        case C.singleQuote:
        case C.doubleQuote:
          v3 = u === C.singleQuote ? "'" : '"', g2 = o2;
          do
            for (d2 = false, g2 = r2.indexOf(v3, g2 + 1), g2 === -1 && x("quote", v3), h2 = g2;r2.charCodeAt(h2 - 1) === C.backslash; )
              h2 -= 1, d2 = !d2;
          while (d2);
          O3 = C.str, c2 = s3, p = o2 - a, l3 = g2 + 1;
          break;
        default:
          u === C.slash && r2.charCodeAt(o2 + 1) === C.asterisk ? (g2 = r2.indexOf("*/", o2 + 2) + 1, g2 === 0 && x("comment", "*/"), f = r2.slice(o2, g2 + 1), m = f.split(`
`), y2 = m.length - 1, y2 > 0 ? (w3 = s3 + y2, b4 = g2 - m[y2].length) : (w3 = s3, b4 = a), O3 = C.comment, s3 = w3, c2 = w3, p = g2 - b4) : u === C.slash ? (g2 = o2, O3 = u, c2 = s3, p = o2 - a, l3 = g2 + 1) : (g2 = Jg(r2, o2), O3 = C.word, c2 = s3, p = g2 - a), l3 = g2 + 1;
          break;
      }
      e2.push([O3, s3, o2 - a, c2, p, o2, l3]), b4 && (a = b4, b4 = null), o2 = l3;
    }
    return e2;
  }
});
var su3 = S3((er2, iu3) => {
  er2.__esModule = true;
  er2.default = undefined;
  var ey = le3(Si2()), es2 = le3(Oi2()), ty = le3(Ai2()), Kl = le3(Ti()), ry = le3(Ii2()), ny = le3(Mi2()), ts2 = le3(Li2()), iy = le3(qi2()), Zl = Kr3(Bi2()), sy = le3(Yi2()), rs2 = le3(Qi2()), ay = le3(Xi2()), oy = le3(Yl()), k3 = Kr3(Xl()), _3 = Kr3(Ki2()), ly = Kr3(J3()), V4 = Ft2(), Ve3, ns2;
  function nu3(t9) {
    if (typeof WeakMap != "function")
      return null;
    var e2 = new WeakMap, r2 = new WeakMap;
    return (nu3 = function(i) {
      return i ? r2 : e2;
    })(t9);
  }
  function Kr3(t9, e2) {
    if (!e2 && t9 && t9.__esModule)
      return t9;
    if (t9 === null || typeof t9 != "object" && typeof t9 != "function")
      return { default: t9 };
    var r2 = nu3(e2);
    if (r2 && r2.has(t9))
      return r2.get(t9);
    var n2 = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t9)
      if (a !== "default" && Object.prototype.hasOwnProperty.call(t9, a)) {
        var s3 = i ? Object.getOwnPropertyDescriptor(t9, a) : null;
        s3 && (s3.get || s3.set) ? Object.defineProperty(n2, a, s3) : n2[a] = t9[a];
      }
    return n2.default = t9, r2 && r2.set(t9, n2), n2;
  }
  function le3(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  function eu3(t9, e2) {
    for (var r2 = 0;r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t9, n2.key, n2);
    }
  }
  function uy(t9, e2, r2) {
    return e2 && eu3(t9.prototype, e2), r2 && eu3(t9, r2), Object.defineProperty(t9, "prototype", { writable: false }), t9;
  }
  var as2 = (Ve3 = {}, Ve3[_3.space] = true, Ve3[_3.cr] = true, Ve3[_3.feed] = true, Ve3[_3.newline] = true, Ve3[_3.tab] = true, Ve3), fy = Object.assign({}, as2, (ns2 = {}, ns2[_3.comment] = true, ns2));
  function tu3(t9) {
    return { line: t9[k3.FIELDS.START_LINE], column: t9[k3.FIELDS.START_COL] };
  }
  function ru3(t9) {
    return { line: t9[k3.FIELDS.END_LINE], column: t9[k3.FIELDS.END_COL] };
  }
  function We2(t9, e2, r2, n2) {
    return { start: { line: t9, column: e2 }, end: { line: r2, column: n2 } };
  }
  function et3(t9) {
    return We2(t9[k3.FIELDS.START_LINE], t9[k3.FIELDS.START_COL], t9[k3.FIELDS.END_LINE], t9[k3.FIELDS.END_COL]);
  }
  function is3(t9, e2) {
    if (!!t9)
      return We2(t9[k3.FIELDS.START_LINE], t9[k3.FIELDS.START_COL], e2[k3.FIELDS.END_LINE], e2[k3.FIELDS.END_COL]);
  }
  function tt3(t9, e2) {
    var r2 = t9[e2];
    if (typeof r2 == "string")
      return r2.indexOf("\\") !== -1 && ((0, V4.ensureObject)(t9, "raws"), t9[e2] = (0, V4.unesc)(r2), t9.raws[e2] === undefined && (t9.raws[e2] = r2)), t9;
  }
  function ss2(t9, e2) {
    for (var r2 = -1, n2 = [];(r2 = t9.indexOf(e2, r2 + 1)) !== -1; )
      n2.push(r2);
    return n2;
  }
  function cy() {
    var t9 = Array.prototype.concat.apply([], arguments);
    return t9.filter(function(e2, r2) {
      return r2 === t9.indexOf(e2);
    });
  }
  var py = function() {
    function t9(r2, n2) {
      n2 === undefined && (n2 = {}), this.rule = r2, this.options = Object.assign({ lossy: false, safe: false }, n2), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, k3.default)({ css: this.css, error: this._errorGenerator(), safe: this.options.safe });
      var i = is3(this.tokens[0], this.tokens[this.tokens.length - 1]);
      this.root = new ey.default({ source: i }), this.root.errorGenerator = this._errorGenerator();
      var a = new es2.default({ source: { start: { line: 1, column: 1 } } });
      this.root.append(a), this.current = a, this.loop();
    }
    var e2 = t9.prototype;
    return e2._errorGenerator = function() {
      var n2 = this;
      return function(i, a) {
        return typeof n2.rule == "string" ? new Error(i) : n2.rule.error(i, a);
      };
    }, e2.attribute = function() {
      var n2 = [], i = this.currToken;
      for (this.position++;this.position < this.tokens.length && this.currToken[k3.FIELDS.TYPE] !== _3.closeSquare; )
        n2.push(this.currToken), this.position++;
      if (this.currToken[k3.FIELDS.TYPE] !== _3.closeSquare)
        return this.expected("closing square bracket", this.currToken[k3.FIELDS.START_POS]);
      var a = n2.length, s3 = { source: We2(i[1], i[2], this.currToken[3], this.currToken[4]), sourceIndex: i[k3.FIELDS.START_POS] };
      if (a === 1 && !~[_3.word].indexOf(n2[0][k3.FIELDS.TYPE]))
        return this.expected("attribute", n2[0][k3.FIELDS.START_POS]);
      for (var o2 = 0, l3 = "", u = "", f = null, p = false;o2 < a; ) {
        var c2 = n2[o2], d2 = this.content(c2), h2 = n2[o2 + 1];
        switch (c2[k3.FIELDS.TYPE]) {
          case _3.space:
            if (p = true, this.options.lossy)
              break;
            if (f) {
              (0, V4.ensureObject)(s3, "spaces", f);
              var y2 = s3.spaces[f].after || "";
              s3.spaces[f].after = y2 + d2;
              var m = (0, V4.getProp)(s3, "raws", "spaces", f, "after") || null;
              m && (s3.raws.spaces[f].after = m + d2);
            } else
              l3 = l3 + d2, u = u + d2;
            break;
          case _3.asterisk:
            if (h2[k3.FIELDS.TYPE] === _3.equals)
              s3.operator = d2, f = "operator";
            else if ((!s3.namespace || f === "namespace" && !p) && h2) {
              l3 && ((0, V4.ensureObject)(s3, "spaces", "attribute"), s3.spaces.attribute.before = l3, l3 = ""), u && ((0, V4.ensureObject)(s3, "raws", "spaces", "attribute"), s3.raws.spaces.attribute.before = l3, u = ""), s3.namespace = (s3.namespace || "") + d2;
              var g2 = (0, V4.getProp)(s3, "raws", "namespace") || null;
              g2 && (s3.raws.namespace += d2), f = "namespace";
            }
            p = false;
            break;
          case _3.dollar:
            if (f === "value") {
              var w3 = (0, V4.getProp)(s3, "raws", "value");
              s3.value += "$", w3 && (s3.raws.value = w3 + "$");
              break;
            }
          case _3.caret:
            h2[k3.FIELDS.TYPE] === _3.equals && (s3.operator = d2, f = "operator"), p = false;
            break;
          case _3.combinator:
            if (d2 === "~" && h2[k3.FIELDS.TYPE] === _3.equals && (s3.operator = d2, f = "operator"), d2 !== "|") {
              p = false;
              break;
            }
            h2[k3.FIELDS.TYPE] === _3.equals ? (s3.operator = d2, f = "operator") : !s3.namespace && !s3.attribute && (s3.namespace = true), p = false;
            break;
          case _3.word:
            if (h2 && this.content(h2) === "|" && n2[o2 + 2] && n2[o2 + 2][k3.FIELDS.TYPE] !== _3.equals && !s3.operator && !s3.namespace)
              s3.namespace = d2, f = "namespace";
            else if (!s3.attribute || f === "attribute" && !p) {
              l3 && ((0, V4.ensureObject)(s3, "spaces", "attribute"), s3.spaces.attribute.before = l3, l3 = ""), u && ((0, V4.ensureObject)(s3, "raws", "spaces", "attribute"), s3.raws.spaces.attribute.before = u, u = ""), s3.attribute = (s3.attribute || "") + d2;
              var b4 = (0, V4.getProp)(s3, "raws", "attribute") || null;
              b4 && (s3.raws.attribute += d2), f = "attribute";
            } else if (!s3.value && s3.value !== "" || f === "value" && !(p || s3.quoteMark)) {
              var v3 = (0, V4.unesc)(d2), O3 = (0, V4.getProp)(s3, "raws", "value") || "", x = s3.value || "";
              s3.value = x + v3, s3.quoteMark = null, (v3 !== d2 || O3) && ((0, V4.ensureObject)(s3, "raws"), s3.raws.value = (O3 || x) + d2), f = "value";
            } else {
              var A = d2 === "i" || d2 === "I";
              (s3.value || s3.value === "") && (s3.quoteMark || p) ? (s3.insensitive = A, (!A || d2 === "I") && ((0, V4.ensureObject)(s3, "raws"), s3.raws.insensitiveFlag = d2), f = "insensitive", l3 && ((0, V4.ensureObject)(s3, "spaces", "insensitive"), s3.spaces.insensitive.before = l3, l3 = ""), u && ((0, V4.ensureObject)(s3, "raws", "spaces", "insensitive"), s3.raws.spaces.insensitive.before = u, u = "")) : (s3.value || s3.value === "") && (f = "value", s3.value += d2, s3.raws.value && (s3.raws.value += d2));
            }
            p = false;
            break;
          case _3.str:
            if (!s3.attribute || !s3.operator)
              return this.error("Expected an attribute followed by an operator preceding the string.", { index: c2[k3.FIELDS.START_POS] });
            var E2 = (0, Zl.unescapeValue)(d2), I3 = E2.unescaped, F = E2.quoteMark;
            s3.value = I3, s3.quoteMark = F, f = "value", (0, V4.ensureObject)(s3, "raws"), s3.raws.value = d2, p = false;
            break;
          case _3.equals:
            if (!s3.attribute)
              return this.expected("attribute", c2[k3.FIELDS.START_POS], d2);
            if (s3.value)
              return this.error('Unexpected "=" found; an operator was already defined.', { index: c2[k3.FIELDS.START_POS] });
            s3.operator = s3.operator ? s3.operator + d2 : d2, f = "operator", p = false;
            break;
          case _3.comment:
            if (f)
              if (p || h2 && h2[k3.FIELDS.TYPE] === _3.space || f === "insensitive") {
                var Y3 = (0, V4.getProp)(s3, "spaces", f, "after") || "", K3 = (0, V4.getProp)(s3, "raws", "spaces", f, "after") || Y3;
                (0, V4.ensureObject)(s3, "raws", "spaces", f), s3.raws.spaces[f].after = K3 + d2;
              } else {
                var B3 = s3[f] || "", qe3 = (0, V4.getProp)(s3, "raws", f) || B3;
                (0, V4.ensureObject)(s3, "raws"), s3.raws[f] = qe3 + d2;
              }
            else
              u = u + d2;
            break;
          default:
            return this.error('Unexpected "' + d2 + '" found.', { index: c2[k3.FIELDS.START_POS] });
        }
        o2++;
      }
      tt3(s3, "attribute"), tt3(s3, "namespace"), this.newNode(new Zl.default(s3)), this.position++;
    }, e2.parseWhitespaceEquivalentTokens = function(n2) {
      n2 < 0 && (n2 = this.tokens.length);
      var i = this.position, a = [], s3 = "", o2 = undefined;
      do
        if (as2[this.currToken[k3.FIELDS.TYPE]])
          this.options.lossy || (s3 += this.content());
        else if (this.currToken[k3.FIELDS.TYPE] === _3.comment) {
          var l3 = {};
          s3 && (l3.before = s3, s3 = ""), o2 = new Kl.default({ value: this.content(), source: et3(this.currToken), sourceIndex: this.currToken[k3.FIELDS.START_POS], spaces: l3 }), a.push(o2);
        }
      while (++this.position < n2);
      if (s3) {
        if (o2)
          o2.spaces.after = s3;
        else if (!this.options.lossy) {
          var u = this.tokens[i], f = this.tokens[this.position - 1];
          a.push(new ts2.default({ value: "", source: We2(u[k3.FIELDS.START_LINE], u[k3.FIELDS.START_COL], f[k3.FIELDS.END_LINE], f[k3.FIELDS.END_COL]), sourceIndex: u[k3.FIELDS.START_POS], spaces: { before: s3, after: "" } }));
        }
      }
      return a;
    }, e2.convertWhitespaceNodesToSpace = function(n2, i) {
      var a = this;
      i === undefined && (i = false);
      var s3 = "", o2 = "";
      n2.forEach(function(u) {
        var f = a.lossySpace(u.spaces.before, i), p = a.lossySpace(u.rawSpaceBefore, i);
        s3 += f + a.lossySpace(u.spaces.after, i && f.length === 0), o2 += f + u.value + a.lossySpace(u.rawSpaceAfter, i && p.length === 0);
      }), o2 === s3 && (o2 = undefined);
      var l3 = { space: s3, rawSpace: o2 };
      return l3;
    }, e2.isNamedCombinator = function(n2) {
      return n2 === undefined && (n2 = this.position), this.tokens[n2 + 0] && this.tokens[n2 + 0][k3.FIELDS.TYPE] === _3.slash && this.tokens[n2 + 1] && this.tokens[n2 + 1][k3.FIELDS.TYPE] === _3.word && this.tokens[n2 + 2] && this.tokens[n2 + 2][k3.FIELDS.TYPE] === _3.slash;
    }, e2.namedCombinator = function() {
      if (this.isNamedCombinator()) {
        var n2 = this.content(this.tokens[this.position + 1]), i = (0, V4.unesc)(n2).toLowerCase(), a = {};
        i !== n2 && (a.value = "/" + n2 + "/");
        var s3 = new rs2.default({ value: "/" + i + "/", source: We2(this.currToken[k3.FIELDS.START_LINE], this.currToken[k3.FIELDS.START_COL], this.tokens[this.position + 2][k3.FIELDS.END_LINE], this.tokens[this.position + 2][k3.FIELDS.END_COL]), sourceIndex: this.currToken[k3.FIELDS.START_POS], raws: a });
        return this.position = this.position + 3, s3;
      } else
        this.unexpected();
    }, e2.combinator = function() {
      var n2 = this;
      if (this.content() === "|")
        return this.namespace();
      var i = this.locateNextMeaningfulToken(this.position);
      if (i < 0 || this.tokens[i][k3.FIELDS.TYPE] === _3.comma) {
        var a = this.parseWhitespaceEquivalentTokens(i);
        if (a.length > 0) {
          var s3 = this.current.last;
          if (s3) {
            var o2 = this.convertWhitespaceNodesToSpace(a), l3 = o2.space, u = o2.rawSpace;
            u !== undefined && (s3.rawSpaceAfter += u), s3.spaces.after += l3;
          } else
            a.forEach(function(O3) {
              return n2.newNode(O3);
            });
        }
        return;
      }
      var f = this.currToken, p = undefined;
      i > this.position && (p = this.parseWhitespaceEquivalentTokens(i));
      var c2;
      if (this.isNamedCombinator() ? c2 = this.namedCombinator() : this.currToken[k3.FIELDS.TYPE] === _3.combinator ? (c2 = new rs2.default({ value: this.content(), source: et3(this.currToken), sourceIndex: this.currToken[k3.FIELDS.START_POS] }), this.position++) : as2[this.currToken[k3.FIELDS.TYPE]] || p || this.unexpected(), c2) {
        if (p) {
          var d2 = this.convertWhitespaceNodesToSpace(p), h2 = d2.space, y2 = d2.rawSpace;
          c2.spaces.before = h2, c2.rawSpaceBefore = y2;
        }
      } else {
        var m = this.convertWhitespaceNodesToSpace(p, true), g2 = m.space, w3 = m.rawSpace;
        w3 || (w3 = g2);
        var b4 = {}, v3 = { spaces: {} };
        g2.endsWith(" ") && w3.endsWith(" ") ? (b4.before = g2.slice(0, g2.length - 1), v3.spaces.before = w3.slice(0, w3.length - 1)) : g2.startsWith(" ") && w3.startsWith(" ") ? (b4.after = g2.slice(1), v3.spaces.after = w3.slice(1)) : v3.value = w3, c2 = new rs2.default({ value: " ", source: is3(f, this.tokens[this.position - 1]), sourceIndex: f[k3.FIELDS.START_POS], spaces: b4, raws: v3 });
      }
      return this.currToken && this.currToken[k3.FIELDS.TYPE] === _3.space && (c2.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(c2);
    }, e2.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = true, this.position++;
        return;
      }
      this.current._inferEndPosition();
      var n2 = new es2.default({ source: { start: tu3(this.tokens[this.position + 1]) } });
      this.current.parent.append(n2), this.current = n2, this.position++;
    }, e2.comment = function() {
      var n2 = this.currToken;
      this.newNode(new Kl.default({ value: this.content(), source: et3(n2), sourceIndex: n2[k3.FIELDS.START_POS] })), this.position++;
    }, e2.error = function(n2, i) {
      throw this.root.error(n2, i);
    }, e2.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.", { index: this.currToken[k3.FIELDS.START_POS] });
    }, e2.missingParenthesis = function() {
      return this.expected("opening parenthesis", this.currToken[k3.FIELDS.START_POS]);
    }, e2.missingSquareBracket = function() {
      return this.expected("opening square bracket", this.currToken[k3.FIELDS.START_POS]);
    }, e2.unexpected = function() {
      return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[k3.FIELDS.START_POS]);
    }, e2.unexpectedPipe = function() {
      return this.error("Unexpected '|'.", this.currToken[k3.FIELDS.START_POS]);
    }, e2.namespace = function() {
      var n2 = this.prevToken && this.content(this.prevToken) || true;
      if (this.nextToken[k3.FIELDS.TYPE] === _3.word)
        return this.position++, this.word(n2);
      if (this.nextToken[k3.FIELDS.TYPE] === _3.asterisk)
        return this.position++, this.universal(n2);
      this.unexpectedPipe();
    }, e2.nesting = function() {
      if (this.nextToken) {
        var n2 = this.content(this.nextToken);
        if (n2 === "|") {
          this.position++;
          return;
        }
      }
      var i = this.currToken;
      this.newNode(new ay.default({ value: this.content(), source: et3(i), sourceIndex: i[k3.FIELDS.START_POS] })), this.position++;
    }, e2.parentheses = function() {
      var n2 = this.current.last, i = 1;
      if (this.position++, n2 && n2.type === ly.PSEUDO) {
        var a = new es2.default({ source: { start: tu3(this.tokens[this.position - 1]) } }), s3 = this.current;
        for (n2.append(a), this.current = a;this.position < this.tokens.length && i; )
          this.currToken[k3.FIELDS.TYPE] === _3.openParenthesis && i++, this.currToken[k3.FIELDS.TYPE] === _3.closeParenthesis && i--, i ? this.parse() : (this.current.source.end = ru3(this.currToken), this.current.parent.source.end = ru3(this.currToken), this.position++);
        this.current = s3;
      } else {
        for (var o2 = this.currToken, l3 = "(", u;this.position < this.tokens.length && i; )
          this.currToken[k3.FIELDS.TYPE] === _3.openParenthesis && i++, this.currToken[k3.FIELDS.TYPE] === _3.closeParenthesis && i--, u = this.currToken, l3 += this.parseParenthesisToken(this.currToken), this.position++;
        n2 ? n2.appendToPropertyAndEscape("value", l3, l3) : this.newNode(new ts2.default({ value: l3, source: We2(o2[k3.FIELDS.START_LINE], o2[k3.FIELDS.START_COL], u[k3.FIELDS.END_LINE], u[k3.FIELDS.END_COL]), sourceIndex: o2[k3.FIELDS.START_POS] }));
      }
      if (i)
        return this.expected("closing parenthesis", this.currToken[k3.FIELDS.START_POS]);
    }, e2.pseudo = function() {
      for (var n2 = this, i = "", a = this.currToken;this.currToken && this.currToken[k3.FIELDS.TYPE] === _3.colon; )
        i += this.content(), this.position++;
      if (!this.currToken)
        return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      if (this.currToken[k3.FIELDS.TYPE] === _3.word)
        this.splitWord(false, function(s3, o2) {
          i += s3, n2.newNode(new iy.default({ value: i, source: is3(a, n2.currToken), sourceIndex: a[k3.FIELDS.START_POS] })), o2 > 1 && n2.nextToken && n2.nextToken[k3.FIELDS.TYPE] === _3.openParenthesis && n2.error("Misplaced parenthesis.", { index: n2.nextToken[k3.FIELDS.START_POS] });
        });
      else
        return this.expected(["pseudo-class", "pseudo-element"], this.currToken[k3.FIELDS.START_POS]);
    }, e2.space = function() {
      var n2 = this.content();
      this.position === 0 || this.prevToken[k3.FIELDS.TYPE] === _3.comma || this.prevToken[k3.FIELDS.TYPE] === _3.openParenthesis || this.current.nodes.every(function(i) {
        return i.type === "comment";
      }) ? (this.spaces = this.optionalSpace(n2), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[k3.FIELDS.TYPE] === _3.comma || this.nextToken[k3.FIELDS.TYPE] === _3.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(n2), this.position++) : this.combinator();
    }, e2.string = function() {
      var n2 = this.currToken;
      this.newNode(new ts2.default({ value: this.content(), source: et3(n2), sourceIndex: n2[k3.FIELDS.START_POS] })), this.position++;
    }, e2.universal = function(n2) {
      var i = this.nextToken;
      if (i && this.content(i) === "|")
        return this.position++, this.namespace();
      var a = this.currToken;
      this.newNode(new sy.default({ value: this.content(), source: et3(a), sourceIndex: a[k3.FIELDS.START_POS] }), n2), this.position++;
    }, e2.splitWord = function(n2, i) {
      for (var a = this, s3 = this.nextToken, o2 = this.content();s3 && ~[_3.dollar, _3.caret, _3.equals, _3.word].indexOf(s3[k3.FIELDS.TYPE]); ) {
        this.position++;
        var l3 = this.content();
        if (o2 += l3, l3.lastIndexOf("\\") === l3.length - 1) {
          var u = this.nextToken;
          u && u[k3.FIELDS.TYPE] === _3.space && (o2 += this.requiredSpace(this.content(u)), this.position++);
        }
        s3 = this.nextToken;
      }
      var f = ss2(o2, ".").filter(function(h2) {
        var y2 = o2[h2 - 1] === "\\", m = /^\d+\.\d+%$/.test(o2);
        return !y2 && !m;
      }), p = ss2(o2, "#").filter(function(h2) {
        return o2[h2 - 1] !== "\\";
      }), c2 = ss2(o2, "#{");
      c2.length && (p = p.filter(function(h2) {
        return !~c2.indexOf(h2);
      }));
      var d2 = (0, oy.default)(cy([0].concat(f, p)));
      d2.forEach(function(h2, y2) {
        var m = d2[y2 + 1] || o2.length, g2 = o2.slice(h2, m);
        if (y2 === 0 && i)
          return i.call(a, g2, d2.length);
        var w3, b4 = a.currToken, v3 = b4[k3.FIELDS.START_POS] + d2[y2], O3 = We2(b4[1], b4[2] + h2, b4[3], b4[2] + (m - 1));
        if (~f.indexOf(h2)) {
          var x = { value: g2.slice(1), source: O3, sourceIndex: v3 };
          w3 = new ty.default(tt3(x, "value"));
        } else if (~p.indexOf(h2)) {
          var A = { value: g2.slice(1), source: O3, sourceIndex: v3 };
          w3 = new ry.default(tt3(A, "value"));
        } else {
          var E2 = { value: g2, source: O3, sourceIndex: v3 };
          tt3(E2, "value"), w3 = new ny.default(E2);
        }
        a.newNode(w3, n2), n2 = null;
      }), this.position++;
    }, e2.word = function(n2) {
      var i = this.nextToken;
      return i && this.content(i) === "|" ? (this.position++, this.namespace()) : this.splitWord(n2);
    }, e2.loop = function() {
      for (;this.position < this.tokens.length; )
        this.parse(true);
      return this.current._inferEndPosition(), this.root;
    }, e2.parse = function(n2) {
      switch (this.currToken[k3.FIELDS.TYPE]) {
        case _3.space:
          this.space();
          break;
        case _3.comment:
          this.comment();
          break;
        case _3.openParenthesis:
          this.parentheses();
          break;
        case _3.closeParenthesis:
          n2 && this.missingParenthesis();
          break;
        case _3.openSquare:
          this.attribute();
          break;
        case _3.dollar:
        case _3.caret:
        case _3.equals:
        case _3.word:
          this.word();
          break;
        case _3.colon:
          this.pseudo();
          break;
        case _3.comma:
          this.comma();
          break;
        case _3.asterisk:
          this.universal();
          break;
        case _3.ampersand:
          this.nesting();
          break;
        case _3.slash:
        case _3.combinator:
          this.combinator();
          break;
        case _3.str:
          this.string();
          break;
        case _3.closeSquare:
          this.missingSquareBracket();
        case _3.semicolon:
          this.missingBackslash();
        default:
          this.unexpected();
      }
    }, e2.expected = function(n2, i, a) {
      if (Array.isArray(n2)) {
        var s3 = n2.pop();
        n2 = n2.join(", ") + " or " + s3;
      }
      var o2 = /^[aeiou]/.test(n2[0]) ? "an" : "a";
      return a ? this.error("Expected " + o2 + " " + n2 + ', found "' + a + '" instead.', { index: i }) : this.error("Expected " + o2 + " " + n2 + ".", { index: i });
    }, e2.requiredSpace = function(n2) {
      return this.options.lossy ? " " : n2;
    }, e2.optionalSpace = function(n2) {
      return this.options.lossy ? "" : n2;
    }, e2.lossySpace = function(n2, i) {
      return this.options.lossy ? i ? " " : "" : n2;
    }, e2.parseParenthesisToken = function(n2) {
      var i = this.content(n2);
      return n2[k3.FIELDS.TYPE] === _3.space ? this.requiredSpace(i) : i;
    }, e2.newNode = function(n2, i) {
      return i && (/^ +$/.test(i) && (this.options.lossy || (this.spaces = (this.spaces || "") + i), i = true), n2.namespace = i, tt3(n2, "namespace")), this.spaces && (n2.spaces.before = this.spaces, this.spaces = ""), this.current.append(n2);
    }, e2.content = function(n2) {
      return n2 === undefined && (n2 = this.currToken), this.css.slice(n2[k3.FIELDS.START_POS], n2[k3.FIELDS.END_POS]);
    }, e2.locateNextMeaningfulToken = function(n2) {
      n2 === undefined && (n2 = this.position + 1);
      for (var i = n2;i < this.tokens.length; )
        if (fy[this.tokens[i][k3.FIELDS.TYPE]]) {
          i++;
          continue;
        } else
          return i;
      return -1;
    }, uy(t9, [{ key: "currToken", get: function() {
      return this.tokens[this.position];
    } }, { key: "nextToken", get: function() {
      return this.tokens[this.position + 1];
    } }, { key: "prevToken", get: function() {
      return this.tokens[this.position - 1];
    } }]), t9;
  }();
  er2.default = py;
  iu3.exports = er2.default;
});
var ou3 = S3((tr2, au3) => {
  tr2.__esModule = true;
  tr2.default = undefined;
  var dy = hy(su3());
  function hy(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  var my = function() {
    function t9(r2, n2) {
      this.func = r2 || function() {
      }, this.funcRes = null, this.options = n2;
    }
    var e2 = t9.prototype;
    return e2._shouldUpdateSelector = function(n2, i) {
      i === undefined && (i = {});
      var a = Object.assign({}, this.options, i);
      return a.updateSelector === false ? false : typeof n2 != "string";
    }, e2._isLossy = function(n2) {
      n2 === undefined && (n2 = {});
      var i = Object.assign({}, this.options, n2);
      return i.lossless === false;
    }, e2._root = function(n2, i) {
      i === undefined && (i = {});
      var a = new dy.default(n2, this._parseOptions(i));
      return a.root;
    }, e2._parseOptions = function(n2) {
      return { lossy: this._isLossy(n2) };
    }, e2._run = function(n2, i) {
      var a = this;
      return i === undefined && (i = {}), new Promise(function(s3, o2) {
        try {
          var l3 = a._root(n2, i);
          Promise.resolve(a.func(l3)).then(function(u) {
            var f = undefined;
            return a._shouldUpdateSelector(n2, i) && (f = l3.toString(), n2.selector = f), { transform: u, root: l3, string: f };
          }).then(s3, o2);
        } catch (u) {
          o2(u);
          return;
        }
      });
    }, e2._runSync = function(n2, i) {
      i === undefined && (i = {});
      var a = this._root(n2, i), s3 = this.func(a);
      if (s3 && typeof s3.then == "function")
        throw new Error("Selector processor returned a promise to a synchronous call.");
      var o2 = undefined;
      return i.updateSelector && typeof n2 != "string" && (o2 = a.toString(), n2.selector = o2), { transform: s3, root: a, string: o2 };
    }, e2.ast = function(n2, i) {
      return this._run(n2, i).then(function(a) {
        return a.root;
      });
    }, e2.astSync = function(n2, i) {
      return this._runSync(n2, i).root;
    }, e2.transform = function(n2, i) {
      return this._run(n2, i).then(function(a) {
        return a.transform;
      });
    }, e2.transformSync = function(n2, i) {
      return this._runSync(n2, i).transform;
    }, e2.process = function(n2, i) {
      return this._run(n2, i).then(function(a) {
        return a.string || a.root.toString();
      });
    }, e2.processSync = function(n2, i) {
      var a = this._runSync(n2, i);
      return a.string || a.root.toString();
    }, t9;
  }();
  tr2.default = my;
  au3.exports = tr2.default;
});
var lu = S3((j3) => {
  j3.__esModule = true;
  j3.universal = j3.tag = j3.string = j3.selector = j3.root = j3.pseudo = j3.nesting = j3.id = j3.comment = j3.combinator = j3.className = j3.attribute = undefined;
  var gy = ue(Bi2()), yy = ue(Ai2()), vy = ue(Qi2()), wy = ue(Ti()), by = ue(Ii2()), xy = ue(Xi2()), Sy = ue(qi2()), ky = ue(Si2()), Oy = ue(Oi2()), Ey = ue(Li2()), Cy = ue(Mi2()), Ay = ue(Yi2());
  function ue(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  var _y = function(e2) {
    return new gy.default(e2);
  };
  j3.attribute = _y;
  var Ty = function(e2) {
    return new yy.default(e2);
  };
  j3.className = Ty;
  var Py = function(e2) {
    return new vy.default(e2);
  };
  j3.combinator = Py;
  var Iy = function(e2) {
    return new wy.default(e2);
  };
  j3.comment = Iy;
  var Ry = function(e2) {
    return new by.default(e2);
  };
  j3.id = Ry;
  var Dy = function(e2) {
    return new xy.default(e2);
  };
  j3.nesting = Dy;
  var My = function(e2) {
    return new Sy.default(e2);
  };
  j3.pseudo = My;
  var Fy = function(e2) {
    return new ky.default(e2);
  };
  j3.root = Fy;
  var Ly = function(e2) {
    return new Oy.default(e2);
  };
  j3.selector = Ly;
  var Ny = function(e2) {
    return new Ey.default(e2);
  };
  j3.string = Ny;
  var qy = function(e2) {
    return new Cy.default(e2);
  };
  j3.tag = qy;
  var $y = function(e2) {
    return new Ay.default(e2);
  };
  j3.universal = $y;
});
var pu2 = S3((D) => {
  D.__esModule = true;
  D.isComment = D.isCombinator = D.isClassName = D.isAttribute = undefined;
  D.isContainer = Xy;
  D.isIdentifier = undefined;
  D.isNamespace = Ky;
  D.isNesting = undefined;
  D.isNode = os3;
  D.isPseudo = undefined;
  D.isPseudoClass = Jy;
  D.isPseudoElement = cu2;
  D.isUniversal = D.isTag = D.isString = D.isSelector = D.isRoot = undefined;
  var W3 = J3(), te2, Uy = (te2 = {}, te2[W3.ATTRIBUTE] = true, te2[W3.CLASS] = true, te2[W3.COMBINATOR] = true, te2[W3.COMMENT] = true, te2[W3.ID] = true, te2[W3.NESTING] = true, te2[W3.PSEUDO] = true, te2[W3.ROOT] = true, te2[W3.SELECTOR] = true, te2[W3.STRING] = true, te2[W3.TAG] = true, te2[W3.UNIVERSAL] = true, te2);
  function os3(t9) {
    return typeof t9 == "object" && Uy[t9.type];
  }
  function fe3(t9, e2) {
    return os3(e2) && e2.type === t9;
  }
  var uu3 = fe3.bind(null, W3.ATTRIBUTE);
  D.isAttribute = uu3;
  var jy = fe3.bind(null, W3.CLASS);
  D.isClassName = jy;
  var zy = fe3.bind(null, W3.COMBINATOR);
  D.isCombinator = zy;
  var Vy = fe3.bind(null, W3.COMMENT);
  D.isComment = Vy;
  var Wy = fe3.bind(null, W3.ID);
  D.isIdentifier = Wy;
  var By = fe3.bind(null, W3.NESTING);
  D.isNesting = By;
  var ls2 = fe3.bind(null, W3.PSEUDO);
  D.isPseudo = ls2;
  var Gy = fe3.bind(null, W3.ROOT);
  D.isRoot = Gy;
  var Yy = fe3.bind(null, W3.SELECTOR);
  D.isSelector = Yy;
  var Hy = fe3.bind(null, W3.STRING);
  D.isString = Hy;
  var fu2 = fe3.bind(null, W3.TAG);
  D.isTag = fu2;
  var Qy = fe3.bind(null, W3.UNIVERSAL);
  D.isUniversal = Qy;
  function cu2(t9) {
    return ls2(t9) && t9.value && (t9.value.startsWith("::") || t9.value.toLowerCase() === ":before" || t9.value.toLowerCase() === ":after" || t9.value.toLowerCase() === ":first-letter" || t9.value.toLowerCase() === ":first-line");
  }
  function Jy(t9) {
    return ls2(t9) && !cu2(t9);
  }
  function Xy(t9) {
    return !!(os3(t9) && t9.walk);
  }
  function Ky(t9) {
    return uu3(t9) || fu2(t9);
  }
});
var du2 = S3((de3) => {
  de3.__esModule = true;
  var us2 = J3();
  Object.keys(us2).forEach(function(t9) {
    t9 === "default" || t9 === "__esModule" || t9 in de3 && de3[t9] === us2[t9] || (de3[t9] = us2[t9]);
  });
  var fs3 = lu();
  Object.keys(fs3).forEach(function(t9) {
    t9 === "default" || t9 === "__esModule" || t9 in de3 && de3[t9] === fs3[t9] || (de3[t9] = fs3[t9]);
  });
  var cs2 = pu2();
  Object.keys(cs2).forEach(function(t9) {
    t9 === "default" || t9 === "__esModule" || t9 in de3 && de3[t9] === cs2[t9] || (de3[t9] = cs2[t9]);
  });
});
var ve3 = S3((rr3, mu2) => {
  rr3.__esModule = true;
  rr3.default = undefined;
  var Zy = r0(ou3()), e0 = t0(du2());
  function hu2(t9) {
    if (typeof WeakMap != "function")
      return null;
    var e2 = new WeakMap, r2 = new WeakMap;
    return (hu2 = function(i) {
      return i ? r2 : e2;
    })(t9);
  }
  function t0(t9, e2) {
    if (!e2 && t9 && t9.__esModule)
      return t9;
    if (t9 === null || typeof t9 != "object" && typeof t9 != "function")
      return { default: t9 };
    var r2 = hu2(e2);
    if (r2 && r2.has(t9))
      return r2.get(t9);
    var n2 = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t9)
      if (a !== "default" && Object.prototype.hasOwnProperty.call(t9, a)) {
        var s3 = i ? Object.getOwnPropertyDescriptor(t9, a) : null;
        s3 && (s3.get || s3.set) ? Object.defineProperty(n2, a, s3) : n2[a] = t9[a];
      }
    return n2.default = t9, r2 && r2.set(t9, n2), n2;
  }
  function r0(t9) {
    return t9 && t9.__esModule ? t9 : { default: t9 };
  }
  var ps2 = function(e2) {
    return new Zy.default(e2);
  };
  Object.assign(ps2, e0);
  delete ps2.__esModule;
  var n0 = ps2;
  rr3.default = n0;
  mu2.exports = rr3.default;
});
var Su2 = S3((Dx, ys2) => {
  var { Rule: yu2, AtRule: i0 } = Ke3(), vu2 = ve3();
  function ms2(t9, e2) {
    let r2;
    try {
      vu2((n2) => {
        r2 = n2;
      }).processSync(t9);
    } catch (n2) {
      throw t9.includes(":") ? e2 ? e2.error("Missed semicolon") : n2 : e2 ? e2.error(n2.message) : n2;
    }
    return r2.at(0);
  }
  function wu2(t9, e2) {
    let r2 = false;
    return t9.each((n2) => {
      if (n2.type === "nesting") {
        let i = e2.clone({});
        n2.value !== "&" ? n2.replaceWith(ms2(n2.value.replace("&", i.toString()))) : n2.replaceWith(i), r2 = true;
      } else
        "nodes" in n2 && n2.nodes && wu2(n2, e2) && (r2 = true);
    }), r2;
  }
  function bu2(t9, e2) {
    let r2 = [];
    return t9.selectors.forEach((n2) => {
      let i = ms2(n2, t9);
      e2.selectors.forEach((a) => {
        if (!a)
          return;
        let s3 = ms2(a, e2);
        wu2(s3, i) || (s3.prepend(vu2.combinator({ value: " " })), s3.prepend(i.clone({}))), r2.push(s3.toString());
      });
    }), r2;
  }
  function Zr3(t9, e2) {
    let r2 = t9.prev();
    for (e2.after(t9);r2 && r2.type === "comment"; ) {
      let n2 = r2.prev();
      e2.after(r2), r2 = n2;
    }
    return t9;
  }
  function s0(t9) {
    return function e(r2, n2, i, a = i) {
      let s3 = [];
      if (n2.each((o2) => {
        o2.type === "rule" && i ? a && (o2.selectors = bu2(r2, o2)) : o2.type === "atrule" && o2.nodes ? t9[o2.name] ? e(r2, o2, a) : n2[gs2] !== false && s3.push(o2) : s3.push(o2);
      }), i && s3.length) {
        let o2 = r2.clone({ nodes: [] });
        for (let l3 of s3)
          o2.append(l3);
        n2.prepend(o2);
      }
    };
  }
  function ds2(t9, e2, r2) {
    let n2 = new yu2({ selector: t9, nodes: [] });
    return n2.append(e2), r2.after(n2), n2;
  }
  function gu2(t9, e2) {
    let r2 = {};
    for (let n2 of t9)
      r2[n2] = true;
    if (e2)
      for (let n2 of e2)
        r2[n2.replace(/^@/, "")] = true;
    return r2;
  }
  function a0(t9) {
    t9 = t9.trim();
    let e2 = t9.match(/^\((.*)\)$/);
    if (!e2)
      return { type: "basic", selector: t9 };
    let r2 = e2[1].match(/^(with(?:out)?):(.+)$/);
    if (r2) {
      let n2 = r2[1] === "with", i = Object.fromEntries(r2[2].trim().split(/\s+/).map((s3) => [s3, true]));
      if (n2 && i.all)
        return { type: "noop" };
      let a = (s3) => !!i[s3];
      return i.all ? a = () => true : n2 && (a = (s3) => s3 === "all" ? false : !i[s3]), { type: "withrules", escapes: a };
    }
    return { type: "unknown" };
  }
  function o0(t9) {
    let e2 = [], r2 = t9.parent;
    for (;r2 && r2 instanceof i0; )
      e2.push(r2), r2 = r2.parent;
    return e2;
  }
  function l0(t9) {
    let e2 = t9[xu2];
    if (!e2)
      t9.after(t9.nodes);
    else {
      let r2 = t9.nodes, n2, i = -1, a, s3, o2, l3 = o0(t9);
      if (l3.forEach((u, f) => {
        if (e2(u.name))
          n2 = u, i = f, s3 = o2;
        else {
          let p = o2;
          o2 = u.clone({ nodes: [] }), p && o2.append(p), a = a || o2;
        }
      }), n2 ? s3 ? (a.append(r2), n2.after(s3)) : n2.after(r2) : t9.after(r2), t9.next() && n2) {
        let u;
        l3.slice(0, i + 1).forEach((f, p, c2) => {
          let d2 = u;
          u = f.clone({ nodes: [] }), d2 && u.append(d2);
          let h2 = [], m = (c2[p - 1] || t9).next();
          for (;m; )
            h2.push(m), m = m.next();
          u.append(h2);
        }), u && (s3 || r2[r2.length - 1]).after(u);
      }
    }
    t9.remove();
  }
  var gs2 = Symbol("rootRuleMergeSel"), xu2 = Symbol("rootRuleEscapes");
  function u0(t9) {
    let { params: e2 } = t9, { type: r2, selector: n2, escapes: i } = a0(e2);
    if (r2 === "unknown")
      throw t9.error(`Unknown @${t9.name} parameter ${JSON.stringify(e2)}`);
    if (r2 === "basic" && n2) {
      let a = new yu2({ selector: n2, nodes: t9.nodes });
      t9.removeAll(), t9.append(a);
    }
    t9[xu2] = i, t9[gs2] = i ? !i("all") : r2 === "noop";
  }
  var hs2 = Symbol("hasRootRule");
  ys2.exports = (t9 = {}) => {
    let e2 = gu2(["media", "supports", "layer", "container"], t9.bubble), r2 = s0(e2), n2 = gu2(["document", "font-face", "keyframes", "-webkit-keyframes", "-moz-keyframes"], t9.unwrap), i = (t9.rootRuleName || "at-root").replace(/^@/, ""), a = t9.preserveEmpty;
    return { postcssPlugin: "postcss-nested", Once(s3) {
      s3.walkAtRules(i, (o2) => {
        u0(o2), s3[hs2] = true;
      });
    }, Rule(s3) {
      let o2 = false, l3 = s3, u = false, f = [];
      s3.each((p) => {
        p.type === "rule" ? (f.length && (l3 = ds2(s3.selector, f, l3), f = []), u = true, o2 = true, p.selectors = bu2(s3, p), l3 = Zr3(p, l3)) : p.type === "atrule" ? (f.length && (l3 = ds2(s3.selector, f, l3), f = []), p.name === i ? (o2 = true, r2(s3, p, true, p[gs2]), l3 = Zr3(p, l3)) : e2[p.name] ? (u = true, o2 = true, r2(s3, p, true), l3 = Zr3(p, l3)) : n2[p.name] ? (u = true, o2 = true, r2(s3, p, false), l3 = Zr3(p, l3)) : u && f.push(p)) : p.type === "decl" && u && f.push(p);
      }), f.length && (l3 = ds2(s3.selector, f, l3)), o2 && a !== true && (s3.raws.semicolon = true, s3.nodes.length === 0 && s3.remove());
    }, RootExit(s3) {
      s3[hs2] && (s3.walkAtRules(i, l0), s3[hs2] = false);
    } };
  };
  ys2.exports.postcss = true;
});
var Cu2 = S3((Mx, Eu2) => {
  var ku2 = /-(\w|$)/g, Ou2 = function(e2, r2) {
    return r2.toUpperCase();
  }, f0 = function(e2) {
    return e2 = e2.toLowerCase(), e2 === "float" ? "cssFloat" : e2.charCodeAt(0) === 45 && e2.charCodeAt(1) === 109 && e2.charCodeAt(2) === 115 && e2.charCodeAt(3) === 45 ? e2.substr(1).replace(ku2, Ou2) : e2.replace(ku2, Ou2);
  };
  Eu2.exports = f0;
});
var bs2 = S3((Fx, Au2) => {
  var c0 = Cu2(), p0 = { boxFlex: true, boxFlexGroup: true, columnCount: true, flex: true, flexGrow: true, flexPositive: true, flexShrink: true, flexNegative: true, fontWeight: true, lineClamp: true, lineHeight: true, opacity: true, order: true, orphans: true, tabSize: true, widows: true, zIndex: true, zoom: true, fillOpacity: true, strokeDashoffset: true, strokeOpacity: true, strokeWidth: true };
  function vs2(t9) {
    return typeof t9.nodes > "u" ? true : ws3(t9);
  }
  function ws3(t9) {
    let e2, r2 = {};
    return t9.each((n2) => {
      if (n2.type === "atrule")
        e2 = "@" + n2.name, n2.params && (e2 += " " + n2.params), typeof r2[e2] > "u" ? r2[e2] = vs2(n2) : Array.isArray(r2[e2]) ? r2[e2].push(vs2(n2)) : r2[e2] = [r2[e2], vs2(n2)];
      else if (n2.type === "rule") {
        let i = ws3(n2);
        if (r2[n2.selector])
          for (let a in i)
            r2[n2.selector][a] = i[a];
        else
          r2[n2.selector] = i;
      } else if (n2.type === "decl") {
        n2.prop[0] === "-" && n2.prop[1] === "-" || n2.parent && n2.parent.selector === ":export" ? e2 = n2.prop : e2 = c0(n2.prop);
        let i = n2.value;
        !isNaN(n2.value) && p0[e2] && (i = parseFloat(n2.value)), n2.important && (i += " !important"), typeof r2[e2] > "u" ? r2[e2] = i : Array.isArray(r2[e2]) ? r2[e2].push(i) : r2[e2] = [r2[e2], i];
      }
    }), r2;
  }
  Au2.exports = ws3;
});
var en3 = S3((Lx, Iu2) => {
  var nr3 = Ke3(), _u2 = /\s*!important\s*$/i, d0 = { "box-flex": true, "box-flex-group": true, "column-count": true, flex: true, "flex-grow": true, "flex-positive": true, "flex-shrink": true, "flex-negative": true, "font-weight": true, "line-clamp": true, "line-height": true, opacity: true, order: true, orphans: true, "tab-size": true, widows: true, "z-index": true, zoom: true, "fill-opacity": true, "stroke-dashoffset": true, "stroke-opacity": true, "stroke-width": true };
  function h0(t9) {
    return t9.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
  }
  function Tu2(t9, e2, r2) {
    r2 === false || r2 === null || (e2.startsWith("--") || (e2 = h0(e2)), typeof r2 == "number" && (r2 === 0 || d0[e2] ? r2 = r2.toString() : r2 += "px"), e2 === "css-float" && (e2 = "float"), _u2.test(r2) ? (r2 = r2.replace(_u2, ""), t9.push(nr3.decl({ prop: e2, value: r2, important: true }))) : t9.push(nr3.decl({ prop: e2, value: r2 })));
  }
  function Pu2(t9, e2, r2) {
    let n2 = nr3.atRule({ name: e2[1], params: e2[3] || "" });
    typeof r2 == "object" && (n2.nodes = [], xs2(r2, n2)), t9.push(n2);
  }
  function xs2(t9, e2) {
    let r2, n2, i;
    for (r2 in t9)
      if (n2 = t9[r2], !(n2 === null || typeof n2 > "u"))
        if (r2[0] === "@") {
          let a = r2.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
          if (Array.isArray(n2))
            for (let s3 of n2)
              Pu2(e2, a, s3);
          else
            Pu2(e2, a, n2);
        } else if (Array.isArray(n2))
          for (let a of n2)
            Tu2(e2, r2, a);
        else
          typeof n2 == "object" ? (i = nr3.rule({ selector: r2 }), xs2(n2, i), e2.push(i)) : Tu2(e2, r2, n2);
  }
  Iu2.exports = function(t9) {
    let e2 = nr3.root();
    return xs2(t9, e2), e2;
  };
});
var Ss2 = S3((Nx, Ru2) => {
  var m0 = bs2();
  Ru2.exports = function(e2) {
    return console && console.warn && e2.warnings().forEach((r2) => {
      let n2 = r2.plugin || "PostCSS";
      console.warn(n2 + ": " + r2.text);
    }), m0(e2.root);
  };
});
var Mu2 = S3((qx, Du2) => {
  var g0 = Ke3(), y0 = Ss2(), v0 = en3();
  Du2.exports = function(e2) {
    let r2 = g0(e2);
    return async (n2) => {
      let i = await r2.process(n2, { parser: v0, from: undefined });
      return y0(i);
    };
  };
});
var Lu2 = S3(($x, Fu2) => {
  var w0 = Ke3(), b0 = Ss2(), x0 = en3();
  Fu2.exports = function(t9) {
    let e2 = w0(t9);
    return (r2) => {
      let n2 = e2.process(r2, { parser: x0, from: undefined });
      return b0(n2);
    };
  };
});
var qu2 = S3((Ux, Nu2) => {
  var S0 = bs2(), k0 = en3(), O0 = Mu2(), E0 = Lu2();
  Nu2.exports = { objectify: S0, parse: k0, async: O0, sync: E0 };
});
var qs2 = S3((Ls2, Ns2) => {
  (function(t9, e2) {
    typeof Ls2 == "object" && typeof Ns2 < "u" ? Ns2.exports = function(r2, n2, i, a, s3) {
      for (n2 = n2.split ? n2.split(".") : n2, a = 0;a < n2.length; a++)
        r2 = r2 ? r2[n2[a]] : s3;
      return r2 === s3 ? i : r2;
    } : typeof define == "function" && define.amd ? define(function() {
      return function(r2, n2, i, a, s3) {
        for (n2 = n2.split ? n2.split(".") : n2, a = 0;a < n2.length; a++)
          r2 = r2 ? r2[n2[a]] : s3;
        return r2 === s3 ? i : r2;
      };
    }) : t9.dlv = function(r2, n2, i, a, s3) {
      for (n2 = n2.split ? n2.split(".") : n2, a = 0;a < n2.length; a++)
        r2 = r2 ? r2[n2[a]] : s3;
      return r2 === s3 ? i : r2;
    };
  })(Ls2);
});
var Bf = S3((bk, On2) => {
  (function() {
    function t9(n2, i, a) {
      if (!n2)
        return null;
      t9.caseSensitive || (n2 = n2.toLowerCase());
      var s3 = t9.threshold === null ? null : t9.threshold * n2.length, o2 = t9.thresholdAbsolute, l3;
      s3 !== null && o2 !== null ? l3 = Math.min(s3, o2) : s3 !== null ? l3 = s3 : o2 !== null ? l3 = o2 : l3 = null;
      var u, f, p, c2, d2, h2 = i.length;
      for (d2 = 0;d2 < h2; d2++)
        if (f = i[d2], a && (f = f[a]), !!f && (t9.caseSensitive ? p = f : p = f.toLowerCase(), c2 = r2(n2, p, l3), (l3 === null || c2 < l3) && (l3 = c2, a && t9.returnWinningObject ? u = i[d2] : u = f, t9.returnFirstMatch)))
          return u;
      return u || t9.nullResultValue;
    }
    t9.threshold = 0.4, t9.thresholdAbsolute = 20, t9.caseSensitive = false, t9.nullResultValue = null, t9.returnWinningObject = null, t9.returnFirstMatch = false, typeof On2 < "u" && On2.exports ? On2.exports = t9 : window.didYouMean = t9;
    var e2 = Math.pow(2, 32) - 1;
    function r2(n2, i, a) {
      a = a || a === 0 ? a : e2;
      var s3 = n2.length, o2 = i.length;
      if (s3 === 0)
        return Math.min(a + 1, o2);
      if (o2 === 0)
        return Math.min(a + 1, s3);
      if (Math.abs(s3 - o2) > a)
        return a + 1;
      var l3 = [], u, f, p, c2, d2;
      for (u = 0;u <= o2; u++)
        l3[u] = [u];
      for (f = 0;f <= s3; f++)
        l3[0][f] = f;
      for (u = 1;u <= o2; u++) {
        for (p = e2, c2 = 1, u > a && (c2 = u - a), d2 = o2 + 1, d2 > a + u && (d2 = a + u), f = 1;f <= s3; f++)
          f < c2 || f > d2 ? l3[u][f] = a + 1 : i.charAt(u - 1) === n2.charAt(f - 1) ? l3[u][f] = l3[u - 1][f - 1] : l3[u][f] = Math.min(l3[u - 1][f - 1] + 1, Math.min(l3[u][f - 1] + 1, l3[u - 1][f] + 1)), l3[u][f] < p && (p = l3[u][f]);
        if (p > a)
          return a + 1;
      }
      return l3[o2][s3];
    }
  })();
});
var Yf = S3((xk, Gf) => {
  var Ks2 = "(".charCodeAt(0), Zs = ")".charCodeAt(0), En3 = "'".charCodeAt(0), ea2 = '"'.charCodeAt(0), ta2 = "\\".charCodeAt(0), ft3 = "/".charCodeAt(0), ra2 = ",".charCodeAt(0), na2 = ":".charCodeAt(0), Cn3 = "*".charCodeAt(0), Yv = "u".charCodeAt(0), Hv = "U".charCodeAt(0), Qv = "+".charCodeAt(0), Jv = /^[a-f0-9?-]+$/i;
  Gf.exports = function(t9) {
    for (var e2 = [], r2 = t9, n2, i, a, s3, o2, l3, u, f, p = 0, c2 = r2.charCodeAt(p), d2 = r2.length, h2 = [{ nodes: e2 }], y2 = 0, m, g2 = "", w3 = "", b4 = "";p < d2; )
      if (c2 <= 32) {
        n2 = p;
        do
          n2 += 1, c2 = r2.charCodeAt(n2);
        while (c2 <= 32);
        s3 = r2.slice(p, n2), a = e2[e2.length - 1], c2 === Zs && y2 ? b4 = s3 : a && a.type === "div" ? (a.after = s3, a.sourceEndIndex += s3.length) : c2 === ra2 || c2 === na2 || c2 === ft3 && r2.charCodeAt(n2 + 1) !== Cn3 && (!m || m && m.type === "function" && m.value !== "calc") ? w3 = s3 : e2.push({ type: "space", sourceIndex: p, sourceEndIndex: n2, value: s3 }), p = n2;
      } else if (c2 === En3 || c2 === ea2) {
        n2 = p, i = c2 === En3 ? "'" : '"', s3 = { type: "string", sourceIndex: p, quote: i };
        do
          if (o2 = false, n2 = r2.indexOf(i, n2 + 1), ~n2)
            for (l3 = n2;r2.charCodeAt(l3 - 1) === ta2; )
              l3 -= 1, o2 = !o2;
          else
            r2 += i, n2 = r2.length - 1, s3.unclosed = true;
        while (o2);
        s3.value = r2.slice(p + 1, n2), s3.sourceEndIndex = s3.unclosed ? n2 : n2 + 1, e2.push(s3), p = n2 + 1, c2 = r2.charCodeAt(p);
      } else if (c2 === ft3 && r2.charCodeAt(p + 1) === Cn3)
        n2 = r2.indexOf("*/", p), s3 = { type: "comment", sourceIndex: p, sourceEndIndex: n2 + 2 }, n2 === -1 && (s3.unclosed = true, n2 = r2.length, s3.sourceEndIndex = n2), s3.value = r2.slice(p + 2, n2), e2.push(s3), p = n2 + 2, c2 = r2.charCodeAt(p);
      else if ((c2 === ft3 || c2 === Cn3) && m && m.type === "function" && m.value === "calc")
        s3 = r2[p], e2.push({ type: "word", sourceIndex: p - w3.length, sourceEndIndex: p + s3.length, value: s3 }), p += 1, c2 = r2.charCodeAt(p);
      else if (c2 === ft3 || c2 === ra2 || c2 === na2)
        s3 = r2[p], e2.push({ type: "div", sourceIndex: p - w3.length, sourceEndIndex: p + s3.length, value: s3, before: w3, after: "" }), w3 = "", p += 1, c2 = r2.charCodeAt(p);
      else if (Ks2 === c2) {
        n2 = p;
        do
          n2 += 1, c2 = r2.charCodeAt(n2);
        while (c2 <= 32);
        if (f = p, s3 = { type: "function", sourceIndex: p - g2.length, value: g2, before: r2.slice(f + 1, n2) }, p = n2, g2 === "url" && c2 !== En3 && c2 !== ea2) {
          n2 -= 1;
          do
            if (o2 = false, n2 = r2.indexOf(")", n2 + 1), ~n2)
              for (l3 = n2;r2.charCodeAt(l3 - 1) === ta2; )
                l3 -= 1, o2 = !o2;
            else
              r2 += ")", n2 = r2.length - 1, s3.unclosed = true;
          while (o2);
          u = n2;
          do
            u -= 1, c2 = r2.charCodeAt(u);
          while (c2 <= 32);
          f < u ? (p !== u + 1 ? s3.nodes = [{ type: "word", sourceIndex: p, sourceEndIndex: u + 1, value: r2.slice(p, u + 1) }] : s3.nodes = [], s3.unclosed && u + 1 !== n2 ? (s3.after = "", s3.nodes.push({ type: "space", sourceIndex: u + 1, sourceEndIndex: n2, value: r2.slice(u + 1, n2) })) : (s3.after = r2.slice(u + 1, n2), s3.sourceEndIndex = n2)) : (s3.after = "", s3.nodes = []), p = n2 + 1, s3.sourceEndIndex = s3.unclosed ? n2 : p, c2 = r2.charCodeAt(p), e2.push(s3);
        } else
          y2 += 1, s3.after = "", s3.sourceEndIndex = p + 1, e2.push(s3), h2.push(s3), e2 = s3.nodes = [], m = s3;
        g2 = "";
      } else if (Zs === c2 && y2)
        p += 1, c2 = r2.charCodeAt(p), m.after = b4, m.sourceEndIndex += b4.length, b4 = "", y2 -= 1, h2[h2.length - 1].sourceEndIndex = p, h2.pop(), m = h2[y2], e2 = m.nodes;
      else {
        n2 = p;
        do
          c2 === ta2 && (n2 += 1), n2 += 1, c2 = r2.charCodeAt(n2);
        while (n2 < d2 && !(c2 <= 32 || c2 === En3 || c2 === ea2 || c2 === ra2 || c2 === na2 || c2 === ft3 || c2 === Ks2 || c2 === Cn3 && m && m.type === "function" && m.value === "calc" || c2 === ft3 && m.type === "function" && m.value === "calc" || c2 === Zs && y2));
        s3 = r2.slice(p, n2), Ks2 === c2 ? g2 = s3 : (Yv === s3.charCodeAt(0) || Hv === s3.charCodeAt(0)) && Qv === s3.charCodeAt(1) && Jv.test(s3.slice(2)) ? e2.push({ type: "unicode-range", sourceIndex: p, sourceEndIndex: n2, value: s3 }) : e2.push({ type: "word", sourceIndex: p, sourceEndIndex: n2, value: s3 }), p = n2;
      }
    for (p = h2.length - 1;p; p -= 1)
      h2[p].unclosed = true, h2[p].sourceEndIndex = r2.length;
    return h2[0].nodes;
  };
});
var Qf = S3((Sk, Hf) => {
  Hf.exports = function t(e2, r2, n2) {
    var i, a, s3, o2;
    for (i = 0, a = e2.length;i < a; i += 1)
      s3 = e2[i], n2 || (o2 = r2(s3, i, e2)), o2 !== false && s3.type === "function" && Array.isArray(s3.nodes) && t(s3.nodes, r2, n2), n2 && r2(s3, i, e2);
  };
});
var Zf = S3((kk, Kf) => {
  function Jf(t9, e2) {
    var { type: r2, value: n2 } = t9, i, a;
    return e2 && (a = e2(t9)) !== undefined ? a : r2 === "word" || r2 === "space" ? n2 : r2 === "string" ? (i = t9.quote || "", i + n2 + (t9.unclosed ? "" : i)) : r2 === "comment" ? "/*" + n2 + (t9.unclosed ? "" : "*/") : r2 === "div" ? (t9.before || "") + n2 + (t9.after || "") : Array.isArray(t9.nodes) ? (i = Xf(t9.nodes, e2), r2 !== "function" ? i : n2 + "(" + (t9.before || "") + i + (t9.after || "") + (t9.unclosed ? "" : ")")) : n2;
  }
  function Xf(t9, e2) {
    var r2, n2;
    if (Array.isArray(t9)) {
      for (r2 = "", n2 = t9.length - 1;~n2; n2 -= 1)
        r2 = Jf(t9[n2], e2) + r2;
      return r2;
    }
    return Jf(t9, e2);
  }
  Kf.exports = Xf;
});
var tc = S3((Ok, ec) => {
  var An3 = "-".charCodeAt(0), _n3 = "+".charCodeAt(0), ia2 = ".".charCodeAt(0), Xv = "e".charCodeAt(0), Kv = "E".charCodeAt(0);
  function Zv(t9) {
    var e2 = t9.charCodeAt(0), r2;
    if (e2 === _n3 || e2 === An3) {
      if (r2 = t9.charCodeAt(1), r2 >= 48 && r2 <= 57)
        return true;
      var n2 = t9.charCodeAt(2);
      return r2 === ia2 && n2 >= 48 && n2 <= 57;
    }
    return e2 === ia2 ? (r2 = t9.charCodeAt(1), r2 >= 48 && r2 <= 57) : e2 >= 48 && e2 <= 57;
  }
  ec.exports = function(t9) {
    var e2 = 0, r2 = t9.length, n2, i, a;
    if (r2 === 0 || !Zv(t9))
      return false;
    for (n2 = t9.charCodeAt(e2), (n2 === _n3 || n2 === An3) && e2++;e2 < r2 && (n2 = t9.charCodeAt(e2), !(n2 < 48 || n2 > 57)); )
      e2 += 1;
    if (n2 = t9.charCodeAt(e2), i = t9.charCodeAt(e2 + 1), n2 === ia2 && i >= 48 && i <= 57)
      for (e2 += 2;e2 < r2 && (n2 = t9.charCodeAt(e2), !(n2 < 48 || n2 > 57)); )
        e2 += 1;
    if (n2 = t9.charCodeAt(e2), i = t9.charCodeAt(e2 + 1), a = t9.charCodeAt(e2 + 2), (n2 === Xv || n2 === Kv) && (i >= 48 && i <= 57 || (i === _n3 || i === An3) && a >= 48 && a <= 57))
      for (e2 += i === _n3 || i === An3 ? 3 : 2;e2 < r2 && (n2 = t9.charCodeAt(e2), !(n2 < 48 || n2 > 57)); )
        e2 += 1;
    return { number: t9.slice(0, e2), unit: t9.slice(e2) };
  };
});
var sc = S3((Ek, ic) => {
  var ew = Yf(), rc = Qf(), nc = Zf();
  function Ne3(t9) {
    return this instanceof Ne3 ? (this.nodes = ew(t9), this) : new Ne3(t9);
  }
  Ne3.prototype.toString = function() {
    return Array.isArray(this.nodes) ? nc(this.nodes) : "";
  };
  Ne3.prototype.walk = function(t9, e2) {
    return rc(this.nodes, t9, e2), this;
  };
  Ne3.unit = tc();
  Ne3.walk = rc;
  Ne3.stringify = nc;
  ic.exports = Ne3;
});
var Sc = S3((CO, xc) => {
  xc.exports = { content: [], presets: [], darkMode: "media", theme: { accentColor: ({ theme: t9 }) => ({ ...t9("colors"), auto: "auto" }), animation: { none: "none", spin: "spin 1s linear infinite", ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite", pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite", bounce: "bounce 1s infinite" }, aria: { checked: 'checked="true"', disabled: 'disabled="true"', expanded: 'expanded="true"', hidden: 'hidden="true"', pressed: 'pressed="true"', readonly: 'readonly="true"', required: 'required="true"', selected: 'selected="true"' }, aspectRatio: { auto: "auto", square: "1 / 1", video: "16 / 9" }, backdropBlur: ({ theme: t9 }) => t9("blur"), backdropBrightness: ({ theme: t9 }) => t9("brightness"), backdropContrast: ({ theme: t9 }) => t9("contrast"), backdropGrayscale: ({ theme: t9 }) => t9("grayscale"), backdropHueRotate: ({ theme: t9 }) => t9("hueRotate"), backdropInvert: ({ theme: t9 }) => t9("invert"), backdropOpacity: ({ theme: t9 }) => t9("opacity"), backdropSaturate: ({ theme: t9 }) => t9("saturate"), backdropSepia: ({ theme: t9 }) => t9("sepia"), backgroundColor: ({ theme: t9 }) => t9("colors"), backgroundImage: { none: "none", "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))", "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))", "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))", "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))", "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))", "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))", "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))", "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))" }, backgroundOpacity: ({ theme: t9 }) => t9("opacity"), backgroundPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, backgroundSize: { auto: "auto", cover: "cover", contain: "contain" }, blur: { 0: "0", none: "0", sm: "4px", DEFAULT: "8px", md: "12px", lg: "16px", xl: "24px", "2xl": "40px", "3xl": "64px" }, borderColor: ({ theme: t9 }) => ({ ...t9("colors"), DEFAULT: t9("colors.gray.200", "currentColor") }), borderOpacity: ({ theme: t9 }) => t9("opacity"), borderRadius: { none: "0px", sm: "0.125rem", DEFAULT: "0.25rem", md: "0.375rem", lg: "0.5rem", xl: "0.75rem", "2xl": "1rem", "3xl": "1.5rem", full: "9999px" }, borderSpacing: ({ theme: t9 }) => ({ ...t9("spacing") }), borderWidth: { DEFAULT: "1px", 0: "0px", 2: "2px", 4: "4px", 8: "8px" }, boxShadow: { sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)", DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)", md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)", lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)", xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)", "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)", inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)", none: "none" }, boxShadowColor: ({ theme: t9 }) => t9("colors"), brightness: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5", 200: "2" }, caretColor: ({ theme: t9 }) => t9("colors"), colors: ({ colors: t9 }) => ({ inherit: t9.inherit, current: t9.current, transparent: t9.transparent, black: t9.black, white: t9.white, slate: t9.slate, gray: t9.gray, zinc: t9.zinc, neutral: t9.neutral, stone: t9.stone, red: t9.red, orange: t9.orange, amber: t9.amber, yellow: t9.yellow, lime: t9.lime, green: t9.green, emerald: t9.emerald, teal: t9.teal, cyan: t9.cyan, sky: t9.sky, blue: t9.blue, indigo: t9.indigo, violet: t9.violet, purple: t9.purple, fuchsia: t9.fuchsia, pink: t9.pink, rose: t9.rose }), columns: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", "3xs": "16rem", "2xs": "18rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem" }, container: {}, content: { none: "none" }, contrast: { 0: "0", 50: ".5", 75: ".75", 100: "1", 125: "1.25", 150: "1.5", 200: "2" }, cursor: { auto: "auto", default: "default", pointer: "pointer", wait: "wait", text: "text", move: "move", help: "help", "not-allowed": "not-allowed", none: "none", "context-menu": "context-menu", progress: "progress", cell: "cell", crosshair: "crosshair", "vertical-text": "vertical-text", alias: "alias", copy: "copy", "no-drop": "no-drop", grab: "grab", grabbing: "grabbing", "all-scroll": "all-scroll", "col-resize": "col-resize", "row-resize": "row-resize", "n-resize": "n-resize", "e-resize": "e-resize", "s-resize": "s-resize", "w-resize": "w-resize", "ne-resize": "ne-resize", "nw-resize": "nw-resize", "se-resize": "se-resize", "sw-resize": "sw-resize", "ew-resize": "ew-resize", "ns-resize": "ns-resize", "nesw-resize": "nesw-resize", "nwse-resize": "nwse-resize", "zoom-in": "zoom-in", "zoom-out": "zoom-out" }, divideColor: ({ theme: t9 }) => t9("borderColor"), divideOpacity: ({ theme: t9 }) => t9("borderOpacity"), divideWidth: ({ theme: t9 }) => t9("borderWidth"), dropShadow: { sm: "0 1px 1px rgb(0 0 0 / 0.05)", DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"], md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"], lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"], xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"], "2xl": "0 25px 25px rgb(0 0 0 / 0.15)", none: "0 0 #0000" }, fill: ({ theme: t9 }) => ({ none: "none", ...t9("colors") }), flex: { 1: "1 1 0%", auto: "1 1 auto", initial: "0 1 auto", none: "none" }, flexBasis: ({ theme: t9 }) => ({ auto: "auto", ...t9("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%" }), flexGrow: { 0: "0", DEFAULT: "1" }, flexShrink: { 0: "0", DEFAULT: "1" }, fontFamily: { sans: ["ui-sans-serif", "system-ui", "-apple-system", "BlinkMacSystemFont", '"Segoe UI"', "Roboto", '"Helvetica Neue"', "Arial", '"Noto Sans"', "sans-serif", '"Apple Color Emoji"', '"Segoe UI Emoji"', '"Segoe UI Symbol"', '"Noto Color Emoji"'], serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"], mono: ["ui-monospace", "SFMono-Regular", "Menlo", "Monaco", "Consolas", '"Liberation Mono"', '"Courier New"', "monospace"] }, fontSize: { xs: ["0.75rem", { lineHeight: "1rem" }], sm: ["0.875rem", { lineHeight: "1.25rem" }], base: ["1rem", { lineHeight: "1.5rem" }], lg: ["1.125rem", { lineHeight: "1.75rem" }], xl: ["1.25rem", { lineHeight: "1.75rem" }], "2xl": ["1.5rem", { lineHeight: "2rem" }], "3xl": ["1.875rem", { lineHeight: "2.25rem" }], "4xl": ["2.25rem", { lineHeight: "2.5rem" }], "5xl": ["3rem", { lineHeight: "1" }], "6xl": ["3.75rem", { lineHeight: "1" }], "7xl": ["4.5rem", { lineHeight: "1" }], "8xl": ["6rem", { lineHeight: "1" }], "9xl": ["8rem", { lineHeight: "1" }] }, fontWeight: { thin: "100", extralight: "200", light: "300", normal: "400", medium: "500", semibold: "600", bold: "700", extrabold: "800", black: "900" }, gap: ({ theme: t9 }) => t9("spacing"), gradientColorStops: ({ theme: t9 }) => t9("colors"), gradientColorStopPositions: { "0%": "0%", "5%": "5%", "10%": "10%", "15%": "15%", "20%": "20%", "25%": "25%", "30%": "30%", "35%": "35%", "40%": "40%", "45%": "45%", "50%": "50%", "55%": "55%", "60%": "60%", "65%": "65%", "70%": "70%", "75%": "75%", "80%": "80%", "85%": "85%", "90%": "90%", "95%": "95%", "100%": "100%" }, grayscale: { 0: "0", DEFAULT: "100%" }, gridAutoColumns: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridAutoRows: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridColumn: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-7": "span 7 / span 7", "span-8": "span 8 / span 8", "span-9": "span 9 / span 9", "span-10": "span 10 / span 10", "span-11": "span 11 / span 11", "span-12": "span 12 / span 12", "span-full": "1 / -1" }, gridColumnEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridColumnStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridRow: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-full": "1 / -1" }, gridRowEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7" }, gridRowStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7" }, gridTemplateColumns: { none: "none", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))", 7: "repeat(7, minmax(0, 1fr))", 8: "repeat(8, minmax(0, 1fr))", 9: "repeat(9, minmax(0, 1fr))", 10: "repeat(10, minmax(0, 1fr))", 11: "repeat(11, minmax(0, 1fr))", 12: "repeat(12, minmax(0, 1fr))" }, gridTemplateRows: { none: "none", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))" }, height: ({ theme: t9 }) => ({ auto: "auto", ...t9("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }), hueRotate: { 0: "0deg", 15: "15deg", 30: "30deg", 60: "60deg", 90: "90deg", 180: "180deg" }, inset: ({ theme: t9 }) => ({ auto: "auto", ...t9("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), invert: { 0: "0", DEFAULT: "100%" }, keyframes: { spin: { to: { transform: "rotate(360deg)" } }, ping: { "75%, 100%": { transform: "scale(2)", opacity: "0" } }, pulse: { "50%": { opacity: ".5" } }, bounce: { "0%, 100%": { transform: "translateY(-25%)", animationTimingFunction: "cubic-bezier(0.8,0,1,1)" }, "50%": { transform: "none", animationTimingFunction: "cubic-bezier(0,0,0.2,1)" } } }, letterSpacing: { tighter: "-0.05em", tight: "-0.025em", normal: "0em", wide: "0.025em", wider: "0.05em", widest: "0.1em" }, lineHeight: { none: "1", tight: "1.25", snug: "1.375", normal: "1.5", relaxed: "1.625", loose: "2", 3: ".75rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem" }, listStyleType: { none: "none", disc: "disc", decimal: "decimal" }, listStyleImage: { none: "none" }, margin: ({ theme: t9 }) => ({ auto: "auto", ...t9("spacing") }), lineClamp: { 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6" }, maxHeight: ({ theme: t9 }) => ({ ...t9("spacing"), none: "none", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }), maxWidth: ({ theme: t9, breakpoints: e2 }) => ({ none: "none", 0: "0rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem", full: "100%", min: "min-content", max: "max-content", fit: "fit-content", prose: "65ch", ...e2(t9("screens")) }), minHeight: { 0: "0px", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }, minWidth: { 0: "0px", full: "100%", min: "min-content", max: "max-content", fit: "fit-content" }, objectPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, opacity: { 0: "0", 5: "0.05", 10: "0.1", 20: "0.2", 25: "0.25", 30: "0.3", 40: "0.4", 50: "0.5", 60: "0.6", 70: "0.7", 75: "0.75", 80: "0.8", 90: "0.9", 95: "0.95", 100: "1" }, order: { first: "-9999", last: "9999", none: "0", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12" }, outlineColor: ({ theme: t9 }) => t9("colors"), outlineOffset: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, outlineWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, padding: ({ theme: t9 }) => t9("spacing"), placeholderColor: ({ theme: t9 }) => t9("colors"), placeholderOpacity: ({ theme: t9 }) => t9("opacity"), ringColor: ({ theme: t9 }) => ({ DEFAULT: t9("colors.blue.500", "#3b82f6"), ...t9("colors") }), ringOffsetColor: ({ theme: t9 }) => t9("colors"), ringOffsetWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, ringOpacity: ({ theme: t9 }) => ({ DEFAULT: "0.5", ...t9("opacity") }), ringWidth: { DEFAULT: "3px", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, rotate: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg", 45: "45deg", 90: "90deg", 180: "180deg" }, saturate: { 0: "0", 50: ".5", 100: "1", 150: "1.5", 200: "2" }, scale: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5" }, screens: { sm: "640px", md: "768px", lg: "1024px", xl: "1280px", "2xl": "1536px" }, scrollMargin: ({ theme: t9 }) => ({ ...t9("spacing") }), scrollPadding: ({ theme: t9 }) => t9("spacing"), sepia: { 0: "0", DEFAULT: "100%" }, skew: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg" }, space: ({ theme: t9 }) => ({ ...t9("spacing") }), spacing: { px: "1px", 0: "0px", 0.5: "0.125rem", 1: "0.25rem", 1.5: "0.375rem", 2: "0.5rem", 2.5: "0.625rem", 3: "0.75rem", 3.5: "0.875rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem", 11: "2.75rem", 12: "3rem", 14: "3.5rem", 16: "4rem", 20: "5rem", 24: "6rem", 28: "7rem", 32: "8rem", 36: "9rem", 40: "10rem", 44: "11rem", 48: "12rem", 52: "13rem", 56: "14rem", 60: "15rem", 64: "16rem", 72: "18rem", 80: "20rem", 96: "24rem" }, stroke: ({ theme: t9 }) => ({ none: "none", ...t9("colors") }), strokeWidth: { 0: "0", 1: "1", 2: "2" }, supports: {}, data: {}, textColor: ({ theme: t9 }) => t9("colors"), textDecorationColor: ({ theme: t9 }) => t9("colors"), textDecorationThickness: { auto: "auto", "from-font": "from-font", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, textIndent: ({ theme: t9 }) => ({ ...t9("spacing") }), textOpacity: ({ theme: t9 }) => t9("opacity"), textUnderlineOffset: { auto: "auto", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, transformOrigin: { center: "center", top: "top", "top-right": "top right", right: "right", "bottom-right": "bottom right", bottom: "bottom", "bottom-left": "bottom left", left: "left", "top-left": "top left" }, transitionDelay: { 0: "0s", 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1000: "1000ms" }, transitionDuration: { DEFAULT: "150ms", 0: "0s", 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1000: "1000ms" }, transitionProperty: { none: "none", all: "all", DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter", colors: "color, background-color, border-color, text-decoration-color, fill, stroke", opacity: "opacity", shadow: "box-shadow", transform: "transform" }, transitionTimingFunction: { DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)", linear: "linear", in: "cubic-bezier(0.4, 0, 1, 1)", out: "cubic-bezier(0, 0, 0.2, 1)", "in-out": "cubic-bezier(0.4, 0, 0.2, 1)" }, translate: ({ theme: t9 }) => ({ ...t9("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), width: ({ theme: t9 }) => ({ auto: "auto", ...t9("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%", screen: "100vw", min: "min-content", max: "max-content", fit: "fit-content" }), willChange: { auto: "auto", scroll: "scroll-position", contents: "contents", transform: "transform" }, zIndex: { auto: "auto", 0: "0", 10: "10", 20: "20", 30: "30", 40: "40", 50: "50" } }, plugins: [] };
});
var Dc = S3((FO, Rc) => {
  var Dn3 = Object.prototype.hasOwnProperty, Ic = Object.prototype.toString, Ec = Object.defineProperty, Cc = Object.getOwnPropertyDescriptor, Ac = function(e2) {
    return typeof Array.isArray == "function" ? Array.isArray(e2) : Ic.call(e2) === "[object Array]";
  }, _c = function(e2) {
    if (!e2 || Ic.call(e2) !== "[object Object]")
      return false;
    var r2 = Dn3.call(e2, "constructor"), n2 = e2.constructor && e2.constructor.prototype && Dn3.call(e2.constructor.prototype, "isPrototypeOf");
    if (e2.constructor && !r2 && !n2)
      return false;
    var i;
    for (i in e2)
      ;
    return typeof i > "u" || Dn3.call(e2, i);
  }, Tc = function(e2, r2) {
    Ec && r2.name === "__proto__" ? Ec(e2, r2.name, { enumerable: true, configurable: true, value: r2.newValue, writable: true }) : e2[r2.name] = r2.newValue;
  }, Pc = function(e2, r2) {
    if (r2 === "__proto__")
      if (Dn3.call(e2, r2)) {
        if (Cc)
          return Cc(e2, r2).value;
      } else
        return;
    return e2[r2];
  };
  Rc.exports = function t() {
    var e2, r2, n2, i, a, s3, o2 = arguments[0], l3 = 1, u = arguments.length, f = false;
    for (typeof o2 == "boolean" && (f = o2, o2 = arguments[1] || {}, l3 = 2), (o2 == null || typeof o2 != "object" && typeof o2 != "function") && (o2 = {});l3 < u; ++l3)
      if (e2 = arguments[l3], e2 != null)
        for (r2 in e2)
          n2 = Pc(o2, r2), i = Pc(e2, r2), o2 !== i && (f && i && (_c(i) || (a = Ac(i))) ? (a ? (a = false, s3 = n2 && Ac(n2) ? n2 : []) : s3 = n2 && _c(n2) ? n2 : {}, Tc(o2, { name: r2, newValue: t(f, s3, i) })) : typeof i < "u" && Tc(o2, { name: r2, newValue: i }));
    return o2;
  };
});
var Mn3 = S3((LO, Mc) => {
  var ya2 = function(t9, e2) {
    var r2 = new t9.constructor;
    return Object.keys(t9).forEach(function(n2) {
      if (!!t9.hasOwnProperty(n2)) {
        var i = t9[n2], a = typeof i;
        n2 === "parent" && a === "object" ? e2 && (r2[n2] = e2) : n2 === "source" ? r2[n2] = i : i instanceof Array ? n2 === "nodes" ? r2[n2] = [] : r2[n2] = i.map(function(s3) {
          ya2(s3, r2);
        }) : n2 !== "before" && n2 !== "after" && n2 !== "between" && n2 !== "semicolon" && (a === "object" && (i = ya2(i)), r2[n2] = i);
      }
    }), r2;
  };
  Mc.exports = ya2;
});
var $c = S3((NO, qc) => {
  qc.exports = Lc;
  function Lc(t9, e2, r2) {
    t9 instanceof RegExp && (t9 = Fc(t9, r2)), e2 instanceof RegExp && (e2 = Fc(e2, r2));
    var n2 = Nc(t9, e2, r2);
    return n2 && { start: n2[0], end: n2[1], pre: r2.slice(0, n2[0]), body: r2.slice(n2[0] + t9.length, n2[1]), post: r2.slice(n2[1] + e2.length) };
  }
  function Fc(t9, e2) {
    var r2 = e2.match(t9);
    return r2 ? r2[0] : null;
  }
  Lc.range = Nc;
  function Nc(t9, e2, r2) {
    var n2, i, a, s3, o2, l3 = r2.indexOf(t9), u = r2.indexOf(e2, l3 + 1), f = l3;
    if (l3 >= 0 && u > 0) {
      if (t9 === e2)
        return [l3, u];
      for (n2 = [], a = r2.length;f >= 0 && !o2; )
        f == l3 ? (n2.push(f), l3 = r2.indexOf(t9, f + 1)) : n2.length == 1 ? o2 = [n2.pop(), u] : (i = n2.pop(), i < a && (a = i, s3 = u), u = r2.indexOf(e2, f + 1)), f = l3 < u && l3 >= 0 ? l3 : u;
      n2.length && (o2 = [a, s3]);
    }
    return o2;
  }
});
var jc = S3((qO, Uc) => {
  var Ow = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?![><+~\s]).)+)(?:(?:(?:\s(?!>>))|(?:\t(?!>>))|(?:\s?>>\s?))(?!\s+))(?![><+~][\s]+?))/, Ew = function(t9) {
    return t9.split(Ow).filter(function(e2) {
      return e2.length > 0;
    }).map(function(e2) {
      return e2.trim().replace(/\s*?>>\s*?/g, "");
    });
  };
  Uc.exports = Ew;
});
var dr3 = S3(($O, zc) => {
  var Cw = jc(), Aw = function(t9, e2) {
    e2 = e2 || false;
    for (var r2 = [[]], n2 = e2 ? t9 : t9.parent;n2; ) {
      var i = (n2.selectors || []).map(function(s3) {
        return { value: s3, type: "selector" };
      });
      n2.type === "atrule" && (i = [].concat(n2.params).map(function(s3) {
        return { value: "@" + n2.name + " " + s3, type: "atrule" };
      }));
      var a = (i.length > 0 ? i : [1]).map(function() {
        return r2.map(function(s3) {
          return s3.slice(0);
        });
      });
      i.forEach(function(s3, o2) {
        a[o2] = a[o2].map(function(l3) {
          var u = [s3.value];
          return s3.type === "selector" && (u = Cw(s3.value)), l3.unshift.apply(l3, u), l3;
        });
      }), r2 = [], a.forEach(function(s3) {
        r2 = r2.concat(s3);
      }), n2 = n2.parent;
    }
    return r2;
  };
  zc.exports = Aw;
});
var Wc = S3((UO, Vc) => {
  var _w = /[|\\{}()[\]^$+*?.]/g;
  Vc.exports = function(t9) {
    if (typeof t9 != "string")
      throw new TypeError("Expected a string");
    return t9.replace(_w, "\\$&");
  };
});
var Gc = S3((jO, Bc) => {
  var Tw = { "*": true, ":root": true, html: true }, Pw = function(t9) {
    return !!Tw[t9];
  };
  Bc.exports = Pw;
});
var Hc = S3((zO, Yc) => {
  var Iw = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?!>>|<|\+|~|\s).)+)(?:(?:(?:>(?!>))|(?:\s?>(?!>)\s?))(?!\s+))(?!(?:>>|<|\+|~)[\s]+?))/, Rw = function(t9) {
    return t9.split(Iw).filter(function(e2) {
      return e2.length > 0;
    }).map(function(e2) {
      return e2.trim().replace(/\s*?>\s*?/g, "");
    });
  };
  Yc.exports = Rw;
});
var va2 = S3((VO, tp) => {
  var Dw = Wc(), Qc = Gc(), Jc = Hc(), Mw = /^@.*/, Kc = /([^\s:]+)((?::|::)[^\s]*?)(\s+|$)/;
  function Zc(t9, e2) {
    var r2, n2, i = e2.some(function(a) {
      return t9.some(function(s3) {
        r2 = null;
        var o2 = true;
        for (n2 = 0;n2 < a.length; n2++) {
          for (var l3 = a[n2], u = r2 || 0, f = -1, p = s3.slice(u), c2 = 0;c2 < p.length; c2++) {
            var d2 = p[c2], h2 = u + c2;
            if (new RegExp(Dw(l3) + "$").test(d2)) {
              f = h2;
              break;
            }
            if (Qc(l3) || Qc(d2)) {
              f = h2;
              break;
            }
            var y2 = Jc(d2);
            if (y2.length > 1) {
              var m = [].concat([y2]), g2 = [].concat([a.slice(n2).reduce(function(v3, O3) {
                return v3.concat(Jc(O3));
              }, [])]), w3 = Zc(m, g2);
              (w3.doesMatchScope || n2 + 1 < a.length) && (f = h2, n2 += w3.scopePieceIndex - 1);
              break;
            }
          }
          var b4 = f >= u;
          if (r2 = f + 1, o2 = o2 && b4, !o2)
            break;
        }
        return o2;
      });
    });
    return { doesMatchScope: i, nodeScopePieceIndex: r2 - 1, scopePieceIndex: n2 };
  }
  var Xc = function(t9) {
    return t9.map(function(e2) {
      return e2.map(function(r2) {
        return Mw.test(r2) ? r2 : r2.replace(new RegExp(Kc.source, "g"), function(n2, i, a, s3) {
          return i + s3;
        });
      });
    });
  }, ep = function(t9, e2, r2) {
    return t9 = Xc(t9), r2 && (e2 = Xc(e2)), Zc(t9, e2).doesMatchScope;
  };
  ep.RE_PSEUDO_SELECTOR = Kc;
  tp.exports = ep;
});
var wa2 = S3((WO, np) => {
  var Fw = va2(), rp = dr3(), Lw = function(t9, e2, r2) {
    var n2 = rp(t9, true), i = rp(e2, true);
    return Fw(n2, i, r2);
  };
  np.exports = Lw;
});
var ba2 = S3((BO, sp) => {
  var ip = function(t9, e2, r2) {
    r2 = r2 || [];
    var n2 = false;
    return t9 && (r2 = t9.reduce(function(i, a) {
      var s3 = !!e2[a], o2 = s3 ? i.some(function(l3) {
        return e2[a].some(function(u) {
          return l3 === u;
        });
      }) : false;
      return n2 = n2 || o2, s3 && !n2 && (i = i.concat(e2[a]), (e2[a] || []).forEach(function(l3) {
        var u = ip(l3.variablesUsed, e2, i);
        i = u.deps, n2 = n2 || u.hasCircularOrSelfReference;
      })), i;
    }, r2)), { deps: r2, hasCircularOrSelfReference: n2 };
  };
  sp.exports = ip;
});
var xa2 = S3((GO, ap) => {
  var Nw = dr3(), qw = function(t9, e2) {
    for (var r2, n2 = e2;n2.parent && !r2; ) {
      var i = Nw(n2.clone(), true);
      i.some(function(a) {
        return a.some(function(s3) {
          return s3 === t9 ? (r2 = n2, true) : false;
        });
      }), n2 = n2.parent;
    }
    return r2;
  };
  ap.exports = qw;
});
var Sa2 = S3((YO, lp) => {
  var op = Mn3(), $w = function(t9, e2, r2) {
    r2 = r2 || function() {
      return true;
    };
    for (var n2 = [], i = t9, a = false;i && !a; )
      i.type === "decl" ? n2.push(i.clone()) : n2.push(op(i)), a = r2(i), i = i.parent;
    for (var s3 = [], o2 = e2;o2; )
      s3.push(op(o2)), o2 = o2.parent;
    return s3.forEach(function(l3, u, f) {
      u + 1 < f.length && (l3.parent = f[u + 1]);
    }), n2.forEach(function(l3, u, f) {
      u + 1 < f.length ? l3.parent = f[u + 1] : (s3.slice(-1)[0].parent = i, l3.parent = s3[0]);
    }), n2[0];
  };
  lp.exports = $w;
});
var ka2 = S3((HO, fp) => {
  var Uw = $c(), jw = dr3(), up = wa2(), zw = ba2(), Vw = xa2(), Ww = Sa2(), Bw = /var\(\s*(--[^,\s)]+)/;
  function Gw(t9) {
    return String(t9);
  }
  function Fn3(t9) {
    var e2 = Uw("(", ")", t9);
    if (e2) {
      if (/(?:^|[^\w-])var$/.test(e2.pre))
        return { pre: e2.pre.slice(0, -3), body: e2.body, post: e2.post };
      var r2 = Fn3(e2.body);
      if (r2)
        return { pre: e2.pre + "(" + r2.pre, body: r2.body, post: r2.post + ")" + e2.post };
      var n2 = Fn3(e2.post);
      if (n2)
        return { pre: e2.pre + "(" + e2.body + ")" + n2.pre, body: n2.body, post: n2.post };
    }
  }
  var Ln3 = function(t9, e2, r2, n2) {
    for (var i = n2 ? "	" : "", a = undefined, s3 = Gw(t9.value), o2 = [], l3 = {}, u = s3;a = Fn3(u); ) {
      var f = a.body.split(","), p = f[0].trim();
      l3[p] = true, u = (a.pre || "") + a.body.replace(p, "") + (a.post || "");
    }
    u = undefined;
    for (var c2 = Object.keys(l3), d2 = false;a = Fn3(s3); ) {
      var h2 = undefined, f = a.body.split(","), p = f[0].trim(), y2 = f.length > 1 ? f.slice(1).join(",").trim() : undefined;
      (e2[p] || []).forEach(function(A) {
        var E2 = A.parent.type === "root" || A.parent.selectors[0] === ":root", I3 = up(t9.parent, A.parent), F = up(t9.parent, A.parent, r2);
        F && (!(h2 || {}).isImportant || A.isImportant) && (h2 = A);
      });
      var m = (h2 || {}).calculatedInPlaceValue || function() {
        var A = y2;
        if (y2) {
          var E2 = t9.clone({ parent: t9.parent, value: y2 });
          A = Ln3(E2, e2, false, true).value;
        }
        return A;
      }();
      if (h2 !== undefined && !zw(c2, e2).hasCircularOrSelfReference) {
        var g2 = jw(t9.parent.parent, true), w3 = g2[0].slice(-1)[0], b4 = Vw(w3, h2.decl.parent), v3 = Ww(h2.decl, t9.parent.parent, function(A) {
          return A === b4;
        });
        m = Ln3(v3, e2, false, true).value;
      }
      d2 = m === undefined, d2 && o2.push(["variable " + p + " is undefined and used without a fallback", { node: t9 }]), s3 = (a.pre || "") + m + (a.post || "");
    }
    return { value: d2 ? undefined : s3, variablesUsed: c2, warnings: o2 };
  };
  Ln3.RE_VAR_FUNC = Bw;
  fp.exports = Ln3;
});
var hp = S3((QO, dp) => {
  var cp = ka2(), Yw = dr3(), Hw = ba2(), pp = va2(), Qw = wa2(), Nn3 = Mn3(), Jw = xa2(), Xw = Sa2();
  function Kw(t9, e2, r2, n2) {
    t9.forEach(function(i) {
      Hw(t9, e2).deps.forEach(function(a) {
        var s3;
        if (a.isUnderAtRule) {
          var o2 = Yw(a.parent, true), l3 = o2[0].slice(-1)[0], u = Jw(l3, r2.parent), f = a.parent.parent;
          s3 = Xw(r2, f, function(h2) {
            return h2 === u;
          });
        } else if (pp.RE_PSEUDO_SELECTOR.test(a.parent.selector)) {
          var p = Nn3(r2.parent);
          p.parent = r2.parent.parent, s3 = r2.clone(), p.append(s3);
          var c2 = a.parent.selector.match(new RegExp(pp.RE_PSEUDO_SELECTOR.source + "$")), d2 = c2 ? c2[2] : "";
          p.selector += d2;
        }
        s3 && Qw(s3, a.parent, true) && n2(s3, a);
      });
    });
  }
  function Zw(t9, e2, r2, n2, i) {
    r2 = (typeof r2 == "function" ? r2(t9) : r2) || false, n2 = n2 || false;
    var a = function(l3) {
      return i && i(l3), l3;
    }, s3 = a(cp(t9, e2)), o2;
    Kw(s3.variablesUsed, e2, t9, function(l3, u) {
      var f = Nn3(t9.parent), p = t9.clone();
      f.append(p);
      let c2;
      if (typeof r2 == "function" ? c2 = r2(t9) : c2 = r2, c2 === true && p.cloneAfter(), p.value = a(cp(l3, e2, true)).value, u.isUnderAtRule) {
        var d2 = Nn3(u.parent.parent);
        d2.append(f);
        for (var h2 = d2, y2 = u.parent.parent;y2.parent.type === "atrule"; ) {
          var m = Nn3(y2.parent);
          m.append(h2), h2 = m, y2 = y2.parent;
        }
        t9.parent.parent.insertAfter(n2 && o2 || t9.parent, h2), o2 = h2;
      } else
        f.selector = l3.parent.selector, t9.parent.parent.insertAfter(n2 && o2 || t9.parent, f);
    }), r2 === true && t9.value !== s3.value && t9.cloneAfter(), s3.value === undefined && (s3.value = "undefined"), t9.value = s3.value;
  }
  dp.exports = Zw;
});
var vp = S3((JO, Oa2) => {
  var mp = Dc(), eb = Mn3(), gp = ka2(), tb = hp(), yp = /(--(.+))/;
  function rb(t9, e2) {
    t9.walkDecls(function(r2) {
      yp.test(r2.prop) && e2(r2);
    });
  }
  function nb(t9) {
    for (var e2 = t9;e2 && e2.nodes.length <= 0; ) {
      var r2 = e2.type !== "root" ? e2 : null;
      r2 ? (e2 = r2.parent, r2.remove()) : e2 = null;
    }
  }
  var ib = { preserve: false, variables: {}, preserveInjectedVariables: true, preserveAtRulesOrder: false };
  Oa2.exports = (t9 = {}) => {
    var e2 = mp({}, ib, t9);
    return { postcssPlugin: "postcss-css-variables", Once(r2, { decl: n2, result: i, rule: a }) {
      var s3 = [], o2 = [], l3 = {};
      l3 = mp(l3, Object.keys(e2.variables).reduce(function(p, c2) {
        var d2 = e2.variables[c2];
        c2 = c2.slice(0, 2) === "--" ? c2 : "--" + c2;
        var h2 = (d2 || {}).value || d2, y2 = (d2 || {}).isImportant || false, m = a({ selector: ":root" });
        r2.root().prepend(m);
        var g2 = n2({ prop: c2, value: h2, important: y2 });
        return m.append(g2), e2.preserveInjectedVariables || o2.push(g2), p[c2] = (p[c2] || []).concat({ decl: g2, prop: c2, calculatedInPlaceValue: h2, isImportant: y2, variablesUsed: [], parent: m, isUnderAtRule: false }), p;
      }, {}));
      var u = function(p) {
        var c2 = [].concat(p.warnings);
        return c2.forEach(function(d2) {
          d2 = [].concat(d2), i.warn.apply(i, d2);
        }), p;
      };
      rb(r2, function(p) {
        var c2 = p.parent, d2 = u(gp(p, l3));
        p.parent.selectors.forEach(function(y2) {
          var m = eb(p.parent);
          m.selector = y2, m.parent = p.parent.parent;
          var g2 = p.clone();
          m.append(g2);
          var w3 = p.prop;
          l3[w3] = (l3[w3] || []).concat({ decl: g2, prop: w3, calculatedInPlaceValue: d2.value, isImportant: p.important || false, variablesUsed: d2.variablesUsed, parent: m, isUnderAtRule: m.parent.type === "atrule" });
        });
        let h2;
        typeof e2.preserve == "function" ? h2 = e2.preserve(p) : h2 = e2.preserve, h2 ? h2 === "computed" && (p.value = d2.value) : p.remove(), c2.nodes.length <= 0 && s3.push(c2);
      });
      var f = [];
      r2.walk(function(p) {
        if (p.nodes !== undefined) {
          var c2 = p.nodes.some(function(d2) {
            if (d2.type === "decl") {
              var h2 = d2;
              if (gp.RE_VAR_FUNC.test(h2.value) && !yp.test(h2.prop))
                return true;
            }
            return false;
          });
          c2 && f.push(p);
        }
      }), f.forEach(function(p) {
        var c2 = [].concat(p);
        p.type === "rule" && p.selectors.length > 1 && (c2 = p.selectors.reverse().map(function(d2) {
          var h2 = p.cloneAfter();
          return h2.selector = d2, h2;
        }), p.remove()), c2.forEach(function(d2) {
          d2.nodes.slice(0).forEach(function(h2) {
            if (h2.type === "decl") {
              var y2 = h2;
              tb(y2, l3, e2.preserve, e2.preserveAtRulesOrder, u);
            }
          });
        });
      }), s3.forEach(nb), o2.forEach(function(p) {
        p.remove();
      });
    } };
  };
  Oa2.exports.postcss = true;
});
var Ra2 = (t9) => ({ extractCSS(e2, r2 = false) {
  let n2 = /(?:[\s\r\n]*)?(?<prop>[\w-]+)\s*:\s*(?<value>[^;\r\n]+)/gm, i, a = {};
  for (;(i = n2.exec(e2)) !== null; ) {
    let { prop: s3, value: o2 } = i.groups;
    a[s3] = o2;
  }
  return Object.entries(a).reduce((s3, [o2, l3]) => s3 + `${r2 ? "	" : ""}${o2}: ${l3}; 
\r`, "");
}, merge() {
  let e2 = /(?<=\.)[^{]+\s*\{(?<content>[^{}]*(?:(?<=;)\s*\n\r?[^{}]*)*)\s*\}/gm, r2, n2 = "";
  for (;(r2 = e2.exec(t9)) !== null; ) {
    let { content: o2 } = r2.groups;
    n2 += o2;
  }
  let i = this.extractCSS(n2), a = /(?<media>@media\s*\([^\)]*\))\s*\{(?<content>[^\}]*)\}/gm, s3;
  for (;(s3 = a.exec(t9)) !== null; ) {
    let { media: o2, content: l3 } = s3.groups;
    i += `
\r${o2} {
\r${this.extractCSS(l3, true)}}
\r`;
  }
  return t9 = i, this;
}, removeUndefined() {
  let e2 = /^[^{}]*(?:[.#][a-zA-Z0-9_-]+)[^{]*{[^}]*\b(?:[a-z-]+):\s*undefined\s*;?[^}]*}/gm;
  return t9 = t9.replace(e2, ""), this;
}, combineMediaQueries() {
  let e2 = new RegExp("@media\\s*(?<conditions>\\([^)]+\\))\\s*{(?<content>(?:[^{}]+|{(?:[^{}]+|{[^{}]*})*})+)}", "gs"), r2 = new Map, n2 = (a) => a.replace(e2, (s3, o2, l3) => {
    var f;
    let u = (f = r2.get(o2)) != null ? f : "";
    return r2.set(o2, u + n2(l3.trim())), n2(l3), "";
  }), i = [];
  return i.push(n2(t9)), i.push(...Array.from(r2, ([a, s3]) => `@media${a}{${s3}}`)), t9 = i.join(""), this;
}, minify() {
  return t9 = t9.replace(/\/\*[\s\S]*?\*\//gm, "").replace(/;\s+/gm, ";").replace(/:\s+/gm, ":").replace(/\)\s*{/gm, "){").replace(/\s+\(/gm, "(").replace(/{\s+/gm, "{").replace(/}\s+/gm, "}").replace(/\s*{/gm, "{").replace(/;?\s*}/gm, "}"), this;
}, fixRGB() {
  let e2 = /rgb\(\s*(?<red>\d+)\s*(?<green>\d+)\s*(?<blue>\d+)(?:\s*\/\s*(?<alpha>[\d%.]+))?\s*\)/gm, r2;
  for (;(r2 = e2.exec(t9)) !== null; ) {
    let [n2] = r2, { red: i, green: a, blue: s3, alpha: o2 = 1 } = r2.groups;
    t9 = t9.replace(n2, `rgb(${i},${a},${s3}${o2 === "1" ? "" : `,${o2}`})`);
  }
  return this;
}, removeMediaQueries() {
  return t9 = t9.replace(/@media[^\{]+\{[^@]+\}/g, ""), this;
}, get() {
  return t9;
} });
var L3 = { info: $n3, warn: $n3, risk: $n3 };
vr3();
var $f = H3(Na2());
var $a2 = "3.3.2";
var zn3 = { name: "tailwindcss", version: $a2, description: "A utility-first CSS framework for rapidly building custom user interfaces.", license: "MIT", main: "lib/index.js", types: "types/index.d.ts", repository: "https://github.com/tailwindlabs/tailwindcss.git", bugs: "https://github.com/tailwindlabs/tailwindcss/issues", homepage: "https://tailwindcss.com", bin: { tailwind: "lib/cli.js", tailwindcss: "lib/cli.js" }, tailwindcss: { engine: "stable" }, scripts: { prebuild: "npm run generate && rimraf lib", build: `swc src --out-dir lib --copy-files --config jsc.transform.optimizer.globals.vars.__OXIDE__='"false"'`, postbuild: "esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js --define:process.env.CSS_TRANSFORMER_WASM=false", "rebuild-fixtures": "npm run build && node -r @swc/register scripts/rebuildFixtures.js", style: "eslint .", pretest: "npm run generate", test: "jest", "test:integrations": "npm run test --prefix ./integrations", "install:integrations": "node scripts/install-integrations.js", "generate:plugin-list": "node -r @swc/register scripts/create-plugin-list.js", "generate:types": "node -r @swc/register scripts/generate-types.js", generate: "npm run generate:plugin-list && npm run generate:types", "release-channel": "node ./scripts/release-channel.js", "release-notes": "node ./scripts/release-notes.js", prepublishOnly: "npm install --force && npm run build" }, files: ["src/*", "cli/*", "lib/*", "peers/*", "scripts/*.js", "stubs/*", "nesting/*", "types/**/*", "*.d.ts", "*.css", "*.js"], devDependencies: { "@swc/cli": "^0.1.62", "@swc/core": "^1.3.55", "@swc/jest": "^0.2.26", "@swc/register": "^0.1.10", autoprefixer: "^10.4.14", browserslist: "^4.21.5", concurrently: "^8.0.1", cssnano: "^6.0.0", esbuild: "^0.17.18", eslint: "^8.39.0", "eslint-config-prettier": "^8.8.0", "eslint-plugin-prettier": "^4.2.1", jest: "^29.5.0", "jest-diff": "^29.5.0", lightningcss: "1.18.0", prettier: "^2.8.8", rimraf: "^5.0.0", "source-map-js": "^1.0.2", turbo: "^1.9.3" }, dependencies: { "@alloc/quick-lru": "^5.2.0", arg: "^5.0.2", chokidar: "^3.5.3", didyoumean: "^1.2.2", dlv: "^1.1.3", "fast-glob": "^3.2.12", "glob-parent": "^6.0.2", "is-glob": "^4.0.3", jiti: "^1.18.2", lilconfig: "^2.1.0", micromatch: "^4.0.5", "normalize-path": "^3.0.0", "object-hash": "^3.0.0", picocolors: "^1.0.0", postcss: "^8.4.23", "postcss-import": "^15.1.0", "postcss-js": "^4.0.1", "postcss-load-config": "^4.0.1", "postcss-nested": "^6.0.1", "postcss-selector-parser": "^6.0.11", "postcss-value-parser": "^4.2.0", resolve: "^1.22.2", sucrase: "^3.32.0" }, browserslist: ["> 1%", "not edge <= 18", "not ie 11", "not op_mini all"], jest: { testTimeout: 30000, setupFilesAfterEnv: ["<rootDir>/jest/customMatchers.js"], testPathIgnorePatterns: ["/node_modules/", "/integrations/", "/standalone-cli/", "\\.test\\.skip\\.js$"], transformIgnorePatterns: ["node_modules/(?!lightningcss)"], transform: { "\\.js$": "@swc/jest", "\\.ts$": "@swc/jest" } }, engines: { node: ">=14.0.0" } };
var Vn3 = typeof process < "u" ? { NODE_ENV: "production", DEBUG: Dp(undefined), ENGINE: zn3.tailwindcss.engine } : { NODE_ENV: "production", DEBUG: false, ENGINE: zn3.tailwindcss.engine };
var Wn3 = new Map;
var ke3 = new String("*");
var mt3 = Symbol("__NONE__");
var $2 = H3(Ke3(), 1);
var R3 = $2.default;
var Kb = $2.default.stringify;
var Zb = $2.default.fromJSON;
var ex = $2.default.plugin;
var tx = $2.default.parse;
var rx = $2.default.list;
var nx = $2.default.document;
var ix = $2.default.comment;
var sx = $2.default.atRule;
var ax = $2.default.rule;
var ox = $2.default.decl;
var lx = $2.default.root;
var ux = $2.default.CssSyntaxError;
var fx = $2.default.Declaration;
var cx = $2.default.Container;
var px = $2.default.Processor;
var dx = $2.default.Document;
var hx = $2.default.Comment;
var mx = $2.default.Warning;
var gx = $2.default.AtRule;
var yx = $2.default.Result;
var vx = $2.default.Input;
var wx = $2.default.Rule;
var bx = $2.default.Root;
var xx = $2.default.Node;
var wn3 = H3(ve3());
var $u2 = H3(Su2());
var rt3 = H3(qu2(), 1);
var tn3 = rt3.default;
var jx = rt3.default.objectify;
var zx = rt3.default.parse;
var Vx = rt3.default.async;
var Wx = rt3.default.sync;
var Uu2 = H3(ve3());
var ks2 = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
var C0 = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
var A0 = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
var Pe3 = /(?:\d+|\d*\.\d+)%?/;
var rn3 = /(?:\s*,\s*|\s+)/;
var ju2 = /\s*[,/]\s*/;
var Ie3 = /var\(--(?:[^ )]*?)\)/;
var _0 = new RegExp(`^(rgba?)\\(\\s*(${Pe3.source}|${Ie3.source})(?:${rn3.source}(${Pe3.source}|${Ie3.source}))?(?:${rn3.source}(${Pe3.source}|${Ie3.source}))?(?:${ju2.source}(${Pe3.source}|${Ie3.source}))?\\s*\\)\$`);
var T0 = new RegExp(`^(hsla?)\\(\\s*((?:${Pe3.source})(?:deg|rad|grad|turn)?|${Ie3.source})(?:${rn3.source}(${Pe3.source}|${Ie3.source}))?(?:${rn3.source}(${Pe3.source}|${Ie3.source}))?(?:${ju2.source}(${Pe3.source}|${Ie3.source}))?\\s*\\)\$`);
var P0 = new Set(["inset", "inherit", "initial", "revert", "unset"]);
var I0 = /\ +(?![^(]*\))/g;
var zu2 = /^-?(\d+|\.\d+)(.*?)$/g;
var R0 = ["min", "max", "clamp", "calc"];
var Wu2 = "--tw-placeholder";
var D0 = new RegExp(Wu2, "g");
var M0 = ["cm", "mm", "Q", "in", "pc", "pt", "px", "em", "ex", "ch", "rem", "lh", "rlh", "vw", "vh", "vmin", "vmax", "vb", "vi", "svw", "svh", "lvw", "lvh", "dvw", "dvh", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax"];
var F0 = `(?:${M0.join("|")})`;
var L0 = new Set(["thin", "medium", "thick"]);
var N0 = new Set(["linear-gradient", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "conic-gradient"]);
var $0 = new Set(["center", "top", "right", "bottom", "left"]);
var U0 = new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]);
var j0 = new Set(["xx-small", "x-small", "small", "medium", "large", "x-large", "x-large", "xxx-large"]);
var z0 = new Set(["larger", "smaller"]);
Gn3();
var tf = { optimizeUniversalDefaults: false, generalizedModifiers: true, get disableColorOpacityUtilitiesByDefault() {
}, get relativeContentPathsByDefault() {
} };
var sn2 = { future: ["hoverOnlyWhenSupported", "respectDefaultRingColorOpacity", "disableColorOpacityUtilitiesByDefault", "relativeContentPathsByDefault"], experimental: ["optimizeUniversalDefaults", "generalizedModifiers"] };
var _s2 = { any: an2, color: W0, url: oe2(Cs2), image: oe2(Hu2), length: oe2(ar3), percentage: oe2(sr3), position: oe2(Qu2), lookup: B0, "generic-name": oe2(Xu2), "family-name": oe2(Ju2), number: oe2(As2), "line-width": oe2(Bu2), "absolute-size": oe2(Ku2), "relative-size": oe2(Zu2), shadow: oe2(Gu2), size: oe2(ef) };
var sf = Object.keys(_s2);
var be3 = H3(ve3());
var hf = H3(jr3());
var ff = H3(ve3());
var Is2 = { "::after": ["terminal", "jumpable"], "::backdrop": ["terminal"], "::before": ["terminal", "jumpable"], "::cue": ["terminal"], "::cue-region": ["terminal"], "::first-letter": ["terminal", "jumpable"], "::first-line": ["terminal", "jumpable"], "::grammar-error": ["terminal"], "::marker": ["terminal"], "::part": ["terminal", "actionable"], "::placeholder": ["terminal"], "::selection": ["terminal"], "::slotted": ["terminal"], "::spelling-error": ["terminal"], "::target-text": ["terminal"], "::file-selector-button": ["terminal", "actionable"], "::-webkit-progress-bar": ["terminal", "actionable"], "::-webkit-scrollbar": ["terminal", "actionable"], "::-webkit-scrollbar-button": ["terminal", "actionable"], "::-webkit-scrollbar-thumb": ["terminal", "actionable"], "::-webkit-scrollbar-track": ["terminal", "actionable"], "::-webkit-scrollbar-track-piece": ["terminal", "actionable"], "::-webkit-scrollbar-corner": ["terminal", "actionable"], "::-webkit-resizer": ["terminal", "actionable"], ":after": ["terminal", "jumpable"], ":before": ["terminal", "jumpable"], ":first-letter": ["terminal", "jumpable"], ":first-line": ["terminal", "jumpable"], __default__: ["actionable"] };
var Ds2 = ":merge";
var Cf = H3(qs2());
var Vs2 = H3(ve3());
vr3();
kt3();
var X0 = new Set(["normal", "reverse", "alternate", "alternate-reverse"]);
var K0 = new Set(["running", "paused"]);
var Z0 = new Set(["none", "forwards", "backwards", "both"]);
var ev = new Set(["infinite"]);
var tv = new Set(["linear", "ease", "ease-in", "ease-out", "ease-in-out", "step-start", "step-end"]);
var rv = ["cubic-bezier", "steps"];
var nv = /\,(?![^(]*\))/g;
var iv = /\ +(?![^(]*\))/g;
var mf = /^(-?[\d.]+m?s)$/;
var sv = /^(\d+)$/;
var gf = (t9) => Object.assign({}, ...Object.entries(t9 != null ? t9 : {}).flatMap(([e2, r2]) => typeof r2 == "object" ? Object.entries(gf(r2)).map(([n2, i]) => ({ [e2 + (n2 === "DEFAULT" ? "" : `-${n2}`)]: i })) : [{ [`${e2}`]: r2 }]));
var Q3 = gf;
var ne4 = { pseudoElementVariants: ({ addVariant: t9 }) => {
  t9("first-letter", "&::first-letter"), t9("first-line", "&::first-line"), t9("marker", [({ container: e2 }) => (cn3(e2, ["--tw-text-opacity"]), "& *::marker"), ({ container: e2 }) => (cn3(e2, ["--tw-text-opacity"]), "&::marker")]), t9("selection", ["& *::selection", "&::selection"]), t9("file", "&::file-selector-button"), t9("placeholder", "&::placeholder"), t9("backdrop", "&::backdrop"), t9("before", ({ container: e2 }) => (e2.walkRules((r2) => {
    let n2 = false;
    r2.walkDecls("content", () => {
      n2 = true;
    }), n2 || r2.prepend(R3.decl({ prop: "content", value: "var(--tw-content)" }));
  }), "&::before")), t9("after", ({ container: e2 }) => (e2.walkRules((r2) => {
    let n2 = false;
    r2.walkDecls("content", () => {
      n2 = true;
    }), n2 || r2.prepend(R3.decl({ prop: "content", value: "var(--tw-content)" }));
  }), "&::after"));
}, pseudoClassVariants: ({ addVariant: t9, matchVariant: e2, config: r2 }) => {
  let n2 = [["first", "&:first-child"], ["last", "&:last-child"], ["only", "&:only-child"], ["odd", "&:nth-child(odd)"], ["even", "&:nth-child(even)"], "first-of-type", "last-of-type", "only-of-type", ["visited", ({ container: a }) => (cn3(a, ["--tw-text-opacity", "--tw-border-opacity", "--tw-bg-opacity"]), "&:visited")], "target", ["open", "&[open]"], "default", "checked", "indeterminate", "placeholder-shown", "autofill", "optional", "required", "valid", "invalid", "in-range", "out-of-range", "read-only", "empty", "focus-within", ["hover", G3(r2(), "hoverOnlyWhenSupported") ? "@media (hover: hover) and (pointer: fine) { &:hover }" : "&:hover"], "focus", "focus-visible", "active", "enabled", "disabled"].map((a) => Array.isArray(a) ? a : [a, `&:${a}`]);
  for (let [a, s3] of n2)
    t9(a, (o2) => typeof s3 == "function" ? s3(o2) : s3);
  let i = { group: (a, { modifier: s3 }) => s3 ? [`:merge(.group\\/${re3(s3)})`, " &"] : [":merge(.group)", " &"], peer: (a, { modifier: s3 }) => s3 ? [`:merge(.peer\\/${re3(s3)})`, " ~ &"] : [":merge(.peer)", " ~ &"] };
  for (let [a, s3] of Object.entries(i))
    e2(a, (o2 = "", l3) => {
      let u = z4(typeof o2 == "function" ? o2(l3) : o2);
      u.includes("&") || (u = "&" + u);
      let [f, p] = s3("", l3), c2 = null, d2 = null, h2 = 0;
      for (let y2 = 0;y2 < u.length; ++y2) {
        let m = u[y2];
        m === "&" ? c2 = y2 : m === "'" || m === '"' ? h2 += 1 : c2 !== null && m === " " && !h2 && (d2 = y2);
      }
      return c2 !== null && d2 === null && (d2 = u.length), u.slice(0, c2) + f + u.slice(c2 + 1, d2) + p + u.slice(d2);
    }, { values: Object.fromEntries(n2) });
}, directionVariants: ({ addVariant: t9 }) => {
  t9("ltr", ':is([dir="ltr"] &)'), t9("rtl", ':is([dir="rtl"] &)');
}, reducedMotionVariants: ({ addVariant: t9 }) => {
  t9("motion-safe", "@media (prefers-reduced-motion: no-preference)"), t9("motion-reduce", "@media (prefers-reduced-motion: reduce)");
}, darkVariants: ({ config: t9, addVariant: e2 }) => {
  let [r2, n2 = ".dark"] = [].concat(t9("darkMode", "media"));
  r2 === false && (r2 = "media", L3.warn("darkmode-false", ["The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.", "Change `darkMode` to `media` or remove it entirely.", "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"])), r2 === "class" ? e2("dark", `:is(${n2} &)`) : r2 === "media" && e2("dark", "@media (prefers-color-scheme: dark)");
}, printVariant: ({ addVariant: t9 }) => {
  t9("print", "@media print");
}, screenVariants: ({ theme: t9, addVariant: e2, matchVariant: r2 }) => {
  var g2;
  let n2 = (g2 = t9("screens")) != null ? g2 : {}, i = Object.values(n2).every((w3) => typeof w3 == "string"), a = Fe3(t9("screens")), s3 = new Set([]);
  function o2(w3) {
    var b4, v3;
    return (v3 = (b4 = w3.match(/(\D+)$/)) == null ? undefined : b4[1]) != null ? v3 : "(none)";
  }
  function l3(w3) {
    w3 !== undefined && s3.add(o2(w3));
  }
  function u(w3) {
    return l3(w3), s3.size === 1;
  }
  for (let w3 of a)
    for (let b4 of w3.values)
      l3(b4.min), l3(b4.max);
  let f = s3.size <= 1;
  function p(w3) {
    return Object.fromEntries(a.filter((b4) => un3(b4).result).map((b4) => {
      let { min: v3, max: O3 } = b4.values[0];
      if (w3 === "min" && v3 !== undefined)
        return b4;
      if (w3 === "min" && O3 !== undefined)
        return { ...b4, not: !b4.not };
      if (w3 === "max" && O3 !== undefined)
        return b4;
      if (w3 === "max" && v3 !== undefined)
        return { ...b4, not: !b4.not };
    }).map((b4) => [b4.name, b4]));
  }
  function c2(w3) {
    return (b4, v3) => vf(w3, b4.value, v3.value);
  }
  let d2 = c2("max"), h2 = c2("min");
  function y2(w3) {
    return (b4) => {
      if (i)
        if (f) {
          if (typeof b4 == "string" && !u(b4))
            return L3.warn("minmax-have-mixed-units", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."]), [];
        } else
          return L3.warn("mixed-screen-units", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."]), [];
      else
        return L3.warn("complex-screen-config", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."]), [];
      return [`@media ${Me3(fn3(b4, w3))}`];
    };
  }
  r2("max", y2("max"), { sort: d2, values: i ? p("max") : {} });
  let m = "min-screens";
  for (let w3 of a)
    e2(w3.name, `@media ${Me3(w3)}`, { id: m, sort: i && f ? h2 : undefined, value: w3 });
  r2("min", y2("min"), { id: m, sort: h2 });
}, supportsVariants: ({ matchVariant: t9, theme: e2 }) => {
  var r2;
  t9("supports", (n2 = "") => {
    let i = z4(n2), a = /^\w*\s*\(/.test(i);
    return i = a ? i.replace(/\b(and|or|not)\b/g, " $1 ") : i, a ? `@supports ${i}` : (i.includes(":") || (i = `${i}: var(--tw)`), i.startsWith("(") && i.endsWith(")") || (i = `(${i})`), `@supports ${i}`);
  }, { values: (r2 = e2("supports")) != null ? r2 : {} });
}, ariaVariants: ({ matchVariant: t9, theme: e2 }) => {
  var r2, n2, i;
  t9("aria", (a) => `&[aria-${z4(a)}]`, { values: (r2 = e2("aria")) != null ? r2 : {} }), t9("group-aria", (a, { modifier: s3 }) => s3 ? `:merge(.group\\/${s3})[aria-${z4(a)}] &` : `:merge(.group)[aria-${z4(a)}] &`, { values: (n2 = e2("aria")) != null ? n2 : {} }), t9("peer-aria", (a, { modifier: s3 }) => s3 ? `:merge(.peer\\/${s3})[aria-${z4(a)}] ~ &` : `:merge(.peer)[aria-${z4(a)}] ~ &`, { values: (i = e2("aria")) != null ? i : {} });
}, dataVariants: ({ matchVariant: t9, theme: e2 }) => {
  var r2, n2, i;
  t9("data", (a) => `&[data-${z4(a)}]`, { values: (r2 = e2("data")) != null ? r2 : {} }), t9("group-data", (a, { modifier: s3 }) => s3 ? `:merge(.group\\/${s3})[data-${z4(a)}] &` : `:merge(.group)[data-${z4(a)}] &`, { values: (n2 = e2("data")) != null ? n2 : {} }), t9("peer-data", (a, { modifier: s3 }) => s3 ? `:merge(.peer\\/${s3})[data-${z4(a)}] ~ &` : `:merge(.peer)[data-${z4(a)}] ~ &`, { values: (i = e2("data")) != null ? i : {} });
}, orientationVariants: ({ addVariant: t9 }) => {
  t9("portrait", "@media (orientation: portrait)"), t9("landscape", "@media (orientation: landscape)");
}, prefersContrastVariants: ({ addVariant: t9 }) => {
  t9("contrast-more", "@media (prefers-contrast: more)"), t9("contrast-less", "@media (prefers-contrast: less)");
} };
var he3 = ["translate(var(--tw-translate-x), var(--tw-translate-y))", "rotate(var(--tw-rotate))", "skewX(var(--tw-skew-x))", "skewY(var(--tw-skew-y))", "scaleX(var(--tw-scale-x))", "scaleY(var(--tw-scale-y))"].join(" ");
var xe3 = ["var(--tw-blur)", "var(--tw-brightness)", "var(--tw-contrast)", "var(--tw-grayscale)", "var(--tw-hue-rotate)", "var(--tw-invert)", "var(--tw-saturate)", "var(--tw-sepia)", "var(--tw-drop-shadow)"].join(" ");
var Se3 = ["var(--tw-backdrop-blur)", "var(--tw-backdrop-brightness)", "var(--tw-backdrop-contrast)", "var(--tw-backdrop-grayscale)", "var(--tw-backdrop-hue-rotate)", "var(--tw-backdrop-invert)", "var(--tw-backdrop-opacity)", "var(--tw-backdrop-saturate)", "var(--tw-backdrop-sepia)"].join(" ");
var wf = { preflight: ({ addBase: t9 }) => {
  let e2 = R3.parse(ht3.readFileSync(Kn3("/", "./css/preflight.css"), "utf8"));
  t9([R3.comment({ text: `! tailwindcss v${$a2} | MIT License | https://tailwindcss.com` }), ...e2.nodes]);
}, container: (() => {
  function t9(r2 = []) {
    return r2.flatMap((n2) => n2.values.map((i) => i.min)).filter((n2) => n2 !== undefined);
  }
  function e2(r2, n2, i) {
    if (typeof i > "u")
      return [];
    if (!(typeof i == "object" && i !== null))
      return [{ screen: "DEFAULT", minWidth: 0, padding: i }];
    let a = [];
    i.DEFAULT && a.push({ screen: "DEFAULT", minWidth: 0, padding: i.DEFAULT });
    for (let s3 of r2)
      for (let o2 of n2)
        for (let { min: l3 } of o2.values)
          l3 === s3 && a.push({ minWidth: s3, padding: i[o2.name] });
    return a;
  }
  return function({ addComponents: r2, theme: n2 }) {
    let i = Fe3(n2("container.screens", n2("screens"))), a = t9(i), s3 = e2(a, i, n2("container.padding")), o2 = (u) => {
      let f = s3.find((p) => p.minWidth === u);
      return f ? { paddingRight: f.padding, paddingLeft: f.padding } : {};
    }, l3 = Array.from(new Set(a.slice().sort((u, f) => parseInt(u) - parseInt(f)))).map((u) => ({ [`@media (min-width: ${u})`]: { ".container": { "max-width": u, ...o2(u) } } }));
    r2([{ ".container": Object.assign({ width: "100%" }, n2("container.center", false) ? { marginRight: "auto", marginLeft: "auto" } : {}, o2(0)) }, ...l3]);
  };
})(), accessibility: ({ addUtilities: t9 }) => {
  t9({ ".sr-only": { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" }, ".not-sr-only": { position: "static", width: "auto", height: "auto", padding: "0", margin: "0", overflow: "visible", clip: "auto", whiteSpace: "normal" } });
}, pointerEvents: ({ addUtilities: t9 }) => {
  t9({ ".pointer-events-none": { "pointer-events": "none" }, ".pointer-events-auto": { "pointer-events": "auto" } });
}, visibility: ({ addUtilities: t9 }) => {
  t9({ ".visible": { visibility: "visible" }, ".invisible": { visibility: "hidden" }, ".collapse": { visibility: "collapse" } });
}, position: ({ addUtilities: t9 }) => {
  t9({ ".static": { position: "static" }, ".fixed": { position: "fixed" }, ".absolute": { position: "absolute" }, ".relative": { position: "relative" }, ".sticky": { position: "sticky" } });
}, inset: T3("inset", [["inset", ["inset"]], [["inset-x", ["left", "right"]], ["inset-y", ["top", "bottom"]]], [["start", ["inset-inline-start"]], ["end", ["inset-inline-end"]], ["top", ["top"]], ["right", ["right"]], ["bottom", ["bottom"]], ["left", ["left"]]]], { supportsNegativeValues: true }), isolation: ({ addUtilities: t9 }) => {
  t9({ ".isolate": { isolation: "isolate" }, ".isolation-auto": { isolation: "auto" } });
}, zIndex: T3("zIndex", [["z", ["zIndex"]]], { supportsNegativeValues: true }), order: T3("order", undefined, { supportsNegativeValues: true }), gridColumn: T3("gridColumn", [["col", ["gridColumn"]]]), gridColumnStart: T3("gridColumnStart", [["col-start", ["gridColumnStart"]]]), gridColumnEnd: T3("gridColumnEnd", [["col-end", ["gridColumnEnd"]]]), gridRow: T3("gridRow", [["row", ["gridRow"]]]), gridRowStart: T3("gridRowStart", [["row-start", ["gridRowStart"]]]), gridRowEnd: T3("gridRowEnd", [["row-end", ["gridRowEnd"]]]), float: ({ addUtilities: t9 }) => {
  t9({ ".float-right": { float: "right" }, ".float-left": { float: "left" }, ".float-none": { float: "none" } });
}, clear: ({ addUtilities: t9 }) => {
  t9({ ".clear-left": { clear: "left" }, ".clear-right": { clear: "right" }, ".clear-both": { clear: "both" }, ".clear-none": { clear: "none" } });
}, margin: T3("margin", [["m", ["margin"]], [["mx", ["margin-left", "margin-right"]], ["my", ["margin-top", "margin-bottom"]]], [["ms", ["margin-inline-start"]], ["me", ["margin-inline-end"]], ["mt", ["margin-top"]], ["mr", ["margin-right"]], ["mb", ["margin-bottom"]], ["ml", ["margin-left"]]]], { supportsNegativeValues: true }), boxSizing: ({ addUtilities: t9 }) => {
  t9({ ".box-border": { "box-sizing": "border-box" }, ".box-content": { "box-sizing": "content-box" } });
}, lineClamp: ({ matchUtilities: t9, addUtilities: e2, theme: r2 }) => {
  t9({ "line-clamp": (n2) => ({ overflow: "hidden", display: "-webkit-box", "-webkit-box-orient": "vertical", "-webkit-line-clamp": `${n2}` }) }, { values: r2("lineClamp") }), e2({ ".line-clamp-none": { overflow: "visible", display: "block", "-webkit-box-orient": "horizontal", "-webkit-line-clamp": "none" } });
}, display: ({ addUtilities: t9 }) => {
  t9({ ".block": { display: "block" }, ".inline-block": { display: "inline-block" }, ".inline": { display: "inline" }, ".flex": { display: "flex" }, ".inline-flex": { display: "inline-flex" }, ".table": { display: "table" }, ".inline-table": { display: "inline-table" }, ".table-caption": { display: "table-caption" }, ".table-cell": { display: "table-cell" }, ".table-column": { display: "table-column" }, ".table-column-group": { display: "table-column-group" }, ".table-footer-group": { display: "table-footer-group" }, ".table-header-group": { display: "table-header-group" }, ".table-row-group": { display: "table-row-group" }, ".table-row": { display: "table-row" }, ".flow-root": { display: "flow-root" }, ".grid": { display: "grid" }, ".inline-grid": { display: "inline-grid" }, ".contents": { display: "contents" }, ".list-item": { display: "list-item" }, ".hidden": { display: "none" } });
}, aspectRatio: T3("aspectRatio", [["aspect", ["aspect-ratio"]]]), height: T3("height", [["h", ["height"]]]), maxHeight: T3("maxHeight", [["max-h", ["maxHeight"]]]), minHeight: T3("minHeight", [["min-h", ["minHeight"]]]), width: T3("width", [["w", ["width"]]]), minWidth: T3("minWidth", [["min-w", ["minWidth"]]]), maxWidth: T3("maxWidth", [["max-w", ["maxWidth"]]]), flex: T3("flex"), flexShrink: T3("flexShrink", [["flex-shrink", ["flex-shrink"]], ["shrink", ["flex-shrink"]]]), flexGrow: T3("flexGrow", [["flex-grow", ["flex-grow"]], ["grow", ["flex-grow"]]]), flexBasis: T3("flexBasis", [["basis", ["flex-basis"]]]), tableLayout: ({ addUtilities: t9 }) => {
  t9({ ".table-auto": { "table-layout": "auto" }, ".table-fixed": { "table-layout": "fixed" } });
}, captionSide: ({ addUtilities: t9 }) => {
  t9({ ".caption-top": { "caption-side": "top" }, ".caption-bottom": { "caption-side": "bottom" } });
}, borderCollapse: ({ addUtilities: t9 }) => {
  t9({ ".border-collapse": { "border-collapse": "collapse" }, ".border-separate": { "border-collapse": "separate" } });
}, borderSpacing: ({ addDefaults: t9, matchUtilities: e2, theme: r2 }) => {
  t9("border-spacing", { "--tw-border-spacing-x": 0, "--tw-border-spacing-y": 0 }), e2({ "border-spacing": (n2) => ({ "--tw-border-spacing-x": n2, "--tw-border-spacing-y": n2, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }), "border-spacing-x": (n2) => ({ "--tw-border-spacing-x": n2, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }), "border-spacing-y": (n2) => ({ "--tw-border-spacing-y": n2, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }) }, { values: r2("borderSpacing") });
}, transformOrigin: T3("transformOrigin", [["origin", ["transformOrigin"]]]), translate: T3("translate", [[["translate-x", [["@defaults transform", {}], "--tw-translate-x", ["transform", he3]]], ["translate-y", [["@defaults transform", {}], "--tw-translate-y", ["transform", he3]]]]], { supportsNegativeValues: true }), rotate: T3("rotate", [["rotate", [["@defaults transform", {}], "--tw-rotate", ["transform", he3]]]], { supportsNegativeValues: true }), skew: T3("skew", [[["skew-x", [["@defaults transform", {}], "--tw-skew-x", ["transform", he3]]], ["skew-y", [["@defaults transform", {}], "--tw-skew-y", ["transform", he3]]]]], { supportsNegativeValues: true }), scale: T3("scale", [["scale", [["@defaults transform", {}], "--tw-scale-x", "--tw-scale-y", ["transform", he3]]], [["scale-x", [["@defaults transform", {}], "--tw-scale-x", ["transform", he3]]], ["scale-y", [["@defaults transform", {}], "--tw-scale-y", ["transform", he3]]]]], { supportsNegativeValues: true }), transform: ({ addDefaults: t9, addUtilities: e2 }) => {
  t9("transform", { "--tw-translate-x": "0", "--tw-translate-y": "0", "--tw-rotate": "0", "--tw-skew-x": "0", "--tw-skew-y": "0", "--tw-scale-x": "1", "--tw-scale-y": "1" }), e2({ ".transform": { "@defaults transform": {}, transform: he3 }, ".transform-cpu": { transform: he3 }, ".transform-gpu": { transform: he3.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)") }, ".transform-none": { transform: "none" } });
}, animation: ({ matchUtilities: t9, theme: e2, config: r2 }) => {
  var a;
  let n2 = (s3) => `${r2("prefix")}${re3(s3)}`, i = Object.fromEntries(Object.entries((a = e2("keyframes")) != null ? a : {}).map(([s3, o2]) => [s3, { [`@keyframes ${n2(s3)}`]: o2 }]));
  t9({ animate: (s3) => {
    let o2 = $s(s3);
    return [...o2.flatMap((l3) => i[l3.name]), { animation: o2.map(({ name: l3, value: u }) => l3 === undefined || i[l3] === undefined ? u : u.replace(l3, n2(l3))).join(", ") }];
  } }, { values: e2("animation") });
}, cursor: T3("cursor"), touchAction: ({ addDefaults: t9, addUtilities: e2 }) => {
  t9("touch-action", { "--tw-pan-x": " ", "--tw-pan-y": " ", "--tw-pinch-zoom": " " });
  let r2 = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
  e2({ ".touch-auto": { "touch-action": "auto" }, ".touch-none": { "touch-action": "none" }, ".touch-pan-x": { "@defaults touch-action": {}, "--tw-pan-x": "pan-x", "touch-action": r2 }, ".touch-pan-left": { "@defaults touch-action": {}, "--tw-pan-x": "pan-left", "touch-action": r2 }, ".touch-pan-right": { "@defaults touch-action": {}, "--tw-pan-x": "pan-right", "touch-action": r2 }, ".touch-pan-y": { "@defaults touch-action": {}, "--tw-pan-y": "pan-y", "touch-action": r2 }, ".touch-pan-up": { "@defaults touch-action": {}, "--tw-pan-y": "pan-up", "touch-action": r2 }, ".touch-pan-down": { "@defaults touch-action": {}, "--tw-pan-y": "pan-down", "touch-action": r2 }, ".touch-pinch-zoom": { "@defaults touch-action": {}, "--tw-pinch-zoom": "pinch-zoom", "touch-action": r2 }, ".touch-manipulation": { "touch-action": "manipulation" } });
}, userSelect: ({ addUtilities: t9 }) => {
  t9({ ".select-none": { "user-select": "none" }, ".select-text": { "user-select": "text" }, ".select-all": { "user-select": "all" }, ".select-auto": { "user-select": "auto" } });
}, resize: ({ addUtilities: t9 }) => {
  t9({ ".resize-none": { resize: "none" }, ".resize-y": { resize: "vertical" }, ".resize-x": { resize: "horizontal" }, ".resize": { resize: "both" } });
}, scrollSnapType: ({ addDefaults: t9, addUtilities: e2 }) => {
  t9("scroll-snap-type", { "--tw-scroll-snap-strictness": "proximity" }), e2({ ".snap-none": { "scroll-snap-type": "none" }, ".snap-x": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "x var(--tw-scroll-snap-strictness)" }, ".snap-y": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "y var(--tw-scroll-snap-strictness)" }, ".snap-both": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "both var(--tw-scroll-snap-strictness)" }, ".snap-mandatory": { "--tw-scroll-snap-strictness": "mandatory" }, ".snap-proximity": { "--tw-scroll-snap-strictness": "proximity" } });
}, scrollSnapAlign: ({ addUtilities: t9 }) => {
  t9({ ".snap-start": { "scroll-snap-align": "start" }, ".snap-end": { "scroll-snap-align": "end" }, ".snap-center": { "scroll-snap-align": "center" }, ".snap-align-none": { "scroll-snap-align": "none" } });
}, scrollSnapStop: ({ addUtilities: t9 }) => {
  t9({ ".snap-normal": { "scroll-snap-stop": "normal" }, ".snap-always": { "scroll-snap-stop": "always" } });
}, scrollMargin: T3("scrollMargin", [["scroll-m", ["scroll-margin"]], [["scroll-mx", ["scroll-margin-left", "scroll-margin-right"]], ["scroll-my", ["scroll-margin-top", "scroll-margin-bottom"]]], [["scroll-ms", ["scroll-margin-inline-start"]], ["scroll-me", ["scroll-margin-inline-end"]], ["scroll-mt", ["scroll-margin-top"]], ["scroll-mr", ["scroll-margin-right"]], ["scroll-mb", ["scroll-margin-bottom"]], ["scroll-ml", ["scroll-margin-left"]]]], { supportsNegativeValues: true }), scrollPadding: T3("scrollPadding", [["scroll-p", ["scroll-padding"]], [["scroll-px", ["scroll-padding-left", "scroll-padding-right"]], ["scroll-py", ["scroll-padding-top", "scroll-padding-bottom"]]], [["scroll-ps", ["scroll-padding-inline-start"]], ["scroll-pe", ["scroll-padding-inline-end"]], ["scroll-pt", ["scroll-padding-top"]], ["scroll-pr", ["scroll-padding-right"]], ["scroll-pb", ["scroll-padding-bottom"]], ["scroll-pl", ["scroll-padding-left"]]]]), listStylePosition: ({ addUtilities: t9 }) => {
  t9({ ".list-inside": { "list-style-position": "inside" }, ".list-outside": { "list-style-position": "outside" } });
}, listStyleType: T3("listStyleType", [["list", ["listStyleType"]]]), listStyleImage: T3("listStyleImage", [["list-image", ["listStyleImage"]]]), appearance: ({ addUtilities: t9 }) => {
  t9({ ".appearance-none": { appearance: "none" } });
}, columns: T3("columns", [["columns", ["columns"]]]), breakBefore: ({ addUtilities: t9 }) => {
  t9({ ".break-before-auto": { "break-before": "auto" }, ".break-before-avoid": { "break-before": "avoid" }, ".break-before-all": { "break-before": "all" }, ".break-before-avoid-page": { "break-before": "avoid-page" }, ".break-before-page": { "break-before": "page" }, ".break-before-left": { "break-before": "left" }, ".break-before-right": { "break-before": "right" }, ".break-before-column": { "break-before": "column" } });
}, breakInside: ({ addUtilities: t9 }) => {
  t9({ ".break-inside-auto": { "break-inside": "auto" }, ".break-inside-avoid": { "break-inside": "avoid" }, ".break-inside-avoid-page": { "break-inside": "avoid-page" }, ".break-inside-avoid-column": { "break-inside": "avoid-column" } });
}, breakAfter: ({ addUtilities: t9 }) => {
  t9({ ".break-after-auto": { "break-after": "auto" }, ".break-after-avoid": { "break-after": "avoid" }, ".break-after-all": { "break-after": "all" }, ".break-after-avoid-page": { "break-after": "avoid-page" }, ".break-after-page": { "break-after": "page" }, ".break-after-left": { "break-after": "left" }, ".break-after-right": { "break-after": "right" }, ".break-after-column": { "break-after": "column" } });
}, gridAutoColumns: T3("gridAutoColumns", [["auto-cols", ["gridAutoColumns"]]]), gridAutoFlow: ({ addUtilities: t9 }) => {
  t9({ ".grid-flow-row": { gridAutoFlow: "row" }, ".grid-flow-col": { gridAutoFlow: "column" }, ".grid-flow-dense": { gridAutoFlow: "dense" }, ".grid-flow-row-dense": { gridAutoFlow: "row dense" }, ".grid-flow-col-dense": { gridAutoFlow: "column dense" } });
}, gridAutoRows: T3("gridAutoRows", [["auto-rows", ["gridAutoRows"]]]), gridTemplateColumns: T3("gridTemplateColumns", [["grid-cols", ["gridTemplateColumns"]]]), gridTemplateRows: T3("gridTemplateRows", [["grid-rows", ["gridTemplateRows"]]]), flexDirection: ({ addUtilities: t9 }) => {
  t9({ ".flex-row": { "flex-direction": "row" }, ".flex-row-reverse": { "flex-direction": "row-reverse" }, ".flex-col": { "flex-direction": "column" }, ".flex-col-reverse": { "flex-direction": "column-reverse" } });
}, flexWrap: ({ addUtilities: t9 }) => {
  t9({ ".flex-wrap": { "flex-wrap": "wrap" }, ".flex-wrap-reverse": { "flex-wrap": "wrap-reverse" }, ".flex-nowrap": { "flex-wrap": "nowrap" } });
}, placeContent: ({ addUtilities: t9 }) => {
  t9({ ".place-content-center": { "place-content": "center" }, ".place-content-start": { "place-content": "start" }, ".place-content-end": { "place-content": "end" }, ".place-content-between": { "place-content": "space-between" }, ".place-content-around": { "place-content": "space-around" }, ".place-content-evenly": { "place-content": "space-evenly" }, ".place-content-baseline": { "place-content": "baseline" }, ".place-content-stretch": { "place-content": "stretch" } });
}, placeItems: ({ addUtilities: t9 }) => {
  t9({ ".place-items-start": { "place-items": "start" }, ".place-items-end": { "place-items": "end" }, ".place-items-center": { "place-items": "center" }, ".place-items-baseline": { "place-items": "baseline" }, ".place-items-stretch": { "place-items": "stretch" } });
}, alignContent: ({ addUtilities: t9 }) => {
  t9({ ".content-normal": { "align-content": "normal" }, ".content-center": { "align-content": "center" }, ".content-start": { "align-content": "flex-start" }, ".content-end": { "align-content": "flex-end" }, ".content-between": { "align-content": "space-between" }, ".content-around": { "align-content": "space-around" }, ".content-evenly": { "align-content": "space-evenly" }, ".content-baseline": { "align-content": "baseline" }, ".content-stretch": { "align-content": "stretch" } });
}, alignItems: ({ addUtilities: t9 }) => {
  t9({ ".items-start": { "align-items": "flex-start" }, ".items-end": { "align-items": "flex-end" }, ".items-center": { "align-items": "center" }, ".items-baseline": { "align-items": "baseline" }, ".items-stretch": { "align-items": "stretch" } });
}, justifyContent: ({ addUtilities: t9 }) => {
  t9({ ".justify-normal": { "justify-content": "normal" }, ".justify-start": { "justify-content": "flex-start" }, ".justify-end": { "justify-content": "flex-end" }, ".justify-center": { "justify-content": "center" }, ".justify-between": { "justify-content": "space-between" }, ".justify-around": { "justify-content": "space-around" }, ".justify-evenly": { "justify-content": "space-evenly" }, ".justify-stretch": { "justify-content": "stretch" } });
}, justifyItems: ({ addUtilities: t9 }) => {
  t9({ ".justify-items-start": { "justify-items": "start" }, ".justify-items-end": { "justify-items": "end" }, ".justify-items-center": { "justify-items": "center" }, ".justify-items-stretch": { "justify-items": "stretch" } });
}, gap: T3("gap", [["gap", ["gap"]], [["gap-x", ["columnGap"]], ["gap-y", ["rowGap"]]]]), space: ({ matchUtilities: t9, addUtilities: e2, theme: r2 }) => {
  t9({ "space-x": (n2) => (n2 = n2 === "0" ? "0px" : n2, { "& > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "0", "margin-right": `calc(${n2} * var(--tw-space-x-reverse))`, "margin-left": `calc(${n2} * calc(1 - var(--tw-space-x-reverse)))` } }), "space-y": (n2) => (n2 = n2 === "0" ? "0px" : n2, { "& > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "0", "margin-top": `calc(${n2} * calc(1 - var(--tw-space-y-reverse)))`, "margin-bottom": `calc(${n2} * var(--tw-space-y-reverse))` } }) }, { values: r2("space"), supportsNegativeValues: true }), e2({ ".space-y-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "1" }, ".space-x-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "1" } });
}, divideWidth: ({ matchUtilities: t9, addUtilities: e2, theme: r2 }) => {
  t9({ "divide-x": (n2) => (n2 = n2 === "0" ? "0px" : n2, { "& > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-x-reverse": "0", "border-right-width": `calc(${n2} * var(--tw-divide-x-reverse))`, "border-left-width": `calc(${n2} * calc(1 - var(--tw-divide-x-reverse)))` } }), "divide-y": (n2) => (n2 = n2 === "0" ? "0px" : n2, { "& > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-y-reverse": "0", "border-top-width": `calc(${n2} * calc(1 - var(--tw-divide-y-reverse)))`, "border-bottom-width": `calc(${n2} * var(--tw-divide-y-reverse))` } }) }, { values: r2("divideWidth"), type: ["line-width", "length", "any"] }), e2({ ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-y-reverse": "1" }, ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-x-reverse": "1" } });
}, divideStyle: ({ addUtilities: t9 }) => {
  t9({ ".divide-solid > :not([hidden]) ~ :not([hidden])": { "border-style": "solid" }, ".divide-dashed > :not([hidden]) ~ :not([hidden])": { "border-style": "dashed" }, ".divide-dotted > :not([hidden]) ~ :not([hidden])": { "border-style": "dotted" }, ".divide-double > :not([hidden]) ~ :not([hidden])": { "border-style": "double" }, ".divide-none > :not([hidden]) ~ :not([hidden])": { "border-style": "none" } });
}, divideColor: ({ matchUtilities: t9, theme: e2, corePlugins: r2 }) => {
  t9({ divide: (n2) => r2("divideOpacity") ? { ["& > :not([hidden]) ~ :not([hidden])"]: Z3({ color: n2, property: "border-color", variable: "--tw-divide-opacity" }) } : { ["& > :not([hidden]) ~ :not([hidden])"]: { "border-color": M2(n2) } } }, { values: (({ DEFAULT: n2, ...i }) => i)(Q3(e2("divideColor"))), type: ["color", "any"] });
}, divideOpacity: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ "divide-opacity": (r2) => ({ ["& > :not([hidden]) ~ :not([hidden])"]: { "--tw-divide-opacity": r2 } }) }, { values: e2("divideOpacity") });
}, placeSelf: ({ addUtilities: t9 }) => {
  t9({ ".place-self-auto": { "place-self": "auto" }, ".place-self-start": { "place-self": "start" }, ".place-self-end": { "place-self": "end" }, ".place-self-center": { "place-self": "center" }, ".place-self-stretch": { "place-self": "stretch" } });
}, alignSelf: ({ addUtilities: t9 }) => {
  t9({ ".self-auto": { "align-self": "auto" }, ".self-start": { "align-self": "flex-start" }, ".self-end": { "align-self": "flex-end" }, ".self-center": { "align-self": "center" }, ".self-stretch": { "align-self": "stretch" }, ".self-baseline": { "align-self": "baseline" } });
}, justifySelf: ({ addUtilities: t9 }) => {
  t9({ ".justify-self-auto": { "justify-self": "auto" }, ".justify-self-start": { "justify-self": "start" }, ".justify-self-end": { "justify-self": "end" }, ".justify-self-center": { "justify-self": "center" }, ".justify-self-stretch": { "justify-self": "stretch" } });
}, overflow: ({ addUtilities: t9 }) => {
  t9({ ".overflow-auto": { overflow: "auto" }, ".overflow-hidden": { overflow: "hidden" }, ".overflow-clip": { overflow: "clip" }, ".overflow-visible": { overflow: "visible" }, ".overflow-scroll": { overflow: "scroll" }, ".overflow-x-auto": { "overflow-x": "auto" }, ".overflow-y-auto": { "overflow-y": "auto" }, ".overflow-x-hidden": { "overflow-x": "hidden" }, ".overflow-y-hidden": { "overflow-y": "hidden" }, ".overflow-x-clip": { "overflow-x": "clip" }, ".overflow-y-clip": { "overflow-y": "clip" }, ".overflow-x-visible": { "overflow-x": "visible" }, ".overflow-y-visible": { "overflow-y": "visible" }, ".overflow-x-scroll": { "overflow-x": "scroll" }, ".overflow-y-scroll": { "overflow-y": "scroll" } });
}, overscrollBehavior: ({ addUtilities: t9 }) => {
  t9({ ".overscroll-auto": { "overscroll-behavior": "auto" }, ".overscroll-contain": { "overscroll-behavior": "contain" }, ".overscroll-none": { "overscroll-behavior": "none" }, ".overscroll-y-auto": { "overscroll-behavior-y": "auto" }, ".overscroll-y-contain": { "overscroll-behavior-y": "contain" }, ".overscroll-y-none": { "overscroll-behavior-y": "none" }, ".overscroll-x-auto": { "overscroll-behavior-x": "auto" }, ".overscroll-x-contain": { "overscroll-behavior-x": "contain" }, ".overscroll-x-none": { "overscroll-behavior-x": "none" } });
}, scrollBehavior: ({ addUtilities: t9 }) => {
  t9({ ".scroll-auto": { "scroll-behavior": "auto" }, ".scroll-smooth": { "scroll-behavior": "smooth" } });
}, textOverflow: ({ addUtilities: t9 }) => {
  t9({ ".truncate": { overflow: "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" }, ".overflow-ellipsis": { "text-overflow": "ellipsis" }, ".text-ellipsis": { "text-overflow": "ellipsis" }, ".text-clip": { "text-overflow": "clip" } });
}, hyphens: ({ addUtilities: t9 }) => {
  t9({ ".hyphens-none": { hyphens: "none" }, ".hyphens-manual": { hyphens: "manual" }, ".hyphens-auto": { hyphens: "auto" } });
}, whitespace: ({ addUtilities: t9 }) => {
  t9({ ".whitespace-normal": { "white-space": "normal" }, ".whitespace-nowrap": { "white-space": "nowrap" }, ".whitespace-pre": { "white-space": "pre" }, ".whitespace-pre-line": { "white-space": "pre-line" }, ".whitespace-pre-wrap": { "white-space": "pre-wrap" }, ".whitespace-break-spaces": { "white-space": "break-spaces" } });
}, wordBreak: ({ addUtilities: t9 }) => {
  t9({ ".break-normal": { "overflow-wrap": "normal", "word-break": "normal" }, ".break-words": { "overflow-wrap": "break-word" }, ".break-all": { "word-break": "break-all" }, ".break-keep": { "word-break": "keep-all" } });
}, borderRadius: T3("borderRadius", [["rounded", ["border-radius"]], [["rounded-s", ["border-start-start-radius", "border-end-start-radius"]], ["rounded-e", ["border-start-end-radius", "border-end-end-radius"]], ["rounded-t", ["border-top-left-radius", "border-top-right-radius"]], ["rounded-r", ["border-top-right-radius", "border-bottom-right-radius"]], ["rounded-b", ["border-bottom-right-radius", "border-bottom-left-radius"]], ["rounded-l", ["border-top-left-radius", "border-bottom-left-radius"]]], [["rounded-ss", ["border-start-start-radius"]], ["rounded-se", ["border-start-end-radius"]], ["rounded-ee", ["border-end-end-radius"]], ["rounded-es", ["border-end-start-radius"]], ["rounded-tl", ["border-top-left-radius"]], ["rounded-tr", ["border-top-right-radius"]], ["rounded-br", ["border-bottom-right-radius"]], ["rounded-bl", ["border-bottom-left-radius"]]]]), borderWidth: T3("borderWidth", [["border", [["@defaults border-width", {}], "border-width"]], [["border-x", [["@defaults border-width", {}], "border-left-width", "border-right-width"]], ["border-y", [["@defaults border-width", {}], "border-top-width", "border-bottom-width"]]], [["border-s", [["@defaults border-width", {}], "border-inline-start-width"]], ["border-e", [["@defaults border-width", {}], "border-inline-end-width"]], ["border-t", [["@defaults border-width", {}], "border-top-width"]], ["border-r", [["@defaults border-width", {}], "border-right-width"]], ["border-b", [["@defaults border-width", {}], "border-bottom-width"]], ["border-l", [["@defaults border-width", {}], "border-left-width"]]]], { type: ["line-width", "length"] }), borderStyle: ({ addUtilities: t9 }) => {
  t9({ ".border-solid": { "border-style": "solid" }, ".border-dashed": { "border-style": "dashed" }, ".border-dotted": { "border-style": "dotted" }, ".border-double": { "border-style": "double" }, ".border-hidden": { "border-style": "hidden" }, ".border-none": { "border-style": "none" } });
}, borderColor: ({ matchUtilities: t9, theme: e2, corePlugins: r2 }) => {
  t9({ border: (n2) => r2("borderOpacity") ? Z3({ color: n2, property: "border-color", variable: "--tw-border-opacity" }) : { "border-color": M2(n2) } }, { values: (({ DEFAULT: n2, ...i }) => i)(Q3(e2("borderColor"))), type: ["color", "any"] }), t9({ "border-x": (n2) => r2("borderOpacity") ? Z3({ color: n2, property: ["border-left-color", "border-right-color"], variable: "--tw-border-opacity" }) : { "border-left-color": M2(n2), "border-right-color": M2(n2) }, "border-y": (n2) => r2("borderOpacity") ? Z3({ color: n2, property: ["border-top-color", "border-bottom-color"], variable: "--tw-border-opacity" }) : { "border-top-color": M2(n2), "border-bottom-color": M2(n2) } }, { values: (({ DEFAULT: n2, ...i }) => i)(Q3(e2("borderColor"))), type: ["color", "any"] }), t9({ "border-s": (n2) => r2("borderOpacity") ? Z3({ color: n2, property: "border-inline-start-color", variable: "--tw-border-opacity" }) : { "border-inline-start-color": M2(n2) }, "border-e": (n2) => r2("borderOpacity") ? Z3({ color: n2, property: "border-inline-end-color", variable: "--tw-border-opacity" }) : { "border-inline-end-color": M2(n2) }, "border-t": (n2) => r2("borderOpacity") ? Z3({ color: n2, property: "border-top-color", variable: "--tw-border-opacity" }) : { "border-top-color": M2(n2) }, "border-r": (n2) => r2("borderOpacity") ? Z3({ color: n2, property: "border-right-color", variable: "--tw-border-opacity" }) : { "border-right-color": M2(n2) }, "border-b": (n2) => r2("borderOpacity") ? Z3({ color: n2, property: "border-bottom-color", variable: "--tw-border-opacity" }) : { "border-bottom-color": M2(n2) }, "border-l": (n2) => r2("borderOpacity") ? Z3({ color: n2, property: "border-left-color", variable: "--tw-border-opacity" }) : { "border-left-color": M2(n2) } }, { values: (({ DEFAULT: n2, ...i }) => i)(Q3(e2("borderColor"))), type: ["color", "any"] });
}, borderOpacity: T3("borderOpacity", [["border-opacity", ["--tw-border-opacity"]]]), backgroundColor: ({ matchUtilities: t9, theme: e2, corePlugins: r2 }) => {
  t9({ bg: (n2) => r2("backgroundOpacity") ? Z3({ color: n2, property: "background-color", variable: "--tw-bg-opacity" }) : { "background-color": M2(n2) } }, { values: Q3(e2("backgroundColor")), type: ["color", "any"] });
}, backgroundOpacity: T3("backgroundOpacity", [["bg-opacity", ["--tw-bg-opacity"]]]), backgroundImage: T3("backgroundImage", [["bg", ["background-image"]]], { type: ["lookup", "image", "url"] }), gradientColorStops: (() => {
  function t9(e2) {
    return we3(e2, 0, "rgb(255 255 255 / 0)");
  }
  return function({ matchUtilities: e2, theme: r2, addDefaults: n2 }) {
    n2("gradient-color-stops", { "--tw-gradient-from-position": " ", "--tw-gradient-via-position": " ", "--tw-gradient-to-position": " " });
    let i = { values: Q3(r2("gradientColorStops")), type: ["color", "any"] }, a = { values: r2("gradientColorStopPositions"), type: ["length", "percentage"] };
    e2({ from: (s3) => {
      let o2 = t9(s3);
      return { "@defaults gradient-color-stops": {}, "--tw-gradient-from": `${M2(s3)} var(--tw-gradient-from-position)`, "--tw-gradient-to": `${o2} var(--tw-gradient-to-position)`, "--tw-gradient-stops": "var(--tw-gradient-from), var(--tw-gradient-to)" };
    } }, i), e2({ from: (s3) => ({ "--tw-gradient-from-position": s3 }) }, a), e2({ via: (s3) => {
      let o2 = t9(s3);
      return { "@defaults gradient-color-stops": {}, "--tw-gradient-to": `${o2}  var(--tw-gradient-to-position)`, "--tw-gradient-stops": `var(--tw-gradient-from), ${M2(s3)} var(--tw-gradient-via-position), var(--tw-gradient-to)` };
    } }, i), e2({ via: (s3) => ({ "--tw-gradient-via-position": s3 }) }, a), e2({ to: (s3) => ({ "@defaults gradient-color-stops": {}, "--tw-gradient-to": `${M2(s3)} var(--tw-gradient-to-position)` }) }, i), e2({ to: (s3) => ({ "--tw-gradient-to-position": s3 }) }, a);
  };
})(), boxDecorationBreak: ({ addUtilities: t9 }) => {
  t9({ ".decoration-slice": { "box-decoration-break": "slice" }, ".decoration-clone": { "box-decoration-break": "clone" }, ".box-decoration-slice": { "box-decoration-break": "slice" }, ".box-decoration-clone": { "box-decoration-break": "clone" } });
}, backgroundSize: T3("backgroundSize", [["bg", ["background-size"]]], { type: ["lookup", "length", "percentage", "size"] }), backgroundAttachment: ({ addUtilities: t9 }) => {
  t9({ ".bg-fixed": { "background-attachment": "fixed" }, ".bg-local": { "background-attachment": "local" }, ".bg-scroll": { "background-attachment": "scroll" } });
}, backgroundClip: ({ addUtilities: t9 }) => {
  t9({ ".bg-clip-border": { "background-clip": "border-box" }, ".bg-clip-padding": { "background-clip": "padding-box" }, ".bg-clip-content": { "background-clip": "content-box" }, ".bg-clip-text": { "background-clip": "text" } });
}, backgroundPosition: T3("backgroundPosition", [["bg", ["background-position"]]], { type: ["lookup", ["position", { preferOnConflict: true }]] }), backgroundRepeat: ({ addUtilities: t9 }) => {
  t9({ ".bg-repeat": { "background-repeat": "repeat" }, ".bg-no-repeat": { "background-repeat": "no-repeat" }, ".bg-repeat-x": { "background-repeat": "repeat-x" }, ".bg-repeat-y": { "background-repeat": "repeat-y" }, ".bg-repeat-round": { "background-repeat": "round" }, ".bg-repeat-space": { "background-repeat": "space" } });
}, backgroundOrigin: ({ addUtilities: t9 }) => {
  t9({ ".bg-origin-border": { "background-origin": "border-box" }, ".bg-origin-padding": { "background-origin": "padding-box" }, ".bg-origin-content": { "background-origin": "content-box" } });
}, fill: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ fill: (r2) => ({ fill: M2(r2) }) }, { values: Q3(e2("fill")), type: ["color", "any"] });
}, stroke: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ stroke: (r2) => ({ stroke: M2(r2) }) }, { values: Q3(e2("stroke")), type: ["color", "url", "any"] });
}, strokeWidth: T3("strokeWidth", [["stroke", ["stroke-width"]]], { type: ["length", "number", "percentage"] }), objectFit: ({ addUtilities: t9 }) => {
  t9({ ".object-contain": { "object-fit": "contain" }, ".object-cover": { "object-fit": "cover" }, ".object-fill": { "object-fit": "fill" }, ".object-none": { "object-fit": "none" }, ".object-scale-down": { "object-fit": "scale-down" } });
}, objectPosition: T3("objectPosition", [["object", ["object-position"]]]), padding: T3("padding", [["p", ["padding"]], [["px", ["padding-left", "padding-right"]], ["py", ["padding-top", "padding-bottom"]]], [["ps", ["padding-inline-start"]], ["pe", ["padding-inline-end"]], ["pt", ["padding-top"]], ["pr", ["padding-right"]], ["pb", ["padding-bottom"]], ["pl", ["padding-left"]]]]), textAlign: ({ addUtilities: t9 }) => {
  t9({ ".text-left": { "text-align": "left" }, ".text-center": { "text-align": "center" }, ".text-right": { "text-align": "right" }, ".text-justify": { "text-align": "justify" }, ".text-start": { "text-align": "start" }, ".text-end": { "text-align": "end" } });
}, textIndent: T3("textIndent", [["indent", ["text-indent"]]], { supportsNegativeValues: true }), verticalAlign: ({ addUtilities: t9, matchUtilities: e2 }) => {
  t9({ ".align-baseline": { "vertical-align": "baseline" }, ".align-top": { "vertical-align": "top" }, ".align-middle": { "vertical-align": "middle" }, ".align-bottom": { "vertical-align": "bottom" }, ".align-text-top": { "vertical-align": "text-top" }, ".align-text-bottom": { "vertical-align": "text-bottom" }, ".align-sub": { "vertical-align": "sub" }, ".align-super": { "vertical-align": "super" } }), e2({ align: (r2) => ({ "vertical-align": r2 }) });
}, fontFamily: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ font: (r2) => {
    let [n2, i = {}] = Array.isArray(r2) && X3(r2[1]) ? r2 : [r2], { fontFeatureSettings: a, fontVariationSettings: s3 } = i;
    return { "font-family": Array.isArray(n2) ? n2.join(", ") : n2, ...a === undefined ? {} : { "font-feature-settings": a }, ...s3 === undefined ? {} : { "font-variation-settings": s3 } };
  } }, { values: e2("fontFamily"), type: ["lookup", "generic-name", "family-name"] });
}, fontSize: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ text: (r2, { modifier: n2 }) => {
    let [i, a] = Array.isArray(r2) ? r2 : [r2];
    if (n2)
      return { "font-size": i, "line-height": n2 };
    let { lineHeight: s3, letterSpacing: o2, fontWeight: l3 } = X3(a) ? a : { lineHeight: a };
    return { "font-size": i, ...s3 === undefined ? {} : { "line-height": s3 }, ...o2 === undefined ? {} : { "letter-spacing": o2 }, ...l3 === undefined ? {} : { "font-weight": l3 } };
  } }, { values: e2("fontSize"), modifiers: e2("lineHeight"), type: ["absolute-size", "relative-size", "length", "percentage"] });
}, fontWeight: T3("fontWeight", [["font", ["fontWeight"]]], { type: ["lookup", "number", "any"] }), textTransform: ({ addUtilities: t9 }) => {
  t9({ ".uppercase": { "text-transform": "uppercase" }, ".lowercase": { "text-transform": "lowercase" }, ".capitalize": { "text-transform": "capitalize" }, ".normal-case": { "text-transform": "none" } });
}, fontStyle: ({ addUtilities: t9 }) => {
  t9({ ".italic": { "font-style": "italic" }, ".not-italic": { "font-style": "normal" } });
}, fontVariantNumeric: ({ addDefaults: t9, addUtilities: e2 }) => {
  let r2 = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
  t9("font-variant-numeric", { "--tw-ordinal": " ", "--tw-slashed-zero": " ", "--tw-numeric-figure": " ", "--tw-numeric-spacing": " ", "--tw-numeric-fraction": " " }), e2({ ".normal-nums": { "font-variant-numeric": "normal" }, ".ordinal": { "@defaults font-variant-numeric": {}, "--tw-ordinal": "ordinal", "font-variant-numeric": r2 }, ".slashed-zero": { "@defaults font-variant-numeric": {}, "--tw-slashed-zero": "slashed-zero", "font-variant-numeric": r2 }, ".lining-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-figure": "lining-nums", "font-variant-numeric": r2 }, ".oldstyle-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-figure": "oldstyle-nums", "font-variant-numeric": r2 }, ".proportional-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-spacing": "proportional-nums", "font-variant-numeric": r2 }, ".tabular-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-spacing": "tabular-nums", "font-variant-numeric": r2 }, ".diagonal-fractions": { "@defaults font-variant-numeric": {}, "--tw-numeric-fraction": "diagonal-fractions", "font-variant-numeric": r2 }, ".stacked-fractions": { "@defaults font-variant-numeric": {}, "--tw-numeric-fraction": "stacked-fractions", "font-variant-numeric": r2 } });
}, lineHeight: T3("lineHeight", [["leading", ["lineHeight"]]]), letterSpacing: T3("letterSpacing", [["tracking", ["letterSpacing"]]], { supportsNegativeValues: true }), textColor: ({ matchUtilities: t9, theme: e2, corePlugins: r2 }) => {
  t9({ text: (n2) => r2("textOpacity") ? Z3({ color: n2, property: "color", variable: "--tw-text-opacity" }) : { color: M2(n2) } }, { values: Q3(e2("textColor")), type: ["color", "any"] });
}, textOpacity: T3("textOpacity", [["text-opacity", ["--tw-text-opacity"]]]), textDecoration: ({ addUtilities: t9 }) => {
  t9({ ".underline": { "text-decoration-line": "underline" }, ".overline": { "text-decoration-line": "overline" }, ".line-through": { "text-decoration-line": "line-through" }, ".no-underline": { "text-decoration-line": "none" } });
}, textDecorationColor: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ decoration: (r2) => ({ "text-decoration-color": M2(r2) }) }, { values: Q3(e2("textDecorationColor")), type: ["color", "any"] });
}, textDecorationStyle: ({ addUtilities: t9 }) => {
  t9({ ".decoration-solid": { "text-decoration-style": "solid" }, ".decoration-double": { "text-decoration-style": "double" }, ".decoration-dotted": { "text-decoration-style": "dotted" }, ".decoration-dashed": { "text-decoration-style": "dashed" }, ".decoration-wavy": { "text-decoration-style": "wavy" } });
}, textDecorationThickness: T3("textDecorationThickness", [["decoration", ["text-decoration-thickness"]]], { type: ["length", "percentage"] }), textUnderlineOffset: T3("textUnderlineOffset", [["underline-offset", ["text-underline-offset"]]], { type: ["length", "percentage", "any"] }), fontSmoothing: ({ addUtilities: t9 }) => {
  t9({ ".antialiased": { "-webkit-font-smoothing": "antialiased", "-moz-osx-font-smoothing": "grayscale" }, ".subpixel-antialiased": { "-webkit-font-smoothing": "auto", "-moz-osx-font-smoothing": "auto" } });
}, placeholderColor: ({ matchUtilities: t9, theme: e2, corePlugins: r2 }) => {
  t9({ placeholder: (n2) => r2("placeholderOpacity") ? { "&::placeholder": Z3({ color: n2, property: "color", variable: "--tw-placeholder-opacity" }) } : { "&::placeholder": { color: M2(n2) } } }, { values: Q3(e2("placeholderColor")), type: ["color", "any"] });
}, placeholderOpacity: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ "placeholder-opacity": (r2) => ({ ["&::placeholder"]: { "--tw-placeholder-opacity": r2 } }) }, { values: e2("placeholderOpacity") });
}, caretColor: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ caret: (r2) => ({ "caret-color": M2(r2) }) }, { values: Q3(e2("caretColor")), type: ["color", "any"] });
}, accentColor: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ accent: (r2) => ({ "accent-color": M2(r2) }) }, { values: Q3(e2("accentColor")), type: ["color", "any"] });
}, opacity: T3("opacity", [["opacity", ["opacity"]]]), backgroundBlendMode: ({ addUtilities: t9 }) => {
  t9({ ".bg-blend-normal": { "background-blend-mode": "normal" }, ".bg-blend-multiply": { "background-blend-mode": "multiply" }, ".bg-blend-screen": { "background-blend-mode": "screen" }, ".bg-blend-overlay": { "background-blend-mode": "overlay" }, ".bg-blend-darken": { "background-blend-mode": "darken" }, ".bg-blend-lighten": { "background-blend-mode": "lighten" }, ".bg-blend-color-dodge": { "background-blend-mode": "color-dodge" }, ".bg-blend-color-burn": { "background-blend-mode": "color-burn" }, ".bg-blend-hard-light": { "background-blend-mode": "hard-light" }, ".bg-blend-soft-light": { "background-blend-mode": "soft-light" }, ".bg-blend-difference": { "background-blend-mode": "difference" }, ".bg-blend-exclusion": { "background-blend-mode": "exclusion" }, ".bg-blend-hue": { "background-blend-mode": "hue" }, ".bg-blend-saturation": { "background-blend-mode": "saturation" }, ".bg-blend-color": { "background-blend-mode": "color" }, ".bg-blend-luminosity": { "background-blend-mode": "luminosity" } });
}, mixBlendMode: ({ addUtilities: t9 }) => {
  t9({ ".mix-blend-normal": { "mix-blend-mode": "normal" }, ".mix-blend-multiply": { "mix-blend-mode": "multiply" }, ".mix-blend-screen": { "mix-blend-mode": "screen" }, ".mix-blend-overlay": { "mix-blend-mode": "overlay" }, ".mix-blend-darken": { "mix-blend-mode": "darken" }, ".mix-blend-lighten": { "mix-blend-mode": "lighten" }, ".mix-blend-color-dodge": { "mix-blend-mode": "color-dodge" }, ".mix-blend-color-burn": { "mix-blend-mode": "color-burn" }, ".mix-blend-hard-light": { "mix-blend-mode": "hard-light" }, ".mix-blend-soft-light": { "mix-blend-mode": "soft-light" }, ".mix-blend-difference": { "mix-blend-mode": "difference" }, ".mix-blend-exclusion": { "mix-blend-mode": "exclusion" }, ".mix-blend-hue": { "mix-blend-mode": "hue" }, ".mix-blend-saturation": { "mix-blend-mode": "saturation" }, ".mix-blend-color": { "mix-blend-mode": "color" }, ".mix-blend-luminosity": { "mix-blend-mode": "luminosity" }, ".mix-blend-plus-lighter": { "mix-blend-mode": "plus-lighter" } });
}, boxShadow: (() => {
  let t9 = Ce3("boxShadow"), e2 = ["var(--tw-ring-offset-shadow, 0 0 #0000)", "var(--tw-ring-shadow, 0 0 #0000)", "var(--tw-shadow)"].join(", ");
  return function({ matchUtilities: r2, addDefaults: n2, theme: i }) {
    n2(" box-shadow", { "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" }), r2({ shadow: (a) => {
      a = t9(a);
      let s3 = nn2(a);
      for (let o2 of s3)
        !o2.valid || (o2.color = "var(--tw-shadow-color)");
      return { "@defaults box-shadow": {}, "--tw-shadow": a === "none" ? "0 0 #0000" : a, "--tw-shadow-colored": a === "none" ? "0 0 #0000" : Vu2(s3), "box-shadow": e2 };
    } }, { values: i("boxShadow"), type: ["shadow"] });
  };
})(), boxShadowColor: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ shadow: (r2) => ({ "--tw-shadow-color": M2(r2), "--tw-shadow": "var(--tw-shadow-colored)" }) }, { values: Q3(e2("boxShadowColor")), type: ["color", "any"] });
}, outlineStyle: ({ addUtilities: t9 }) => {
  t9({ ".outline-none": { outline: "2px solid transparent", "outline-offset": "2px" }, ".outline": { "outline-style": "solid" }, ".outline-dashed": { "outline-style": "dashed" }, ".outline-dotted": { "outline-style": "dotted" }, ".outline-double": { "outline-style": "double" } });
}, outlineWidth: T3("outlineWidth", [["outline", ["outline-width"]]], { type: ["length", "number", "percentage"] }), outlineOffset: T3("outlineOffset", [["outline-offset", ["outline-offset"]]], { type: ["length", "number", "percentage", "any"], supportsNegativeValues: true }), outlineColor: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ outline: (r2) => ({ "outline-color": M2(r2) }) }, { values: Q3(e2("outlineColor")), type: ["color", "any"] });
}, ringWidth: ({ matchUtilities: t9, addDefaults: e2, addUtilities: r2, theme: n2, config: i }) => {
  let a = (() => {
    var o2, l3;
    if (G3(i(), "respectDefaultRingColorOpacity"))
      return n2("ringColor.DEFAULT");
    let s3 = n2("ringOpacity.DEFAULT", "0.5");
    return (o2 = n2("ringColor")) != null && o2.DEFAULT ? we3((l3 = n2("ringColor")) == null ? undefined : l3.DEFAULT, s3, `rgb(147 197 253 / ${s3})`) : `rgb(147 197 253 / ${s3})`;
  })();
  e2("ring-width", { "--tw-ring-inset": " ", "--tw-ring-offset-width": n2("ringOffsetWidth.DEFAULT", "0px"), "--tw-ring-offset-color": n2("ringOffsetColor.DEFAULT", "#fff"), "--tw-ring-color": a, "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" }), t9({ ring: (s3) => ({ "@defaults ring-width": {}, "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)", "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${s3} + var(--tw-ring-offset-width)) var(--tw-ring-color)`, "box-shadow": ["var(--tw-ring-offset-shadow)", "var(--tw-ring-shadow)", "var(--tw-shadow, 0 0 #0000)"].join(", ") }) }, { values: n2("ringWidth"), type: "length" }), r2({ ".ring-inset": { "@defaults ring-width": {}, "--tw-ring-inset": "inset" } });
}, ringColor: ({ matchUtilities: t9, theme: e2, corePlugins: r2 }) => {
  t9({ ring: (n2) => r2("ringOpacity") ? Z3({ color: n2, property: "--tw-ring-color", variable: "--tw-ring-opacity" }) : { "--tw-ring-color": M2(n2) } }, { values: Object.fromEntries(Object.entries(Q3(e2("ringColor"))).filter(([n2]) => n2 !== "DEFAULT")), type: ["color", "any"] });
}, ringOpacity: (t9) => {
  let { config: e2 } = t9;
  return T3("ringOpacity", [["ring-opacity", ["--tw-ring-opacity"]]], { filterDefault: !G3(e2(), "respectDefaultRingColorOpacity") })(t9);
}, ringOffsetWidth: T3("ringOffsetWidth", [["ring-offset", ["--tw-ring-offset-width"]]], { type: "length" }), ringOffsetColor: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ "ring-offset": (r2) => ({ "--tw-ring-offset-color": M2(r2) }) }, { values: Q3(e2("ringOffsetColor")), type: ["color", "any"] });
}, blur: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ blur: (r2) => ({ "--tw-blur": `blur(${r2})`, "@defaults filter": {}, filter: xe3 }) }, { values: e2("blur") });
}, brightness: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ brightness: (r2) => ({ "--tw-brightness": `brightness(${r2})`, "@defaults filter": {}, filter: xe3 }) }, { values: e2("brightness") });
}, contrast: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ contrast: (r2) => ({ "--tw-contrast": `contrast(${r2})`, "@defaults filter": {}, filter: xe3 }) }, { values: e2("contrast") });
}, dropShadow: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ "drop-shadow": (r2) => ({ "--tw-drop-shadow": Array.isArray(r2) ? r2.map((n2) => `drop-shadow(${n2})`).join(" ") : `drop-shadow(${r2})`, "@defaults filter": {}, filter: xe3 }) }, { values: e2("dropShadow") });
}, grayscale: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ grayscale: (r2) => ({ "--tw-grayscale": `grayscale(${r2})`, "@defaults filter": {}, filter: xe3 }) }, { values: e2("grayscale") });
}, hueRotate: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ "hue-rotate": (r2) => ({ "--tw-hue-rotate": `hue-rotate(${r2})`, "@defaults filter": {}, filter: xe3 }) }, { values: e2("hueRotate"), supportsNegativeValues: true });
}, invert: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ invert: (r2) => ({ "--tw-invert": `invert(${r2})`, "@defaults filter": {}, filter: xe3 }) }, { values: e2("invert") });
}, saturate: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ saturate: (r2) => ({ "--tw-saturate": `saturate(${r2})`, "@defaults filter": {}, filter: xe3 }) }, { values: e2("saturate") });
}, sepia: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ sepia: (r2) => ({ "--tw-sepia": `sepia(${r2})`, "@defaults filter": {}, filter: xe3 }) }, { values: e2("sepia") });
}, filter: ({ addDefaults: t9, addUtilities: e2 }) => {
  t9("filter", { "--tw-blur": " ", "--tw-brightness": " ", "--tw-contrast": " ", "--tw-grayscale": " ", "--tw-hue-rotate": " ", "--tw-invert": " ", "--tw-saturate": " ", "--tw-sepia": " ", "--tw-drop-shadow": " " }), e2({ ".filter": { "@defaults filter": {}, filter: xe3 }, ".filter-none": { filter: "none" } });
}, backdropBlur: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ "backdrop-blur": (r2) => ({ "--tw-backdrop-blur": `blur(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se3 }) }, { values: e2("backdropBlur") });
}, backdropBrightness: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ "backdrop-brightness": (r2) => ({ "--tw-backdrop-brightness": `brightness(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se3 }) }, { values: e2("backdropBrightness") });
}, backdropContrast: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ "backdrop-contrast": (r2) => ({ "--tw-backdrop-contrast": `contrast(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se3 }) }, { values: e2("backdropContrast") });
}, backdropGrayscale: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ "backdrop-grayscale": (r2) => ({ "--tw-backdrop-grayscale": `grayscale(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se3 }) }, { values: e2("backdropGrayscale") });
}, backdropHueRotate: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ "backdrop-hue-rotate": (r2) => ({ "--tw-backdrop-hue-rotate": `hue-rotate(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se3 }) }, { values: e2("backdropHueRotate"), supportsNegativeValues: true });
}, backdropInvert: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ "backdrop-invert": (r2) => ({ "--tw-backdrop-invert": `invert(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se3 }) }, { values: e2("backdropInvert") });
}, backdropOpacity: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ "backdrop-opacity": (r2) => ({ "--tw-backdrop-opacity": `opacity(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se3 }) }, { values: e2("backdropOpacity") });
}, backdropSaturate: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ "backdrop-saturate": (r2) => ({ "--tw-backdrop-saturate": `saturate(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se3 }) }, { values: e2("backdropSaturate") });
}, backdropSepia: ({ matchUtilities: t9, theme: e2 }) => {
  t9({ "backdrop-sepia": (r2) => ({ "--tw-backdrop-sepia": `sepia(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se3 }) }, { values: e2("backdropSepia") });
}, backdropFilter: ({ addDefaults: t9, addUtilities: e2 }) => {
  t9("backdrop-filter", { "--tw-backdrop-blur": " ", "--tw-backdrop-brightness": " ", "--tw-backdrop-contrast": " ", "--tw-backdrop-grayscale": " ", "--tw-backdrop-hue-rotate": " ", "--tw-backdrop-invert": " ", "--tw-backdrop-opacity": " ", "--tw-backdrop-saturate": " ", "--tw-backdrop-sepia": " " }), e2({ ".backdrop-filter": { "@defaults backdrop-filter": {}, "backdrop-filter": Se3 }, ".backdrop-filter-none": { "backdrop-filter": "none" } });
}, transitionProperty: ({ matchUtilities: t9, theme: e2 }) => {
  let r2 = e2("transitionTimingFunction.DEFAULT"), n2 = e2("transitionDuration.DEFAULT");
  t9({ transition: (i) => ({ "transition-property": i, ...i === "none" ? {} : { "transition-timing-function": r2, "transition-duration": n2 } }) }, { values: e2("transitionProperty") });
}, transitionDelay: T3("transitionDelay", [["delay", ["transitionDelay"]]]), transitionDuration: T3("transitionDuration", [["duration", ["transitionDuration"]]], { filterDefault: true }), transitionTimingFunction: T3("transitionTimingFunction", [["ease", ["transitionTimingFunction"]]], { filterDefault: true }), willChange: T3("willChange", [["will-change", ["will-change"]]]), content: T3("content", [["content", ["--tw-content", ["content", "var(--tw-content)"]]]]) };
var xf = new Map([["{", "}"], ["[", "]"], ["(", ")"]]);
var bf = new Map(Array.from(xf.entries()).map(([t9, e2]) => [e2, t9]));
var av = new Set(['"', "'", "`"]);
var dn3 = class {
  constructor() {
    this.offsets = { defaults: 0n, base: 0n, components: 0n, utilities: 0n, variants: 0n, user: 0n }, this.layerPositions = { defaults: 0n, base: 1n, components: 2n, utilities: 3n, user: 4n, variants: 5n }, this.reservedVariantBits = 0n, this.variantOffsets = new Map;
  }
  create(e2) {
    return { layer: e2, parentLayer: e2, arbitrary: 0n, variants: 0n, parallelIndex: 0n, index: this.offsets[e2]++, options: [] };
  }
  arbitraryProperty() {
    return { ...this.create("utilities"), arbitrary: 1n };
  }
  forVariant(e2, r2 = 0) {
    let n2 = this.variantOffsets.get(e2);
    if (n2 === undefined)
      throw new Error(`Cannot find offset for unknown variant ${e2}`);
    return { ...this.create("variants"), variants: n2 << BigInt(r2) };
  }
  applyVariantOffset(e2, r2, n2) {
    return n2.variant = r2.variants, { ...e2, layer: "variants", parentLayer: e2.layer === "variants" ? e2.parentLayer : e2.layer, variants: e2.variants | r2.variants, options: n2.sort ? [].concat(n2, e2.options) : e2.options, parallelIndex: kf([e2.parallelIndex, r2.parallelIndex]) };
  }
  applyParallelOffset(e2, r2) {
    return { ...e2, parallelIndex: BigInt(r2) };
  }
  recordVariants(e2, r2) {
    for (let n2 of e2)
      this.recordVariant(n2, r2(n2));
  }
  recordVariant(e2, r2 = 1) {
    return this.variantOffsets.set(e2, 1n << this.reservedVariantBits), this.reservedVariantBits += BigInt(r2), { ...this.create("variants"), variants: this.variantOffsets.get(e2) };
  }
  compare(e2, r2) {
    var n2;
    if (e2.layer !== r2.layer)
      return this.layerPositions[e2.layer] - this.layerPositions[r2.layer];
    if (e2.parentLayer !== r2.parentLayer)
      return this.layerPositions[e2.parentLayer] - this.layerPositions[r2.parentLayer];
    for (let i of e2.options)
      for (let a of r2.options) {
        if (i.id !== a.id || !i.sort || !a.sort)
          continue;
        let s3 = (n2 = kf([i.variant, a.variant])) != null ? n2 : 0n, o2 = ~(s3 | s3 - 1n), l3 = e2.variants & o2, u = r2.variants & o2;
        if (l3 !== u)
          continue;
        let f = i.sort({ value: i.value, modifier: i.modifier }, { value: a.value, modifier: a.modifier });
        if (f !== 0)
          return f;
      }
    return e2.variants !== r2.variants ? e2.variants - r2.variants : e2.parallelIndex !== r2.parallelIndex ? e2.parallelIndex - r2.parallelIndex : e2.arbitrary !== r2.arbitrary ? e2.arbitrary - r2.arbitrary : e2.index - r2.index;
  }
  recalculateVariantOffsets() {
    let e2 = Array.from(this.variantOffsets.entries()).filter(([i]) => i.startsWith("[")).sort(([i], [a]) => ov(i, a)), r2 = e2.map(([, i]) => i).sort((i, a) => pn3(i - a));
    return e2.map(([, i], a) => [i, r2[a]]).filter(([i, a]) => i !== a);
  }
  remapArbitraryVariantOffsets(e2) {
    let r2 = this.recalculateVariantOffsets();
    return r2.length === 0 ? e2 : e2.map((n2) => {
      let [i, a] = n2;
      return i = { ...i, variants: Sf(i.variants, r2) }, [i, a];
    });
  }
  sort(e2) {
    return e2 = this.remapArbitraryVariantOffsets(e2), e2.sort(([r2], [n2]) => pn3(this.compare(r2, n2)));
  }
};
var Us2 = { AddVariant: Symbol.for("ADD_VARIANT"), MatchVariant: Symbol.for("MATCH_VARIANT") };
var zs2 = { Base: 1 << 0, Dynamic: 1 << 1 };
var Bs2 = H3(ve3());
var gv = (0, wn3.default)((t9) => t9.first.filter(({ type: e2 }) => e2 === "class").pop().value);
var xv = /^[a-z_-]/;
var Df = /[\\^$.*+?()[\]{}|]/g;
var Pv = RegExp(Df.source);
var Dv = /([\[\]'"`])([^\[\]'"`])?/g;
var Mv = /[^"'`\s<>\]]+/;
var Ae3 = Vn3;
var Nf = { DEFAULT: Lf };
var qf = { DEFAULT: (t9) => t9, svelte: (t9) => t9.replace(/(?:^|\s)class:/g, " ") };
var ur3 = new WeakMap;
var kn3 = H3(ve3());
var Uv = (0, kn3.default)();
var fr3 = H3(qs2());
var oc = H3(Bf());
var oa2 = H3(sc());
var iw = { atrule: "params", decl: "value" };
var Tn3 = H3(ve3());
var pc = { id(t9) {
  return Tn3.default.attribute({ attribute: "id", operator: "=", value: t9.value, quoteMark: '"' });
} };
var lw = (0, Tn3.default)((t9) => t9.map((e2) => {
  let r2 = e2.split((n2) => n2.type === "combinator" && n2.value === " ").pop();
  return ow(r2);
}));
var la2 = new Map;
var dc = { atrule: ["name", "params"], rule: ["selector"] };
var fw = new Set(Object.keys(dc));
var cw = Symbol("unitless-number");
var mc = ["preflight", "container", "accessibility", "pointerEvents", "visibility", "position", "inset", "isolation", "zIndex", "order", "gridColumn", "gridColumnStart", "gridColumnEnd", "gridRow", "gridRowStart", "gridRowEnd", "float", "clear", "margin", "boxSizing", "lineClamp", "display", "aspectRatio", "height", "maxHeight", "minHeight", "width", "minWidth", "maxWidth", "flex", "flexShrink", "flexGrow", "flexBasis", "tableLayout", "captionSide", "borderCollapse", "borderSpacing", "transformOrigin", "translate", "rotate", "skew", "scale", "transform", "animation", "cursor", "touchAction", "userSelect", "resize", "scrollSnapType", "scrollSnapAlign", "scrollSnapStop", "scrollMargin", "scrollPadding", "listStylePosition", "listStyleType", "listStyleImage", "appearance", "columns", "breakBefore", "breakInside", "breakAfter", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateColumns", "gridTemplateRows", "flexDirection", "flexWrap", "placeContent", "placeItems", "alignContent", "alignItems", "justifyContent", "justifyItems", "gap", "space", "divideWidth", "divideStyle", "divideColor", "divideOpacity", "placeSelf", "alignSelf", "justifySelf", "overflow", "overscrollBehavior", "scrollBehavior", "textOverflow", "hyphens", "whitespace", "wordBreak", "borderRadius", "borderWidth", "borderStyle", "borderColor", "borderOpacity", "backgroundColor", "backgroundOpacity", "backgroundImage", "gradientColorStops", "boxDecorationBreak", "backgroundSize", "backgroundAttachment", "backgroundClip", "backgroundPosition", "backgroundRepeat", "backgroundOrigin", "fill", "stroke", "strokeWidth", "objectFit", "objectPosition", "padding", "textAlign", "textIndent", "verticalAlign", "fontFamily", "fontSize", "fontWeight", "textTransform", "fontStyle", "fontVariantNumeric", "lineHeight", "letterSpacing", "textColor", "textOpacity", "textDecoration", "textDecorationColor", "textDecorationStyle", "textDecorationThickness", "textUnderlineOffset", "fontSmoothing", "placeholderColor", "placeholderOpacity", "caretColor", "accentColor", "opacity", "backgroundBlendMode", "mixBlendMode", "boxShadow", "boxShadowColor", "outlineStyle", "outlineWidth", "outlineOffset", "outlineColor", "ringWidth", "ringColor", "ringOpacity", "ringOffsetWidth", "ringOffsetColor", "blur", "brightness", "contrast", "dropShadow", "grayscale", "hueRotate", "invert", "saturate", "sepia", "filter", "backdropBlur", "backdropBrightness", "backdropContrast", "backdropGrayscale", "backdropHueRotate", "backdropInvert", "backdropOpacity", "backdropSaturate", "backdropSepia", "backdropFilter", "transitionProperty", "transitionDelay", "transitionDuration", "transitionTimingFunction", "willChange", "content"];
var yc = { inherit: "inherit", current: "currentColor", transparent: "transparent", black: "#000", white: "#fff", slate: { 50: "#f8fafc", 100: "#f1f5f9", 200: "#e2e8f0", 300: "#cbd5e1", 400: "#94a3b8", 500: "#64748b", 600: "#475569", 700: "#334155", 800: "#1e293b", 900: "#0f172a", 950: "#020617" }, gray: { 50: "#f9fafb", 100: "#f3f4f6", 200: "#e5e7eb", 300: "#d1d5db", 400: "#9ca3af", 500: "#6b7280", 600: "#4b5563", 700: "#374151", 800: "#1f2937", 900: "#111827", 950: "#030712" }, zinc: { 50: "#fafafa", 100: "#f4f4f5", 200: "#e4e4e7", 300: "#d4d4d8", 400: "#a1a1aa", 500: "#71717a", 600: "#52525b", 700: "#3f3f46", 800: "#27272a", 900: "#18181b", 950: "#09090b" }, neutral: { 50: "#fafafa", 100: "#f5f5f5", 200: "#e5e5e5", 300: "#d4d4d4", 400: "#a3a3a3", 500: "#737373", 600: "#525252", 700: "#404040", 800: "#262626", 900: "#171717", 950: "#0a0a0a" }, stone: { 50: "#fafaf9", 100: "#f5f5f4", 200: "#e7e5e4", 300: "#d6d3d1", 400: "#a8a29e", 500: "#78716c", 600: "#57534e", 700: "#44403c", 800: "#292524", 900: "#1c1917", 950: "#0c0a09" }, red: { 50: "#fef2f2", 100: "#fee2e2", 200: "#fecaca", 300: "#fca5a5", 400: "#f87171", 500: "#ef4444", 600: "#dc2626", 700: "#b91c1c", 800: "#991b1b", 900: "#7f1d1d", 950: "#450a0a" }, orange: { 50: "#fff7ed", 100: "#ffedd5", 200: "#fed7aa", 300: "#fdba74", 400: "#fb923c", 500: "#f97316", 600: "#ea580c", 700: "#c2410c", 800: "#9a3412", 900: "#7c2d12", 950: "#431407" }, amber: { 50: "#fffbeb", 100: "#fef3c7", 200: "#fde68a", 300: "#fcd34d", 400: "#fbbf24", 500: "#f59e0b", 600: "#d97706", 700: "#b45309", 800: "#92400e", 900: "#78350f", 950: "#451a03" }, yellow: { 50: "#fefce8", 100: "#fef9c3", 200: "#fef08a", 300: "#fde047", 400: "#facc15", 500: "#eab308", 600: "#ca8a04", 700: "#a16207", 800: "#854d0e", 900: "#713f12", 950: "#422006" }, lime: { 50: "#f7fee7", 100: "#ecfccb", 200: "#d9f99d", 300: "#bef264", 400: "#a3e635", 500: "#84cc16", 600: "#65a30d", 700: "#4d7c0f", 800: "#3f6212", 900: "#365314", 950: "#1a2e05" }, green: { 50: "#f0fdf4", 100: "#dcfce7", 200: "#bbf7d0", 300: "#86efac", 400: "#4ade80", 500: "#22c55e", 600: "#16a34a", 700: "#15803d", 800: "#166534", 900: "#14532d", 950: "#052e16" }, emerald: { 50: "#ecfdf5", 100: "#d1fae5", 200: "#a7f3d0", 300: "#6ee7b7", 400: "#34d399", 500: "#10b981", 600: "#059669", 700: "#047857", 800: "#065f46", 900: "#064e3b", 950: "#022c22" }, teal: { 50: "#f0fdfa", 100: "#ccfbf1", 200: "#99f6e4", 300: "#5eead4", 400: "#2dd4bf", 500: "#14b8a6", 600: "#0d9488", 700: "#0f766e", 800: "#115e59", 900: "#134e4a", 950: "#042f2e" }, cyan: { 50: "#ecfeff", 100: "#cffafe", 200: "#a5f3fc", 300: "#67e8f9", 400: "#22d3ee", 500: "#06b6d4", 600: "#0891b2", 700: "#0e7490", 800: "#155e75", 900: "#164e63", 950: "#083344" }, sky: { 50: "#f0f9ff", 100: "#e0f2fe", 200: "#bae6fd", 300: "#7dd3fc", 400: "#38bdf8", 500: "#0ea5e9", 600: "#0284c7", 700: "#0369a1", 800: "#075985", 900: "#0c4a6e", 950: "#082f49" }, blue: { 50: "#eff6ff", 100: "#dbeafe", 200: "#bfdbfe", 300: "#93c5fd", 400: "#60a5fa", 500: "#3b82f6", 600: "#2563eb", 700: "#1d4ed8", 800: "#1e40af", 900: "#1e3a8a", 950: "#172554" }, indigo: { 50: "#eef2ff", 100: "#e0e7ff", 200: "#c7d2fe", 300: "#a5b4fc", 400: "#818cf8", 500: "#6366f1", 600: "#4f46e5", 700: "#4338ca", 800: "#3730a3", 900: "#312e81", 950: "#1e1b4b" }, violet: { 50: "#f5f3ff", 100: "#ede9fe", 200: "#ddd6fe", 300: "#c4b5fd", 400: "#a78bfa", 500: "#8b5cf6", 600: "#7c3aed", 700: "#6d28d9", 800: "#5b21b6", 900: "#4c1d95", 950: "#2e1065" }, purple: { 50: "#faf5ff", 100: "#f3e8ff", 200: "#e9d5ff", 300: "#d8b4fe", 400: "#c084fc", 500: "#a855f7", 600: "#9333ea", 700: "#7e22ce", 800: "#6b21a8", 900: "#581c87", 950: "#3b0764" }, fuchsia: { 50: "#fdf4ff", 100: "#fae8ff", 200: "#f5d0fe", 300: "#f0abfc", 400: "#e879f9", 500: "#d946ef", 600: "#c026d3", 700: "#a21caf", 800: "#86198f", 900: "#701a75", 950: "#4a044e" }, pink: { 50: "#fdf2f8", 100: "#fce7f3", 200: "#fbcfe8", 300: "#f9a8d4", 400: "#f472b6", 500: "#ec4899", 600: "#db2777", 700: "#be185d", 800: "#9d174d", 900: "#831843", 950: "#500724" }, rose: { 50: "#fff1f2", 100: "#ffe4e6", 200: "#fecdd3", 300: "#fda4af", 400: "#fb7185", 500: "#f43f5e", 600: "#e11d48", 700: "#be123c", 800: "#9f1239", 900: "#881337", 950: "#4c0519" }, get lightBlue() {
  return cr3({ version: "v2.2", from: "lightBlue", to: "sky" }), this.sky;
}, get warmGray() {
  return cr3({ version: "v3.0", from: "warmGray", to: "stone" }), this.stone;
}, get trueGray() {
  return cr3({ version: "v3.0", from: "trueGray", to: "neutral" }), this.neutral;
}, get coolGray() {
  return cr3({ version: "v3.0", from: "coolGray", to: "gray" }), this.gray;
}, get blueGray() {
  return cr3({ version: "v3.0", from: "blueGray", to: "slate" }), this.slate;
} };
var ha2 = { colors: yc, negative(t9) {
  return Object.keys(t9).filter((e2) => t9[e2] !== "0").reduce((e2, r2) => {
    let n2 = Re3(t9[r2]);
    return n2 !== undefined && (e2[`-${r2}`] = n2), e2;
  }, {});
}, breakpoints(t9) {
  return Object.keys(t9).filter((e2) => typeof t9[e2] == "string").reduce((e2, r2) => ({ ...e2, [`screen-${r2}`]: t9[r2] }), {});
} };
var kc = H3(Sc());
var Oc = (t9) => {
  var n2;
  let e2 = ga2((n2 = t9.config) != null ? n2 : {});
  return pa2((i) => () => i.createContext(e2, [{ content: t9.content }]));
};
var wp = H3(vp(), 1);
var bp = (t9) => {
  let e2 = Oc({ config: t9.config, content: t9.content });
  return R3([e2, (0, wp.default)()]).process(xp, { from: undefined }).css;
};
var xp = String.raw`
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
`;
var sb = (t9, e2) => {
  var i, a;
  let r2 = (a = (i = e2 == null ? undefined : e2.corePlugins) == null ? undefined : i.preflight) != null ? a : false, n2 = (e2 == null ? undefined : e2.corePlugins) || {};
  return bp({ config: { ...e2, corePlugins: { ...n2, preflight: r2 } }, content: t9 });
};
var Op = ({ config: t9, options: e2 }) => ({ twi: Ea2(t9, e2), twj: Cp(t9, e2) });
var Ep = (...t9) => {
  let e2 = "";
  return typeof t9[0] == "string" ? e2 = t9[0] : Array.isArray(t9[0]) ? e2 = t9.flat(1 / 0).map((r2) => Ep(r2)).join(" ") : typeof t9[0] == "object" && (e2 = Object.entries(t9[0]).filter((r2) => !!r2[1]).map((r2) => r2[0]).join(" ")), e2 = e2.replace(/\s+/g, " "), e2;
};
var Ea2 = (t9, e2) => (...r2) => {
  let n2 = Ep(r2), { 1: i } = r2 || {}, s3 = { ...{ merge: true, minify: true, ignoreMediaQueries: true }, ...e2, ...i }, o2 = Ra2(sb(n2, t9));
  return s3 != null && s3.ignoreMediaQueries ? o2.removeMediaQueries() : (o2.removeUndefined(), o2.combineMediaQueries()), o2.fixRGB(), s3 != null && s3.merge && o2.merge(), s3 != null && s3.minify && o2.minify(), o2.get();
};
var Cp = (t9, e2) => (...r2) => kp(Ea2(t9, e2)(r2));
var Sp = Ea2();
var ab2 = Cp();
/*! https://mths.be/cssesc v3.0.0 by @mathias */

// node_modules/@react-email/tailwind/dist/index.mjs
var jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
function processElement(element, headStyles, twi) {
  let modifiedElement = element;
  if (modifiedElement.props.className) {
    const convertedStyles = [];
    const responsiveStyles = [];
    const classNames = modifiedElement.props.className.split(" ");
    const customClassNames = classNames.filter((className) => {
      const tailwindClassName = twi(className, { ignoreMediaQueries: true });
      if (tailwindClassName) {
        convertedStyles.push(tailwindClassName);
        return false;
      } else if (twi(className, { ignoreMediaQueries: false })) {
        responsiveStyles.push(className);
        return false;
      }
      return true;
    });
    const convertedResponsiveStyles = twi(responsiveStyles, {
      ignoreMediaQueries: false,
      merge: false
    });
    headStyles.push(convertedResponsiveStyles.replace(/^\n+/, "").replace(/\n+$/, ""));
    modifiedElement = React2.cloneElement(modifiedElement, __spreadProps12(__spreadValues12({}, modifiedElement.props), {
      className: customClassNames.length ? customClassNames.join(" ") : undefined,
      style: __spreadValues12(__spreadValues12({}, modifiedElement.props.style), cssToJsxStyle(convertedStyles.join(" ")))
    }));
  }
  if (modifiedElement.props.children) {
    const children = React2.Children.toArray(modifiedElement.props.children);
    const processedChildren = children.map((child) => {
      if (React2.isValidElement(child)) {
        return processElement(child, headStyles, twi);
      }
      return child;
    });
    modifiedElement = React2.cloneElement(modifiedElement, modifiedElement.props, ...processedChildren);
  }
  return modifiedElement;
}
function processHead(child, responsiveStyles) {
  let modifiedChild = child;
  if (modifiedChild.type === "head" || modifiedChild.type.displayName === "Head") {
    const styleElement = /* @__PURE__ */ jsx_runtime12.jsx("style", { children: responsiveStyles });
    const headChildren = React2.Children.toArray(modifiedChild.props.children);
    headChildren.push(styleElement);
    modifiedChild = React2.cloneElement(modifiedChild, modifiedChild.props, ...headChildren);
  }
  if (modifiedChild.props.children) {
    const children = React2.Children.toArray(modifiedChild.props.children);
    const processedChildren = children.map((processedChild) => {
      if (React2.isValidElement(processedChild)) {
        return processHead(processedChild, responsiveStyles);
      }
      return processedChild;
    });
    modifiedChild = React2.cloneElement(modifiedChild, modifiedChild.props, ...processedChildren);
  }
  return modifiedChild;
}
var __defProp13 = Object.defineProperty;
var __defProps12 = Object.defineProperties;
var __getOwnPropDescs12 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols12 = Object.getOwnPropertySymbols;
var __hasOwnProp13 = Object.prototype.hasOwnProperty;
var __propIsEnum12 = Object.prototype.propertyIsEnumerable;
var __defNormalProp12 = (obj, key, value) => (key in obj) ? __defProp13(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues12 = (a, b4) => {
  for (var prop in b4 || (b4 = {}))
    if (__hasOwnProp13.call(b4, prop))
      __defNormalProp12(a, prop, b4[prop]);
  if (__getOwnPropSymbols12)
    for (var prop of __getOwnPropSymbols12(b4)) {
      if (__propIsEnum12.call(b4, prop))
        __defNormalProp12(a, prop, b4[prop]);
    }
  return a;
};
var __spreadProps12 = (a, b4) => __defProps12(a, __getOwnPropDescs12(b4));
var camelCase = (string) => string.replace(/-(\w|$)/g, (_3, p1) => p1.toUpperCase());
var convertPropertyName = (prop) => {
  let modifiedProp = prop;
  modifiedProp = modifiedProp.toLowerCase();
  if (modifiedProp === "float") {
    return "cssFloat";
  }
  if (modifiedProp.startsWith("--")) {
    return modifiedProp;
  }
  if (modifiedProp.startsWith("-ms-")) {
    modifiedProp = modifiedProp.substr(1);
  }
  return camelCase(modifiedProp);
};
var splitDeclarations = (cssText) => {
  const declarations = [];
  let capturing;
  let i = cssText.length;
  let last = i;
  while (i-- > -1) {
    if ((cssText[i] === '"' || cssText[i] === "'") && cssText[i - 1] !== "\\") {
      if (!capturing) {
        capturing = cssText[i];
      } else if (cssText[i] === capturing) {
        capturing = false;
      }
    }
    if (!capturing && cssText[i] === ")") {
      capturing = cssText[i];
    }
    if (cssText[i] === "(" && capturing === ")") {
      capturing = false;
    }
    if (i < 0 || !capturing && cssText[i] === ";") {
      declarations.unshift(cssText.slice(i + 1, last));
      last = i;
    }
  }
  return declarations;
};
var splitDeclaration = (declaration) => {
  const i = declaration.indexOf(":");
  return [declaration.substr(0, i).trim(), declaration.substr(i + 1).trim()];
};
var cssToJsxStyle = (cssText) => splitDeclarations(cssText).map(splitDeclaration).reduce((styles, [name2, value]) => {
  if (name2 && value) {
    styles[convertPropertyName(name2)] = value;
  }
  return styles;
}, {});
var Tailwind = ({ children, config }) => {
  const headStyles = [];
  const { twi } = Op({
    config
  });
  const childrenWithInlineStyles = React2.Children.map(children, (child) => {
    if (React2.isValidElement(child)) {
      return processElement(child, headStyles, twi);
    }
    return child;
  });
  if (!childrenWithInlineStyles)
    return /* @__PURE__ */ jsx_runtime12.jsx(jsx_runtime12.Fragment, { children });
  const fullHTML = $renderToStaticMarkup(/* @__PURE__ */ jsx_runtime12.jsx(jsx_runtime12.Fragment, { children: childrenWithInlineStyles }));
  const hasResponsiveStyles = new RegExp("@media[^{]+\\{(?<content>[\\s\\S]+?)\\}\\s*\\}", "gm").test(headStyles.join(" "));
  const hasHTMLAndHead = /<html[^>]*>(?=[\s\S]*<head[^>]*>)/gm.test(fullHTML);
  if (hasResponsiveStyles && !hasHTMLAndHead) {
    throw new Error("Tailwind: To use responsive styles you must have a <html> and <head> element in your template.");
  }
  const childrenWithInlineAndResponsiveStyles = React2.Children.map(childrenWithInlineStyles, (child) => {
    if (React2.isValidElement(child)) {
      return processHead(child, headStyles);
    }
    return child;
  });
  return /* @__PURE__ */ jsx_runtime12.jsx(jsx_runtime12.Fragment, { children: childrenWithInlineAndResponsiveStyles });
};

// node_modules/@react-email/text/dist/index.mjs
var jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var __defProp14 = Object.defineProperty;
var __defProps13 = Object.defineProperties;
var __getOwnPropDescs13 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols13 = Object.getOwnPropertySymbols;
var __hasOwnProp14 = Object.prototype.hasOwnProperty;
var __propIsEnum13 = Object.prototype.propertyIsEnumerable;
var __defNormalProp13 = (obj, key, value) => (key in obj) ? __defProp14(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues13 = (a, b4) => {
  for (var prop in b4 || (b4 = {}))
    if (__hasOwnProp14.call(b4, prop))
      __defNormalProp13(a, prop, b4[prop]);
  if (__getOwnPropSymbols13)
    for (var prop of __getOwnPropSymbols13(b4)) {
      if (__propIsEnum13.call(b4, prop))
        __defNormalProp13(a, prop, b4[prop]);
    }
  return a;
};
var __spreadProps13 = (a, b4) => __defProps13(a, __getOwnPropDescs13(b4));
var __objRest11 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp14.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols13)
    for (var prop of __getOwnPropSymbols13(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum13.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Text3 = (_a3) => {
  var _b = _a3, { style } = _b, props = __objRest11(_b, ["style"]);
  return /* @__PURE__ */ jsx_runtime13.jsx("p", __spreadProps13(__spreadValues13({}, props), {
    style: __spreadValues13({
      fontSize: "14px",
      lineHeight: "24px",
      margin: "16px 0"
    }, style)
  }));
};

// src/mail/templates/authentication-magic-link.tsx
var jsx_dev_runtime = __toESM(require_jsx_dev_runtime(), 1);
function AuthenticationMagicLinkTemplate({
  userEmail,
  authLink,
  appName = "Pizza Shop",
  expiresInMinutes = 15
}) {
  const previewText = `Fa\xE7a login na ${appName}`;
  return /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Html, {
    children: [
      /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Head, {}, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Preview, {
        children: previewText
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Tailwind, {
        children: /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Body, {
          className: "bg-white my-auto mx-auto font-sans",
          children: /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Container, {
            className: "border border-solid border-[#eaeaea] rounded my-[40px] mx-auto p-[20px] w-[465px]",
            children: [
              /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Section, {
                className: "mt-[32px] text-center",
                children: /* @__PURE__ */ jsx_dev_runtime.jsxDEV("span", {
                  className: "text-2xl",
                  children: "\uD83C\uDF55"
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Heading, {
                className: "text-black text-[24px] font-normal text-center p-0 my-[30px] mx-0",
                children: [
                  "Fa\xE7a login na ",
                  appName
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Text3, {
                className: "text-black text-[14px] leading-[24px]",
                children: [
                  "Voc\xEA solicitou um link para login na ",
                  appName,
                  " atrav\xE9s do e-mail",
                  " ",
                  /* @__PURE__ */ jsx_dev_runtime.jsxDEV("strong", {
                    children: userEmail
                  }, undefined, false, undefined, this),
                  "."
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Text3, {
                className: "text-black text-[14px] leading-[24px]",
                children: [
                  "Este link expira em ",
                  /* @__PURE__ */ jsx_dev_runtime.jsxDEV("strong", {
                    children: [
                      expiresInMinutes,
                      " minuto(s)"
                    ]
                  }, undefined, true, undefined, this),
                  "."
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Section, {
                className: "text-center mt-[32px] mb-[32px]",
                children: /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Button, {
                  className: "bg-sky-500 rounded text-white px-5 py-3 text-[12px] font-semibold no-underline text-center",
                  href: authLink,
                  children: "Entrar agora"
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Text3, {
                className: "text-black text-[14px] leading-[24px]",
                children: [
                  "ou copie a URL abaixo e cole em seu navegador:",
                  " ",
                  /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Link, {
                    href: authLink,
                    className: "text-sky-500 no-underline break-all",
                    children: authLink
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Hr2, {
                className: "border border-solid border-[#eaeaea] my-[26px] mx-0 w-full"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Text3, {
                className: "text-[#666666] text-[12px] leading-[24px]",
                children: "Se voc\xEA n\xE3o solicitou esse link de autentica\xE7\xE3o, apenas descarte este e-mail."
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}

// src/http/routes/send-authentication-link.tsx
var sendAuthenticationLink = new import_elysia3.default().post("/authenticate", async ({ body }) => {
  const { email } = body;
  const userFromEmail = await db3.query.users.findFirst({
    where(fields, { eq: eq2 }) {
      return eq2(fields.email, email);
    }
  });
  if (!userFromEmail) {
    throw new UnauthorizedError;
  }
  const authLinkCode = $createId();
  await db3.insert(authLinks).values({
    userId: userFromEmail.id,
    code: authLinkCode,
    expiresAt: new Date(Date.now() + minutes(15))
  });
  const authLink = new URL("/auth-links/authenticate", env.API_BASE_URL);
  authLink.searchParams.set("code", authLinkCode);
  authLink.searchParams.set("redirect", env.AUTH_REDIRECT_URL);
  console.log("Magic link:", authLink.toString());
  const html = await render2(AuthenticationMagicLinkTemplate({
    userEmail: email,
    authLink: authLink.toString(),
    appName: "Pizza Shop",
    expiresInMinutes: 15
  }));
  const text2 = await render2(AuthenticationMagicLinkTemplate({
    userEmail: email,
    authLink: authLink.toString(),
    appName: "Pizza Shop",
    expiresInMinutes: 15
  }), { plainText: true });
  await transporter.sendMail({
    from: `"Pizza Shop" <${env.SMTP_USER}>`,
    to: email,
    subject: "[Pizza Shop] Seu link de acesso",
    html,
    text: text2
  });
  return { message: "E-mail enviado (verifique sua caixa de entrada)" };
}, {
  body: import_elysia3.t.Object({
    email: import_elysia3.t.String({ format: "email" })
  })
});

// src/http/routes/create-order.ts
var import_elysia5 = __toESM(require_cjs2(), 1);

// src/http/authentication.ts
var import_elysia4 = __toESM(require_cjs2(), 1);
var cookie = __toESM(require_cjs5(), 1);
var jwt = __toESM(require_cjs7(), 1);

// src/http/routes/errors/not-a-manager-error.ts
class NotAManagerError extends Error {
  constructor() {
    super("User is not a restaurant manager.");
  }
}

// src/http/authentication.ts
var jwtPayloadSchema = import_elysia4.t.Object({
  sub: import_elysia4.t.String(),
  restaurantId: import_elysia4.t.Optional(import_elysia4.t.String())
});
var authentication = new import_elysia4.default().error({
  UNAUTHORIZED: UnauthorizedError,
  NOT_A_MANAGER: NotAManagerError
}).onError(({ code, error, set }) => {
  switch (code) {
    case "UNAUTHORIZED":
      set.status = 401;
      return { code, message: error.message };
    case "NOT_A_MANAGER":
      set.status = 401;
      return { code, message: error.message };
  }
}).use(jwt.default({
  name: "jwt",
  secret: env.JWT_SECRET_KEY,
  schema: jwtPayloadSchema
})).use(cookie.default()).derive(({ jwt: jwt3, cookie: cookie3, setCookie, removeCookie }) => {
  return {
    getCurrentUser: async () => {
      const payload = await jwt3.verify(cookie3.auth);
      if (!payload) {
        throw new UnauthorizedError;
      }
      return payload;
    },
    signUser: async (payload) => {
      setCookie("auth", await jwt3.sign(payload), {
        httpOnly: true,
        maxAge: 7 * 86400,
        path: "/"
      });
    },
    signOut: () => {
      removeCookie("auth");
    }
  };
}).derive(({ getCurrentUser }) => {
  return {
    getManagedRestaurantId: async () => {
      const { restaurantId } = await getCurrentUser();
      if (!restaurantId) {
        throw new NotAManagerError;
      }
      return restaurantId;
    }
  };
});

// src/http/routes/create-order.ts
var createOrder = new import_elysia5.default().use(authentication).post("/restaurants/:restaurantId/orders", async ({ params, body, getCurrentUser, set }) => {
  const { sub: customerId } = await getCurrentUser();
  const { restaurantId } = params;
  const { items } = body;
  const productsIds = items.map((item) => item.productId);
  const products3 = await db3.query.products.findMany({
    where(fields, { eq: eq2, and: and2, inArray: inArray2 }) {
      return and2(eq2(fields.restaurantId, restaurantId), inArray2(fields.id, productsIds));
    }
  });
  const orderProducts = items.map((item) => {
    const product = products3.find((product2) => product2.id === item.productId);
    if (!product) {
      throw new Error("Not all products are available in this restaurant.");
    }
    return {
      productId: item.productId,
      unitPriceInCents: product.priceInCents,
      quantity: item.quantity,
      subtotalInCents: item.quantity * product.priceInCents
    };
  });
  const totalInCents = orderProducts.reduce((total, orderItem) => {
    return total + orderItem.subtotalInCents;
  }, 0);
  await db3.transaction(async (tx2) => {
    const [order] = await tx2.insert(orders).values({
      totalInCents,
      customerId,
      restaurantId
    }).returning({
      id: orders.id
    });
    await tx2.insert(orderItems).values(orderProducts.map((orderProduct) => {
      return {
        orderId: order.id,
        productId: orderProduct.productId,
        priceInCents: orderProduct.unitPriceInCents,
        quantity: orderProduct.quantity
      };
    }));
  });
  set.status = 201;
}, {
  body: import_elysia5.t.Object({
    items: import_elysia5.t.Array(import_elysia5.t.Object({
      productId: import_elysia5.t.String(),
      quantity: import_elysia5.t.Integer()
    }))
  }),
  params: import_elysia5.t.Object({
    restaurantId: import_elysia5.t.String()
  })
});

// src/http/routes/approve-order.ts
var import_elysia6 = __toESM(require_cjs2(), 1);
var approveOrder = new import_elysia6.default().use(authentication).patch("/orders/:id/approve", async ({ getManagedRestaurantId, set, params }) => {
  const { id: orderId } = params;
  const restaurantId = await getManagedRestaurantId();
  const order = await db3.query.orders.findFirst({
    where(fields, { eq: eq2, and: and2 }) {
      return and2(eq2(fields.id, orderId), eq2(fields.restaurantId, restaurantId));
    }
  });
  if (!order) {
    throw new UnauthorizedError;
  }
  if (order.status !== "pending") {
    set.status = 400;
    return { message: "Order was already approved before." };
  }
  await db3.update(orders).set({
    status: "processing"
  }).where(eq(orders.id, orderId));
  set.status = 204;
}, {
  params: import_elysia6.t.Object({
    id: import_elysia6.t.String()
  })
});

// src/http/routes/cancel-order.ts
var import_elysia7 = __toESM(require_cjs2(), 1);
var cancelOrder = new import_elysia7.default().use(authentication).patch("/orders/:id/cancel", async ({ getCurrentUser, set, params }) => {
  const { id: orderId } = params;
  const { restaurantId } = await getCurrentUser();
  if (!restaurantId) {
    set.status = 401;
    throw new Error("User is not a restaurant manager.");
  }
  const order = await db3.query.orders.findFirst({
    where(fields, { eq: eq2, and: and2 }) {
      return and2(eq2(fields.id, orderId), eq2(fields.restaurantId, restaurantId));
    }
  });
  if (!order) {
    set.status = 401;
    throw new Error("Order not found under the user managed restaurant.");
  }
  if (!["pending", "processing"].includes(order.status)) {
    set.status = 400;
    return {
      code: "STATUS_NOT_VALID",
      message: "O pedido n\xE3o pode ser cancelado depois de ser enviado."
    };
  }
  await db3.update(orders).set({
    status: "canceled"
  }).where(eq(orders.id, orderId));
  set.status = 204;
}, {
  params: import_elysia7.t.Object({
    id: import_elysia7.t.String()
  })
});

// src/http/routes/get-orders.ts
var import_elysia8 = __toESM(require_cjs2(), 1);

// node_modules/drizzle-typebox/index.mjs
var typebox = __toESM(require_typebox(), 1);

// node_modules/drizzle-orm/mysql-core/table.js
var InlineForeignKeys2 = Symbol.for("drizzle:MySqlInlineForeignKeys");

class MySqlTable extends Table {
  static [entityKind] = "MySqlTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys: InlineForeignKeys2
  });
  [Table.Symbol.Columns];
  [InlineForeignKeys2] = [];
  [Table.Symbol.ExtraConfigBuilder] = undefined;
}

// node_modules/drizzle-orm/mysql-core/unique-constraint.js
function uniqueKeyName2(table18, columns2) {
  return `${table18[MySqlTable.Symbol.Name]}_${columns2.join("_")}_unique`;
}

// node_modules/drizzle-orm/mysql-core/columns/common.js
class MySqlColumn extends Column {
  constructor(table18, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName2(table18, [config.name]);
    }
    super(table18, config);
    this.table = table18;
  }
  static [entityKind] = "MySqlColumn";
}
class MySqlColumnWithAutoIncrement extends MySqlColumn {
  static [entityKind] = "MySqlColumnWithAutoIncrement";
  autoIncrement = this.config.autoIncrement;
}

// node_modules/drizzle-orm/mysql-core/columns/char.js
class MySqlChar extends MySqlColumn {
  static [entityKind] = "MySqlChar";
  length = this.config.length;
  enumValues = this.config.enum;
  getSQLType() {
    return this.length === undefined ? `char` : `char(${this.length})`;
  }
}

// node_modules/drizzle-orm/mysql-core/columns/varbinary.js
class MySqlVarBinary extends MySqlColumn {
  static [entityKind] = "MySqlVarBinary";
  length = this.config.length;
  getSQLType() {
    return this.length === undefined ? `varbinary` : `varbinary(${this.length})`;
  }
}

// node_modules/drizzle-orm/mysql-core/columns/varchar.js
class MySqlVarChar extends MySqlColumn {
  static [entityKind] = "MySqlVarChar";
  length = this.config.length;
  enumValues = this.config.enum;
  getSQLType() {
    return this.length === undefined ? `varchar` : `varchar(${this.length})`;
  }
}

// node_modules/drizzle-orm/sqlite-core/table.js
var InlineForeignKeys3 = Symbol.for("drizzle:SQLiteInlineForeignKeys");

class SQLiteTable extends Table {
  static [entityKind] = "SQLiteTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys: InlineForeignKeys3
  });
  [Table.Symbol.Columns];
  [InlineForeignKeys3] = [];
  [Table.Symbol.ExtraConfigBuilder] = undefined;
}

// node_modules/drizzle-orm/sqlite-core/unique-constraint.js
function uniqueKeyName3(table20, columns2) {
  return `${table20[SQLiteTable.Symbol.Name]}_${columns2.join("_")}_unique`;
}

// node_modules/drizzle-orm/sqlite-core/columns/common.js
class SQLiteColumn extends Column {
  constructor(table20, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName3(table20, [config.name]);
    }
    super(table20, config);
    this.table = table20;
  }
  static [entityKind] = "SQLiteColumn";
}

// node_modules/drizzle-orm/sqlite-core/columns/text.js
class SQLiteText extends SQLiteColumn {
  static [entityKind] = "SQLiteText";
  enumValues = this.config.enumValues;
  length = this.config.length;
  constructor(table20, config) {
    super(table20, config);
  }
  getSQLType() {
    return `text${this.config.length ? `(${this.config.length})` : ""}`;
  }
}

// node_modules/drizzle-typebox/index.mjs
function y2(n2, r2) {
  const o2 = getTableColumns(n2), i = Object.entries(o2);
  let a = Object.fromEntries(i.map(([e3, t14]) => [e3, d2(t14)]));
  r2 && (a = Object.assign(a, Object.fromEntries(Object.entries(r2).map(([e3, t14]) => [e3, typeof t14 == "function" ? t14(a) : t14]))));
  for (const [e3, t14] of i)
    t14.notNull || (a[e3] = u(a[e3]));
  return typebox.Type.Object(a);
}
function d2(t14) {
  let f;
  if (function(e3) {
    return "enumValues" in e3 && Array.isArray(e3.enumValues) && e3.enumValues.length > 0;
  }(t14) && (f = t14.enumValues?.length ? typebox.Type.Union(t14.enumValues.map((t15) => typebox.Type.Literal(t15))) : typebox.Type.String()), !f)
    if (t14.dataType === "custom")
      f = typebox.Type.Any();
    else if (t14.dataType === "json")
      f = c2;
    else if (t14.dataType === "array")
      f = typebox.Type.Array(d2(t14.baseColumn));
    else if (t14.dataType === "number")
      f = typebox.Type.Number();
    else if (t14.dataType === "bigint")
      f = typebox.Type.BigInt();
    else if (t14.dataType === "boolean")
      f = typebox.Type.Boolean();
    else if (t14.dataType === "date")
      f = typebox.Type.Date();
    else if (t14.dataType === "string") {
      const s3 = typebox.Type.String();
      (is(t14, PgChar) || is(t14, PgVarchar) || is(t14, MySqlVarChar) || is(t14, MySqlVarBinary) || is(t14, MySqlChar) || is(t14, SQLiteText)) && typeof t14.length == "number" && (s3.maxLength = t14.length), f = s3;
    } else
      is(t14, PgUUID) && (f = typebox.Type.RegEx(b4));
  return f || (f = typebox.Type.Any()), f;
}
var f = typebox.Type.Union([typebox.Type.String(), typebox.Type.Number(), typebox.Type.Boolean(), typebox.Type.Null()]);
var c2 = typebox.Type.Union([f, typebox.Type.Array(typebox.Type.Any()), typebox.Type.Record(typebox.Type.String(), typebox.Type.Any())]);
var u = (t14) => typebox.Type.Union([t14, typebox.Type.Null()]);
var b4 = /^[\dA-Fa-f]{8}(?:-[\dA-Fa-f]{4}){3}-[\dA-Fa-f]{12}$/;

// src/http/routes/get-orders.ts
var getOrders = new import_elysia8.default().use(authentication).get("/orders", async ({ query: query5, getCurrentUser, set }) => {
  const { pageIndex, orderId, customerName, status } = query5;
  const { restaurantId } = await getCurrentUser();
  if (!restaurantId) {
    set.status = 401;
    throw new Error("User is not a restaurant manager.");
  }
  const baseQuery = db3.select({
    orderId: orders.id,
    createdAt: orders.createdAt,
    status: orders.status,
    customerName: users.name,
    total: orders.totalInCents
  }).from(orders).innerJoin(users, eq(users.id, orders.customerId)).where(and(eq(orders.restaurantId, restaurantId), orderId ? ilike(orders.id, `%${orderId}%`) : undefined, status ? eq(orders.status, status) : undefined, customerName ? ilike(users.name, `%${customerName}%`) : undefined));
  const [ordersCount] = await db3.select({ count: count() }).from(baseQuery.as("baseQuery"));
  const allOrders = await baseQuery.offset(pageIndex * 10).limit(10).orderBy((fields) => {
    return [
      sql2`CASE ${fields.status} 
            WHEN 'pending' THEN 1
            WHEN 'processing' THEN 2
            WHEN 'delivering' THEN 3
            WHEN 'delivered' THEN 4
            WHEN 'canceled' THEN 99
          END`,
      desc(fields.createdAt)
    ];
  });
  const result2 = {
    orders: allOrders,
    meta: {
      pageIndex,
      perPage: 10,
      totalCount: ordersCount.count
    }
  };
  return result2;
}, {
  query: import_elysia8.t.Object({
    customerName: import_elysia8.t.Optional(import_elysia8.t.String()),
    orderId: import_elysia8.t.Optional(import_elysia8.t.String()),
    status: import_elysia8.t.Optional(y2(orders).properties.status),
    pageIndex: import_elysia8.t.Numeric({ minimum: 0 })
  })
});

// src/http/routes/create-evaluation.ts
var import_elysia9 = __toESM(require_cjs2(), 1);
var createEvaluation = new import_elysia9.default().use(authentication).post("/evaluations", async ({ body, getCurrentUser, set }) => {
  const { sub: userId } = await getCurrentUser();
  const { restaurantId, rate, comment } = body;
  await db3.insert(evaluations).values({
    restaurantId,
    customerId: userId,
    rate,
    comment
  });
  set.status = 201;
}, {
  body: import_elysia9.t.Object({
    restaurantId: import_elysia9.t.String(),
    rate: import_elysia9.t.Integer({ minimum: 1, maximum: 5 }),
    comment: import_elysia9.t.Optional(import_elysia9.t.String())
  })
});

// src/http/routes/get-evaluations.ts
var import_elysia10 = __toESM(require_cjs2(), 1);
var getEvaluations = new import_elysia10.default().use(authentication).get("/evaluations", async ({ query: query5, set, getCurrentUser }) => {
  const { restaurantId } = await getCurrentUser();
  if (!restaurantId) {
    set.status = 401;
    throw new Error("User is not a restaurant manager.");
  }
  const { pageIndex } = z.object({
    pageIndex: z.coerce.number().default(0)
  }).parse(query5);
  const evaluations3 = await db3.query.evaluations.findMany({
    offset: pageIndex * 10,
    limit: 10,
    orderBy: (evaluations4, { desc: desc2 }) => desc2(evaluations4.createdAt)
  });
  return evaluations3;
}, {
  query: import_elysia10.t.Object({
    pageIndex: import_elysia10.t.Numeric({ minimum: 0 })
  })
});

// src/http/routes/update-menu.ts
var import_elysia11 = __toESM(require_cjs2(), 1);
var productSchema = import_elysia11.t.Object({
  id: import_elysia11.t.Optional(import_elysia11.t.String()),
  name: import_elysia11.t.String(),
  description: import_elysia11.t.Optional(import_elysia11.t.String()),
  price: import_elysia11.t.Number({ minimum: 0 })
});
var updateMenu = new import_elysia11.default().use(authentication).put("/menu", async ({ getManagedRestaurantId, set, body }) => {
  const restaurantId = await getManagedRestaurantId();
  const {
    products: { deletedProductIds, newOrUpdatedProducts }
  } = body;
  if (deletedProductIds.length > 0) {
    await db3.delete(products).where(and(inArray(products.id, deletedProductIds), eq(products.restaurantId, restaurantId)));
  }
  const updatedProducts = newOrUpdatedProducts.filter((product) => {
    return !!product.id;
  });
  if (updatedProducts.length > 0) {
    await Promise.all(updatedProducts.map((product) => {
      return db3.update(products).set({
        name: product.name,
        description: product.description,
        priceInCents: product.price * 100
      }).where(and(eq(products.id, product.id), eq(products.restaurantId, restaurantId)));
    }));
  }
  const newProducts = newOrUpdatedProducts.filter((product) => {
    return !product.id;
  });
  if (newProducts.length) {
    await db3.insert(products).values(newProducts.map((product) => {
      return {
        name: product.name,
        description: product.description,
        priceInCents: product.price * 100,
        restaurantId
      };
    }));
  }
  set.status = 204;
}, {
  body: import_elysia11.t.Object({
    products: import_elysia11.t.Object({
      newOrUpdatedProducts: import_elysia11.t.Array(productSchema),
      deletedProductIds: import_elysia11.t.Array(import_elysia11.t.String())
    })
  })
});

// src/http/routes/update-profile.ts
var import_elysia12 = __toESM(require_cjs2(), 1);
var updateProfile = new import_elysia12.default().use(authentication).put("/profile", async ({ getManagedRestaurantId, set, body }) => {
  const restaurantId = await getManagedRestaurantId();
  const { name: name2, description } = body;
  await db3.update(restaurants).set({
    name: name2,
    description
  }).where(eq(restaurants.id, restaurantId));
  set.status = 204;
}, {
  body: import_elysia12.t.Object({
    name: import_elysia12.t.String(),
    description: import_elysia12.t.Optional(import_elysia12.t.String())
  })
});

// src/http/routes/get-profile.ts
var import_elysia13 = __toESM(require_cjs2(), 1);
var getProfile = new import_elysia13.default().use(authentication).get("/me", async ({ getCurrentUser }) => {
  const { sub: userId } = await getCurrentUser();
  const user = await db3.query.users.findFirst({
    where(fields, { eq: eq2 }) {
      return eq2(fields.id, userId);
    }
  });
  if (!user) {
    throw new Error("User not found.");
  }
  return user;
});

// src/http/routes/authenticate-from-link.ts
var import_elysia14 = __toESM(require_cjs2(), 1);
var import_dayjs = __toESM(require_dayjs_min(), 1);
var authenticateFromLink = new import_elysia14.default().use(authentication).get("/auth-links/authenticate", async ({ signUser, query: query5, set }) => {
  const { code, redirect } = query5;
  const authLinkFromCode = await db3.query.authLinks.findFirst({
    where(fields, { eq: eq2 }) {
      return eq2(fields.code, code);
    }
  });
  if (!authLinkFromCode) {
    throw new UnauthorizedError;
  }
  if (import_dayjs.default().diff(authLinkFromCode.createdAt, "days") > 7) {
    throw new UnauthorizedError;
  }
  const managedRestaurant = await db3.query.restaurants.findFirst({
    where(fields, { eq: eq2 }) {
      return eq2(fields.managerId, authLinkFromCode.userId);
    }
  });
  await signUser({
    sub: authLinkFromCode.userId,
    restaurantId: managedRestaurant?.id
  });
  await db3.delete(authLinks).where(eq(authLinks.code, code));
  set.redirect = redirect;
}, {
  query: import_elysia14.t.Object({
    code: import_elysia14.t.String(),
    redirect: import_elysia14.t.String()
  })
});

// src/http/routes/get-managed-restaurant.ts
var import_elysia15 = __toESM(require_cjs2(), 1);
var getManagedRestaurant = new import_elysia15.default().use(authentication).get("/managed-restaurant", async ({ getManagedRestaurantId }) => {
  const restaurantId = await getManagedRestaurantId();
  const restaurant = await db3.query.restaurants.findFirst({
    where(fields, { eq: eq2 }) {
      return eq2(fields.id, restaurantId);
    }
  });
  if (!restaurant) {
    throw new Error("Restaurant not found.");
  }
  return restaurant;
});

// src/http/routes/sign-out.ts
var import_elysia16 = __toESM(require_cjs2(), 1);
var signOut = new import_elysia16.default().use(authentication).post("/sign-out", async ({ signOut: signOut2 }) => {
  signOut2();
});

// src/http/routes/get-order-details.ts
var import_elysia17 = __toESM(require_cjs2(), 1);
var getOrderDetails = new import_elysia17.default().use(authentication).get("/orders/:id", async ({ getCurrentUser, params }) => {
  const { id: orderId } = params;
  const { restaurantId } = await getCurrentUser();
  if (!restaurantId) {
    throw new NotAManagerError;
  }
  const order = await db3.query.orders.findFirst({
    columns: {
      id: true,
      createdAt: true,
      status: true,
      totalInCents: true
    },
    with: {
      customer: {
        columns: {
          name: true,
          phone: true,
          email: true
        }
      },
      orderItems: {
        columns: {
          id: true,
          priceInCents: true,
          quantity: true
        },
        with: {
          product: {
            columns: {
              name: true
            }
          }
        }
      }
    },
    where(fields, { eq: eq2, and: and2 }) {
      return and2(eq2(fields.id, orderId), eq2(fields.restaurantId, restaurantId));
    }
  });
  if (!order) {
    throw new UnauthorizedError;
  }
  return order;
}, {
  params: import_elysia17.t.Object({
    id: import_elysia17.t.String()
  })
});

// src/http/routes/get-month-receipt.ts
var import_elysia18 = __toESM(require_cjs2(), 1);
var import_dayjs2 = __toESM(require_dayjs_min(), 1);
var getMonthReceipt = new import_elysia18.default().use(authentication).get("/metrics/month-receipt", async ({ getManagedRestaurantId }) => {
  const restaurantId = await getManagedRestaurantId();
  const today = import_dayjs2.default();
  const lastMonth = today.subtract(1, "month");
  const startOfLastMonth = lastMonth.startOf("month");
  const lastMonthWithYear = lastMonth.format("YYYY-MM");
  const currentMonthWithYear = today.format("YYYY-MM");
  const monthsReceipts = await db3.select({
    monthWithYear: sql2`TO_CHAR(${orders.createdAt}, 'YYYY-MM')`,
    receipt: sum(orders.totalInCents).mapWith(Number)
  }).from(orders).where(and(eq(orders.restaurantId, restaurantId), gte(orders.createdAt, startOfLastMonth.toDate()))).groupBy(sql2`TO_CHAR(${orders.createdAt}, 'YYYY-MM')`).having(({ receipt }) => gte(receipt, 1));
  const currentMonthReceipt = monthsReceipts.find((monthReceipt) => {
    return monthReceipt.monthWithYear === currentMonthWithYear;
  });
  const lastMonthReceipt = monthsReceipts.find((monthReceipt) => {
    return monthReceipt.monthWithYear === lastMonthWithYear;
  });
  const diffFromLastMonth = lastMonthReceipt && currentMonthReceipt ? currentMonthReceipt.receipt * 100 / lastMonthReceipt.receipt : null;
  return {
    receipt: currentMonthReceipt?.receipt ?? 0,
    diffFromLastMonth: diffFromLastMonth ? Number((diffFromLastMonth - 100).toFixed(2)) : 0
  };
});

// src/http/routes/get-month-orders-amount.ts
var import_elysia19 = __toESM(require_cjs2(), 1);
var import_dayjs3 = __toESM(require_dayjs_min(), 1);
var getMonthOrdersAmount = new import_elysia19.default().use(authentication).get("/metrics/month-orders-amount", async ({ getManagedRestaurantId }) => {
  const restaurantId = await getManagedRestaurantId();
  const today = import_dayjs3.default();
  const lastMonth = today.subtract(1, "month");
  const startOfLastMonth = lastMonth.startOf("month");
  const lastMonthWithYear = lastMonth.format("YYYY-MM");
  const currentMonthWithYear = today.format("YYYY-MM");
  const ordersPerMonth = await db3.select({
    monthWithYear: sql2`TO_CHAR(${orders.createdAt}, 'YYYY-MM')`,
    amount: count(orders.id)
  }).from(orders).where(and(eq(orders.restaurantId, restaurantId), gte(orders.createdAt, startOfLastMonth.toDate()))).groupBy(sql2`TO_CHAR(${orders.createdAt}, 'YYYY-MM')`).having(({ amount }) => gte(amount, 1));
  const currentMonthOrdersAmount = ordersPerMonth.find((ordersInMonth) => {
    return ordersInMonth.monthWithYear === currentMonthWithYear;
  });
  const lastMonthOrdersAmount = ordersPerMonth.find((ordersInMonth) => {
    return ordersInMonth.monthWithYear === lastMonthWithYear;
  });
  const diffFromLastMonth = lastMonthOrdersAmount && currentMonthOrdersAmount ? currentMonthOrdersAmount.amount * 100 / lastMonthOrdersAmount.amount : null;
  return {
    amount: currentMonthOrdersAmount?.amount ?? 0,
    diffFromLastMonth: diffFromLastMonth ? Number((diffFromLastMonth - 100).toFixed(2)) : 0
  };
});

// src/http/routes/get-day-orders-amount.ts
var import_elysia20 = __toESM(require_cjs2(), 1);
var import_dayjs4 = __toESM(require_dayjs_min(), 1);
var getDayOrdersAmount = new import_elysia20.default().use(authentication).get("/metrics/day-orders-amount", async ({ getManagedRestaurantId }) => {
  const restaurantId = await getManagedRestaurantId();
  const today = import_dayjs4.default();
  const yesterday = today.subtract(1, "day");
  const startOfYesterday = yesterday.startOf("day");
  const yesterdayWithMonthAndYear = yesterday.format("YYYY-MM-DD");
  const todayWithMonthAndYear = today.format("YYYY-MM-DD");
  const ordersPerDay = await db3.select({
    dayWithMonthAndYear: sql2`TO_CHAR(${orders.createdAt}, 'YYYY-MM-DD')`,
    amount: count(orders.id)
  }).from(orders).where(and(eq(orders.restaurantId, restaurantId), gte(orders.createdAt, startOfYesterday.toDate()))).groupBy(sql2`TO_CHAR(${orders.createdAt}, 'YYYY-MM-DD')`).having(({ amount }) => gte(amount, 1));
  const todayOrdersAmount = ordersPerDay.find((orderInDay) => {
    return orderInDay.dayWithMonthAndYear === todayWithMonthAndYear;
  });
  const yesterdayOrdersAmount = ordersPerDay.find((orderInDay) => {
    return orderInDay.dayWithMonthAndYear === yesterdayWithMonthAndYear;
  });
  const diffFromYesterday = yesterdayOrdersAmount && todayOrdersAmount ? todayOrdersAmount.amount * 100 / yesterdayOrdersAmount.amount : null;
  return {
    amount: todayOrdersAmount?.amount ?? 0,
    diffFromYesterday: diffFromYesterday ? Number((diffFromYesterday - 100).toFixed(2)) : 0
  };
});

// src/http/routes/get-month-canceled-orders-amount.ts
var import_elysia21 = __toESM(require_cjs2(), 1);
var import_dayjs5 = __toESM(require_dayjs_min(), 1);
var getMonthCanceledOrdersAmount = new import_elysia21.default().use(authentication).get("/metrics/month-canceled-orders-amount", async ({ getManagedRestaurantId }) => {
  const restaurantId = await getManagedRestaurantId();
  const today = import_dayjs5.default();
  const lastMonth = today.subtract(1, "month");
  const startOfLastMonth = lastMonth.startOf("month");
  const lastMonthWithYear = lastMonth.format("YYYY-MM");
  const currentMonthWithYear = today.format("YYYY-MM");
  const ordersPerMonth = await db3.select({
    monthWithYear: sql2`TO_CHAR(${orders.createdAt}, 'YYYY-MM')`,
    amount: count(orders.id)
  }).from(orders).where(and(eq(orders.restaurantId, restaurantId), eq(orders.status, "canceled"), gte(orders.createdAt, startOfLastMonth.toDate()))).groupBy(sql2`TO_CHAR(${orders.createdAt}, 'YYYY-MM')`).having(({ amount }) => gte(amount, 1));
  const currentMonthOrdersAmount = ordersPerMonth.find((ordersInMonth) => {
    return ordersInMonth.monthWithYear === currentMonthWithYear;
  });
  const lastMonthOrdersAmount = ordersPerMonth.find((ordersInMonth) => {
    return ordersInMonth.monthWithYear === lastMonthWithYear;
  });
  const diffFromLastMonth = lastMonthOrdersAmount && currentMonthOrdersAmount ? currentMonthOrdersAmount.amount * 100 / lastMonthOrdersAmount.amount : null;
  return {
    amount: currentMonthOrdersAmount?.amount ?? 0,
    diffFromLastMonth: diffFromLastMonth ? Number((diffFromLastMonth - 100).toFixed(2)) : 0
  };
});

// src/http/routes/get-daily-receipt-in-period.ts
var import_elysia22 = __toESM(require_cjs2(), 1);
var import_dayjs6 = __toESM(require_dayjs_min(), 1);
var getDailyReceiptInPeriod = new import_elysia22.default().use(authentication).get("/metrics/daily-receipt-in-period", async ({ getManagedRestaurantId, query: query5, set }) => {
  const restaurantId = await getManagedRestaurantId();
  const { from, to: to3 } = query5;
  const startDate = from ? import_dayjs6.default(from) : import_dayjs6.default().subtract(7, "d");
  const endDate = to3 ? import_dayjs6.default(to3) : from ? startDate.add(7, "days") : import_dayjs6.default();
  if (endDate.diff(startDate, "days") > 7) {
    set.status = 400;
    return {
      code: "INVALID_PERIOD",
      message: "O intervalo das datas n\xE3o pode ser superior a 7 dias."
    };
  }
  const receiptPerDay = await db3.select({
    date: sql2`TO_CHAR(${orders.createdAt}, 'DD/MM')`,
    receipt: sum(orders.totalInCents).mapWith(Number)
  }).from(orders).where(and(eq(orders.restaurantId, restaurantId), gte(orders.createdAt, startDate.startOf("day").add(startDate.utcOffset(), "minutes").toDate()), lte(orders.createdAt, endDate.endOf("day").add(endDate.utcOffset(), "minutes").toDate()))).groupBy(sql2`TO_CHAR(${orders.createdAt}, 'DD/MM')`).having(({ receipt }) => gte(receipt, 1));
  const orderedReceiptPerDay = receiptPerDay.sort((a, b5) => {
    const [dayA, monthA] = a.date.split("/").map(Number);
    const [dayB, monthB] = b5.date.split("/").map(Number);
    if (monthA === monthB) {
      return dayA - dayB;
    } else {
      const dateA = new Date(2023, monthA - 1);
      const dateB = new Date(2023, monthB - 1);
      return dateA.getTime() - dateB.getTime();
    }
  });
  return orderedReceiptPerDay;
}, {
  query: import_elysia22.t.Object({
    from: import_elysia22.t.Optional(import_elysia22.t.String()),
    to: import_elysia22.t.Optional(import_elysia22.t.String())
  })
});

// src/http/routes/get-popular-products.ts
var import_elysia23 = __toESM(require_cjs2(), 1);
var getPopularProducts = new import_elysia23.default().use(authentication).get("/metrics/popular-products", async ({ getManagedRestaurantId }) => {
  const restaurantId = await getManagedRestaurantId();
  try {
    const popularProducts = await db3.select({
      product: products.name,
      amount: count(orderItems.id)
    }).from(orderItems).leftJoin(orders, eq(orders.id, orderItems.orderId)).leftJoin(products, eq(products.id, orderItems.productId)).where(and(eq(orders.restaurantId, restaurantId))).groupBy(products.name).limit(5);
    return popularProducts;
  } catch (err) {
    console.log(err);
  }
});

// src/http/routes/dispatch-order.ts
var import_elysia24 = __toESM(require_cjs2(), 1);
var dispatchOrder = new import_elysia24.default().use(authentication).patch("/orders/:id/dispatch", async ({ getManagedRestaurantId, set, params }) => {
  const { id: orderId } = params;
  const restaurantId = await getManagedRestaurantId();
  const order = await db3.query.orders.findFirst({
    where(fields, { eq: eq2, and: and2 }) {
      return and2(eq2(fields.id, orderId), eq2(fields.restaurantId, restaurantId));
    }
  });
  if (!order) {
    throw new UnauthorizedError;
  }
  if (order.status !== "processing") {
    set.status = 400;
    return { message: "O pedido j\xE1 foi enviado ao cliente." };
  }
  await db3.update(orders).set({
    status: "delivering"
  }).where(eq(orders.id, orderId));
  set.status = 204;
}, {
  params: import_elysia24.t.Object({
    id: import_elysia24.t.String()
  })
});

// src/http/routes/deliver-order.ts
var import_elysia25 = __toESM(require_cjs2(), 1);
var deliverOrder = new import_elysia25.default().use(authentication).patch("/orders/:id/deliver", async ({ getManagedRestaurantId, set, params }) => {
  const { id: orderId } = params;
  const restaurantId = await getManagedRestaurantId();
  const order = await db3.query.orders.findFirst({
    where(fields, { eq: eq2, and: and2 }) {
      return and2(eq2(fields.id, orderId), eq2(fields.restaurantId, restaurantId));
    }
  });
  if (!order) {
    throw new UnauthorizedError;
  }
  if (order.status !== "delivering") {
    set.status = 400;
    return { message: "O pedido j\xE1 foi entregue." };
  }
  await db3.update(orders).set({
    status: "delivered"
  }).where(eq(orders.id, orderId));
  set.status = 204;
}, {
  params: import_elysia25.t.Object({
    id: import_elysia25.t.String()
  })
});

// src/http/server.ts
var app = new import_elysia26.Elysia().use(cors.cors({
  credentials: true,
  allowedHeaders: ["content-type"],
  methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"],
  origin: (request) => {
    const origin = request.headers.get("origin");
    if (!origin) {
      return false;
    }
    return true;
  }
})).use(authentication).use(signOut).use(getProfile).use(getManagedRestaurant).use(registerRestaurant).use(registerCustomer).use(sendAuthenticationLink).use(authenticateFromLink).use(createOrder).use(approveOrder).use(cancelOrder).use(dispatchOrder).use(deliverOrder).use(getOrders).use(getOrderDetails).use(createEvaluation).use(getEvaluations).use(updateMenu).use(updateProfile).use(getMonthReceipt).use(getMonthOrdersAmount).use(getDayOrdersAmount).use(getMonthCanceledOrdersAmount).use(getDailyReceiptInPeriod).use(getPopularProducts).onError(({ code, error, set }) => {
  switch (code) {
    case "VALIDATION": {
      set.status = error.status;
      return error.toResponse();
    }
    case "NOT_FOUND": {
      return new Response(null, { status: 404 });
    }
    default: {
      console.error(error);
      return new Response(null, { status: 500 });
    }
  }
});
app.listen(3333);
console.log(`\uD83D\uDD25 HTTP server running at ${app.server?.hostname}:${app.server?.port}`);
